/* This source file must have a .cpp extension so that all C++ compilers
   recognize the extension without flags.  Borland does not know .cxx for
   example.  */
#ifndef __cplusplus
# error "A C compiler has been selected for C++."
#endif


/* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  */

#if defined(__COMO__)
# define COMPILER_ID "Comeau"
  /* __COMO_VERSION__ = VRR */
# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)
# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)

#elif defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
  /* __INTEL_COMPILER = VRP */
# define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
# define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
# if defined(__INTEL_COMPILER_UPDATE)
#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
# else
#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
# endif
# if defined(__INTEL_COMPILER_BUILD_DATE)
  /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
# endif
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif

#elif defined(__PATHCC__)
# define COMPILER_ID "PathScale"
# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
# if defined(__PATHCC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
# endif

#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)
# define COMPILER_ID "Embarcadero"
# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)
# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)
# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)

#elif defined(__BORLANDC__)
# define COMPILER_ID "Borland"
  /* __BORLANDC__ = 0xVRR */
# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)

#elif defined(__WATCOMC__) && __WATCOMC__ < 1200
# define COMPILER_ID "Watcom"
   /* __WATCOMC__ = VVRR */
# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__WATCOMC__)
# define COMPILER_ID "OpenWatcom"
   /* __WATCOMC__ = VVRP + 1100 */
# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__SUNPRO_CC)
# define COMPILER_ID "SunPro"
# if __SUNPRO_CC >= 0x5100
   /* __SUNPRO_CC = 0xVRRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# else
   /* __SUNPRO_CC = 0xVRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# endif

#elif defined(__HP_aCC)
# define COMPILER_ID "HP"
  /* __HP_aCC = VVRRPP */
# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)
# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)

#elif defined(__DECCXX)
# define COMPILER_ID "Compaq"
  /* __DECCXX_VER = VVRRTPPPP */
# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)
# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)
# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)

#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)
# define COMPILER_ID "zOS"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800
# define COMPILER_ID "XL"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ < 800
# define COMPILER_ID "VisualAge"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__PGI)
# define COMPILER_ID "PGI"
# define COMPILER_VERSION_MAJOR DEC(__PGIC__)
# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
# if defined(__PGIC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
# endif

#elif defined(_CRAYC)
# define COMPILER_ID "Cray"
# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)
# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)

#elif defined(__TI_COMPILER_VERSION__)
# define COMPILER_ID "TI"
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)

#elif defined(__FUJITSU) || defined(__FCC_VERSION) || defined(__fcc_version)
# define COMPILER_ID "Fujitsu"

#elif defined(__SCO_VERSION__)
# define COMPILER_ID "SCO"

#elif defined(__clang__) && defined(__apple_build_version__)
# define COMPILER_ID "AppleClang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)

#elif defined(__clang__)
# define COMPILER_ID "Clang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif

#elif defined(__GNUC__)
# define COMPILER_ID "GNU"
# define COMPILER_VERSION_MAJOR DEC(__GNUC__)
# if defined(__GNUC_MINOR__)
#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif defined(_MSC_VER)
# define COMPILER_ID "MSVC"
  /* _MSC_VER = VVRR */
# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
# if defined(_MSC_FULL_VER)
#  if _MSC_VER >= 1400
    /* _MSC_FULL_VER = VVRRPPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
#  else
    /* _MSC_FULL_VER = VVRRPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
#  endif
# endif
# if defined(_MSC_BUILD)
#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
# endif

#elif defined(__VISUALDSPVERSION__) || defined(__ADSPBLACKFIN__) || defined(__ADSPTS__) || defined(__ADSP21000__)
# define COMPILER_ID "ADSP"
#if defined(__VISUALDSPVERSION__)
  /* __VISUALDSPVERSION__ = 0xVVRRPP00 */
# define COMPILER_VERSION_MAJOR HEX(__VISUALDSPVERSION__>>24)
# define COMPILER_VERSION_MINOR HEX(__VISUALDSPVERSION__>>16 & 0xFF)
# define COMPILER_VERSION_PATCH HEX(__VISUALDSPVERSION__>>8  & 0xFF)
#endif

#elif defined(__IAR_SYSTEMS_ICC__ ) || defined(__IAR_SYSTEMS_ICC)
# define COMPILER_ID "IAR"

#elif defined(__ARMCC_VERSION)
# define COMPILER_ID "ARMCC"
#if __ARMCC_VERSION >= 1000000
  /* __ARMCC_VERSION = VRRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)
#else
  /* __ARMCC_VERSION = VRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)
#endif


#elif defined(_SGI_COMPILER_VERSION) || defined(_COMPILER_VERSION)
# define COMPILER_ID "MIPSpro"
# if defined(_SGI_COMPILER_VERSION)
  /* _SGI_COMPILER_VERSION = VRP */
#  define COMPILER_VERSION_MAJOR DEC(_SGI_COMPILER_VERSION/100)
#  define COMPILER_VERSION_MINOR DEC(_SGI_COMPILER_VERSION/10 % 10)
#  define COMPILER_VERSION_PATCH DEC(_SGI_COMPILER_VERSION    % 10)
# else
  /* _COMPILER_VERSION = VRP */
#  define COMPILER_VERSION_MAJOR DEC(_COMPILER_VERSION/100)
#  define COMPILER_VERSION_MINOR DEC(_COMPILER_VERSION/10 % 10)
#  define COMPILER_VERSION_PATCH DEC(_COMPILER_VERSION    % 10)
# endif


/* These compilers are either not known or too old to define an
  identification macro.  Try to identify the platform and guess that
  it is the native compiler.  */
#elif defined(__sgi)
# define COMPILER_ID "MIPSpro"

#elif defined(__hpux) || defined(__hpua)
# define COMPILER_ID "HP"

#else /* unknown compiler */
# define COMPILER_ID ""
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";
#ifdef SIMULATE_ID
char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";
#endif

#ifdef __QNXNTO__
char const* qnxnto = "INFO" ":" "qnxnto[]";
#endif

#if defined(__CRAYXE) || defined(__CRAYXC)
char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";
#endif

#define STRINGIFY_HELPER(X) #X
#define STRINGIFY(X) STRINGIFY_HELPER(X)

/* Identify known platforms by name.  */
#if defined(__linux) || defined(__linux__) || defined(linux)
# define PLATFORM_ID "Linux"

#elif defined(__CYGWIN__)
# define PLATFORM_ID "Cygwin"

#elif defined(__MINGW32__)
# define PLATFORM_ID "MinGW"

#elif defined(__APPLE__)
# define PLATFORM_ID "Darwin"

#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
# define PLATFORM_ID "Windows"

#elif defined(__FreeBSD__) || defined(__FreeBSD)
# define PLATFORM_ID "FreeBSD"

#elif defined(__NetBSD__) || defined(__NetBSD)
# define PLATFORM_ID "NetBSD"

#elif defined(__OpenBSD__) || defined(__OPENBSD)
# define PLATFORM_ID "OpenBSD"

#elif defined(__sun) || defined(sun)
# define PLATFORM_ID "SunOS"

#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
# define PLATFORM_ID "AIX"

#elif defined(__sgi) || defined(__sgi__) || defined(_SGI)
# define PLATFORM_ID "IRIX"

#elif defined(__hpux) || defined(__hpux__)
# define PLATFORM_ID "HP-UX"

#elif defined(__HAIKU__)
# define PLATFORM_ID "Haiku"

#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
# define PLATFORM_ID "BeOS"

#elif defined(__QNX__) || defined(__QNXNTO__)
# define PLATFORM_ID "QNX"

#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
# define PLATFORM_ID "Tru64"

#elif defined(__riscos) || defined(__riscos__)
# define PLATFORM_ID "RISCos"

#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
# define PLATFORM_ID "SINIX"

#elif defined(__UNIX_SV__)
# define PLATFORM_ID "UNIX_SV"

#elif defined(__bsdos__)
# define PLATFORM_ID "BSDOS"

#elif defined(_MPRAS) || defined(MPRAS)
# define PLATFORM_ID "MP-RAS"

#elif defined(__osf) || defined(__osf__)
# define PLATFORM_ID "OSF1"

#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
# define PLATFORM_ID "SCO_SV"

#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
# define PLATFORM_ID "ULTRIX"

#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
# define PLATFORM_ID "Xenix"

#elif defined(__WATCOMC__)
# if defined(__LINUX__)
#  define PLATFORM_ID "Linux"

# elif defined(__DOS__)
#  define PLATFORM_ID "DOS"

# elif defined(__OS2__)
#  define PLATFORM_ID "OS2"

# elif defined(__WINDOWS__)
#  define PLATFORM_ID "Windows3x"

# else /* unknown platform */
#  define PLATFORM_ID ""
# endif

#else /* unknown platform */
# define PLATFORM_ID ""

#endif

/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
*/
#if defined(_WIN32) && defined(_MSC_VER)
# if defined(_M_IA64)
#  define ARCHITECTURE_ID "IA64"

# elif defined(_M_X64) || defined(_M_AMD64)
#  define ARCHITECTURE_ID "x64"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# elif defined(_M_ARM)
#  if _M_ARM == 4
#   define ARCHITECTURE_ID "ARMV4I"
#  elif _M_ARM == 5
#   define ARCHITECTURE_ID "ARMV5I"
#  else
#   define ARCHITECTURE_ID "ARMV" STRINGIFY(_M_ARM)
#  endif

# elif defined(_M_MIPS)
#  define ARCHITECTURE_ID "MIPS"

# elif defined(_M_SH)
#  define ARCHITECTURE_ID "SHx"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__WATCOMC__)
# if defined(_M_I86)
#  define ARCHITECTURE_ID "I86"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#else
#  define ARCHITECTURE_ID ""
#endif

/* Convert integer to decimal digit literals.  */
#define DEC(n)                   \
  ('0' + (((n) / 10000000)%10)), \
  ('0' + (((n) / 1000000)%10)),  \
  ('0' + (((n) / 100000)%10)),   \
  ('0' + (((n) / 10000)%10)),    \
  ('0' + (((n) / 1000)%10)),     \
  ('0' + (((n) / 100)%10)),      \
  ('0' + (((n) / 10)%10)),       \
  ('0' +  ((n) % 10))

/* Convert integer to hex digit literals.  */
#define HEX(n)             \
  ('0' + ((n)>>28 & 0xF)), \
  ('0' + ((n)>>24 & 0xF)), \
  ('0' + ((n)>>20 & 0xF)), \
  ('0' + ((n)>>16 & 0xF)), \
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
  ('0' + ((n)     & 0xF))

/* Construct a string literal encoding the version number components. */
#ifdef COMPILER_VERSION_MAJOR
char const info_version[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',
  COMPILER_VERSION_MAJOR,
# ifdef COMPILER_VERSION_MINOR
  '.', COMPILER_VERSION_MINOR,
#  ifdef COMPILER_VERSION_PATCH
   '.', COMPILER_VERSION_PATCH,
#   ifdef COMPILER_VERSION_TWEAK
    '.', COMPILER_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct a string literal encoding the version number components. */
#ifdef SIMULATE_VERSION_MAJOR
char const info_simulate_version[] = {
  'I', 'N', 'F', 'O', ':',
  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',
  SIMULATE_VERSION_MAJOR,
# ifdef SIMULATE_VERSION_MINOR
  '.', SIMULATE_VERSION_MINOR,
#  ifdef SIMULATE_VERSION_PATCH
   '.', SIMULATE_VERSION_PATCH,
#   ifdef SIMULATE_VERSION_TWEAK
    '.', SIMULATE_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";




const char* info_language_dialect_default = "INFO" ":" "dialect_default["
#if __cplusplus >= 201402L
  "14"
#elif __cplusplus >= 201103L
  "11"
#else
  "98"
#endif
"]";

/*--------------------------------------------------------------------------*/

int main(int argc, char* argv[])
{
  int require = 0;
  require += info_compiler[argc];
  require += info_platform[argc];
#ifdef COMPILER_VERSION_MAJOR
  require += info_version[argc];
#endif
#ifdef SIMULATE_ID
  require += info_simulate[argc];
#endif
#ifdef SIMULATE_VERSION_MAJOR
  require += info_simulate_version[argc];
#endif
#if defined(__CRAYXE) || defined(__CRAYXC)
  require += info_cray[argc];
#endif
  require += info_language_dialect_default[argc];
  (void)argv;
  return require;
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <unistd.h>

#include <cstdio>
#include <string>
#include <vector>
#include <sstream>
#include <fstream>
#include <iostream>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

using namespace caf;

using std::cout;
using std::cerr;
using std::endl;
using std::string;
using std::vector;

static constexpr const char base64_tbl[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                           "abcdefghijklmnopqrstuvwxyz"
                                           "0123456789+/";

std::string encode_base64(const string& str) {
  std::string result;
  // consumes three characters from input
  auto consume = [&](const char* i) {
    int buf[] {
      (i[0] & 0xfc) >> 2,
      ((i[0] & 0x03) << 4) + ((i[1] & 0xf0) >> 4),
      ((i[1] & 0x0f) << 2) + ((i[2] & 0xc0) >> 6),
      i[2] & 0x3f
    };
    for (auto x : buf)
      result += base64_tbl[x];
  };
  // iterate string in chunks of three characters
  auto i = str.begin();
  for ( ; std::distance(i, str.end()) >= 3; i += 3)
    consume(&(*i));
  if (i != str.end()) {
    // "fill" string with 0s
    char cbuf[] = {0, 0, 0};
    std::copy(i, str.end(), cbuf);
    consume(cbuf);
    // override filled characters (garbage) with '='
    for (auto j = result.end() - (3 - (str.size() % 3)); j != result.end(); ++j)
      *j = '=';
  }
  return result;
}

class host_desc {
public:
  std::string host;
  int cpu_slots;
  string opencl_device_ids;

  host_desc(std::string host_addr, int slots, string cldevices)
      : host(std::move(host_addr)),
        cpu_slots(slots),
        opencl_device_ids(std::move(cldevices)) {
    // nop
  }

  host_desc(host_desc&&) = default;
  host_desc(const host_desc&) = default;
  host_desc& operator=(host_desc&&) = default;
  host_desc& operator=(const host_desc&) = default;

  static void append(vector<host_desc>& xs, const string& line, size_t num) {
    vector<string> fields;
    split(fields, line, is_any_of(" "), token_compress_on);
    if (fields.empty())
      return;
    host_desc hd;
    hd.host = std::move(fields.front());
    hd.cpu_slots = 0;
    hd.opencl_device_ids = "";
    for (auto i = fields.begin() + 1; i != fields.end(); ++i) {
      if (starts_with(*i, "device_ids=")) {
        hd.opencl_device_ids.assign(std::find(i->begin(), i->end(), '=') + 1,
                                    i->end());
      } else if (sscanf(i->c_str(), "slots=%d", &hd.cpu_slots) != 0) {
        cerr << "invalid option at line " << num << ": " << *i << endl;
      }
    }
    xs.emplace_back(std::move(hd));
  }

private:
  host_desc() = default;
};

std::vector<host_desc> read_hostfile(const string& fname) {
  std::vector<host_desc> result;
  std::ifstream in{fname};
  std::string line;
  size_t line_num = 0;
  while (std::getline(in, line))
    host_desc::append(result, line, ++line_num);
  return result;
}

bool run_ssh(actor_system& system, const string& wdir,
             const string& cmd, const string& host) {
  std::cout << "runssh, wdir: " << wdir << " cmd: " << cmd
            << " host: " << host << std::endl;
  // pack command before sending it to avoid any issue with shell escaping
  string full_cmd = "cd ";
  full_cmd += wdir;
  full_cmd += '\n';
  full_cmd += cmd;
  auto packed = encode_base64(full_cmd);
  std::ostringstream oss;
  oss << "ssh -Y -o ServerAliveInterval=60 " << host
      << R"( "echo )" << packed << R"( | base64 --decode | /bin/sh")";
  //return system(oss.str().c_str());
  string line;
  std::cout << "popen: " << oss.str() << std::endl;
  auto fp = popen(oss.str().c_str(), "r");
  if (fp == nullptr)
    return false;
  char buf[512];
  auto eob = buf + sizeof(buf); // end-of-buf
  auto pred = [](char c) { return c == 0 || c == '\n'; };
  scoped_actor self{system};
  while (fgets(buf, sizeof(buf), fp) != nullptr) {
    auto i = buf;
    auto e = std::find_if(i, eob, pred);
    line.insert(line.end(), i, e);
    while (e != eob && *e != 0) {
      aout(self) << line << std::endl;
      line.clear();
      i = e + 1;
      e = std::find_if(i, eob, pred);
      line.insert(line.end(), i, e);
    }
  }
  pclose(fp);
  std::cout << "host down: " << host << std::endl;
  if (!line.empty())
    aout(self) << line << std::endl;
  return true;
}

void bootstrap(actor_system& system,
               const string& wdir,
               const host_desc& master,
               vector<host_desc> slaves,
               const string& cmd,
               vector<string> args) {
  using io::network::interfaces;
  if (!args.empty())
    args.erase(args.begin());
  scoped_actor self{system};
  // open a random port and generate a list of all
  // possible addresses slaves can use to connect to us
  auto port_res = system.middleman().publish(self, 0);
  if (!port_res) {
    cerr << "fatal: unable to publish actor: "
         << system.render(port_res.error()) << endl;
    return;
  }
  auto port = *port_res;
  // run a slave process at master host if user defined slots > 1 for it
  if (master.cpu_slots > 1)
    slaves.emplace_back(master.host, master.cpu_slots - 1,
                        master.opencl_device_ids);
  for (auto& slave : slaves) {
    using namespace caf::io::network;
    // build SSH command and pack it to avoid any issue with shell escaping
    std::thread{[=, &system](actor bootstrapper) {
      std::ostringstream oss;
      oss << cmd;
      if (slave.cpu_slots > 0)
        oss << " --caf#scheduler.max-threads=" << slave.cpu_slots;
      if (!slave.opencl_device_ids.empty())
        oss << " --caf#opencl-devices=" << slave.opencl_device_ids;
      oss << " --caf#slave-mode"
          << " --caf#slave-name=" << slave.host
          << " --caf#bootstrap-node=";
      bool is_first = true;
      interfaces::traverse(
        {protocol::ipv4, protocol::ipv6},
        [&](const char*, protocol::network, bool lo, const char* x) {
          if (lo)
            return;
          if (!is_first)
            oss << ",";
          else
            is_first = false;
          oss << x << "/" << port;
        });
      for (auto& arg : args)
        oss << " " << arg;
      if (!run_ssh(system, wdir, oss.str(), slave.host))
        anon_send(bootstrapper, slave.host);
    }, actor{self}}.detach();
  }
  std::string slaveslist;
  for (size_t i = 0; i < slaves.size(); ++i) {
    self->receive(
      [&](const string& host, uint16_t slave_port) {
        if (!slaveslist.empty())
          slaveslist += ',';
        slaveslist += host;
        slaveslist += '/';
        slaveslist += std::to_string(slave_port);
      },
      [](const string& node) {
        cerr << "unable to launch process via SSH at node " << node << endl;
      }
    );
  }
  // run (and wait for) master
  std::ostringstream oss;
  oss << cmd << " --caf#slave-nodes=" << slaveslist << " " << join(args, " ");
  run_ssh(system, wdir, oss.str(), master.host);
}

#define RETURN_WITH_ERROR(output)                                              \
  do {                                                                         \
    ::std::cerr << output << ::std::endl;                                      \
    return 1;                                                                  \
  } while (true)

int main(int argc, char** argv) {
  actor_system_config cfg;
  cfg.parse(argc, argv);
  if (cfg.cli_helptext_printed)
    return 0;
  if (cfg.slave_mode)
    RETURN_WITH_ERROR("cannot use slave mode in caf-run tool");
  string hostfile;
  std::unique_ptr<char, void (*)(void*)> pwd{getcwd(nullptr, 0), ::free};
  string wdir;
  auto res = cfg.args_remainder.extract_opts({
    {"hostfile", "path to the hostfile", hostfile},
    {"wdir", wdir}
  });
  if (hostfile.empty())
    RETURN_WITH_ERROR("no hostfile specified or hostfile is empty");
  auto& remainder = res.remainder;
  if (remainder.empty())
    RETURN_WITH_ERROR("empty command line");
  auto cmd = std::move(remainder.get_mutable_as<std::string>(0));
  vector<string> xs;
  remainder.drop(1).extract([&](string& x) { xs.emplace_back(std::move(x)); });
  auto hosts = read_hostfile(hostfile);
  if (hosts.empty())
    RETURN_WITH_ERROR("no valid entry in hostfile");
  actor_system system{cfg};
  auto master = hosts.front();
  hosts.erase(hosts.begin());
  bootstrap(system, (wdir.empty()) ? pwd.get() : wdir.c_str(), master,
            std::move(hosts), cmd, xs);
}
#include <string>
#include <vector>
#include <cctype>
#include <utility>
#include <cassert>
#include <fstream>
#include <iostream>

#include "caf/all.hpp"

using std::string;

using namespace caf;

using thread_id = string;
using vector_timestamp = std::vector<size_t>;

// -- convenience functions for strings

// removes leading and trailing whitespaces
void trim(string& s) {
  auto not_space = [](char c) { return isspace(c) == 0; };
  // trim left
  s.erase(s.begin(), find_if(s.begin(), s.end(), not_space));
  // trim right
  s.erase(find_if(s.rbegin(), s.rend(), not_space).base(), s.end());
}

// -- convenience functions for I/O streams

using istream_fun = std::function<std::istream& (std::istream&)>;

std::istream& skip_whitespaces(std::istream& in) {
  while (in.peek() == ' ')
    in.get();
  return in;
}

std::istream& skip_to_next_line(std::istream& in) {
  in.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
  return in;
}

std::istream& skip_word(std::istream& in) {
  skip_whitespaces(in);
  auto nonspace = [](char x) { return (isprint(x) != 0) && (isspace(x) == 0); };
  while (nonspace(static_cast<char>(in.peek())))
    in.get();
  return in;
}

struct line_reader {
  std::string& line;
  char delim;
};

std::istream& operator>>(std::istream& in, line_reader x) {
  std::getline(in, x.line, x.delim);
  trim(x.line);
  return in;
}

line_reader rd_line(std::string& line, char delim = '\n') {
  return {line, delim};
}

struct istream_char_consumer {
  const char* what;
  size_t count;
};

std::istream& operator>>(std::istream& in, istream_char_consumer x) {
  if (!in)
    return in;
  // ignore leading whitespaces
  skip_whitespaces(in);
  // ignore trailing '\0'
  for (size_t i = 0; i < x.count; ++i) {
//cout << "in: " << (char) in.peek() << ", x: " << x.what[i] << endl;
    if (in.get() != x.what[i]) {
      in.setstate(std::ios::failbit);
      break;
    }
  }
  return in;
}

template <size_t S>
istream_char_consumer consume(const char (&what)[S]) {
  return {what, S - 1};
}

// -- convenience functions for vector timestamps

vector_timestamp& merge(vector_timestamp& x, const vector_timestamp& y) {
  assert(x.size() == y.size());
  for (size_t i = 0; i < x.size(); ++i)
    x[i] = std::max(x[i], y[i]);
  return x;
}

constexpr const char* log_level_name[] = {"ERROR", "WARN", "INFO",
                                          "DEBUG", "TRACE", "?????"};

enum class log_level { error, warn, info, debug, trace, invalid };

std::ostream& operator<<(std::ostream& out, const log_level& lvl) {
  return out << log_level_name[static_cast<size_t>(lvl)];
}

std::istream& operator>>(std::istream& in, log_level& lvl) {
  std::string tmp;
  in >> tmp;
  auto pred = [&](const char* cstr) {
    return cstr == tmp;
  };
  auto b = std::begin(log_level_name);
  auto e = std::end(log_level_name);
  auto i = std::find_if(b, e, pred);
  if (i == e)
    lvl = log_level::invalid;
  else
    lvl = static_cast<log_level>(std::distance(b, i));
  return in;
}

/// The ID of entities as used in a logfile. If the logger field is "actor0"
/// then this line represents a thread. Otherwise, the thread field is ignored.
struct logger_id {
  /// Content of the [LOGGER] field (0 if logger is a thread).
  actor_id aid;
  /// Content of the [THREAD] field.
  string tid;
};

bool operator<(const logger_id& x, const logger_id& y) {
  return x.aid == 0 && y.aid == 0 ? x.tid < y.tid : x.aid < y.aid;
}

std::istream& operator>>(std::istream& in, logger_id& x) {
  return in >> consume("actor") >> x.aid >> skip_whitespaces >> x.tid;
}

std::istream& operator>>(std::istream& in, node_id& x) {
  in >> skip_whitespaces;
  if (in.peek() == 'i') {
    x = node_id{};
    return in >> consume("invalid-node");
  }
  string node_hex_id;
  uint32_t pid;
  if (in >> rd_line(node_hex_id, '#') >> pid) {
    x = node_id{pid, node_hex_id};
  }
  return in;
}

/// The ID of a mailbox in a logfile. Parsed from `<actor>@<node>` entries.
struct mailbox_id {
  /// Actor ID of the receiver.
  actor_id aid;
  /// Node ID of the receiver.
  node_id nid;
};

std::string to_string(const mailbox_id& x) {
  auto res = std::to_string(x.aid);
  res += '@';
  res += to_string(x.nid);
  return res;
}

std::istream& operator>>(std::istream& in, mailbox_id& x) {
  // format is <actor>@<node>
  return in >> x.aid >> consume("@") >> x.nid;
}

std::ostream& operator<<(std::ostream& out, const mailbox_id& x) {
  return out << x.aid << '@' << to_string(x.nid);
}

/// An entity in our distributed system, i.e., either an actor or a thread.
struct entity {
  /// The ID of this entity if it is an actor, otherwise 0.
  actor_id aid;
  /// The ID of this entity if it is a thread, otherwise empty.
  thread_id tid;
  /// The ID of the node this entity is running at.
  node_id nid;
  /// The ID of this node in the vector clock.
  size_t vid;
  /// Marks system-level actors to enable filtering.
  bool hidden;
  /// A human-redable name, e.g., "actor42" or "thread23".
  string pretty_name;
};

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, entity& x) {
  return f(meta::type_name("entity"), x.aid, x.tid, x.nid, x.vid, x.hidden,
           x.pretty_name);
}

mailbox_id to_mailbox_id(const entity& x) {
  if (x.aid == 0)
    CAF_RAISE_ERROR("threads do not have a mailbox ID");
  return {x.aid, x.nid};
}

logger_id to_logger_id(const entity& x) {
  return {x.aid, x.tid};
}

/// Sorts entities by `nid` first, then places threads before actors
/// and finally compares `aid` or `tid`.
bool operator<(const entity& x, const entity& y) {
  // We sort by node ID first.
  auto cres = x.nid.compare(y.nid);
  if (cres != 0)
    return cres < 0;
  return (x.aid == 0 && y.aid == 0) ? x.tid < y.tid : x.aid < y.aid;
}

/// Set of `entity` sorted in ascending order by node ID, actor ID,
/// and thread ID (in that order).
using entity_set = std::set<entity>;

class entity_set_range {
public:
  using iterator = entity_set::const_iterator;

  entity_set_range() = default;
  entity_set_range(const entity_set_range&) = default;
  entity_set_range& operator=(const entity_set_range&) = default;

  iterator begin() const {
    return begin_;
  }

  iterator end() const {
    return end_;
  }

protected:
  iterator begin_;
  iterator end_;
};

struct node_cmp_t {
  bool operator()(const entity& x, const node_id& y) const {
    return x.nid < y;
  }
  bool operator()(const node_id& x, const entity& y) const {
    return x < y.nid;
  }
};

constexpr node_cmp_t node_cmp = node_cmp_t{};

/// Range within an `entity_set` containing all entities for a given actor.
struct actor_cmp_t {
  bool operator()(const entity& x, actor_id y) const {
    return x.aid < y;
  }
  bool operator()(actor_id x, const entity& y) const {
    return x < y.aid;
  }
};

constexpr actor_cmp_t actor_cmp = actor_cmp_t{};

class node_range : public entity_set_range {
public:
  node_range(const entity_set& xs, const node_id& y) {
    // get range for the node
    using namespace std;
    begin_ = lower_bound(xs.begin(), xs.end(), y, node_cmp);
    end_ = upper_bound(begin_, xs.end(), y, node_cmp);
  }

  node_range(const node_range&) = default;
  node_range& operator=(const node_range&) = default;

  const node_id& node() const {
    return node_;
  }

private:
  node_id node_;
};

/// Range within an `entity_set` containing all entities for a given node.
class thread_range : public entity_set_range {
public:
  thread_range(const node_range& xs) : node_(xs.node()) {
    actor_id dummy = 0;
    // get range for the node
    using namespace std;
    begin_ = xs.begin();
    end_ = upper_bound(begin_, xs.end(), dummy, actor_cmp);
  }

  thread_range(const thread_range&) = default;
  thread_range& operator=(const thread_range&) = default;

  const node_id& node() const {
    return node_;
  }

private:
  node_id node_;
};

const entity* get(const thread_range& xs, const thread_id& y) {
  // only compares thread ID
  auto thread_cmp = [](const entity& lhs, thread_id rhs) {
    return lhs.tid < rhs;
  };
  // range [xs.first, xs.second) is sortd by thread ID
  using namespace std;
  auto i = lower_bound(xs.begin(), xs.end(), y, thread_cmp);
  if (i->tid == y)
    return &(*i);
  return nullptr;
}

const entity* get(const node_range& xs, const thread_id& y) {
  thread_range subrange{xs};
  return get(subrange, y);
}

/// Returns the entity for `y` from the node range `xs`.
const entity* get(const node_range& xs, actor_id y) {
  if (y == 0)
    return nullptr;
  // range [xs.first, xs.second) is sortd by actor ID
  using namespace std;
  auto i = lower_bound(xs.begin(), xs.end(), y, actor_cmp);
  if (i->aid == y)
    return &(*i);
  return nullptr;
}

const entity* get(const node_range& xs, const logger_id& y) {
  return y.aid > 0 ? get(xs, y.aid) : get(xs, y.tid);
}

/// A single entry in a logfile.
struct log_entry {
  /// A UNIX timestamp.
  int64_t timestamp;
  /// Identifies the logging component, e.g., "caf".
  string component;
  /// Severity level of this entry.
  log_level level;
  /// ID of the logging entitiy.
  logger_id id;
  /// Context information about currently active class.
  string class_name;
  /// Context information about currently executed function.
  string function_name;
  /// Context information about currently executed source file.
  string file_name;
  /// Context information about currently executed source line.
  int32_t line_number;
  /// Description of the log entry.
  string message;
};

/// Stores a log event along with context information.
struct enhanced_log_entry {
  /// The original log entry without context information.
  const log_entry& data;
  /// The actual ID of the logging entity.
  const entity& id;
  /// Current vector time as seen by `id`.
  vector_timestamp& vstamp;
  /// JSON representation of `vstamp`.
  string json_vstamp;
};

/// CAF events according to SE-0001.
enum class se_type {
  spawn,
  init,
  send,
  reject,
  receive,
  drop,
  skip,
  finalize,
  terminate,
  none
};

string to_string(se_type x) {
  const char* tbl[] = {"spawn", "init", "send",     "reject",    "receive",
                       "drop",  "skip", "finalize", "terminate", "none"};
  return tbl[static_cast<int>(x)];
}

using string_map = std::map<string, string>;

/// An SE-0001 event, see http://actor-framework.github.io/rfcs/
struct se_event {
  const entity* source;
  vector_timestamp vstamp;
  se_type type;
  string_map fields;
};

string to_string(const se_event& x) {
  string res;
  res += "node{";
  res += to_string(*x.source);
  res += ", ";
  res += deep_to_string(x.vstamp);
  res += ", ";
  res += to_string(x.type);
  res += ", ";
  res += deep_to_string(x.fields);
  res += "}";
  return res;
}


CAF_ALLOW_UNSAFE_MESSAGE_TYPE(se_event)

bool field_key_compare(const std::pair<const std::string, std::string>& x,
                       const std::string& y) {
  return x.first == y;
}

#define ATM_CASE(name, value)                                                  \
  case static_cast<uint64_t>(atom(name)):                                      \
    y.type = se_type::value

#define CHECK_FIELDS(...)                                                      \
  {                                                                            \
    std::set<std::string> keys{__VA_ARGS__};                                   \
    if (y.fields.size() != keys.size())                                        \
      return sec::invalid_argument;                                            \
    if (!std::equal(y.fields.begin(), y.fields.end(), keys.begin(),            \
                    field_key_compare))                                        \
      return sec::invalid_argument;                                            \
  }                                                                            \
  static_cast<void>(0)

#define CHECK_NO_FIELDS()                                                      \
  if (!y.fields.empty())                                                       \
    return sec::invalid_argument;

expected<se_event> parse_event(const enhanced_log_entry& x) {
  se_event y{&x.id, x.vstamp, se_type::none, string_map{}};
  std::istringstream in{x.data.message};
  string type;
  if (!(in >> type))
    return sec::invalid_argument;
  string field_name;
  string field_content;
  in >> consume(";");
  while (in >> field_name >> consume("=") >> rd_line(field_content, ';'))
    y.fields.emplace(std::move(field_name), std::move(field_content));
  switch (static_cast<uint64_t>(atom_from_string(type))) {
    default:
      return sec::invalid_argument;
    ATM_CASE("SPAWN", spawn);
      CHECK_FIELDS("ID", "ARGS");
      break;
    ATM_CASE("INIT", init);
      CHECK_FIELDS("NAME", "HIDDEN");
      break;
    ATM_CASE("SEND", send);
      CHECK_FIELDS("TO", "FROM", "STAGES", "CONTENT");
      break;
    ATM_CASE("REJECT", reject);
      CHECK_NO_FIELDS();
      break;
    ATM_CASE("RECEIVE", receive);
      CHECK_FIELDS("FROM", "STAGES", "CONTENT");
      // insert TO field to allow comparing SEND and RECEIVE events easily
      y.fields.emplace("TO", to_string(to_mailbox_id(x.id)));
      break;
    ATM_CASE("DROP", drop);
      CHECK_NO_FIELDS();
      break;
    ATM_CASE("SKIP", skip);
      CHECK_NO_FIELDS();
      break;
    ATM_CASE("FINALIZE", finalize);
      CHECK_NO_FIELDS();
      break;
    ATM_CASE("TERMINATE", terminate);
      CHECK_FIELDS("REASON");
      break;
  }
  return {std::move(y)};
}

std::ostream& operator<<(std::ostream& out, const enhanced_log_entry& x) {
  return out << x.json_vstamp << ' ' << x.data.timestamp << ' '
             << x.data.component << ' ' << x.data.level << ' '
             << x.id.pretty_name << ' ' << x.data.class_name << ' '
             << x.data.function_name << ' '
             << x.data.file_name << ':' << x.data.line_number << ' '
             << x.data.message;
}

std::istream& operator>>(std::istream& in, log_entry& x) {
  in >> x.timestamp >> x.component >> x.level
     >> consume("actor") >> x.id.aid >> x.id.tid
     >> x.class_name >> x.function_name
     >> skip_whitespaces >> rd_line(x.file_name, ':')
     >> x.line_number >> skip_whitespaces >> rd_line(x.message);
  if (x.level == log_level::invalid)
    in.setstate(std::ios::failbit);
  return in;
}

struct logger_id_meta_data {
  bool hidden;
  string pretty_name;
};

/// Stores all log entities and their node ID.
struct first_pass_result {
  /// Node ID used in the parsed file.
  node_id this_node;
  /// Entities of the parsed file. The value is `true` if an entity is
  /// hidden, otherwise `false`.
  std::map<logger_id, logger_id_meta_data> entities;
};

enum verbosity_level {
  silent,
  informative,
  noisy
};

expected<first_pass_result> first_pass(blocking_actor* self, std::istream& in,
                                       verbosity_level vl) {
  first_pass_result res;
  // read first line to extract the node ID of local actors
  // _ caf INFO actor0 _ caf.logger start _:_ level = _, node = NODE
  if (!(in >> skip_word >> consume("caf") >> consume("INFO")
           >> consume("actor0") >> skip_word >> consume("caf.logger")
           >> consume("start") >> skip_word
           >> consume("level =") >> skip_word >> consume("node = ")
           >> res.this_node >> skip_to_next_line)) {
    std::cerr << "*** malformed log file, expect the first line to contain "
              << "an INFO entry of the logger" << std::endl;
    return sec::invalid_argument;
  }
  if (vl >= verbosity_level::informative)
    aout(self) << "found node " << res.this_node << std::endl;
  logger_id id;
  string message;
  while (in >> skip_word >> skip_word >> skip_word >> id
            >> skip_word >> skip_word >> skip_word >> rd_line(message)) {
    // store in map
    auto i = res.entities.emplace(id, logger_id_meta_data{false, "actor"}).first;
    if (starts_with(message, "INIT ; NAME = ")) {
      std::istringstream iss{message};
      iss >> consume("INIT ; NAME = ") >> rd_line(i->second.pretty_name, ';');
      if (ends_with(message, "HIDDEN = true"))
        i->second.hidden = true;
    }
  }
  if (vl >= verbosity_level::informative)
    aout(self) << "found " << res.entities.size() << " entities for node "
               << res.this_node << std::endl;
  return res;
}

const string& get(const std::map<string, string>& xs, const string& x) {
  auto i = xs.find(x);
  if (i != xs.end())
    return i->second;
  CAF_RAISE_ERROR("key not found");
}

void second_pass(blocking_actor* self, const group& grp,
                 const entity_set& entities, const node_id& nid,
                 const std::vector<string>& json_names, std::istream& in,
                 std::ostream& out, std::mutex& out_mtx,
                 bool drop_hidden_actors, verbosity_level vl) {
  assert(entities.size() == json_names.size());
  node_range local_entities{entities, nid};
  if (local_entities.begin() == local_entities.end())
    return;
  // state for each local entity
  struct state_t {
    const entity& eid;
    vector_timestamp clock;
  };
  std::map<logger_id, state_t> local_entities_state;
  for (auto& x : local_entities) {
    vector_timestamp vzero;
    vzero.resize(entities.size());
    local_entities_state.emplace(logger_id{x.aid, x.tid},
                                 state_t{x, std::move(vzero)});
  }
  // lambda for accessing state via logger ID
  auto state = [&](const logger_id& x) -> state_t& {
    auto i = local_entities_state.find(x);
    if (i != local_entities_state.end())
      return i->second;
    CAF_RAISE_ERROR("logger ID not found");
  };
  // additional state for second pass
  size_t line = 0;
  log_entry plain_entry;
  std::vector<se_event> in_flight_messages;
  std::vector<se_event> in_flight_spawns;
  // maps scoped actor IDs to their parent ID
  std::map<logger_id, logger_id> scoped_actors;
  // lambda for broadcasting events that could cross node boundary
  auto bcast = [&](const se_event& x) {
    if (vl >= verbosity_level::noisy)
      aout(self) << "broadcast event from " << nid
                 << ": " << deep_to_string(x) << std::endl;
    if (self != nullptr)
      self->send(grp, x);
  };
  // fetch message from another node via the group
  auto fetch_message = [&](const std::map<string, string>& fields)
                       -> se_event& {
    // TODO: this receive unconditionally waits on a message,
    //       i.e., is a potential deadlock
    if (vl >= verbosity_level::noisy)
      aout(self) << "wait for send from another node matching fields "
                 << deep_to_string(fields) << std::endl;
    se_event* res = nullptr;
    self->receive_while([&] { return res == nullptr; })(
      [&](const se_event& x) {
        switch (x.type) {
          default:
            break;
          case se_type::send:
            in_flight_messages.emplace_back(x);
            if (x.fields == fields)
              res = &in_flight_messages.back();
            break;
        }
      }
    );
    return *res;
  };
  // second pass
  while (in >> plain_entry) {
    ++line;
    // increment local time
    auto& st = state(plain_entry.id);
    // do not produce log output for internal actors but still track messages
    // through those actors, because they might be forwarding messages
    bool internal = drop_hidden_actors && st.eid.hidden;
    if (!internal)
      st.clock[st.eid.vid] += 1;
    // generate enhanced entry (with incomplete JSON timestamp for now)
    enhanced_log_entry entry{plain_entry, st.eid, st.clock, string{}};
    // check whether entry contains an SE-0001 event
    auto tmp = parse_event(entry);
    if (tmp) {
      auto& event = *tmp;
      switch (event.type) {
        default:
          break;
        case se_type::send:
          bcast(event);
          in_flight_messages.emplace_back(std::move(event));
          break;
        case se_type::receive: {
          auto pred = [&](const se_event& x) {
            assert(x.type == se_type::send);
            return event.fields == x.fields;
          };
          auto e = in_flight_messages.end();
          auto i = std::find_if(in_flight_messages.begin(), e, pred);
          if (i != e) {
            merge(st.clock, i->vstamp);
          } else {
            merge(st.clock, fetch_message(event.fields).vstamp);
          }
          break;
        }
        case se_type::spawn:
          in_flight_spawns.emplace_back(std::move(event));
          break;
        case se_type::init: {
          auto id_field = std::to_string(st.eid.aid);
          auto pred = [&](const se_event& x) {
            assert(x.type == se_type::spawn);
            return get(x.fields, "ID") == id_field;
          };
          auto e = in_flight_spawns.end();
          auto i = std::find_if(in_flight_spawns.begin(), e, pred);
          if (i != e) {
            merge(st.clock, i->vstamp);
            // keep book on scoped actors since their terminate
            // event propagates back to the parent
            if (get(event.fields, "NAME") == "scoped_actor")
              scoped_actors.emplace(plain_entry.id, to_logger_id(*i->source));
            in_flight_spawns.erase(i);
          } else {
            std::cerr << "*** cannot match init event to a previous spawn"
                      << std::endl;
          }
          break;
        }
        case se_type::terminate:
          auto i = scoped_actors.find(plain_entry.id);
          if (i != scoped_actors.end()) {
            // merge timestamp with parent to capture happens-before relation
            auto& parent_state = state(i->second);
            merge(parent_state.clock, st.clock);
            scoped_actors.erase(i);
          }
          break;
      }
    }
    // create ShiViz compatible JSON-formatted vector timestamp
    std::ostringstream oss;
    oss << '{';
    bool need_comma = false;
    for (size_t i = 0; i < st.clock.size(); ++i) {
      auto x = st.clock[i];
      if (x > 0) {
        if (need_comma)
          oss << ',';
        else
          need_comma = true;
        oss << '"' << json_names[i] << '"' << ':' << x;
      }
    }
    oss << '}';
    entry.json_vstamp = oss.str();
    // print entry to output file
    if (!internal) {
      std::lock_guard<std::mutex> guard{out_mtx};
      out << entry << '\n';
    }
  }
}

namespace {

struct config : public actor_system_config {
  string output_file;
  bool include_hidden_actors = false;
  size_t verbosity = 0;
  config() {
    opt_group{custom_options_, "global"}
    .add(output_file, "output-file,o", "Path for the output file")
    .add(include_hidden_actors, "include-hidden-actors,i",
         "Include hidden (system-level) actors")
    .add(verbosity, "verbosity,v", "Debug output (from 0 to 2)");
    // shutdown logging per default
    logger_verbosity = atom("quiet");
  }
};

// two pass parser for CAF log files that enhances logs with vector
// clock timestamps
void caf_main(actor_system& sys, const config& cfg) {
  using namespace std;
  if (cfg.output_file.empty()) {
    cerr << "*** no output file specified" << std::endl;
    return;
  }
  verbosity_level vl;
  switch (cfg.verbosity) {
    case 0:
      vl = silent;
      break;
    case 1:
      vl = verbosity_level::informative;
      break;
    default:
      vl = verbosity_level::noisy;
  }
  // open output file
  std::ofstream out{cfg.output_file};
  if (!out) {
    cerr << "unable to open output file: " << cfg.output_file << endl;
    return;
  }
  using file_path = string;
  static constexpr size_t irsize = sizeof(file_path) + sizeof(std::ifstream)
                                   + sizeof(first_pass_result);
  using ifstream_ptr = std::unique_ptr<std::ifstream>;
  struct intermediate_res {
    file_path fname;
    ifstream_ptr fstream;
    first_pass_result res;
    char pad[irsize >= CAF_CACHE_LINE_SIZE ? 1 : CAF_CACHE_LINE_SIZE - irsize];
    intermediate_res() = default;
    intermediate_res(intermediate_res&&) = default;
    intermediate_res& operator=(intermediate_res&&) = default;
    intermediate_res(file_path fp, ifstream_ptr fs, first_pass_result&& fr)
        : fname(std::move(fp)),
          fstream(std::move(fs)),
          res(std::move(fr)) {
      // nop
    }
  };
  // do a first pass on all files to extract node IDs and entities
  vector<intermediate_res> intermediate_results;
  intermediate_results.resize(cfg.args_remainder.size());
  for (size_t i = 0; i < cfg.args_remainder.size(); ++i) {
    auto& file = cfg.args_remainder.get_as<string>(i);
    auto ptr = &intermediate_results[i];
    ptr->fname = file;
    ptr->fstream.reset(new std::ifstream(file));
    if (!*ptr->fstream) {
      cerr << "could not open file: " << file << endl;
      continue;
    }
    sys.spawn([ptr, vl](blocking_actor* self) {
      auto& f = *ptr->fstream;
      auto res = first_pass(self, f, vl);
      if (res) {
        // rewind stream and push intermediate results
        f.clear();
        f.seekg(0);
        ptr->res = std::move(*res);
      }
    });
  }
  sys.await_all_actors_done();
  // post-process collected entity IDs before second pass
  entity_set entities;
  std::vector<string> entity_names;
  auto sort_pred = [](const intermediate_res& x, const intermediate_res& y) {
    return x.res.this_node < y.res.this_node;
  };
  std::map<string, size_t> pretty_actor_names;
  size_t thread_count = 0;
  // make sure we insert in sorted order into the entities set
  std::sort(intermediate_results.begin(), intermediate_results.end(),
            sort_pred);
  for (auto& ir : intermediate_results) {
    auto node_as_string = to_string(ir.res.this_node);
    for (auto& kvp : ir.res.entities) {
      string pretty_name;
      // make each (pretty) actor and thread name unique
      auto& pn = kvp.second.pretty_name;
      if (kvp.first.aid != 0)
        pretty_name = pn + std::to_string(++pretty_actor_names[pn]);
        //"actor" + std::to_string(kvp.first.aid);
      else
        pretty_name = "thread" + std::to_string(++thread_count);
      auto vid = entities.size(); // position in the vector timestamp
      entity_names.emplace_back(pretty_name);
      entities.emplace(entity{kvp.first.aid, kvp.first.tid, ir.res.this_node,
                              vid, kvp.second.hidden, std::move(pretty_name)});
    }
  }
  // check whether entities set is in the right order
  auto vid_cmp = [](const entity& x, const entity& y) {
    return x.vid < y.vid;
  };
  if (!std::is_sorted(entities.begin(), entities.end(), vid_cmp)) {
    cerr << "*** ERROR: entity set not sorted by vector timestamp ID:\n"
         << deep_to_string(entities) << endl;
    return;
  }
  // do a second pass for all log files
  // first line is the regex to parse the remainder of the file
  out << R"((?<clock>\S+) (?<timestamp>\d+) (?<component>\S+) )"
      << R"((?<level>\S+) (?<host>\S+) (?<class>\S+) (?<function>\S+) )"
      << R"((?<file>\S+):(?<line>\d+) (?<event>.+))"
      << endl;
  // second line is the separator for multiple runs
  out << endl;
  std::mutex out_mtx;
  auto grp = sys.groups().anonymous();
  for (auto& fpr : intermediate_results) {
    sys.spawn_in_group(grp, [&](blocking_actor* self) {
      second_pass(self, grp, entities, fpr.res.this_node, entity_names,
                  *fpr.fstream, out, out_mtx, !cfg.include_hidden_actors, vl);
    });
  }
  sys.await_all_actors_done();
}

} // namespace <anonymous>

CAF_MAIN()

/******************************************************************************\
 * This example is an implementation of the classical Dining Philosophers     *
 * exercise using only libcaf's event-based actor implementation.             *
\ ******************************************************************************/

#include <map>
#include <thread>
#include <utility>
#include <vector>
#include <chrono>
#include <sstream>
#include <iostream>

#include "caf/all.hpp"

using std::cout;
using std::cerr;
using std::endl;
using std::chrono::seconds;

using namespace caf;

namespace {

// atoms for chopstick interface
using put_atom = atom_constant<atom("put")>;
using take_atom = atom_constant<atom("take")>;
using taken_atom = atom_constant<atom("taken")>;

// atoms for philosopher interface
using eat_atom = atom_constant<atom("eat")>;
using think_atom = atom_constant<atom("think")>;

// a chopstick
using chopstick = typed_actor<replies_to<take_atom>::with<taken_atom, bool>,
                              reacts_to<put_atom>>;

chopstick::behavior_type taken_chopstick(chopstick::pointer,
                                         const strong_actor_ptr&);

// either taken by a philosopher or available
chopstick::behavior_type available_chopstick(chopstick::pointer self) {
  return {
    [=](take_atom) -> std::tuple<taken_atom, bool> {
      self->become(taken_chopstick(self, self->current_sender()));
      return std::make_tuple(taken_atom::value, true);
    },
    [](put_atom) {
      cerr << "chopstick received unexpected 'put'" << endl;
    }
  };
}

chopstick::behavior_type taken_chopstick(chopstick::pointer self,
                                         const strong_actor_ptr& user) {
  return {
    [](take_atom) -> std::tuple<taken_atom, bool> {
      return std::make_tuple(taken_atom::value, false);
    },
    [=](put_atom) {
      if (self->current_sender() == user)
        self->become(available_chopstick(self));
    }
  };
}

/* Based on: http://www.dalnefre.com/wp/2010/08/dining-philosophers-in-humus/
 *
 *
 *                +-------------+     {busy|taken}
 *      /-------->|  thinking   |<------------------\
 *      |         +-------------+                   |
 *      |                |                          |
 *      |                | {eat}                    |
 *      |                |                          |
 *      |                V                          |
 *      |         +-------------+  {busy}    +-------------+
 *      |         |   hungry    |----------->|   denied    |
 *      |         +-------------+            +-------------+
 *      |                |
 *      |                | {taken}
 *      |                |
 *      |                V
 *      |         +-------------+
 *      |         |   granted   |
 *      |         +-------------+
 *      |           |    |
 *      |  {busy}   |    | {taken}
 *      \-----------/    |
 *      |                V
 *      | {think} +-------------+
 *      \---------|   eating    |
 *                +-------------+
 */

class philosopher : public event_based_actor {
public:
  philosopher(actor_config& cfg,
              std::string  n,
              chopstick  l,
              chopstick  r)
      : event_based_actor(cfg),
        name_(std::move(n)),
        left_(std::move(l)),
        right_(std::move(r)) {
    // we only accept one message per state and skip others in the meantime
    set_default_handler(skip);
    // a philosopher that receives {eat} stops thinking and becomes hungry
    thinking_.assign(
      [=](eat_atom) {
        become(hungry_);
        send(left_, take_atom::value);
        send(right_, take_atom::value);
      }
    );
    // wait for the first answer of a chopstick
    hungry_.assign(
      [=](taken_atom, bool result) {
        if (result)
          become(granted_);
        else
          become(denied_);
      }
    );
    // philosopher was able to obtain the first chopstick
    granted_.assign(
      [=](taken_atom, bool result) {
        if (result) {
          aout(this) << name_
                     << " has picked up chopsticks with IDs "
                     << left_->id() << " and " << right_->id()
                     << " and starts to eat\n";
          // eat some time
          delayed_send(this, seconds(5), think_atom::value);
          become(eating_);
        } else {
          send(current_sender() == left_ ? right_ : left_, put_atom::value);
          send(this, eat_atom::value);
          become(thinking_);
        }
      }
    );
    // philosopher was *not* able to obtain the first chopstick
    denied_.assign(
      [=](taken_atom, bool result) {
        if (result)
          send(current_sender() == left_ ? left_ : right_, put_atom::value);
        send(this, eat_atom::value);
        become(thinking_);
      }
    );
    // philosopher obtained both chopstick and eats (for five seconds)
    eating_.assign(
      [=](think_atom) {
        send(left_, put_atom::value);
        send(right_, put_atom::value);
        delayed_send(this, seconds(5), eat_atom::value);
        aout(this) << name_
                   << " puts down his chopsticks and starts to think\n";
        become(thinking_);
      }
    );
  }

  const char* name() const override {
    return name_.c_str();
  }

protected:
  behavior make_behavior() override {
    // start thinking
    send(this, think_atom::value);
    // philosophers start to think after receiving {think}
    return (
      [=](think_atom) {
        aout(this) << name_ << " starts to think\n";
        delayed_send(this, seconds(5), eat_atom::value);
        become(thinking_);
      }
    );
  }

private:
  std::string name_;     // the name of this philosopher
  chopstick   left_;     // left chopstick
  chopstick   right_;    // right chopstick
  behavior    thinking_; // initial behavior
  behavior    hungry_;   // tries to take chopsticks
  behavior    granted_;  // has one chopstick and waits for the second one
  behavior    denied_;   // could not get first chopsticks
  behavior    eating_;   // wait for some time, then go thinking again
};

} // namespace <anonymous>

void caf_main(actor_system& system) {
  scoped_actor self{system};
  // create five chopsticks
  aout(self) << "chopstick ids are:";
  std::vector<chopstick> chopsticks;
  for (size_t i = 0; i < 5; ++i) {
    chopsticks.push_back(self->spawn(available_chopstick));
    aout(self) << " " << chopsticks.back()->id();
  }
  aout(self) << endl;
  // spawn five philosophers
  std::vector<std::string> names {"Plato", "Hume", "Kant",
                                  "Nietzsche", "Descartes"};
  for (size_t i = 0; i < 5; ++i)
    self->spawn<philosopher>(names[i], chopsticks[i], chopsticks[(i + 1) % 5]);
}

CAF_MAIN()
#include "caf/all.hpp"
using namespace caf;

using idle_atom = atom_constant<atom("idle")>;
using request_atom = atom_constant<atom("request")>;
using response_atom = atom_constant<atom("response")>;

behavior server(event_based_actor* self) {
  return {
    [=](idle_atom, const actor& worker) {
      self->become (
        keep_behavior,
        [=](request_atom atm) {
          self->delegate(worker, atm);
          self->unbecome();
        },
        [=](idle_atom) {
          return skip();
        }
      );
    },
    [=](request_atom) {
      return skip();
    }
  };
}

behavior client(event_based_actor* self, const actor& serv) {
  self->link_to(serv);
  self->send(serv, idle_atom::value, self);
  return {
    [=](request_atom) {
      self->send(serv, idle_atom::value, self);
      return response_atom::value;
    }
  };
}

void caf_main(actor_system& system) {
  auto serv = system.spawn(server);
  auto worker = system.spawn(client, serv);
  scoped_actor self{system};
  self->request(serv, std::chrono::seconds(10), request_atom::value).receive(
    [&](response_atom) {
      aout(self) << "received response from "
                 << (self->current_sender() == worker ? "worker\n"
                                                      : "server\n");
    },
    [&](error& err) {
      aout(self) << "received error "
                 << system.render(err)
                 << " from "
                 << (self->current_sender() == worker ? "worker\n"
                                                      : "server\n");
    }
  );
  self->send_exit(serv, exit_reason::user_shutdown);
}

CAF_MAIN()
#include <string>
#include <utility>

#include "caf/all.hpp"
#include "caf/detail/scope_guard.hpp"

CAF_PUSH_WARNINGS
#include <QMessageBox>
#include <QInputDialog>
CAF_POP_WARNINGS

#include "chatwidget.hpp"

using namespace std;
using namespace caf;

ChatWidget::ChatWidget(QWidget* parent, Qt::WindowFlags f)
    : super(parent, f),
      input_(nullptr),
      output_(nullptr) {
  // nop
}

ChatWidget::~ChatWidget() {
  // nop
}

void ChatWidget::init(actor_system& system) {
  super::init(system);
  set_message_handler ([=](actor_companion* self) -> message_handler {
    return {
      [=](join_atom, const group& what) {
        if (chatroom_) {
          self->send(chatroom_, name_ + " has left the chatroom");
          self->leave(chatroom_);
        }
        self->join(what);
        print(("*** joined " + to_string(what)).c_str());
        chatroom_ = what;
        self->send(what, name_ + " has entered the chatroom");
      },
      [=](set_name_atom, string& name) {
        self->send(chatroom_, name_ + " is now known as " + name);
        name_ = std::move(name);
        print("*** changed name to " + QString::fromUtf8(name_.c_str()));
      },
      [=](quit_atom) {
        quit_and_close();
      },
      [=](const string& txt) {
        // don't print own messages
        if (self != self->current_sender())
          print(QString::fromUtf8(txt.c_str()));
      },
      [=](const group_down_msg& gdm) {
        print("*** chatroom offline: "
              + QString::fromUtf8(to_string(gdm.source).c_str()));
      }
    };
  });
}

void ChatWidget::sendChatMessage() {
  auto cleanup = detail::make_scope_guard([=] {
    input()->setText(QString());
  });
  QString line = input()->text();
  if (line.startsWith('/')) {
    vector<string> words;
    split(words, line.midRef(1).toUtf8().constData(), is_any_of(" "));
    message_builder mb;
    if (words.size() > 1) {
      // convert first word to an atom
      mb.append(atom_from_string(words.front()))
        .append(words.begin() + 1, words.end());
    };
    auto res = mb.apply({
      [=](join_atom, const string& mod, const string& g) {
        auto x = system().groups().get(mod, g);
        if (! x)
          print("*** error: "
                + QString::fromUtf8(system().render(x.error()).c_str()));
        else
          self()->send(self(), atom("join"), std::move(*x));
      },
      [=](set_name_atom atm, string& name) {
        send_as(as_actor(), as_actor(), atm, std::move(name));
      }
    });
    if (! res)
      print("*** list of commands:\n"
            "/join <module> <group id>\n"
            "/setName <new name>\n");
    return;
  }
  if (name_.empty()) {
    print("*** please set a name before sending messages");
    return;
  }
  if (! chatroom_) {
    print("*** no one is listening... please join a group");
    return;
  }
  string msg = name_;
  msg += ": ";
  msg += line.toUtf8().constData();
  print("<you>: " + input()->text());
  send_as(as_actor(), chatroom_, std::move(msg));
}

void ChatWidget::joinGroup() {
  if (name_.empty()) {
    QMessageBox::information(this, "No Name, No Chat",
                             "Please set a name first.");
    return;
  }
  auto gname = QInputDialog::getText(this,
                                     "Join Group",
                                     "Please enter a group as <module>:<id>",
                                     QLineEdit::Normal,
                                     "remote:chatroom@localhost:4242");
  int pos = gname.indexOf(':');
  if (pos < 0) {
    QMessageBox::warning(this, "Not a Group", "Invalid format");
    return;
  }
  string mod = gname.left(pos).toUtf8().constData();
  string gid = gname.midRef(pos+1).toUtf8().constData();
  auto x = system().groups().get(mod, gid);
  if (! x)
    QMessageBox::critical(this, "Error", system().render(x.error()).c_str());
  else
    self()->send(self(), join_atom::value, std::move(*x));
}

void ChatWidget::changeName() {
  auto name = QInputDialog::getText(this, "Change Name",
                                    "Please enter a new name");
  if (! name.isEmpty())
    send_as(as_actor(), as_actor(), atom("setName"), name.toUtf8().constData());
}
/******************************************************************************\
 * This example program represents a minimal GUI chat program                 *
 * based on group communication. This chat program is compatible to the       *
 * terminal version in remote_actors/group_chat.cpp.                          *
 *                                                                            *
 * Setup for a minimal chat between "alice" and "bob":                        *
 * - ./build/bin/group_server -p 4242                                         *
 * - ./build/bin/qt_group_chat -g remote:chatroom@localhost:4242 -n alice     *
 * - ./build/bin/qt_group_chat -g remote:chatroom@localhost:4242 -n bob       *
\******************************************************************************/

#include <set>
#include <map>
#include <vector>
#include <iostream>
#include <sstream>
#include <time.h>
#include <cstdlib>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

CAF_PUSH_WARNINGS
#include <QMainWindow>
#include <QApplication>
#include "ui_chatwindow.h" // auto generated from chatwindow.ui
CAF_POP_WARNINGS

using namespace std;
using namespace caf;

class config : public actor_system_config {
public:
  std::string name;
  std::string group_id;

  config(int argc, char** argv) {
    opt_group{custom_options_, "global"}
    .add(name, "name,n", "set name")
    .add(group_id, "group,g", "join group (format: <module>:<id>");
    parse(argc, argv);
    load<io::middleman>();
  }
};

int main(int argc, char** argv) {
  config cfg{argc, argv};
  actor_system system{cfg};
  auto name = cfg.name;
  group grp;
  // evaluate group parameters
  if (! cfg.group_id.empty()) {
    auto p = cfg.group_id.find(':');
    if (p == std::string::npos) {
      cerr << "*** error parsing argument " << cfg.group_id
         << ", expected format: <module_name>:<group_id>";
    } else {
      auto module = cfg.group_id.substr(0, p);
      auto group_uri = cfg.group_id.substr(p + 1);
      auto g = system.groups().get(module, group_uri);
      if (! g) {
        cerr << "*** unable to get group " << group_uri
             << " from module " << module << ": "
             << system.render(g.error()) << endl;
        return -1;
      }
      grp = std::move(*g);
    }
  }
  QApplication app{argc, argv};
  app.setQuitOnLastWindowClosed(true);
  QMainWindow mw;
  Ui::ChatWindow helper;
  helper.setupUi(&mw);
  helper.chatwidget->init(system);
  auto client = helper.chatwidget->as_actor();
  if (! name.empty())
    send_as(client, client, atom("setName"), move(name));
  if (grp)
    send_as(client, client, atom("join"), std::move(grp));
  mw.show();
  return app.exec();
}
#include <exception>

#include "caf/all.hpp"
#include "caf/mixin/actor_widget.hpp"

CAF_PUSH_WARNINGS
#include <QWidget>
#include <QLineEdit>
#include <QTextEdit>
CAF_POP_WARNINGS

class ChatWidget : public caf::mixin::actor_widget<QWidget> {
private:
  // -- Qt boilerplate code ----------------------------------------------------

  Q_OBJECT

public:
  // -- member types -----------------------------------------------------------

  using super = caf::mixin::actor_widget<QWidget>;

  using set_name_atom = caf::atom_constant<caf::atom("setName")>;

  using quit_atom = caf::atom_constant<caf::atom("quit")>;

  ChatWidget(QWidget* parent = nullptr, Qt::WindowFlags f = 0);

  ~ChatWidget();

  void init(caf::actor_system& system);

public slots:

  void sendChatMessage();
  void joinGroup();
  void changeName();

private:

  template<typename T>
  T* get(T*& member, const char* name) {
    if (member == nullptr) {
      member = findChild<T*>(name);
      if (member == nullptr)
        throw std::runtime_error("unable to find child: " + std::string(name));
    }
    return member;
  }

  inline QLineEdit* input() {
    return get(input_, "input");
  }

  inline QTextEdit* output() {
    return get(output_, "output");
  }

  inline void print(const QString& what) {
    output()->append(what);
  }

  caf::actor_system& system() {
    return self()->home_system();
  }

  QLineEdit* input_;
  QTextEdit* output_;
  std::string name_;
  caf::group chatroom_;
};
#include <vector>
#include <string>
#include <limits>
#include <memory>
#include <iostream>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

#ifdef CAF_WINDOWS
#include <winsock2.h>
#else
#include <arpa/inet.h>
#endif

CAF_PUSH_WARNINGS
#include "pingpong.pb.h"
CAF_POP_WARNINGS

namespace {

using namespace std;
using namespace caf;
using namespace caf::io;

using ping_atom = atom_constant<atom("ping")>;
using pong_atom = atom_constant<atom("pong")>;
using kickoff_atom = atom_constant<atom("kickoff")>;

// utility function to print an exit message with custom name
void print_on_exit(scheduled_actor* self, const std::string& name) {
  self->attach_functor([=](const error& reason) {
    aout(self) << name << " exited: " << self->home_system().render(reason)
               << endl;
  });
}

struct ping_state {
  size_t count = 0;
};

behavior ping(stateful_actor<ping_state>* self, size_t num_pings) {
  print_on_exit(self, "ping");
  return {
    [=](kickoff_atom, const actor& pong) {
      self->send(pong, ping_atom::value, 1);
      self->become (
        [=](pong_atom, int value) -> message {
          if (++(self->state.count) >= num_pings)
            self->quit();
          return make_message(ping_atom::value, value + 1);
        }
      );
    }
  };
}

behavior pong(event_based_actor* self) {
  print_on_exit(self, "pong");
  return {
    [=](ping_atom, int value) {
      return make_message(pong_atom::value, value);
    }
  };
}

void protobuf_io(broker* self, connection_handle hdl, const actor& buddy) {
  print_on_exit(self, "protobuf_io");
  aout(self) << "protobuf broker started" << endl;
  self->monitor(buddy);
  self->set_down_handler(
    [=](const down_msg& dm) {
      if (dm.source == buddy) {
        aout(self) << "our buddy is down" << endl;
        self->quit(dm.reason);
      }
    });
  auto write = [=](const org::libcppa::PingOrPong& p) {
    string buf = p.SerializeAsString();
    auto s = htonl(static_cast<uint32_t>(buf.size()));
    self->write(hdl, sizeof(uint32_t), &s);
    self->write(hdl, buf.size(), buf.data());
    self->flush(hdl);
  };
  message_handler default_bhvr = {
    [=](const connection_closed_msg&) {
      aout(self) << "connection closed" << endl;
      self->send_exit(buddy, exit_reason::remote_link_unreachable);
      self->quit(exit_reason::remote_link_unreachable);
    },
    [=](ping_atom, int i) {
      aout(self) << "'ping' " << i << endl;
      org::libcppa::PingOrPong p;
      p.mutable_ping()->set_id(i);
      write(p);
    },
    [=](pong_atom, int i) {
      aout(self) << "'pong' " << i << endl;
      org::libcppa::PingOrPong p;
      p.mutable_pong()->set_id(i);
      write(p);
    }
  };
  auto await_protobuf_data = message_handler {
    [=](const new_data_msg& msg) {
      org::libcppa::PingOrPong p;
      p.ParseFromArray(msg.buf.data(), static_cast<int>(msg.buf.size()));
      if (p.has_ping()) {
        self->send(buddy, ping_atom::value, p.ping().id());
      }
      else if (p.has_pong()) {
        self->send(buddy, pong_atom::value, p.pong().id());
      }
      else {
        self->quit(exit_reason::user_shutdown);
        cerr << "neither Ping nor Pong!" << endl;
      }
      // receive next length prefix
      self->configure_read(hdl, receive_policy::exactly(sizeof(uint32_t)));
      self->unbecome();
    }
  }.or_else(default_bhvr);
  auto await_length_prefix = message_handler {
    [=](const new_data_msg& msg) {
      uint32_t num_bytes;
      memcpy(&num_bytes, msg.buf.data(), sizeof(uint32_t));
      num_bytes = htonl(num_bytes);
      if (num_bytes > (1024 * 1024)) {
        aout(self) << "someone is trying something nasty" << endl;
        self->quit(exit_reason::user_shutdown);
        return;
      }
      // receive protobuf data
      auto nb = static_cast<size_t>(num_bytes);
      self->configure_read(hdl, receive_policy::exactly(nb));
      self->become(keep_behavior, await_protobuf_data);
    }
  }.or_else(default_bhvr);
  // initial setup
  self->configure_read(hdl, receive_policy::exactly(sizeof(uint32_t)));
  self->become(await_length_prefix);
}

behavior server(broker* self, const actor& buddy) {
  print_on_exit(self, "server");
  aout(self) << "server is running" << endl;
  return {
    [=](const new_connection_msg& msg) {
      aout(self) << "server accepted new connection" << endl;
      auto io_actor = self->fork(protobuf_io, msg.handle, buddy);
      // only accept 1 connection in our example
      self->quit();
    }
  };
}

class config : public actor_system_config {
public:
  uint16_t port = 0;
  std::string host = "localhost";
  bool server_mode = false;

  config() {
    opt_group{custom_options_, "global"}
    .add(port, "port,p", "set port")
    .add(host, "host,H", "set host (ignored in server mode)")
    .add(server_mode, "server-mode,s", "enable server mode");
  }
};

void run_server(actor_system& system, const config& cfg) {
  cout << "run in server mode" << endl;
  auto pong_actor = system.spawn(pong);
  auto server_actor = system.middleman().spawn_server(server, cfg.port,
                                                      pong_actor);
  if (!server_actor)
    cerr << "unable to spawn server: "
         << system.render(server_actor.error()) << endl;
}

void run_client(actor_system& system, const config& cfg) {
  cout << "run in client mode" << endl;
  auto ping_actor = system.spawn(ping, 20u);
  auto io_actor = system.middleman().spawn_client(protobuf_io, cfg.host,
                                                  cfg.port, ping_actor);
  if (!io_actor) {
    cout << "cannot connect to " << cfg.host << " at port " << cfg.port
         << ": " << system.render(io_actor.error()) << endl;
    return;
  }
  send_as(*io_actor, ping_actor, kickoff_atom::value, *io_actor);
}

void caf_main(actor_system& system, const config& cfg) {
  auto f = cfg.server_mode ? run_server : run_client;
  f(system, cfg);
}

} // namespace <anonymous>

CAF_MAIN(io::middleman)
﻿/******************************************************************************\
 * This example program showcases how to manually manage socket IO using      *
 * a broker. Server and client exchange integers in a 'ping-pong protocol'.   *
 *                                                                            *
 * Minimal setup:                                                             *
 * - ./build/bin/broker -s 4242                                               *
 * - ./build/bin/broker -c localhost 4242                                     *
\ ******************************************************************************/

// Manual refs: 46-50 (Actors.tex)

#include "caf/config.hpp"

#ifdef WIN32
# define _WIN32_WINNT 0x0600
# include <winsock2.h>
#else
# include <arpa/inet.h> // htonl
#endif

#include <vector>
#include <string>
#include <limits>
#include <memory>
#include <cstdint>
#include <cassert>
#include <iostream>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

using std::cout;
using std::cerr;
using std::endl;

using namespace caf;
using namespace caf::io;

namespace {

using ping_atom = atom_constant<atom("ping")>;
using pong_atom = atom_constant<atom("pong")>;
using kickoff_atom = atom_constant<atom("kickoff")>;

// utility function to print an exit message with custom name
void print_on_exit(const actor& hdl, const std::string& name) {
  hdl->attach_functor([=](const error& reason) {
    cout << name << " exited: " << to_string(reason) << endl;
  });
}

behavior ping(event_based_actor* self, size_t num_pings) {
  auto count = std::make_shared<size_t>(0);
  return {
    [=](kickoff_atom, const actor& pong) {
      self->send(pong, ping_atom::value, int32_t(1));
      self->become (
        [=](pong_atom, int32_t value) -> result<ping_atom, int32_t> {
          if (++*count >= num_pings) self->quit();
          return {ping_atom::value, value + 1};
        }
      );
    }
  };
}

behavior pong() {
  return {
    [](ping_atom, int32_t value) -> result<pong_atom, int32_t> {
      return {pong_atom::value, value};
    }
  };
}

// utility function for sending an integer type
template <class T>
void write_int(broker* self, connection_handle hdl, T value) {
  using unsigned_type = typename std::make_unsigned<T>::type;
  auto cpy = static_cast<T>(htonl(static_cast<unsigned_type>(value)));
  self->write(hdl, sizeof(T), &cpy);
  self->flush(hdl);
}

void write_int(broker* self, connection_handle hdl, uint64_t value) {
  // write two uint32 values instead (htonl does not work for 64bit integers)
  write_int(self, hdl, static_cast<uint32_t>(value));
  write_int(self, hdl, static_cast<uint32_t>(value >> sizeof(uint32_t)));
}

// utility function for reading an ingeger from incoming data
template <class T>
void read_int(const void* data, T& storage) {
  using unsigned_type = typename std::make_unsigned<T>::type;
  memcpy(&storage, data, sizeof(T));
  storage = static_cast<T>(ntohl(static_cast<unsigned_type>(storage)));
}

void read_int(const void* data, uint64_t& storage) {
  uint32_t first;
  uint32_t second;
  read_int(data, first);
  read_int(reinterpret_cast<const char*>(data) + sizeof(uint32_t), second);
  storage = first | (static_cast<uint64_t>(second) << sizeof(uint32_t));
}

// implemenation of our broker
behavior broker_impl(broker* self, connection_handle hdl, const actor& buddy) {
  // we assume io_fsm manages a broker with exactly one connection,
  // i.e., the connection ponted to by `hdl`
  assert(self->num_connections() == 1);
  // monitor buddy to quit broker if buddy is done
  self->monitor(buddy);
  self->set_down_handler([=](down_msg& dm) {
    if (dm.source == buddy) {
      aout(self) << "our buddy is down" << endl;
      // quit for same reason
      self->quit(dm.reason);
    }
  });
  // setup: we are exchanging only messages consisting of an atom
  // (as uint64_t) and an integer value (int32_t)
  self->configure_read(hdl, receive_policy::exactly(sizeof(uint64_t) +
                            sizeof(int32_t)));
  // our message handlers
  return {
    [=](const connection_closed_msg& msg) {
      // brokers can multiplex any number of connections, however
      // this example assumes io_fsm to manage a broker with
      // exactly one connection
      if (msg.handle == hdl) {
        aout(self) << "connection closed" << endl;
        // force buddy to quit
        self->send_exit(buddy, exit_reason::remote_link_unreachable);
        self->quit(exit_reason::remote_link_unreachable);
      }
    },
    [=](atom_value av, int32_t i) {
      assert(av == ping_atom::value || av == pong_atom::value);
      aout(self) << "send {" << to_string(av) << ", " << i << "}" << endl;
      // cast atom to its underlying type, i.e., uint64_t
      write_int(self, hdl, static_cast<uint64_t>(av));
      write_int(self, hdl, i);
    },
    [=](const new_data_msg& msg) {
      // read the atom value as uint64_t from buffer
      uint64_t atm_val;
      read_int(msg.buf.data(), atm_val);
      // cast to original type
      auto atm = static_cast<atom_value>(atm_val);
      // read integer value from buffer, jumping to the correct
      // position via offset_data(...)
      int32_t ival;
      read_int(msg.buf.data() + sizeof(uint64_t), ival);
      // show some output
      aout(self) << "received {" << to_string(atm) << ", " << ival << "}"
             << endl;
      // send composed message to our buddy
      self->send(buddy, atm, ival);
    }
  };
}

behavior server(broker* self, const actor& buddy) {
  aout(self) << "server is running" << endl;
  return {
    [=](const new_connection_msg& msg) {
      aout(self) << "server accepted new connection" << endl;
      // by forking into a new broker, we are no longer
      // responsible for the connection
      auto impl = self->fork(broker_impl, msg.handle, buddy);
      print_on_exit(impl, "broker_impl");
      aout(self) << "quit server (only accept 1 connection)" << endl;
      self->quit();
    }
  };
}

class config : public actor_system_config {
public:
  uint16_t port = 0;
  std::string host = "localhost";
  bool server_mode = false;

  config() {
    opt_group{custom_options_, "global"}
    .add(port, "port,p", "set port")
    .add(host, "host,H", "set host (ignored in server mode)")
    .add(server_mode, "server-mode,s", "enable server mode");
  }
};

void run_server(actor_system& system, const config& cfg) {
  cout << "run in server mode" << endl;
  auto pong_actor = system.spawn(pong);
  auto server_actor = system.middleman().spawn_server(server, cfg.port,
                                                      pong_actor);
  if (!server_actor) {
    std::cerr << "failed to spawn server: "
               << system.render(server_actor.error()) << endl;
    return;
  }
  print_on_exit(*server_actor, "server");
  print_on_exit(pong_actor, "pong");
}

void run_client(actor_system& system, const config& cfg) {
  auto ping_actor = system.spawn(ping, size_t{20});
  auto io_actor = system.middleman().spawn_client(broker_impl, cfg.host,
                                                  cfg.port, ping_actor);
  if (!io_actor) {
    std::cerr << "failed to spawn client: "
               << system.render(io_actor.error()) << endl;
    return;
  }
  print_on_exit(ping_actor, "ping");
  print_on_exit(*io_actor, "protobuf_io");
  send_as(*io_actor, ping_actor, kickoff_atom::value, *io_actor);
}

void caf_main(actor_system& system, const config& cfg) {
  auto f = cfg.server_mode ? run_server : run_client;
  f(system, cfg);
}

} // namespace <anonymous>

CAF_MAIN(io::middleman)
#include <iostream>
#include <chrono>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

using std::cout;
using std::cerr;
using std::endl;

using namespace caf;
using namespace caf::io;

namespace {

using tick_atom = atom_constant<atom("tick")>;

constexpr const char http_ok[] = R"__(HTTP/1.1 200 OK
Content-Type: text/plain
Connection: keep-alive
Transfer-Encoding: chunked

d
Hi there! :)

0


)__";

template <size_t Size>
constexpr size_t cstr_size(const char (&)[Size]) {
  return Size;
}

behavior connection_worker(broker* self, connection_handle hdl) {
  self->configure_read(hdl, receive_policy::at_most(1024));
  return {
    [=](const new_data_msg& msg) {
      self->write(msg.handle, cstr_size(http_ok), http_ok);
      self->quit();
    },
    [=](const connection_closed_msg&) {
      self->quit();
    }
  };
}

behavior server(broker* self) {
  auto counter = std::make_shared<int>(0);
  self->set_down_handler([=](down_msg&) {
    ++*counter;
  });
  self->delayed_send(self, std::chrono::seconds(1), tick_atom::value);
  return {
    [=](const new_connection_msg& ncm) {
      auto worker = self->fork(connection_worker, ncm.handle);
      self->monitor(worker);
      self->link_to(worker);
    },
    [=](tick_atom) {
      aout(self) << "Finished " << *counter << " requests per second." << endl;
      *counter = 0;
      self->delayed_send(self, std::chrono::seconds(1), tick_atom::value);
    }
  };
}

class config : public actor_system_config {
public:
  uint16_t port = 0;

  config() {
    opt_group{custom_options_, "global"}
    .add(port, "port,p", "set port");
  }
};

void caf_main(actor_system& system, const config& cfg) {
  auto server_actor = system.middleman().spawn_server(server, cfg.port);
  if (!server_actor) {
    cerr << "*** cannot spawn server: "
         << system.render(server_actor.error()) << endl;
    return;
  }
  cout << "*** listening on port " << cfg.port << endl;
  cout << "*** to quit the program, simply press <enter>" << endl;
  // wait for any input
  std::string dummy;
  std::getline(std::cin, dummy);
  // kill server
  anon_send_exit(*server_actor, exit_reason::user_shutdown);
}

} // namespace <anonymous>

CAF_MAIN(io::middleman)
/******************************************************************************
 * This example                                                               *
 * - emulates a client launching a request every 10-300ms                     *
 * - uses a CURL-backend consisting of a master and 10 workers                *
 * - runs until it is shut down by a CTRL+C signal                            *
 *                                                                            *
 *                                                                            *
 * Schematic view:                                                            *
 *                                                                            *
 *    client      |    client_job    |    curl_master    |    curl_worker     *
 *          /--------------|*|-------------\       /-------------|*|          *
 *         /---------------|*|--------------\     /                           *
 *        /----------------|*|---------------\   /                            *
 *     |*| ----------------|*|----------------|*|----------------|*|          *
 *        \________________|*|_______________/   \                            *
 *         \_______________|*|______________/     \                           *
 *          \______________|*|_____________/       \-------------|*|          *
 *                                                                            *
 *                                                                            *
 * Communication pattern:                                                     *
 *                                                                            *
 *        client_job      curl_master        curl_worker                      *
 *          |                  |                  |                           *
 *          | ----(read)-----> |                  |                           *
 *          |                  | --(forward)----> |                           *
 *          |                                     |---\                       *
 *          |                                     |   |                       *
 *          |                                     |<--/                       *
 *          | <-------------(reply)-------------- |                           *
 *          X                                                                 *
 ******************************************************************************/

// C includes
#include <ctime>
#include <csignal>
#include <cstdlib>

// C++ includes
#include <string>
#include <vector>
#include <random>
#include <iostream>

// CAF
#include "caf/all.hpp"
#include "caf/io/all.hpp"

CAF_PUSH_WARNINGS
#include <curl/curl.h>
CAF_POP_WARNINGS

// disable some clang warnings here caused by CURL macros
#ifdef __clang__
# pragma clang diagnostic ignored "-Wshorten-64-to-32"
# pragma clang diagnostic ignored "-Wdisabled-macro-expansion"
# pragma clang diagnostic ignored "-Wunused-const-variable"
#endif // __clang__

using namespace caf;

using buffer_type = std::vector<char>;

using read_atom = atom_constant<atom("read")>;
using fail_atom = atom_constant<atom("fail")>;
using next_atom = atom_constant<atom("next")>;
using reply_atom = atom_constant<atom("reply")>;
using finished_atom = atom_constant<atom("finished")>;

namespace color {

// UNIX terminal color codes
constexpr char reset[]        = "\033[0m";
constexpr char reset_endl[]   = "\033[0m\n";
constexpr char black[]        = "\033[30m";
constexpr char red[]          = "\033[31m";
constexpr char green[]        = "\033[32m";
constexpr char yellow[]       = "\033[33m";
constexpr char blue[]         = "\033[34m";
constexpr char magenta[]      = "\033[35m";
constexpr char cyan[]         = "\033[36m";
constexpr char white[]        = "\033[37m";
constexpr char bold_black[]   = "\033[1m\033[30m";
constexpr char bold_red[]     = "\033[1m\033[31m";
constexpr char bold_green[]   = "\033[1m\033[32m";
constexpr char bold_yellow[]  = "\033[1m\033[33m";
constexpr char bold_blue[]    = "\033[1m\033[34m";
constexpr char bold_magenta[] = "\033[1m\033[35m";
constexpr char bold_cyan[]    = "\033[1m\033[36m";
constexpr char bold_white[]   = "\033[1m\033[37m";

} // namespace color

// number of HTTP workers
constexpr size_t num_curl_workers = 10;

// minimum delay between HTTP requests
constexpr int min_req_interval = 10;

// maximum delay between HTTP requests
constexpr int max_req_interval = 300;

// put everything into anonymous namespace (except main)
namespace {

// provides print utility, a name, and a parent
struct base_state {
  base_state(local_actor* thisptr) : self(thisptr) {
    // nop
  }

  actor_ostream print() {
    return aout(self) << color << name << " (id = " << self->id() << "): ";
  }

  virtual bool init(std::string m_name, std::string m_color) {
    name = std::move(m_name);
    color = std::move(m_color);
    print() << "started" << color::reset_endl;
    return true;
  }

  virtual ~base_state() {
    print() << "done" << color::reset_endl;
  }

  local_actor* self;
  std::string name;
  std::string color;
};

// encapsulates an HTTP request
behavior client_job(stateful_actor<base_state>* self, const actor& parent) {
  if (!self->state.init("client-job", color::blue))
    return {}; // returning an empty behavior terminates the actor
  self->send(parent, read_atom::value,
             "http://www.example.com/index.html",
             uint64_t{0}, uint64_t{4095});
  return {
    [=](reply_atom, const buffer_type& buf) {
      self->state.print() << "successfully received " << buf.size() << " bytes"
                          << color::reset_endl;
      self->quit();
    },
    [=](fail_atom) {
      self->state.print() << "failure" << color::reset_endl;
      self->quit();
    }
  };
}

struct client_state : base_state {
  client_state(local_actor* selfptr)
      : base_state(selfptr),
        count(0),
        re(rd()),
        dist(min_req_interval, max_req_interval) {
    // nop
  }

  size_t count;
  std::random_device rd;
  std::default_random_engine re;
  std::uniform_int_distribution<int> dist;
};

// spawns HTTP requests
behavior client(stateful_actor<client_state>* self, const actor& parent) {
  using std::chrono::milliseconds;
  self->link_to(parent);
  if (!self->state.init("client", color::green))
    return {}; // returning an empty behavior terminates the actor
  self->send(self, next_atom::value);
  return {
    [=](next_atom) {
      auto& st = self->state;
      st.print() << "spawn new client_job (nr. " << ++st.count << ")"
                 << color::reset_endl;
      // client_job will use IO
      // and should thus be spawned in a separate thread
      self->spawn<detached+linked>(client_job, parent);
      // compute random delay until next job is launched
      auto delay = st.dist(st.re);
      self->delayed_send(self, milliseconds(delay), next_atom::value);
    }
  };
}

struct curl_state : base_state {
  curl_state(local_actor* selfptr) : base_state(selfptr) {
    // nop
  }

  ~curl_state() override {
    if (curl != nullptr)
      curl_easy_cleanup(curl);
  }

  static size_t callback(void* data, size_t bsize, size_t nmemb, void* userp) {
    size_t size = bsize * nmemb;
    auto& buf = reinterpret_cast<curl_state*>(userp)->buf;
    auto first = reinterpret_cast<char*>(data);
    auto last = first + bsize;
    buf.insert(buf.end(), first, last);
    return size;
  }

  bool init(std::string m_name, std::string m_color) override {
    curl = curl_easy_init();
    if (curl == nullptr)
      return false;
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &curl_state::callback);
    curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);
    return base_state::init(std::move(m_name), std::move(m_color));
  }

  CURL*       curl = nullptr;
  buffer_type buf;
};

// manages a CURL session
behavior curl_worker(stateful_actor<curl_state>* self, const actor& parent) {
  if (!self->state.init("curl-worker", color::yellow))
    return {}; // returning an empty behavior terminates the actor
  return {
    [=](read_atom, const std::string& fname, uint64_t offset, uint64_t range)
    -> message {
      auto& st = self->state;
      st.print() << "read" << color::reset_endl;
      for (;;) {
        st.buf.clear();
        // set URL
        curl_easy_setopt(st.curl, CURLOPT_URL, fname.c_str());
        // set range
        std::ostringstream oss;
        oss << offset << "-" << range;
        curl_easy_setopt(st.curl, CURLOPT_RANGE, oss.str().c_str());
        // set curl callback
        curl_easy_setopt(st.curl, CURLOPT_WRITEDATA,
                         reinterpret_cast<void*>(&st));
        // launch file transfer
        auto res = curl_easy_perform(st.curl);
        if (res != CURLE_OK) {
          st.print() << "curl_easy_perform() failed: "
                     << curl_easy_strerror(res)
                     << color::reset_endl;
        } else {
          long hc = 0; // http return code
          curl_easy_getinfo(st.curl, CURLINFO_RESPONSE_CODE, &hc);
          switch (hc) {
            default:
              st.print() << "http error: download failed with "
                         << "'HTTP RETURN CODE': "
                         << hc
                         << color::reset_endl;
              break;
            case 200: // ok
            case 206: // partial content
              st.print() << "received "
                         << st.buf.size()
                         << " bytes with 'HTTP RETURN CODE': "
                         << hc
                         << color::reset_endl;
              // tell parent that this worker is done
              self->send(parent, finished_atom::value);
              return make_message(reply_atom::value, std::move(st.buf));
            case 404: // file does not exist
              st.print() << "http error: download failed with "
                         << "'HTTP RETURN CODE': 404 (file does "
                         << "not exist!)"
                         << color::reset_endl;
          }
        }
        // avoid 100% cpu utilization if remote side is not accessible
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
      }
    }
  };
}

struct master_state : base_state {
  master_state(local_actor* selfptr) : base_state(selfptr) {
    // nop
  }
  std::vector<actor> idle;
  std::vector<actor> busy;
};

behavior curl_master(stateful_actor<master_state>* self) {
  if (!self->state.init("curl-master", color::magenta))
    return {}; // returning an empty behavior terminates the actor
  // spawn workers
  for(size_t i = 0; i < num_curl_workers; ++i)
    self->state.idle.push_back(self->spawn<detached+linked>(curl_worker, self));
  auto worker_finished = [=] {
    auto sender = self->current_sender();
    auto last = self->state.busy.end();
    auto i = std::find(self->state.busy.begin(), last, sender);
    if (i == last)
      return;
    self->state.idle.push_back(*i);
    self->state.busy.erase(i);
    self->state.print() << "worker is done" << color::reset_endl;
  };
  self->state.print() << "spawned " << self->state.idle.size()
                      << " worker(s)" << color::reset_endl;
  return {
    [=](read_atom rd, std::string& str, uint64_t x, uint64_t y) {
      auto& st = self->state;
      st.print() << "received {'read'}" << color::reset_endl;
      // forward job to an idle worker
      actor worker = st.idle.back();
      st.idle.pop_back();
      st.busy.push_back(worker);
      self->delegate(worker, rd, std::move(str), x, y);
      st.print() << st.busy.size() << " active jobs" << color::reset_endl;
      if (st.idle.empty()) {
        // wait until at least one worker finished its job
        self->become (
          keep_behavior,
          [=](finished_atom) {
            worker_finished();
            self->unbecome();
          }
        );
      }
    },
    [=](finished_atom) {
      worker_finished();
    }
  };
}

// signal handling for ctrl+c
std::atomic<bool> shutdown_flag{false};

} // namespace <anonymous>

void caf_main(actor_system& system) {
  // install signal handler
  struct sigaction act;
  act.sa_handler = [](int) { shutdown_flag = true; };
  auto set_sighandler = [&] {
    if (sigaction(SIGINT, &act, nullptr) != 0) {
      std::cerr << "fatal: cannot set signal handler" << std::endl;
      abort();
    }
  };
  set_sighandler();
  // initialize CURL
  curl_global_init(CURL_GLOBAL_DEFAULT);
  // get a scoped actor for the communication with our CURL actors
  scoped_actor self{system};
  // spawn client and curl_master
  auto master = self->spawn<detached>(curl_master);
  self->spawn<detached>(client, master);
  // poll CTRL+C flag every second
  while (!shutdown_flag)
    std::this_thread::sleep_for(std::chrono::seconds(1));
  aout(self) << color::cyan << "received CTRL+C" << color::reset_endl;
  // shutdown actors
  anon_send_exit(master, exit_reason::user_shutdown);
  // await actors
  act.sa_handler = [](int) { abort(); };
  set_sighandler();
  aout(self) << color::cyan
             << "await CURL; this may take a while "
                "(press CTRL+C again to abort)"
             << color::reset_endl;
  self->await_all_other_actors_done();
  // shutdown CURL
  curl_global_cleanup();
}

CAF_MAIN(io::middleman)
#include <string>
#include <iostream>

#include "caf/all.hpp"

using std::endl;
using std::string;

using namespace caf;

behavior mirror(event_based_actor* self) {
  // return the (initial) actor behavior
  return {
    // a handler for messages containing a single string
    // that replies with a string
    [=](const string& what) -> string {
      // prints "Hello World!" via aout (thread-safe cout wrapper)
      aout(self) << what << endl;
      // reply "!dlroW olleH"
      return string(what.rbegin(), what.rend());
    }
  };
}

void hello_world(event_based_actor* self, const actor& buddy) {
  // send "Hello World!" to our buddy ...
  self->request(buddy, std::chrono::seconds(10), "Hello World!").then(
    // ... wait up to 10s for a response ...
    [=](const string& what) {
      // ... and print it
      aout(self) << what << endl;
    }
  );
}

int main() {
  // our CAF environment
  actor_system_config cfg;
  actor_system system{cfg};
  // create a new actor that calls 'mirror()'
  auto mirror_actor = system.spawn(mirror);
  // create another actor that calls 'hello_world(mirror_actor)';
  system.spawn(hello_world, mirror_actor);
  // system will wait until both actors are destroyed before leaving main
}
#include <random>
#include <chrono>
#include <cstdlib>
#include <iostream>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

using namespace caf;
using std::endl;

void caf_main(actor_system& system) {
  for (int i = 1; i <= 50; ++i) {
    system.spawn([i](blocking_actor* self) {
      aout(self) << "Hi there! This is actor nr. "
                 << i << "!" << endl;
      std::random_device rd;
      std::default_random_engine re(rd());
      std::chrono::milliseconds tout{re() % 10};
      self->delayed_send(self, tout, 42);
      self->receive(
        [i, self](int) {
          aout(self) << "Actor nr. "
                     << i << " says goodbye!" << endl;
        }
      );
    });
  }
}

CAF_MAIN()
// Showcases custom message types that cannot provide
// friend access to the inspect() function.

// Manual refs: 20-49, 76-103 (TypeInspection)

#include <utility>
#include <iostream>

#include "caf/all.hpp"

using std::cout;
using std::endl;
using std::make_pair;

using namespace caf;

namespace {

// identical to our second custom type example, but
// no friend access for `inspect`
class foo {
public:
  foo(int a0 = 0, int b0 = 0) : a_(a0), b_(b0) {
    // nop
  }

  foo(const foo&) = default;
  foo& operator=(const foo&) = default;

  int a() const {
    return a_;
  }

  void set_a(int val) {
    a_ = val;
  }

  int b() const {
    return b_;
  }

  void set_b(int val) {
    b_ = val;
  }

private:
  int a_;
  int b_;
};

// A lightweight scope guard implementation.
template <class Fun>
class scope_guard {
public:
  scope_guard(Fun f) : fun_(std::move(f)), enabled_(true) { }

  scope_guard(scope_guard&& x) : fun_(std::move(x.fun_)), enabled_(x.enabled_) {
    x.enabled_ = false;
  }

  ~scope_guard() {
    if (enabled_) fun_();
  }

private:
  Fun fun_;
  bool enabled_;
};

// Creates a guard that executes `f` as soon as it goes out of scope.
template <class Fun>
scope_guard<Fun> make_scope_guard(Fun f) {
  return {std::move(f)};
}

template <class Inspector>
typename std::enable_if<Inspector::reads_state,
                        typename Inspector::result_type>::type
inspect(Inspector& f, foo& x) {
  return f(meta::type_name("foo"), x.a(), x.b());
}

template <class Inspector>
typename std::enable_if<Inspector::writes_state,
                        typename Inspector::result_type>::type
inspect(Inspector& f, foo& x) {
  int a;
  int b;
  // write back to x at scope exit
  auto g = make_scope_guard([&] {
    x.set_a(a);
    x.set_b(b);
  });
  return f(meta::type_name("foo"), a, b);
}

behavior testee(event_based_actor* self) {
  return {
    [=](const foo& x) {
      aout(self) << to_string(x) << endl;
    }
  };
}

class config : public actor_system_config {
public:
  config() {
    add_message_type<foo>("foo");
  }
};

void caf_main(actor_system& system, const config&) {
  anon_send(system.spawn(testee), foo{1, 2});
}

} // namespace <anonymous>

CAF_MAIN()
// showcases how to add custom message types to CAF
// if friend access for serialization is available

#include <utility>
#include <iostream>

#include "caf/all.hpp"

using std::cout;
using std::endl;
using std::make_pair;

using namespace caf;

namespace {

// a simple class using getter and setter member functions
class foo {
public:
  foo(int a0 = 0, int b0 = 0) : a_(a0), b_(b0) {
    // nop
  }

  foo(const foo&) = default;
  foo& operator=(const foo&) = default;

  int a() const {
    return a_;
  }

  void set_a(int val) {
    a_ = val;
  }

  int b() const {
    return b_;
  }

  void set_b(int val) {
    b_ = val;
  }

  template <class Inspector>
  friend typename Inspector::result_type inspect(Inspector& f, foo& x) {
    return f(meta::type_name("foo"), x.a_, x.b_);
  }

private:
  int a_;
  int b_;
};

behavior testee(event_based_actor* self) {
  return {
    [=](const foo& x) {
      aout(self) << to_string(x) << endl;
    }
  };
}

class config : public actor_system_config {
public:
  config() {
    add_message_type<foo>("foo");
  }
};

void caf_main(actor_system& system, const config&) {
  anon_send(system.spawn(testee), foo{1, 2});
}

} // namespace <anonymous>

CAF_MAIN()
// Showcases how to add custom POD message types.

// Manual refs: 24-27, 30-34, 75-78, 81-84 (ConfiguringActorApplications)
//              23-33 (TypeInspection)

#include <string>
#include <vector>
#include <cassert>
#include <utility>
#include <iostream>

#include "caf/all.hpp"

using std::cout;
using std::cerr;
using std::endl;
using std::vector;

using namespace caf;

namespace {

// POD struct foo
struct foo {
  std::vector<int> a;
  int b;
};

// foo needs to be serializable
template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, foo& x) {
  return f(meta::type_name("foo"), x.a, x.b);
}

// a pair of two ints
using foo_pair = std::pair<int, int>;

// another alias for pairs of two ints
using foo_pair2 = std::pair<int, int>;

// a struct with a nested container
struct foo2 {
  int a;
  vector<vector<double>> b;
};

// foo2 also needs to be serializable
template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, foo2& x) {
  return f(meta::type_name("foo2"), x.a, x.b);
}

// receives our custom message types
void testee(event_based_actor* self, size_t remaining) {
  auto set_next_behavior = [=] {
    if (remaining > 1)
      testee(self, remaining - 1);
    else
      self->quit();
  };
  self->become (
    // note: we sent a foo_pair2, but match on foo_pair
    // that works because both are aliases for std::pair<int, int>
    [=](const foo_pair& val) {
      aout(self) << "foo_pair" << deep_to_string(val) << endl;
      set_next_behavior();
    },
    [=](const foo& val) {
      aout(self) << to_string(val) << endl;
      set_next_behavior();
    }
  );
}

class config : public actor_system_config {
public:
  config() {
    add_message_type<foo>("foo");
    add_message_type<foo2>("foo2");
    add_message_type<foo_pair>("foo_pair");
  }
};

void caf_main(actor_system& system, const config&) {
  // two variables for testing serialization
  foo2 f1;
  foo2 f2;
  // init some test data
  f1.a = 5;
  f1.b.resize(1);
  f1.b.back().push_back(42);
  // I/O buffer
  vector<char> buf;
  // write f1 to buffer
  binary_serializer bs{system, buf};
  auto e = bs(f1);
  if (e) {
    std::cerr << "*** unable to serialize foo2: "
              << system.render(e) << std::endl;
    return;
  }
  // read f2 back from buffer
  binary_deserializer bd{system, buf};
  e = bd(f2);
  if (e) {
    std::cerr << "*** unable to serialize foo2: "
              << system.render(e) << std::endl;
    return;
  }
  // must be equal
  assert(to_string(f1) == to_string(f2));
  // spawn a testee that receives two messages of user-defined type
  auto t = system.spawn(testee, 2u);
  scoped_actor self{system};
  // send t a foo
  self->send(t, foo{std::vector<int>{1, 2, 3, 4}, 5});
  // send t a foo_pair2
  self->send(t, foo_pair2{3, 4});
}

} // namespace <anonymous>

CAF_MAIN()
/******************************************************************************\
 * This example is a very basic, non-interactive math service implemented     *
 * using composable states.                                                   *
\******************************************************************************/

// This file is partially included in the manual, do not modify
// without updating the references in the *.tex files!
// Manual references: lines 20-52 (Actor.tex)

#include <iostream>

#include "caf/all.hpp"

using std::cout;
using std::endl;
using namespace caf;

namespace {

// using add_atom = atom_constant<atom("add")>; (defined in atom.hpp)
using multiply_atom = atom_constant<atom("multiply")>;

using adder = typed_actor<replies_to<add_atom, int, int>::with<int>>;
using multiplier = typed_actor<replies_to<multiply_atom, int, int>::with<int>>;

class adder_bhvr : public composable_behavior<adder> {
public:
  result<int> operator()(add_atom, int x, int y) override {
    return x + y;
  }
};

class multiplier_bhvr : public composable_behavior<multiplier> {
public:
  result<int> operator()(multiply_atom, int x, int y) override {
    return x * y;
  }
};

// calculator_bhvr can be inherited from or composed further
using calculator_bhvr = composed_behavior<adder_bhvr, multiplier_bhvr>;

} // namespace <anonymous>

void caf_main(actor_system& system) {
  auto f = make_function_view(system.spawn<calculator_bhvr>());
  cout << "10 + 20 = " << f(add_atom::value, 10, 20) << endl;
  cout << "7 * 9 = " << f(multiply_atom::value, 7, 9) << endl;
}

CAF_MAIN()
/******************************************************************************\
 * This example is a simple dictionary implemented * using composable states. *
\******************************************************************************/

// This file is partially included in the manual, do not modify
// without updating the references in the *.tex files!
// Manual references: lines 22-44 (Actor.tex)

#include <string>
#include <iostream>
#include <unordered_map>

#include "caf/all.hpp"

using std::cout;
using std::endl;
using std::string;
using namespace caf;

namespace {

using dict = typed_actor<reacts_to<put_atom, string, string>,
                         replies_to<get_atom, string>::with<string>>;

class dict_behavior : public composable_behavior<dict> {
public:
  result<string> operator()(get_atom, param<string> key) override {
    auto i = values_.find(key);
    if (i == values_.end())
      return "";
    return i->second;
  }

  result<void> operator()(put_atom, param<string> key,
                          param<string> value) override {
    if (values_.count(key) != 0)
      return unit;
    values_.emplace(key.move(), value.move());
    return unit;
  }

protected:
  std::unordered_map<string, string> values_;
};

} // namespace <anonymous>

void caf_main(actor_system& system) {
  auto f = make_function_view(system.spawn<dict_behavior>());
  f(put_atom::value, "CAF", "success");
  cout << "CAF is the key to " << f(get_atom::value, "CAF") << endl;
}

CAF_MAIN()
/******************************************************************************\
 * This example is a very basic, non-interactive math service implemented     *
 * for both the blocking and the event-based API.                             *
\******************************************************************************/

// This file is partially included in the manual, do not modify
// without updating the references in the *.tex files!
// Manual references: lines 18-44, and 49-50 (Actor.tex)

#include <iostream>

#include "caf/all.hpp"

using std::cout;
using std::endl;
using namespace caf;

using cell = typed_actor<reacts_to<put_atom, int>,
                         replies_to<get_atom>::with<int>>;

struct cell_state {
  int value = 0;
};

cell::behavior_type type_checked_cell(cell::stateful_pointer<cell_state> self) {
  return {
    [=](put_atom, int val) {
      self->state.value = val;
    },
    [=](get_atom) {
      return self->state.value;
    }
  };
}

behavior unchecked_cell(stateful_actor<cell_state>* self) {
  return {
    [=](put_atom, int val) {
      self->state.value = val;
    },
    [=](get_atom) {
      return self->state.value;
    }
  };
}

void caf_main(actor_system& system) {
  // create one cell for each implementation
  auto cell1 = system.spawn(type_checked_cell);
  auto cell2 = system.spawn(unchecked_cell);
  auto f = make_function_view(cell1);
  cout << "cell value: " << f(get_atom::value) << endl;
  f(put_atom::value, 20);
  cout << "cell value (after setting to 20): " << f(get_atom::value) << endl;
  // get an unchecked cell and send it some garbage
  anon_send(cell2, "hello there!");
}

CAF_MAIN()
/******************************************************************************\
 * This example illustrates how to do time-triggered loops in libcaf.         *
\ ******************************************************************************/

#include <chrono>
#include <iostream>
#include <algorithm>
#include "caf/all.hpp"

// This file is partially included in the manual, do not modify
// without updating the references in the *.tex files!
// Manual references: lines 56-75 (MessagePassing.tex)

using std::cout;
using std::endl;
using std::pair;

using namespace caf;

using step_atom = atom_constant<atom("step")>;

// ASCII art figures
constexpr const char* figures[] = {
  "<(^.^<)",
  "<(^.^)>",
  "(>^.^)>"
};

struct animation_step { size_t figure_idx; size_t offset; };

// array of {figure, offset} pairs
constexpr animation_step animation_steps[] = {
  {1,  7}, {0,  7}, {0,  6}, {0,  5}, {1,  5}, {2,  5}, {2,  6},
  {2,  7}, {2,  8}, {2,  9}, {2, 10}, {1, 10}, {0, 10}, {0,  9},
  {1,  9}, {2, 10}, {2, 11}, {2, 12}, {2, 13}, {1, 13}, {0, 13},
  {0, 12}, {0, 11}, {0, 10}, {0,  9}, {0,  8}, {0,  7}, {1,  7}
};

constexpr size_t animation_width = 20;

// "draws" an animation step by printing "{offset_whitespaces}{figure}{padding}"
void draw_kirby(const animation_step& animation) {
  cout.width(animation_width);
  // override last figure
  cout << '\r';
  // print offset
  std::fill_n(std::ostream_iterator<char>{cout}, animation.offset, ' ');
  // print figure
  cout << figures[animation.figure_idx];
  // print padding
  cout.fill(' ');
  // make sure figure is printed
  cout.flush();
}

// uses a message-based loop to iterate over all animation steps
void dancing_kirby(event_based_actor* self) {
  // let's get it started
  self->send(self, step_atom::value, size_t{0});
  self->become (
    [=](step_atom, size_t step) {
      if (step == sizeof(animation_step)) {
        // we've printed all animation steps (done)
        cout << endl;
        self->quit();
        return;
      }
      // print given step
      draw_kirby(animation_steps[step]);
      // animate next step in 150ms
      self->delayed_send(self, std::chrono::milliseconds(150),
                         step_atom::value, step + 1);
    }
  );
}

void caf_main(actor_system& system) {
  system.spawn(dancing_kirby);
}

CAF_MAIN()
/******************************************************************************\
 * A very basic, interactive divider.                                         *
\******************************************************************************/

// Manual refs: 19-25, 35-48, 68-77 (MessagePassing);
//              19-34, 50-58 (Error)

#include <iostream>

#include "caf/all.hpp"

using std::cout;
using std::endl;
using std::flush;
using namespace caf;

namespace {

enum class math_error : uint8_t {
  division_by_zero = 1
};

error make_error(math_error x) {
  return {static_cast<uint8_t>(x), atom("math")};
}

std::string to_string(math_error x) {
  switch (x) {
    case math_error::division_by_zero:
      return "division_by_zero";
    default:
      return "-unknown-error-";
  }
}

using div_atom = atom_constant<atom("div")>;

using divider = typed_actor<replies_to<div_atom, double, double>::with<double>>;

divider::behavior_type divider_impl() {
  return {
    [](div_atom, double x, double y) -> result<double> {
      if (y == 0.0)
        return math_error::division_by_zero;
      return x / y;
    }
  };
}

class config : public actor_system_config {
public:
  config() {
    auto renderer = [](uint8_t x, atom_value, const message&) {
      return "math_error" + deep_to_string_as_tuple(static_cast<math_error>(x));
    };
    add_error_category(atom("math"), renderer);
  }
};

void caf_main(actor_system& system, const config&) {
  double x;
  double y;
  cout << "x: " << flush;
  std::cin >> x;
  cout << "y: " << flush;
  std::cin >> y;
  auto div = system.spawn(divider_impl);
  scoped_actor self{system};
  self->request(div, std::chrono::seconds(10), div_atom::value, x, y).receive(
    [&](double z) {
      aout(self) << x << " / " << y << " = " << z << endl;
    },
    [&](const error& err) {
      aout(self) << "*** cannot compute " << x << " / " << y << " => "
                 << system.render(err) << endl;
    }
  );
}

} // namespace <anonymous>

CAF_MAIN()
#include <cassert>
#include <cstdint>
#include <iostream>
#include "caf/all.hpp"

using std::endl;
using namespace caf;

namespace {

using pop_atom = atom_constant<atom("pop")>;
using push_atom = atom_constant<atom("push")>;

enum class fixed_stack_errc : uint8_t { push_to_full = 1, pop_from_empty };

error make_error(fixed_stack_errc x) {
  return error{static_cast<uint8_t>(x), atom("FixedStack")};
}

class fixed_stack : public event_based_actor {
public:
  fixed_stack(actor_config& cfg, size_t stack_size)
      : event_based_actor(cfg),
        size_(stack_size)  {
    full_.assign(
      [=](push_atom, int) -> error {
        return fixed_stack_errc::push_to_full;
      },
      [=](pop_atom) -> int {
        auto result = data_.back();
        data_.pop_back();
        become(filled_);
        return result;
      }
    );
    filled_.assign(
      [=](push_atom, int what) {
        data_.push_back(what);
        if (data_.size() == size_)
          become(full_);
      },
      [=](pop_atom) -> int {
        auto result = data_.back();
        data_.pop_back();
        if (data_.empty())
          become(empty_);
        return result;
      }
    );
    empty_.assign(
      [=](push_atom, int what) {
        data_.push_back(what);
        become(filled_);
      },
      [=](pop_atom) -> error {
        return fixed_stack_errc::pop_from_empty;
      }
    );
  }

  behavior make_behavior() override {
    assert(size_ < 2);
    return empty_;
  }

private:
  size_t size_;
  std::vector<int> data_;
  behavior full_;
  behavior filled_;
  behavior empty_;
};

void caf_main(actor_system& system) {
  scoped_actor self{system};
  auto st = self->spawn<fixed_stack>(5u);
  // fill stack
  for (int i = 0; i < 10; ++i)
    self->send(st, push_atom::value, i);
  // drain stack
  aout(self) << "stack: { ";
  bool stack_empty = false;
  while (!stack_empty) {
    self->request(st, std::chrono::seconds(10), pop_atom::value).receive(
      [&](int x) {
        aout(self) << x << "  ";
      },
      [&](const error&) {
        stack_empty = true;
      }
    );
  }
  aout(self) << "}" << endl;
  self->send_exit(st, exit_reason::user_shutdown);
}

} // namespace <anonymous>

CAF_MAIN()
/******************************************************************************\
 * This example is a very basic, non-interactive math service implemented     *
 * for both the blocking and the event-based API.                             *
\******************************************************************************/

// Manual refs: lines 19-21, 31-72, 74-108, 140-145 (Actor)

#include <iostream>

#include "caf/all.hpp"

using std::endl;
using namespace caf;

namespace {

using add_atom = atom_constant<atom("add")>;
using sub_atom = atom_constant<atom("sub")>;

using calculator_actor = typed_actor<replies_to<add_atom, int, int>::with<int>,
                                     replies_to<sub_atom, int, int>::with<int>>;

// prototypes and forward declarations
behavior calculator_fun(event_based_actor* self);
void blocking_calculator_fun(blocking_actor* self);
calculator_actor::behavior_type typed_calculator_fun();
class calculator;
class blocking_calculator;
class typed_calculator;

// function-based, dynamically typed, event-based API
behavior calculator_fun(event_based_actor*) {
  return behavior{
    [](add_atom, int a, int b) {
      return a + b;
    },
    [](sub_atom, int a, int b) {
      return a - b;
    }
  };
}

// function-based, dynamically typed, blocking API
void blocking_calculator_fun(blocking_actor* self) {
  bool running = true;
  self->receive_while(running) (
    [](add_atom, int a, int b) {
      return a + b;
    },
    [](sub_atom, int a, int b) {
      return a - b;
    },
    [&](exit_msg& em) {
      if (em.reason) {
        self->fail_state(std::move(em.reason));
        running = false;
      }
    }
  );
}

// function-based, statically typed, event-based API
calculator_actor::behavior_type typed_calculator_fun() {
  return {
    [](add_atom, int a, int b) {
      return a + b;
    },
    [](sub_atom, int a, int b) {
      return a - b;
    }
  };
}

// class-based, dynamically typed, event-based API
class calculator : public event_based_actor {
public:
  calculator(actor_config& cfg) : event_based_actor(cfg) {
    // nop
  }

  behavior make_behavior() override {
    return calculator_fun(this);
  }
};

// class-based, dynamically typed, blocking API
class blocking_calculator : public blocking_actor {
public:
  blocking_calculator(actor_config& cfg) : blocking_actor(cfg) {
    // nop
  }

  void act() override {
    blocking_calculator_fun(this);
  }
};

// class-based, statically typed, event-based API
class typed_calculator : public calculator_actor::base {
public:
  typed_calculator(actor_config& cfg) : calculator_actor::base(cfg) {
    // nop
  }

  behavior_type make_behavior() override {
    return typed_calculator_fun();
  }
};

void tester(scoped_actor&) {
  // end of recursion
}

// tests a calculator instance
template <class Handle, class... Ts>
void tester(scoped_actor& self, const Handle& hdl, int x, int y, Ts&&... xs) {
  auto handle_err = [&](const error& err) {
    aout(self) << "AUT (actor under test) failed: "
               << self->system().render(err) << endl;
  };
  // first test: x + y = z
  self->request(hdl, infinite, add_atom::value, x, y).receive(
    [&](int res1) {
      aout(self) << x << " + " << y << " = " << res1 << endl;
      // second test: x - y = z
      self->request(hdl, infinite, sub_atom::value, x, y).receive(
        [&](int res2) {
          aout(self) << x << " - " << y << " = " << res2 << endl;
        },
        handle_err
      );
    },
    handle_err
  );
  tester(self, std::forward<Ts>(xs)...);
}

void caf_main(actor_system& system) {
  auto a1 = system.spawn(blocking_calculator_fun);
  auto a2 = system.spawn(calculator_fun);
  auto a3 = system.spawn(typed_calculator_fun);
  auto a4 = system.spawn<blocking_calculator>();
  auto a5 = system.spawn<calculator>();
  auto a6 = system.spawn<typed_calculator>();
  scoped_actor self{system};
  tester(self, a1, 1, 2, a2, 3, 4, a3, 5, 6, a4, 7, 8, a5, 9, 10, a6, 11, 12);
}

} // namespace <anonymous>

CAF_MAIN()
#include "caf/all.hpp"

using std::endl;
using namespace caf;

behavior foo(event_based_actor* self) {
  self->send(self, "world");
  self->send<message_priority::high>(self, "hello");
  // when spawning `foo` with priority_aware flag, it will print "hello" first
  return {
    [=](const std::string& str) {
      aout(self) << str << endl;
    }
  };
}

void caf_main(actor_system& system) {
  scoped_actor self{system};
  aout(self) << "spawn foo" << endl;
  self->spawn(foo);
  self->await_all_other_actors_done();
  aout(self) << "spawn foo again with priority_aware flag" << endl;
  self->spawn<priority_aware>(foo);
}

CAF_MAIN()
#include <iostream>
#include "caf/all.hpp"

// This file is partially included in the manual, do not modify
// without updating the references in the *.tex files!
// Manual references: lines 15-42 (MessagePassing.tex)

using std::endl;
using namespace caf;

// using add_atom = atom_constant<atom("add")>; (defined in atom.hpp)

using calc = typed_actor<replies_to<add_atom, int, int>::with<int>>;

void actor_a(event_based_actor* self, const calc& worker) {
  self->request(worker, std::chrono::seconds(10), add_atom::value, 1, 2).then(
    [=](int result) {
      aout(self) << "1 + 2 = " << result << endl;
    }
  );
}

calc::behavior_type actor_b(calc::pointer self, const calc& worker) {
  return {
    [=](add_atom add, int x, int y) {
      return self->delegate(worker, add, x, y);
    }
  };
}

calc::behavior_type actor_c() {
  return {
    [](add_atom, int x, int y) {
      return x + y;
    }
  };
}

void caf_main(actor_system& system) {
  system.spawn(actor_a, system.spawn(actor_b, system.spawn(actor_c)));
}

CAF_MAIN()
/******************************************************************************\
 * Illustrates semantics of request().{then|await|receive}.                   *
\******************************************************************************/

// This file is partially included in the manual, do not modify
// without updating the references in the *.tex files!
// Manual references: lines 20-37, 39-51, 53-64, 67-69 (MessagePassing.tex)

#include <vector>
#include <chrono>
#include <iostream>

#include "caf/all.hpp"

using std::endl;
using std::vector;
using std::chrono::seconds;
using namespace caf;

using cell = typed_actor<reacts_to<put_atom, int>,
                         replies_to<get_atom>::with<int>>;

struct cell_state {
  int value = 0;
};

cell::behavior_type cell_impl(cell::stateful_pointer<cell_state> self, int x0) {
  self->state.value = x0;
  return {
    [=](put_atom, int val) {
      self->state.value = val;
    },
    [=](get_atom) {
      return self->state.value;
    }
  };
}

void waiting_testee(event_based_actor* self, vector<cell> cells) {
  for (auto& x : cells)
    self->request(x, seconds(1), get_atom::value).await([=](int y) {
      aout(self) << "cell #" << x.id() << " -> " << y << endl;
    });
}

void multiplexed_testee(event_based_actor* self, vector<cell> cells) {
  for (auto& x : cells)
    self->request(x, seconds(1), get_atom::value).then([=](int y) {
      aout(self) << "cell #" << x.id() << " -> " << y << endl;
    });
}

void blocking_testee(blocking_actor* self, vector<cell> cells) {
  for (auto& x : cells)
    self->request(x, seconds(1), get_atom::value).receive(
      [&](int y) {
        aout(self) << "cell #" << x.id() << " -> " << y << endl;
      },
      [&](error& err) {
        aout(self) << "cell #" << x.id()
                   << " -> " << self->system().render(err) << endl;
      }
    );
}

void caf_main(actor_system& system) {
  vector<cell> cells;
  for (auto i = 0; i < 5; ++i)
    cells.emplace_back(system.spawn(cell_impl, i * i));
  scoped_actor self{system};
  aout(self) << "waiting_testee" << endl;
  auto x1 = self->spawn(waiting_testee, cells);
  self->wait_for(x1);
  aout(self) << "multiplexed_testee" << endl;
  auto x2 = self->spawn(multiplexed_testee, cells);
  self->wait_for(x2);
  aout(self) << "blocking_testee" << endl;
  system.spawn(blocking_testee, cells);
}

CAF_MAIN()
/******************************************************************************\
 * Illustrates response promises.                                             *
\******************************************************************************/

// This file is partially included in the manual, do not modify
// without updating the references in the *.tex files!
// Manual references: lines 18-43 (MessagePassing.tex)

#include <iostream>

#include "caf/all.hpp"

using std::cout;
using std::endl;

using namespace caf;

// using add_atom = atom_constant<atom("add")>; (defined in atom.hpp)

using adder = typed_actor<replies_to<add_atom, int, int>::with<int>>;

// function-based, statically typed, event-based API
adder::behavior_type worker() {
  return {
    [](add_atom, int a, int b) {
      return a + b;
    }
  };
}

// function-based, statically typed, event-based API
adder::behavior_type calculator_master(adder::pointer self) {
  auto w = self->spawn(worker);
  return {
    [=](add_atom x, int y, int z) -> result<int> {
      auto rp = self->make_response_promise<int>();
      self->request(w, infinite, x, y, z).then([=](int result) mutable {
        rp.deliver(result);
      });
      return rp;
    }
  };
}

void caf_main(actor_system& system) {
  auto f = make_function_view(system.spawn(calculator_master));
  cout << "12 + 13 = " << f(add_atom::value, 12, 13) << endl;
}

CAF_MAIN()
/******************************************************************************\
 * This example is a very basic, non-interactive math service implemented     *
 * using typed actors.                                                        *
\ ******************************************************************************/

#include <cassert>
#include <iostream>
#include "caf/all.hpp"

using std::endl;
using namespace caf;

namespace {

using plus_atom = atom_constant<atom("plus")>;
using minus_atom = atom_constant<atom("minus")>;
using result_atom = atom_constant<atom("result")>;

using calculator_type =
  typed_actor<replies_to<plus_atom, int, int>::with<result_atom, int>,
              replies_to<minus_atom, int, int>::with<result_atom, int>>;

calculator_type::behavior_type typed_calculator_fun(calculator_type::pointer) {
  return {
    [](plus_atom, int x, int y) {
      return std::make_tuple(result_atom::value, x + y);
    },
    [](minus_atom, int x, int y) {
      return std::make_tuple(result_atom::value, x - y);
    }
  };
}

class typed_calculator_class : public calculator_type::base {
protected:
  typed_calculator_class(actor_config& cfg) : calculator_type::base(cfg) {
    // nop
  }

  behavior_type make_behavior() override {
    return {
      [](plus_atom, int x, int y) {
        return std::make_tuple(result_atom::value, x + y);
      },
      [](minus_atom, int x, int y) {
        return std::make_tuple(result_atom::value, x - y);
      }
    };
  }
};

void tester(event_based_actor* self, const calculator_type& testee) {
  self->link_to(testee);
  // first test: 2 + 1 = 3
  self->request(testee, plus_atom::value, 2, 1).then(
    [=](result_atom, int r1) {
      // second test: 2 - 1 = 1
      self->request(testee, minus_atom::value, 2, 1).then(
        [=](result_atom, int r2) {
          // both tests succeeded
          if (r1 == 3 && r2 == 1) {
            aout(self) << "AUT (actor under test) seems to be ok"
                       << endl;
          }
          self->send_exit(testee, exit_reason::user_shutdown);
        }
      );
    },
    [=](const error& err) {
      aout(self) << "AUT (actor under test) failed: "
                 << self->system().render(err) << endl;
      self->quit(exit_reason::user_shutdown);
    }
  );
}

} // namespace <anonymous>

int main() {
  actor_system system;
  // test function-based impl
  system.spawn(tester, system.spawn(typed_calculator_fun));
  system.await_all_actors_done();
  // test class-based impl
  system.spawn(tester, system.spawn<typed_calculator_class>());
}
/******************************************************************************\
 * This example program represents a minimal IRC-like group                   *
 * communication server.                                                      *
 *                                                                            *
 * Setup for a minimal chat between "alice" and "bob":                        *
 * - ./build/bin/group_server -p 4242                                         *
 * - ./build/bin/group_chat -g remote:chatroom@localhost:4242 -n alice        *
 * - ./build/bin/group_chat -g remote:chatroom@localhost:4242 -n bob          *
\ ******************************************************************************/

#include <string>
#include <cstdlib>
#include <iostream>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

using namespace std;
using namespace caf;

namespace {

class config : public actor_system_config {
public:
  uint16_t port = 0;

  config() {
    opt_group{custom_options_, "global"}
    .add(port, "port,p", "set port");
  }
};

void caf_main(actor_system& system, const config& cfg) {
  system.middleman().publish_local_groups(cfg.port);
  cout << "type 'quit' to shutdown the server" << endl;
  string line;
  while (getline(cin, line))
    if (line == "quit")
      return;
    else
      cerr << "illegal command" << endl;
}

} // namespace <anonymous>

CAF_MAIN(io::middleman)
// This program illustrates how to spawn a simple calculator
// across the network.
//
// Run server at port 4242:
// - remote_spawn -s -p 4242
//
// Run client at the same host:
// - remote_spawn -H localhost -p 4242

// Manual refs: 33-39, 99-101,106,110 (ConfiguringActorApplications)
//              125-143 (RemoteSpawn)

#include <array>
#include <vector>
#include <string>
#include <sstream>
#include <cassert>
#include <iostream>
#include <functional>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

using std::cout;
using std::cerr;
using std::endl;
using std::string;

using namespace caf;

namespace {

using add_atom = atom_constant<atom("add")>;
using sub_atom = atom_constant<atom("sub")>;

using calculator = typed_actor<replies_to<add_atom, int, int>::with<int>,
                               replies_to<sub_atom, int, int>::with<int>>;

calculator::behavior_type calculator_fun(calculator::pointer self) {
  return {
    [=](add_atom, int a, int b) -> int {
      aout(self) << "received task from a remote node" << endl;
      return a + b;
    },
    [=](sub_atom, int a, int b) -> int {
      aout(self) << "received task from a remote node" << endl;
      return a - b;
    }
  };
}

// removes leading and trailing whitespaces
string trim(string s) {
  auto not_space = [](char c) { return isspace(c) == 0; };
  // trim left
  s.erase(s.begin(), find_if(s.begin(), s.end(), not_space));
  // trim right
  s.erase(find_if(s.rbegin(), s.rend(), not_space).base(), s.end());
  return s;
}

// implements our main loop for reading user input
void client_repl(function_view<calculator> f) {
  auto usage = [] {
  cout << "Usage:" << endl
       << "  quit                  : terminate program" << endl
       << "  <x> + <y>             : adds two integers" << endl
       << "  <x> - <y>             : subtracts two integers" << endl << endl;
  };
  usage();
  // read next line, split it, and evaluate user input
  string line;
  while (std::getline(std::cin, line)) {
    if ((line = trim(std::move(line))) == "quit")
      return;
    std::vector<string> words;
    split(words, line, is_any_of(" "), token_compress_on);
    if (words.size() != 3) {
      usage();
      continue;
    }
    auto to_int = [](const string& str) -> optional<int> {
      char* end = nullptr;
      auto res = strtol(str.c_str(), &end, 10);
      if (end == str.c_str() + str.size())
        return static_cast<int>(res);
      return none;
    };
    auto x = to_int(words[0]);
    auto y = to_int(words[2]);
    if (!x || !y || (words[1] != "+" && words[1] != "-"))
      usage();
    else
      cout << " = " << (words[1] == "+" ? f(add_atom::value, *x, *y)
                                        : f(sub_atom::value, *x, *y)) << "\n";
  }
}

struct config : actor_system_config {
  config() {
    add_actor_type("calculator", calculator_fun);
    opt_group{custom_options_, "global"}
    .add(port, "port,p", "set port")
    .add(host, "host,H", "set node (ignored in server mode)")
    .add(server_mode, "server-mode,s", "enable server mode");
  }
  uint16_t port = 0;
  string host = "localhost";
  bool server_mode = false;
};

void server(actor_system& system, const config& cfg) {
  auto res = system.middleman().open(cfg.port);
  if (!res) {
    cerr << "*** cannot open port: "
         << system.render(res.error()) << endl;
    return;
  }
  cout << "*** running on port: "
       << *res << endl
       << "*** press <enter> to shutdown server" << endl;
  getchar();
}

void client(actor_system& system, const config& cfg) {
  auto node = system.middleman().connect(cfg.host, cfg.port);
  if (!node) {
    cerr << "*** connect failed: "
         << system.render(node.error()) << endl;
    return;
  }
  auto type = "calculator"; // type of the actor we wish to spawn
  auto args = make_message(); // arguments to construct the actor
  auto tout = std::chrono::seconds(30); // wait no longer than 30s
  auto worker = system.middleman().remote_spawn<calculator>(*node, type,
                                                            args, tout);
  if (!worker) {
    cerr << "*** remote spawn failed: "
         << system.render(worker.error()) << endl;
    return;
  }
  // start using worker in main loop
  client_repl(make_function_view(*worker));
  // be a good citizen and terminate remotely spawned actor before exiting
  anon_send_exit(*worker, exit_reason::kill);
}

void caf_main(actor_system& system, const config& cfg) {
  auto f = cfg.server_mode ? server : client;
  f(system, cfg);
}

} // namespace <anonymous>

CAF_MAIN(io::middleman)
/******************************************************************************\
 * This example program represents a minimal terminal chat program            *
 * based on group communication.                                              *
 *                                                                            *
 * Setup for a minimal chat between "alice" and "bob":                        *
 * - ./build/bin/group_chat -s -p 4242                                        *
 * - ./build/bin/group_chat -g remote:chatroom@localhost:4242 -n alice        *
 * - ./build/bin/group_chat -g remote:chatroom@localhost:4242 -n bob          *
\ ******************************************************************************/

#include <set>
#include <map>
#include <vector>
#include <cstdlib>
#include <sstream>
#include <iostream>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

#include "caf/string_algorithms.hpp"

using namespace std;
using namespace caf;

namespace {

using broadcast_atom = atom_constant<atom("broadcast")>;

struct line { string str; };

istream& operator>>(istream& is, line& l) {
  getline(is, l.str);
  return is;
}

behavior client(event_based_actor* self, const string& name) {
  return {
    [=](broadcast_atom, const string& message) {
      for(auto& dest : self->joined_groups()) {
        self->send(dest, name + ": " + message);
      }
    },
    [=](join_atom, const group& what) {
      for (const auto& g : self->joined_groups()) {
        cout << "*** leave " << to_string(g) << endl;
        self->send(g, name + " has left the chatroom");
        self->leave(g);
      }
      cout << "*** join " << to_string(what) << endl;
      self->join(what);
      self->send(what, name + " has entered the chatroom");
    },
    [=](const string& txt) {
      // don't print own messages
      if (self->current_sender() != self)
        cout << txt << endl;
    },
    [=](const group_down_msg& g) {
      cout << "*** chatroom offline: " << to_string(g.source) << endl;
    }
  };
}

class config : public actor_system_config {
public:
  std::string name;
  std::vector<std::string> group_uris;
  uint16_t port = 0;
  bool server_mode = false;

  config() {
    opt_group{custom_options_, "global"}
    .add(name, "name,n", "set name")
    .add(group_uris, "group,g", "join group")
    .add(server_mode, "server,s", "run in server mode")
    .add(port, "port,p", "set port (ignored in client mode)");
  }
};

void run_server(actor_system& system, const config& cfg) {
  auto res = system.middleman().publish_local_groups(cfg.port);
  if (! res) {
    std::cerr << "*** publishing local groups failed: "
              << system.render(res.error()) << endl;
    return;
  }
  cout << "*** listening at port " << *res << endl
       << "*** press [enter] to quit" << endl;
  string dummy;
  std::getline(std::cin, dummy);
  cout << "... cya" << endl;
}

void run_client(actor_system& system, const config& cfg) {
  auto name = cfg.name;
  while (name.empty()) {
    cout << "please enter your name: " << flush;
    if (!getline(cin, name)) {
      cerr << "*** no name given... terminating" << endl;
      return;
    }
  }
  cout << "*** starting client, type '/help' for a list of commands" << endl;
  auto client_actor = system.spawn(client, name);
  for (auto& uri : cfg.group_uris) {
    auto tmp = system.groups().get(uri);
    if (tmp)
      anon_send(client_actor, join_atom::value, std::move(*tmp));
    else
      cerr << R"(*** failed to parse ")" << uri << R"(" as group URI: )"
           << system.render(tmp.error()) << endl;
  }
  istream_iterator<line> eof;
  vector<string> words;
  for (istream_iterator<line> i(cin); i != eof; ++i) {
    auto send_input = [&] {
      if (!i->str.empty())
        anon_send(client_actor, broadcast_atom::value, i->str);
    };
    words.clear();
    split(words, i->str, is_any_of(" "));
    auto res = message_builder(words.begin(), words.end()).apply({
      [&](const string& cmd, const string& mod, const string& id) {
        if (cmd == "/join") {
          auto grp = system.groups().get(mod, id);
          if (grp)
            anon_send(client_actor, join_atom::value, *grp);
        }
        else {
          send_input();
        }
      },
      [&](const string& cmd) {
        if (cmd == "/quit") {
          cin.setstate(ios_base::eofbit);
        }
        else if (cmd[0] == '/') {
          cout << "*** available commands:\n"
            "  /join <module> <group> join a new chat channel\n"
            "  /quit          quit the program\n"
            "  /help          print this text\n" << flush;
        }
        else {
          send_input();
        }
      }
    });
    if (!res)
      send_input();
  }
  // force actor to quit
  anon_send_exit(client_actor, exit_reason::user_shutdown);
}

void caf_main(actor_system& system, const config& cfg) {
  auto f = cfg.server_mode ? run_server : run_client;
  f(system, cfg);
}

} // namespace <anonymous>

CAF_MAIN(io::middleman)
// This program is a distributed version of the math_actor example.
// Client and server use a stateless request/response protocol and the client
// is failure resilient by using a FIFO request queue.
// The client auto-reconnects and also allows for server reconfiguration.
//
// Run server at port 4242:
// - ./build/bin/distributed_math_actor -s -p 4242
//
// Run client at the same host:
// - ./build/bin/distributed_math_actor -c -p 4242

// Manual refs: 222-234 (ConfiguringActorSystems)

#include <array>
#include <vector>
#include <string>
#include <sstream>
#include <cassert>
#include <iostream>
#include <functional>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

using std::cout;
using std::cerr;
using std::endl;
using std::string;

using namespace caf;

namespace {

constexpr auto task_timeout = std::chrono::seconds(10);

using plus_atom = atom_constant<atom("plus")>;
using minus_atom = atom_constant<atom("minus")>;

// our "service"
behavior calculator_fun() {
  return {
    [](plus_atom, int a, int b) {
      return a + b;
    },
    [](minus_atom, int a, int b) {
      return a - b;
    }
  };
}

/* State transition of the client for connecting to the server:
 *
 *                    +-------------+
 *                    |    init     |
 *                    +-------------+
 *                           |
 *                           V
 *                    +-------------+
 *                    | unconnected |<------------------\
 *                    +-------------+                   |
 *                           |                          |
 *                           | {connect Host Port}      |
 *                           |                          |
 *                           V                          |
 *                    +-------------+  {error}          |
 *    /-------------->| connecting  |------------------>|
 *    |               +-------------+                   ^
 *    |                      |                          |
 *    |                      | {ok, Calculator}         |
 *    |{connect Host Port}   |                          |
 *    |                      V                          |
 *    |               +-------------+   {DOWN server}   |
 *    \---------------|   running   |-------------------/
 *                    +-------------+
 */

namespace client {

// a simple calculater task: operation + operands
struct task {
  atom_value op;
  int lhs;
  int rhs;
};

// the client queues pending tasks
struct state {
  strong_actor_ptr current_server;
  std::vector<task> tasks;
};

// prototype definition for unconnected state
behavior unconnected(stateful_actor<state>*);

// prototype definition for transition to `connecting` with Host and Port
void connecting(stateful_actor<state>*,
                const std::string& host, uint16_t port);

// prototype definition for transition to `running` with Calculator
behavior running(stateful_actor<state>*, const actor& calculator);

// starting point of our FSM
behavior init(stateful_actor<state>* self) {
  // transition to `unconnected` on server failure
  self->set_down_handler([=](const down_msg& dm) {
    if (dm.source == self->state.current_server) {
      aout(self) << "*** lost connection to server" << endl;
      self->state.current_server = nullptr;
      self->become(unconnected(self));
    }
  });
  return unconnected(self);
}

behavior unconnected(stateful_actor<state>* self) {
  return {
    [=](plus_atom op, int x, int y) {
      self->state.tasks.emplace_back(task{op, x, y});
    },
    [=](minus_atom op, int x, int y) {
      self->state.tasks.emplace_back(task{op, x, y});
    },
    [=](connect_atom, const std::string& host, uint16_t port) {
      connecting(self, host, port);
    }
  };
}

void connecting(stateful_actor<state>* self,
                const std::string& host, uint16_t port) {
  // make sure we are not pointing to an old server
  self->state.current_server = nullptr;
  // use request().await() to suspend regular behavior until MM responded
  auto mm = self->system().middleman().actor_handle();
  self->request(mm, infinite, connect_atom::value, host, port).await(
    [=](const node_id&, strong_actor_ptr serv,
        const std::set<std::string>& ifs) {
      if (!serv) {
        aout(self) << R"(*** no server found at ")" << host << R"(":)"
                   << port << endl;
        return;
      }
      if (!ifs.empty()) {
        aout(self) << R"(*** typed actor found at ")" << host << R"(":)"
                   << port << ", but expected an untyped actor "<< endl;
        return;
      }
      aout(self) << "*** successfully connected to server" << endl;
      self->state.current_server = serv;
      auto hdl = actor_cast<actor>(serv);
      self->monitor(hdl);
      self->become(running(self, hdl));
    },
    [=](const error& err) {
      aout(self) << R"(*** cannot connect to ")" << host << R"(":)"
                 << port << " => " << self->system().render(err) << endl;
      self->become(unconnected(self));
    }
  );
}

// prototype definition for transition to `running` with Calculator
behavior running(stateful_actor<state>* self, const actor& calculator) {
  auto send_task = [=](const task& x) {
    self->request(calculator, task_timeout, x.op, x.lhs, x.rhs).then(
      [=](int result) {
        aout(self) << x.lhs << (x.op == plus_atom::value ? " + " : " - ")
                   << x.rhs << " = " << result << endl;
      },
      [=](const error&) {
        // simply try again by enqueueing the task to the mailbox again
        self->send(self, x.op, x.lhs, x.rhs);
      }
    );
  };
  for (auto& x : self->state.tasks)
    send_task(x);
  self->state.tasks.clear();
  return {
    [=](plus_atom op, int x, int y) {
      send_task(task{op, x, y});
    },
    [=](minus_atom op, int x, int y) {
      send_task(task{op, x, y});
    },
    [=](connect_atom, const std::string& host, uint16_t port) {
      connecting(self, host, port);
    }
  };
}

} // namespace client

// removes leading and trailing whitespaces
string trim(std::string s) {
  auto not_space = [](char c) { return isspace(c) == 0; };
  // trim left
  s.erase(s.begin(), find_if(s.begin(), s.end(), not_space));
  // trim right
  s.erase(find_if(s.rbegin(), s.rend(), not_space).base(), s.end());
  return s;
}

// tries to convert `str` to an int
optional<int> toint(const string& str) {
  char* end;
  auto result = static_cast<int>(strtol(str.c_str(), &end, 10));
  if (end == str.c_str() + str.size())
    return result;
  return none;
}

// converts "+" to the atom '+' and "-" to the atom '-'
optional<atom_value> plus_or_minus(const string& str) {
  if (str == "+")
    return plus_atom::value;
  if (str == "-")
    return minus_atom::value;
  return none;
}

class config : public actor_system_config {
public:
  uint16_t port = 0;
  std::string host = "localhost";
  bool server_mode = false;

  config() {
    opt_group{custom_options_, "global"}
    .add(port, "port,p", "set port")
    .add(host, "host,H", "set host (ignored in server mode)")
    .add(server_mode, "server-mode,s", "enable server mode");
  }
};

void client_repl(actor_system& system, const config& cfg) {
  // keeps track of requests and tries to reconnect on server failures
  auto usage = [] {
  cout << "Usage:" << endl
       << "  quit                  : terminates the program" << endl
       << "  connect <host> <port> : connects to a remote actor" << endl
       << "  <x> + <y>             : adds two integers" << endl
       << "  <x> - <y>             : subtracts two integers" << endl
       << endl;
  };
  usage();
  bool done = false;
  auto client = system.spawn(client::init);
  if (!cfg.host.empty() && cfg.port > 0)
    anon_send(client, connect_atom::value, cfg.host, cfg.port);
  else
    cout << "*** no server received via config, "
         << R"(please use "connect <host> <port>" before using the calculator)"
         << endl;
  // defining the handler outside the loop is more efficient as it avoids
  // re-creating the same object over and over again
  message_handler eval{
    [&](const string& cmd) {
      if (cmd != "quit")
        return;
      anon_send_exit(client, exit_reason::user_shutdown);
      done = true;
    },
    [&](string& arg0, string& arg1, string& arg2) {
      if (arg0 == "connect") {
        char* end = nullptr;
        auto lport = strtoul(arg2.c_str(), &end, 10);
        if (end != arg2.c_str() + arg2.size())
          cout << R"(")" << arg2 << R"(" is not an unsigned integer)" << endl;
        else if (lport > std::numeric_limits<uint16_t>::max())
          cout << R"(")" << arg2 << R"(" > )"
               << std::numeric_limits<uint16_t>::max() << endl;
        else
          anon_send(client, connect_atom::value, move(arg1),
                    static_cast<uint16_t>(lport));
      }
      else {
        auto x = toint(arg0);
        auto op = plus_or_minus(arg1);
        auto y = toint(arg2);
        if (x && y && op)
          anon_send(client, *op, *x, *y);
      }
    }
  };
  // read next line, split it, and feed to the eval handler
  string line;
  while (!done && std::getline(std::cin, line)) {
    line = trim(std::move(line)); // ignore leading and trailing whitespaces
    std::vector<string> words;
    split(words, line, is_any_of(" "), token_compress_on);
    if (!message_builder(words.begin(), words.end()).apply(eval))
      usage();
  }
}

void run_server(actor_system& system, const config& cfg) {
  auto calc = system.spawn(calculator_fun);
  // try to publish math actor at given port
  cout << "*** try publish at port " << cfg.port << endl;
  auto expected_port = io::publish(calc, cfg.port);
  if (!expected_port) {
    std::cerr << "*** publish failed: "
              << system.render(expected_port.error()) << endl;
    return;
  }
  cout << "*** server successfully published at port " << *expected_port << endl
       << "*** press [enter] to quit" << endl;
  string dummy;
  std::getline(std::cin, dummy);
  cout << "... cya" << endl;
  anon_send_exit(calc, exit_reason::user_shutdown);
}

void caf_main(actor_system& system, const config& cfg) {
  auto f = cfg.server_mode ? run_server : client_repl;
  f(system, cfg);
}

} // namespace <anonymous>

CAF_MAIN(io::middleman)
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/network/default_multiplexer.hpp"

#include "caf/config.hpp"
#include "caf/optional.hpp"
#include "caf/make_counted.hpp"
#include "caf/actor_system_config.hpp"

#include "caf/scheduler/abstract_coordinator.hpp"

#include "caf/io/broker.hpp"
#include "caf/io/middleman.hpp"

#include "caf/io/network/protocol.hpp"
#include "caf/io/network/interfaces.hpp"

#ifdef CAF_WINDOWS
# include <winsock2.h>
# include <ws2tcpip.h> // socklen_t, etc. (MSVC20xx)
# include <windows.h>
# include <io.h>
#else
# include <cerrno>
# include <netdb.h>
# include <fcntl.h>
# include <sys/types.h>
# include <arpa/inet.h>
# include <sys/socket.h>
# include <netinet/in.h>
# include <netinet/tcp.h>
# include <utility>
#endif

using std::string;

// -- Utiliy functions for converting errno into CAF errors --------------------

namespace {

constexpr size_t receive_buffer_size = std::numeric_limits<uint16_t>::max();

// safe ourselves some typing
constexpr auto ipv4 = caf::io::network::protocol::ipv4;
constexpr auto ipv6 = caf::io::network::protocol::ipv6;

// predicate for `ccall` meaning "expected result of f is 0"
bool cc_zero(int value) {
  return value == 0;
}

// predicate for `ccall` meaning "expected result of f is 1"
bool cc_one(int value) {
  return value == 1;
}

// predicate for `ccall` meaning "expected result of f is not -1"
bool cc_not_minus1(int value) {
  return value != -1;
}

// predicate for `ccall` meaning "expected result of f is a valid socket"
bool cc_valid_socket(caf::io::network::native_socket fd) {
  return fd != caf::io::network::invalid_native_socket;
}

// calls a C functions and returns an error if `predicate(var)`  returns false
#define CALL_CFUN(var, predicate, fun_name, expr)                              \
  auto var = expr;                                                             \
  if (!predicate(var))                                                         \
    return make_error(sec::network_syscall_failed,                             \
                      fun_name, last_socket_error_as_string())

#ifdef CAF_WINDOWS
// calls a C functions and calls exit() if `predicate(var)`  returns false
#define CALL_CRITICAL_CFUN(var, predicate, funname, expr)                      \
  auto var = expr;                                                             \
  if (!predicate(var)) {                                                       \
    fprintf(stderr, "[FATAL] %s:%u: syscall failed: %s returned %s\n",         \
           __FILE__, __LINE__, funname, last_socket_error_as_string().c_str());\
    abort();                                                                   \
  } static_cast<void>(0)

#ifndef SIO_UDP_CONNRESET
#define SIO_UDP_CONNRESET _WSAIOW(IOC_VENDOR, 12)
#endif
#endif // CAF_WINDOWS

} // namespace <anonymous>

namespace caf {
namespace io {
namespace network {

// -- OS-specific functions for sockets and pipes ------------------------------

#ifndef CAF_WINDOWS

  string last_socket_error_as_string() {
    return strerror(errno);
  }

  expected<void> nonblocking(native_socket fd, bool new_value) {
    CAF_LOG_TRACE(CAF_ARG(fd) << CAF_ARG(new_value));
    // read flags for fd
    CALL_CFUN(rf, cc_not_minus1, "fcntl", fcntl(fd, F_GETFL, 0));
    // calculate and set new flags
    auto wf = new_value ? (rf | O_NONBLOCK) : (rf & (~(O_NONBLOCK)));
    CALL_CFUN(set_res, cc_not_minus1, "fcntl", fcntl(fd, F_SETFL, wf));
    return unit;
  }

  expected<void> allow_sigpipe(native_socket fd, bool new_value) {
    if (no_sigpipe_socket_flag != 0) {
      int value = new_value ? 0 : 1;
      CALL_CFUN(res, cc_zero, "setsockopt",
                setsockopt(fd, SOL_SOCKET, no_sigpipe_socket_flag, &value,
                           static_cast<unsigned>(sizeof(value))));
    }
    return unit;
  }

  expected<void> allow_udp_connreset(native_socket, bool) {
    // nop; SIO_UDP_CONNRESET only exists on Windows
    return unit;
  }

  std::pair<native_socket, native_socket> create_pipe() {
    int pipefds[2];
    if (pipe(pipefds) != 0) {
      perror("pipe");
      exit(EXIT_FAILURE);
    }
    return {pipefds[0], pipefds[1]};
  }

#else // CAF_WINDOWS

  string last_socket_error_as_string() {
    LPTSTR errorText = NULL;
    auto hresult = last_socket_error();
    FormatMessage( // use system message tables to retrieve error text
      FORMAT_MESSAGE_FROM_SYSTEM
      // allocate buffer on local heap for error text
      | FORMAT_MESSAGE_ALLOCATE_BUFFER
      // Important! will fail otherwise, since we're not
      // (and CANNOT) pass insertion parameters
      | FORMAT_MESSAGE_IGNORE_INSERTS,
      nullptr, // unused with FORMAT_MESSAGE_FROM_SYSTEM
      hresult, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
      (LPTSTR) & errorText, // output
      0,                    // minimum size for output buffer
      nullptr);             // arguments - see note
    std::string result;
    if (errorText != nullptr) {
      result = errorText;
      // release memory allocated by FormatMessage()
      LocalFree(errorText);
    }
    return result;
  }

  expected<void> nonblocking(native_socket fd, bool new_value) {
    u_long mode = new_value ? 1 : 0;
    CALL_CFUN(res, cc_zero, "ioctlsocket", ioctlsocket(fd, FIONBIO, &mode));
    return unit;
  }

  expected<void> allow_sigpipe(native_socket, bool) {
    // nop; SIGPIPE does not exist on Windows
    return unit;
  }

  expected<void> allow_udp_connreset(native_socket fd, bool new_value) {
    DWORD bytes_returned = 0;
    CALL_CFUN(res, cc_zero, "WSAIoctl",
              WSAIoctl(fd, SIO_UDP_CONNRESET, &new_value, sizeof(new_value),
                       NULL, 0, &bytes_returned, NULL, NULL));
    return unit;
  }

  /**************************************************************************\
   * Based on work of others;                                               *
   * original header:                                                       *
   *                                                                        *
   * Copyright 2007, 2010 by Nathan C. Myers <ncm@cantrip.org>              *
   * Redistribution and use in source and binary forms, with or without     *
   * modification, are permitted provided that the following conditions     *
   * are met:                                                               *
   *                                                                        *
   * Redistributions of source code must retain the above copyright notice, *
   * this list of conditions and the following disclaimer.                  *
   *                                                                        *
   * Redistributions in binary form must reproduce the above copyright      *
   * notice, this list of conditions and the following disclaimer in the    *
   * documentation and/or other materials provided with the distribution.   *
   *                                                                        *
   * The name of the author must not be used to endorse or promote products *
   * derived from this software without specific prior written permission.  *
   *                                                                        *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    *
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      *
   * LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR *
   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   *
   * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, *
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT       *
   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  *
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  *
   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    *
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  *
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   *
  \**************************************************************************/
  std::pair<native_socket, native_socket> create_pipe() {
    socklen_t addrlen = sizeof(sockaddr_in);
    native_socket socks[2] = {invalid_native_socket, invalid_native_socket};
    CALL_CRITICAL_CFUN(listener, cc_valid_socket, "socket",
                       socket(AF_INET, SOCK_STREAM, IPPROTO_TCP));
    union {
      sockaddr_in inaddr;
      sockaddr addr;
    } a;
    memset(&a, 0, sizeof(a));
    a.inaddr.sin_family = AF_INET;
    a.inaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    a.inaddr.sin_port = 0;
    // makes sure all sockets are closed in case of an error
    auto guard = detail::make_scope_guard([&] {
      auto e = WSAGetLastError();
      closesocket(listener);
      closesocket(socks[0]);
      closesocket(socks[1]);
      WSASetLastError(e);
    });
    // bind listener to a local port
    int reuse = 1;
    CALL_CRITICAL_CFUN(tmp1, cc_zero, "setsockopt",
                       setsockopt(listener, SOL_SOCKET, SO_REUSEADDR,
                                  reinterpret_cast<char*>(&reuse),
                                  static_cast<int>(sizeof(reuse))));
    CALL_CRITICAL_CFUN(tmp2, cc_zero, "bind",
                       bind(listener, &a.addr,
                            static_cast<int>(sizeof(a.inaddr))));
    // read the port in use: win32 getsockname may only set the port number
    // (http://msdn.microsoft.com/library/ms738543.aspx):
    memset(&a, 0, sizeof(a));
    CALL_CRITICAL_CFUN(tmp3, cc_zero, "getsockname",
                       getsockname(listener, &a.addr, &addrlen));
    a.inaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    a.inaddr.sin_family = AF_INET;
    // set listener to listen mode
    CALL_CRITICAL_CFUN(tmp5, cc_zero, "listen", listen(listener, 1));
    // create read-only end of the pipe
    DWORD flags = 0;
    CALL_CRITICAL_CFUN(read_fd, cc_valid_socket, "WSASocketW",
                       WSASocketW(AF_INET, SOCK_STREAM, 0, nullptr, 0, flags));
    CALL_CRITICAL_CFUN(tmp6, cc_zero, "connect",
                       connect(read_fd, &a.addr,
                               static_cast<int>(sizeof(a.inaddr))));
    // get write-only end of the pipe
    CALL_CRITICAL_CFUN(write_fd, cc_valid_socket, "accept",
                       accept(listener, nullptr, nullptr));
    closesocket(listener);
    guard.disable();
    return std::make_pair(read_fd, write_fd);
  }

#endif

// -- Platform-dependent abstraction over epoll() or poll() --------------------

#ifdef CAF_EPOLL_MULTIPLEXER

  // In this implementation, shadow_ is the number of sockets we have
  // registered to epoll.

  default_multiplexer::default_multiplexer(actor_system* sys)
      : multiplexer(sys),
        epollfd_(invalid_native_socket),
        shadow_(1),
        pipe_reader_(*this),
        servant_ids_(0) {
    init();
    epollfd_ = epoll_create1(EPOLL_CLOEXEC);
    if (epollfd_ == -1) {
      CAF_LOG_ERROR("epoll_create1: " << strerror(errno));
      exit(errno);
    }
    // handle at most 64 events at a time
    pollset_.resize(64);
    pipe_ = create_pipe();
    pipe_reader_.init(pipe_.first);
    epoll_event ee;
    ee.events = input_mask;
    ee.data.ptr = &pipe_reader_;
    if (epoll_ctl(epollfd_, EPOLL_CTL_ADD, pipe_reader_.fd(), &ee) < 0) {
      CAF_LOG_ERROR("epoll_ctl: " << strerror(errno));
      exit(errno);
    }
  }

  bool default_multiplexer::poll_once_impl(bool block) {
    CAF_LOG_TRACE("epoll()-based multiplexer");
    CAF_ASSERT(block == false || internally_posted_.empty());
    // Keep running in case of `EINTR`.
    for (;;) {
      int presult = epoll_wait(epollfd_, pollset_.data(),
                               static_cast<int>(pollset_.size()),
                               block ? -1 : 0);
      CAF_LOG_DEBUG("epoll_wait() on"      << shadow_
                    << "sockets reported" << presult << "event(s)");
      if (presult < 0) {
        switch (errno) {
          case EINTR: {
            // a signal was caught
            // just try again
            continue;
          }
          default: {
            perror("epoll_wait() failed");
            CAF_CRITICAL("epoll_wait() failed");
          }
        }
      }
      if (presult == 0)
        return false;
      auto iter = pollset_.begin();
      auto last = iter + presult;
      for (; iter != last; ++iter) {
        auto ptr = reinterpret_cast<event_handler*>(iter->data.ptr);
        auto fd = ptr ? ptr->fd() : pipe_.first;
        handle_socket_event(fd, static_cast<int>(iter->events), ptr);
      }
      for (auto& me : events_) {
        handle(me);
      }
      events_.clear();
      return true;
    }
  }

  void default_multiplexer::run() {
    CAF_LOG_TRACE("epoll()-based multiplexer");
    while (shadow_ > 0)
      poll_once(true);
  }

  void default_multiplexer::handle(const default_multiplexer::event& e) {
    CAF_LOG_TRACE("e.fd = " << CAF_ARG(e.fd) << ", mask = "
                  << CAF_ARG(e.mask));
    // ptr is only allowed to nullptr if fd is our pipe
    // read handle which is only registered for input
    CAF_ASSERT(e.ptr != nullptr || e.fd == pipe_.first);
    if (e.ptr && e.ptr->eventbf() == e.mask) {
      // nop
      return;
    }
    auto old = e.ptr ? e.ptr->eventbf() : input_mask;
    if (e.ptr){
      e.ptr->eventbf(e.mask);
    }
    epoll_event ee;
    ee.events = static_cast<uint32_t>(e.mask);
    ee.data.ptr = e.ptr;
    int op;
    if (e.mask == 0) {
      CAF_LOG_DEBUG("attempt to remove socket " << CAF_ARG(e.fd)
                    << " from epoll");
      op = EPOLL_CTL_DEL;
      --shadow_;
    } else if (old == 0) {
      CAF_LOG_DEBUG("attempt to add socket " << CAF_ARG(e.fd) << " to epoll");
      op = EPOLL_CTL_ADD;
      ++shadow_;
    } else {
      CAF_LOG_DEBUG("modify epoll event mask for socket " << CAF_ARG(e.fd)
                    << ": " << CAF_ARG(old) << " -> " << CAF_ARG(e.mask));
      op = EPOLL_CTL_MOD;
    }
    if (epoll_ctl(epollfd_, op, e.fd, &ee) < 0) {
      switch (last_socket_error()) {
        // supplied file descriptor is already registered
        case EEXIST:
          CAF_LOG_ERROR("file descriptor registered twice");
          --shadow_;
          break;
        // op was EPOLL_CTL_MOD or EPOLL_CTL_DEL,
        // and fd is not registered with this epoll instance.
        case ENOENT:
          CAF_LOG_ERROR(
            "cannot delete file descriptor "
            "because it isn't registered");
          if (e.mask == 0) {
            ++shadow_;
          }
          break;
        default:
          CAF_LOG_ERROR(strerror(errno));
          perror("epoll_ctl() failed");
          CAF_CRITICAL("epoll_ctl() failed");
      }
    }
    if (e.ptr) {
      auto remove_from_loop_if_needed = [&](int flag, operation flag_op) {
        if ((old & flag) && !(e.mask & flag)) {
          e.ptr->removed_from_loop(flag_op);
        }
      };
      remove_from_loop_if_needed(input_mask, operation::read);
      remove_from_loop_if_needed(output_mask, operation::write);
    }
  }

#else // CAF_EPOLL_MULTIPLEXER

  // Let's be honest: the API of poll() sucks. When dealing with 1000 sockets
  // and the very last socket in your pollset triggers, you have to traverse
  // all elements only to find a single event. Even worse, poll() does
  // not give you a way of storing a user-defined pointer in the pollset.
  // Hence, you need to find a pointer to the actual object managing the
  // socket. When using a map, your already dreadful O(n) turns into
  // a worst case of O(n * log n). To deal with this nonsense, we have two
  // vectors in this implementation: pollset_ and shadow_. The former
  // stores our pollset, the latter stores our pointers. Both vectors
  // are sorted by the file descriptor. This allows us to quickly,
  // i.e., O(1), access the actual object when handling socket events.

  default_multiplexer::default_multiplexer(actor_system* sys)
      : multiplexer(sys),
        epollfd_(-1),
        pipe_reader_(*this),
        servant_ids_(0) {
    init();
    // initial setup
    pipe_ = create_pipe();
    pipe_reader_.init(pipe_.first);
    pollfd pipefd;
    pipefd.fd = pipe_reader_.fd();
    pipefd.events = input_mask;
    pipefd.revents = 0;
    pollset_.push_back(pipefd);
    shadow_.push_back(&pipe_reader_);
  }

  bool default_multiplexer::poll_once_impl(bool block) {
    CAF_LOG_TRACE("poll()-based multiplexer");
    CAF_ASSERT(block == false || internally_posted_.empty());
    // we store the results of poll() in a separate vector , because
    // altering the pollset while traversing it is not exactly a
    // bright idea ...
    struct fd_event {
      native_socket  fd;      // our file descriptor
      short          mask;    // the event mask returned by poll()
      event_handler* ptr;     // nullptr in case of a pipe event
    };
    std::vector<fd_event> poll_res;
    for(;;) {
      int presult;
#     ifdef CAF_WINDOWS
        presult = ::WSAPoll(pollset_.data(),
                            static_cast<ULONG>(pollset_.size()),
                            block ? -1 : 0);
#     else
        presult = ::poll(pollset_.data(),
                         static_cast<nfds_t>(pollset_.size()), block ? -1 : 0);
#     endif
      CAF_LOG_DEBUG("poll() on" << pollset_.size()
                    << "sockets reported" << presult << "event(s)");
      if (presult < 0) {
        switch (last_socket_error()) {
          case EINTR: {
            CAF_LOG_DEBUG("received EINTR, try again");
            // a signal was caught
            // just try again
            break;
          }
          case ENOMEM: {
            CAF_LOG_ERROR("poll() failed for reason ENOMEM");
            // there's not much we can do other than try again
            // in hope someone else releases memory
            break;
          }
          default: {
            perror("poll() failed");
            CAF_CRITICAL("poll() failed");
          }
        }
        continue; // rinse and repeat
      }
      if (presult == 0)
        return false;
      // scan pollset for events first, because we might alter pollset_
      // while running callbacks (not a good idea while traversing it)
      CAF_LOG_DEBUG("scan pollset for socket events");
      for (size_t i = 0; i < pollset_.size() && presult > 0; ++i) {
        auto& pfd = pollset_[i];
        if (pfd.revents != 0) {
          CAF_LOG_DEBUG("event on socket:" << CAF_ARG(pfd.fd)
                        << CAF_ARG(pfd.revents));
          poll_res.push_back({pfd.fd, pfd.revents, shadow_[i]});
          pfd.revents = 0;
          --presult; // stop as early as possible
        }
      }
      CAF_LOG_DEBUG(CAF_ARG(poll_res.size()));
      for (auto& e : poll_res) {
        // we try to read/write as much as possible by ignoring
        // error states as long as there are still valid
        // operations possible on the socket
        handle_socket_event(e.fd, e.mask, e.ptr);
      }
      CAF_LOG_DEBUG(CAF_ARG(events_.size()));
      poll_res.clear();
      for (auto& me : events_)
        handle(me);
      events_.clear();
      return true;
    }
  }

  void default_multiplexer::run() {
    CAF_LOG_TRACE("poll()-based multiplexer:" << CAF_ARG(input_mask)
                  << CAF_ARG(output_mask) << CAF_ARG(error_mask));
    while (!pollset_.empty())
      poll_once(true);
  }

  void default_multiplexer::handle(const default_multiplexer::event& e) {
    CAF_ASSERT(e.fd != invalid_native_socket);
    CAF_ASSERT(pollset_.size() == shadow_.size());
    CAF_LOG_TRACE(CAF_ARG(e.fd) << CAF_ARG(e.mask));
    auto last = pollset_.end();
    auto i = std::lower_bound(pollset_.begin(), last, e.fd,
                              [](const pollfd& lhs, native_socket rhs) {
                                return lhs.fd < rhs;
                              });
    pollfd new_element;
    new_element.fd = e.fd;
    new_element.events = static_cast<short>(e.mask);
    new_element.revents = 0;
    int old_mask = 0;
    if (e.ptr != nullptr) {
      old_mask = e.ptr->eventbf();
      e.ptr->eventbf(e.mask);
    }
    // calculate shadow of i
    multiplexer_poll_shadow_data::iterator j;
    if (i == last) {
      j = shadow_.end();
    } else {
      j = shadow_.begin();
      std::advance(j, distance(pollset_.begin(), i));
    }
    // modify vectors
    if (i == last) { // append
      if (e.mask != 0) {
        pollset_.push_back(new_element);
        shadow_.push_back(e.ptr);
      }
    } else if (i->fd == e.fd) { // modify
      if (e.mask == 0) {
        // delete item
        pollset_.erase(i);
        shadow_.erase(j);
      } else {
        // update event mask of existing entry
        CAF_ASSERT(*j == e.ptr);
        i->events = static_cast<short>(e.mask);
      }
      if (e.ptr != nullptr) {
        auto remove_from_loop_if_needed = [&](int flag, operation flag_op) {
          if (((old_mask & flag) != 0) && ((e.mask & flag) == 0)) {
            e.ptr->removed_from_loop(flag_op);
          }
        };
        remove_from_loop_if_needed(input_mask, operation::read);
        remove_from_loop_if_needed(output_mask, operation::write);
      }
    } else { // insert at iterator pos
      pollset_.insert(i, new_element);
      shadow_.insert(j, e.ptr);
    }
  }

#endif // CAF_EPOLL_MULTIPLEXER

// -- Helper functions for defining bitmasks of event handlers -----------------

int add_flag(operation op, int bf) {
  switch (op) {
    case operation::read:
      return bf | input_mask;
    case operation::write:
      return bf | output_mask;
    case operation::propagate_error:
      CAF_LOG_ERROR("unexpected operation");
      break;
  }
  // weird stuff going on
  return 0;
}

int del_flag(operation op, int bf) {
  switch (op) {
    case operation::read:
      return bf & ~input_mask;
    case operation::write:
      return bf & ~output_mask;
    case operation::propagate_error:
      CAF_LOG_ERROR("unexpected operation");
      break;
  }
  // weird stuff going on
  return 0;
}

// -- Platform-independent free functions --------------------------------------

expected<void> tcp_nodelay(native_socket fd, bool new_value) {
  CAF_LOG_TRACE(CAF_ARG(fd) << CAF_ARG(new_value));
  int flag = new_value ? 1 : 0;
  CALL_CFUN(res, cc_zero, "setsockopt",
            setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,
                       reinterpret_cast<setsockopt_ptr>(&flag),
                       static_cast<socklen_t>(sizeof(flag))));
  return unit;
}

bool is_error(ssize_t res, bool is_nonblock) {
  if (res < 0) {
    auto err = last_socket_error();
    if (!is_nonblock || !would_block_or_temporarily_unavailable(err)) {
      return true;
    }
    // don't report an error in case of
    // spurious wakeup or something similar
  }
  return false;
}

rw_state read_some(size_t& result, native_socket fd, void* buf, size_t len) {
  CAF_LOG_TRACE(CAF_ARG(fd) << CAF_ARG(len));
  auto sres = ::recv(fd, reinterpret_cast<socket_recv_ptr>(buf),
                     len, no_sigpipe_io_flag);
  CAF_LOG_DEBUG(CAF_ARG(len) << CAF_ARG(fd) << CAF_ARG(sres));
  if (is_error(sres, true) || sres == 0) {
    // recv returns 0  when the peer has performed an orderly shutdown
    return rw_state::failure;
  }
  result = (sres > 0) ? static_cast<size_t>(sres) : 0;
  return rw_state::success;
}

rw_state write_some(size_t& result, native_socket fd, const void* buf,
                    size_t len) {
  CAF_LOG_TRACE(CAF_ARG(fd) << CAF_ARG(len));
  auto sres = ::send(fd, reinterpret_cast<socket_send_ptr>(buf),
                     len, no_sigpipe_io_flag);
  CAF_LOG_DEBUG(CAF_ARG(len) << CAF_ARG(fd) << CAF_ARG(sres));
  if (is_error(sres, true))
    return rw_state::failure;
  result = (sres > 0) ? static_cast<size_t>(sres) : 0;
  return rw_state::success;
}

 bool try_accept(native_socket& result, native_socket fd) {
  CAF_LOG_TRACE(CAF_ARG(fd));
  sockaddr_storage addr;
  memset(&addr, 0, sizeof(addr));
  socklen_t addrlen = sizeof(addr);
  result = ::accept(fd, reinterpret_cast<sockaddr*>(&addr), &addrlen);
  CAF_LOG_DEBUG(CAF_ARG(fd) << CAF_ARG(result));
  if (result == invalid_native_socket) {
    auto err = last_socket_error();
    if (!would_block_or_temporarily_unavailable(err)) {
      return false;
    }
  }
  return true;
}

bool read_datagram(size_t& result, native_socket fd, void* buf, size_t buf_len,
                   ip_endpoint& ep) {
  CAF_LOG_TRACE(CAF_ARG(fd));
  memset(ep.address(), 0, sizeof(sockaddr_storage));
  socklen_t len = sizeof(sockaddr_storage);
  auto sres = ::recvfrom(fd, static_cast<socket_recv_ptr>(buf), buf_len, 0, ep.address(), &len);
  if (is_error(sres, true)) {
    CAF_LOG_ERROR("recvfrom returned" << CAF_ARG(sres));
    return false;
  }
  if (sres == 0)
    CAF_LOG_INFO("Received empty datagram");
  else if (sres > static_cast<ssize_t>(buf_len))
    CAF_LOG_WARNING("recvfrom cut of message, only received " << CAF_ARG(buf_len)
                    << " of " << CAF_ARG(sres) << " bytes");
  result = (sres > 0) ? static_cast<size_t>(sres) : 0;
  *ep.length() = static_cast<size_t>(len);
  return true;
}

bool write_datagram(size_t& result, native_socket fd, void* buf, size_t buf_len,
                    const ip_endpoint& ep) {
  CAF_LOG_TRACE(CAF_ARG(fd) << CAF_ARG(buf_len));
  socklen_t len = static_cast<socklen_t>(*ep.clength());
  auto sres = ::sendto(fd, reinterpret_cast<socket_send_ptr>(buf), buf_len,
                       0, ep.caddress(),
                       len);
  if (is_error(sres, true)) {
    CAF_LOG_ERROR("sendto returned" << CAF_ARG(sres));
    return false;
  }
  result = (sres > 0) ? static_cast<size_t>(sres) : 0;
  return true;
}

// -- Policy class for TCP wrapping above free functions -----------------------

read_some_fun tcp_policy::read_some = network::read_some;

write_some_fun tcp_policy::write_some = network::write_some;

try_accept_fun tcp_policy::try_accept = network::try_accept;

// -- Policy class for UDP wrappign above free functions -----------------------

read_datagram_fun udp_policy::read_datagram = network::read_datagram;

write_datagram_fun udp_policy::write_datagram = network::write_datagram;

// -- Platform-independent parts of the default_multiplexer --------------------

bool default_multiplexer::try_run_once() {
  return poll_once(false);
}

void default_multiplexer::run_once() {
  poll_once(true);
}

void default_multiplexer::add(operation op, native_socket fd,
                              event_handler* ptr) {
  CAF_ASSERT(fd != invalid_native_socket);
  // ptr == nullptr is only allowed to store our pipe read handle
  // and the pipe read handle is added in the ctor (not allowed here)
  CAF_ASSERT(ptr != nullptr);
  CAF_LOG_TRACE(CAF_ARG(op) << CAF_ARG(fd));
  new_event(add_flag, op, fd, ptr);
}

void default_multiplexer::del(operation op, native_socket fd,
                              event_handler* ptr) {
  CAF_ASSERT(fd != invalid_native_socket);
  // ptr == nullptr is only allowed when removing our pipe read handle
  CAF_ASSERT(ptr != nullptr || fd == pipe_.first);
  CAF_LOG_TRACE(CAF_ARG(op)<< CAF_ARG(fd));
  new_event(del_flag, op, fd, ptr);
}

void default_multiplexer::wr_dispatch_request(resumable* ptr) {
  intptr_t ptrval = reinterpret_cast<intptr_t>(ptr);
  // on windows, we actually have sockets, otherwise we have file handles
# ifdef CAF_WINDOWS
  auto res = ::send(pipe_.second, reinterpret_cast<socket_send_ptr>(&ptrval),
                    sizeof(ptrval), no_sigpipe_io_flag);
# else
  auto res = ::write(pipe_.second, &ptrval, sizeof(ptrval));
# endif
  if (res <= 0) {
    // pipe closed, discard resumable
    intrusive_ptr_release(ptr);
  } else if (static_cast<size_t>(res) < sizeof(ptrval)) {
    // must not happen: wrote invalid pointer to pipe
    std::cerr << "[CAF] Fatal error: wrote invalid data to pipe" << std::endl;
    abort();
  }
}

multiplexer::supervisor_ptr default_multiplexer::make_supervisor() {
  class impl : public multiplexer::supervisor {
  public:
    explicit impl(default_multiplexer* thisptr) : this_(thisptr) {
      // nop
    }
    ~impl() override {
      auto ptr = this_;
      ptr->dispatch([=] { ptr->close_pipe(); });
    }
  private:
    default_multiplexer* this_;
  };
  return supervisor_ptr{new impl(this)};
}

void default_multiplexer::close_pipe() {
  CAF_LOG_TRACE("");
  del(operation::read, pipe_.first, nullptr);
}

void default_multiplexer::handle_socket_event(native_socket fd, int mask,
                                              event_handler* ptr) {
  CAF_LOG_TRACE(CAF_ARG(fd) << CAF_ARG(mask));
  CAF_ASSERT(ptr != nullptr);
  bool checkerror = true;
  if ((mask & input_mask) != 0) {
    checkerror = false;
    // ignore read events if a previous event caused
    // this socket to be shut down for reading
    if (!ptr->read_channel_closed())
      ptr->handle_event(operation::read);
  }
  if ((mask & output_mask) != 0) {
    checkerror = false;
    ptr->handle_event(operation::write);
  }
  if (checkerror && ((mask & error_mask) != 0)) {
    CAF_LOG_DEBUG("error occured on socket:"
                  << CAF_ARG(fd) << CAF_ARG(last_socket_error())
                  << CAF_ARG(last_socket_error_as_string()));
    ptr->handle_event(operation::propagate_error);
    del(operation::read, fd, ptr);
    del(operation::write, fd, ptr);
  }
}

void default_multiplexer::init() {
# ifdef CAF_WINDOWS
  WSADATA WinsockData;
  if (WSAStartup(MAKEWORD(2, 2), &WinsockData) != 0) {
      CAF_CRITICAL("WSAStartup failed");
  }
# endif
}

bool default_multiplexer::poll_once(bool block) {
  CAF_LOG_TRACE(CAF_ARG(block));
  if (!internally_posted_.empty()) {
    // Don't iterate internally_posted_ directly, because resumables can
    // enqueue new elements into it.
    std::vector<intrusive_ptr<resumable>> xs;
    internally_posted_.swap(xs);
    for (auto& ptr : xs)
      resume(std::move(ptr));
    for (auto& me : events_)
      handle(me);
    events_.clear();
    // Try to swap back to internall_posted_ to re-use allocated memory.
    if (internally_posted_.empty()) {
      xs.swap(internally_posted_);
      internally_posted_.clear();
    }
    poll_once_impl(false);
    return true;
  }
  return poll_once_impl(block);
}

void default_multiplexer::resume(intrusive_ptr<resumable> ptr) {
  CAF_LOG_TRACE("");
  auto mt = system().config().scheduler_max_throughput;
  switch (ptr->resume(this, mt)) {
    case resumable::resume_later:
      // Delay resumable until next cycle.
      internally_posted_.emplace_back(ptr.release(), false);
      break;
    case resumable::shutdown_execution_unit:
      // Don't touch reference count of shutdown helpers.
      ptr.release();
      break;
    default:
      ; // Done. Release reference to resumable.
  }
}

default_multiplexer::~default_multiplexer() {
  if (epollfd_ != invalid_native_socket)
    closesocket(epollfd_);
  // close write handle first
  closesocket(pipe_.second);
  // flush pipe before closing it
  nonblocking(pipe_.first, true);
  auto ptr = pipe_reader_.try_read_next();
  while (ptr != nullptr) {
    scheduler::abstract_coordinator::cleanup_and_release(ptr);
    ptr = pipe_reader_.try_read_next();
  }
  // do cleanup for pipe reader manually, since WSACleanup needs to happen last
  closesocket(pipe_reader_.fd());
  pipe_reader_.init(invalid_native_socket);
# ifdef CAF_WINDOWS
  WSACleanup();
# endif
}

void default_multiplexer::exec_later(resumable* ptr) {
  CAF_LOG_TRACE(CAF_ARG(ptr));
  CAF_ASSERT(ptr != nullptr);
  switch (ptr->subtype()) {
    case resumable::io_actor:
    case resumable::function_object:
      if (std::this_thread::get_id() != thread_id())
        wr_dispatch_request(ptr);
      else
        internally_posted_.emplace_back(ptr, false);
      break;
    default:
      system().scheduler().enqueue(ptr);
  }
}

scribe_ptr default_multiplexer::new_scribe(native_socket fd) {
  CAF_LOG_TRACE("");
  return make_counted<scribe_impl>(*this, fd);
}

expected<scribe_ptr>
default_multiplexer::new_tcp_scribe(const std::string& host, uint16_t port) {
  auto fd = new_tcp_connection(host, port);
  if (!fd)
    return std::move(fd.error());
  return new_scribe(*fd);
}

doorman_ptr default_multiplexer::new_doorman(native_socket fd) {
  CAF_LOG_TRACE(CAF_ARG(fd));
  CAF_ASSERT(fd != network::invalid_native_socket);
  return make_counted<doorman_impl>(*this, fd);
}

expected<doorman_ptr> default_multiplexer::new_tcp_doorman(uint16_t port,
                                                           const char* in,
                                                           bool reuse_addr) {
  auto fd = new_tcp_acceptor_impl(port, in, reuse_addr);
  if (fd)
    return new_doorman(*fd);
  return std::move(fd.error());
}

datagram_servant_ptr
default_multiplexer::new_datagram_servant(native_socket fd) {
  CAF_LOG_TRACE(CAF_ARG(fd));
  CAF_ASSERT(fd != network::invalid_native_socket);
  return make_counted<datagram_servant_impl>(*this, fd, next_endpoint_id());
}

datagram_servant_ptr
default_multiplexer::new_datagram_servant_for_endpoint(native_socket fd,
                                                       const ip_endpoint& ep) {
  CAF_LOG_TRACE(CAF_ARG(ep));
  auto ds = new_datagram_servant(fd);
  ds->add_endpoint(ep, ds->hdl());
  return ds;
};

expected<datagram_servant_ptr>
default_multiplexer::new_remote_udp_endpoint(const std::string& host,
                                             uint16_t port) {
  auto res = new_remote_udp_endpoint_impl(host, port);
  if (!res)
    return std::move(res.error());
  return new_datagram_servant_for_endpoint(res->first, res->second);
}

expected<datagram_servant_ptr>
default_multiplexer::new_local_udp_endpoint(uint16_t port, const char* in,
                                            bool reuse_addr) {
  auto res = new_local_udp_endpoint_impl(port, in, reuse_addr);
  if (res)
    return new_datagram_servant((*res).first);
  return std::move(res.error());
}

int64_t default_multiplexer::next_endpoint_id() {
  return servant_ids_++;
}

event_handler::event_handler(default_multiplexer& dm, native_socket sockfd)
    : eventbf_(0),
      fd_(sockfd),
      read_channel_closed_(false),
      backend_(dm) {
  set_fd_flags();
}

event_handler::~event_handler() {
  if (fd_ != invalid_native_socket) {
    CAF_LOG_DEBUG("close socket" << CAF_ARG(fd_));
    closesocket(fd_);
  }
}

void event_handler::close_read_channel() {
  if (fd_ == invalid_native_socket || read_channel_closed_)
    return;
  ::shutdown(fd_, 0); // 0 identifies the read channel on Win & UNIX
  read_channel_closed_ = true;
}

void event_handler::passivate() {
  backend().del(operation::read, fd(), this);
}

void event_handler::activate() {
  backend().add(operation::read, fd(), this);
}

void event_handler::set_fd_flags() {
  if (fd_ == invalid_native_socket)
    return;
  // enable nonblocking IO, disable Nagle's algorithm, and suppress SIGPIPE
  nonblocking(fd_, true);
  tcp_nodelay(fd_, true);
  allow_sigpipe(fd_, false);
}

pipe_reader::pipe_reader(default_multiplexer& dm)
    : event_handler(dm, invalid_native_socket) {
  // nop
}

void pipe_reader::removed_from_loop(operation) {
  // nop
}

resumable* pipe_reader::try_read_next() {
  intptr_t ptrval;
  // on windows, we actually have sockets, otherwise we have file handles
# ifdef CAF_WINDOWS
    auto res = recv(fd(), reinterpret_cast<socket_recv_ptr>(&ptrval),
                    sizeof(ptrval), 0);
# else
    auto res = read(fd(), &ptrval, sizeof(ptrval));
# endif
  if (res != sizeof(ptrval))
    return nullptr;
  return reinterpret_cast<resumable*>(ptrval);
}

void pipe_reader::handle_event(operation op) {
  CAF_LOG_TRACE(CAF_ARG(op));
  if (op == operation::read) {
    auto ptr = try_read_next();
    if (ptr != nullptr)
      backend().resume({ptr, false});
  }
  // else: ignore errors
}

void pipe_reader::init(native_socket sock_fd) {
  fd_ = sock_fd;
}

stream::stream(default_multiplexer& backend_ref, native_socket sockfd)
    : event_handler(backend_ref, sockfd),
      read_threshold_(1),
      collected_(0),
      ack_writes_(false),
      writing_(false),
      written_(0) {
  configure_read(receive_policy::at_most(1024));
}

void stream::start(stream_manager* mgr) {
  CAF_ASSERT(mgr != nullptr);
  activate(mgr);
}

void stream::activate(stream_manager* mgr) {
  if (!reader_) {
    reader_.reset(mgr);
    event_handler::activate();
    prepare_next_read();
  }
}

void stream::configure_read(receive_policy::config config) {
  rd_flag_ = config.first;
  max_ = config.second;
}

void stream::ack_writes(bool x) {
  ack_writes_ = x;
}

void stream::write(const void* buf, size_t num_bytes) {
  CAF_LOG_TRACE(CAF_ARG(num_bytes));
  auto first = reinterpret_cast<const char*>(buf);
  auto last  = first + num_bytes;
  wr_offline_buf_.insert(wr_offline_buf_.end(), first, last);
}

void stream::flush(const manager_ptr& mgr) {
  CAF_ASSERT(mgr != nullptr);
  CAF_LOG_TRACE(CAF_ARG(wr_offline_buf_.size()));
  if (!wr_offline_buf_.empty() && !writing_) {
    backend().add(operation::write, fd(), this);
    writer_ = mgr;
    writing_ = true;
    prepare_next_write();
  }
}

void stream::stop_reading() {
  CAF_LOG_TRACE("");
  close_read_channel();
  passivate();
}

void stream::removed_from_loop(operation op) {
  CAF_LOG_TRACE(CAF_ARG(op));
  switch (op) {
    case operation::read:  reader_.reset(); break;
    case operation::write: writer_.reset(); break;
    case operation::propagate_error: break;
  }
}

size_t stream::max_consecutive_reads() {
  return backend().system().config().middleman_max_consecutive_reads;
}

void stream::prepare_next_read() {
  collected_ = 0;
  switch (rd_flag_) {
    case receive_policy_flag::exactly:
      if (rd_buf_.size() != max_)
        rd_buf_.resize(max_);
      read_threshold_ = max_;
      break;
    case receive_policy_flag::at_most:
      if (rd_buf_.size() != max_)
        rd_buf_.resize(max_);
      read_threshold_ = 1;
      break;
    case receive_policy_flag::at_least: {
      // read up to 10% more, but at least allow 100 bytes more
      auto max_size = max_ + std::max<size_t>(100, max_ / 10);
      if (rd_buf_.size() != max_size)
        rd_buf_.resize(max_size);
      read_threshold_ = max_;
      break;
    }
  }
}

void stream::prepare_next_write() {
  CAF_LOG_TRACE(CAF_ARG(wr_buf_.size()) << CAF_ARG(wr_offline_buf_.size()));
  written_ = 0;
  wr_buf_.clear();
  if (wr_offline_buf_.empty()) {
    writing_ = false;
    backend().del(operation::write, fd(), this);
  } else {
    wr_buf_.swap(wr_offline_buf_);
  }
}

acceptor::acceptor(default_multiplexer& backend_ref, native_socket sockfd)
    : event_handler(backend_ref, sockfd),
      sock_(invalid_native_socket) {
  // nop
}

void acceptor::start(acceptor_manager* mgr) {
  CAF_LOG_TRACE(CAF_ARG2("fd", fd()));
  CAF_ASSERT(mgr != nullptr);
  activate(mgr);
}

void acceptor::activate(acceptor_manager* mgr) {
  if (!mgr_) {
    mgr_.reset(mgr);
    event_handler::activate();
  }
}

void acceptor::stop_reading() {
  CAF_LOG_TRACE(CAF_ARG2("fd", fd()));
  close_read_channel();
  passivate();
}

void acceptor::removed_from_loop(operation op) {
  CAF_LOG_TRACE(CAF_ARG2("fd", fd()) << CAF_ARG(op));
  if (op == operation::read)
    mgr_.reset();
}

datagram_handler::datagram_handler(default_multiplexer& backend_ref,
                                   native_socket sockfd)
  : event_handler(backend_ref, sockfd),
    max_datagram_size_(receive_buffer_size),
    rd_buf_(receive_buffer_size),
    send_buffer_size_(0),
    ack_writes_(false),
    writing_(false) {
  allow_udp_connreset(sockfd, false);
  auto es = send_buffer_size(sockfd);
  if (!es)
    CAF_LOG_ERROR("cannot determine socket buffer size");
  else
    send_buffer_size_ = *es;
}

void datagram_handler::start(datagram_manager* mgr) {
  CAF_LOG_TRACE(CAF_ARG2("fd", fd()));
  CAF_ASSERT(mgr != nullptr);
  activate(mgr);
}

void datagram_handler::activate(datagram_manager* mgr) {
  if (!reader_) {
    reader_.reset(mgr);
    event_handler::activate();
    prepare_next_read();
  }
}

void datagram_handler::ack_writes(bool x) {
  ack_writes_ = x;
}


void datagram_handler::write(datagram_handle hdl, const void* buf,
                             size_t num_bytes) {
  wr_offline_buf_.emplace_back();
  wr_offline_buf_.back().first = hdl;
  auto cbuf = reinterpret_cast<const char*>(buf);
  wr_offline_buf_.back().second.assign(cbuf,
                                       cbuf + static_cast<ptrdiff_t>(num_bytes));
}

void datagram_handler::flush(const manager_ptr& mgr) {
  CAF_ASSERT(mgr != nullptr);
  CAF_LOG_TRACE(CAF_ARG(wr_offline_buf_.size()));
  if (!wr_offline_buf_.empty() && !writing_) {
    backend().add(operation::write, fd(), this);
    writer_ = mgr;
    writing_ = true;
    prepare_next_write();
  }
}


std::unordered_map<datagram_handle, ip_endpoint>& datagram_handler::endpoints() {
  return ep_by_hdl_;
}

const std::unordered_map<datagram_handle, ip_endpoint>&
datagram_handler::endpoints() const {
  return ep_by_hdl_;
}

void datagram_handler::add_endpoint(datagram_handle hdl, const ip_endpoint& ep,
                                    const manager_ptr mgr) {
  auto itr = hdl_by_ep_.find(ep);
  if (itr == hdl_by_ep_.end()) {
    hdl_by_ep_[ep] = hdl;
    ep_by_hdl_[hdl] = ep;
    writer_ = mgr;
  } else if (!writer_) {
    writer_ = mgr;
  } else {
    CAF_LOG_ERROR("cannot assign a second servant to the endpoint "
                  << to_string(ep));
    abort();
  }
}

void datagram_handler::remove_endpoint(datagram_handle hdl) {
  CAF_LOG_TRACE(CAF_ARG(hdl));
  auto itr = ep_by_hdl_.find(hdl);
  if (itr != ep_by_hdl_.end()) {
    hdl_by_ep_.erase(itr->second);
    ep_by_hdl_.erase(itr);
  }
}

void datagram_handler::stop_reading() {
  CAF_LOG_TRACE("");
  close_read_channel();
  passivate();
}

void datagram_handler::removed_from_loop(operation op) {
  switch (op) {
    case operation::read: reader_.reset(); break;
    case operation::write: writer_.reset(); break;
    case operation::propagate_error: break;
  };
}

size_t datagram_handler::max_consecutive_reads() {
  return backend().system().config().middleman_max_consecutive_reads;
}

void datagram_handler::prepare_next_read() {
  CAF_LOG_TRACE(CAF_ARG(wr_buf_.second.size())
                << CAF_ARG(wr_offline_buf_.size()));
  rd_buf_.resize(max_datagram_size_);
}

void datagram_handler::prepare_next_write() {
  CAF_LOG_TRACE(CAF_ARG(wr_offline_buf_.size()));
  wr_buf_.second.clear();
  if (wr_offline_buf_.empty()) {
    writing_ = false;
    backend().del(operation::write, fd(), this);
  } else {
    wr_buf_.swap(wr_offline_buf_.front());
    wr_offline_buf_.pop_front();
  }
}

class socket_guard {
public:
  explicit socket_guard(native_socket fd) : fd_(fd) {
    // nop
  }

  ~socket_guard() {
    close();
  }

  native_socket release() {
    auto fd = fd_;
    fd_ = invalid_native_socket;
    return fd;
  }

  void close() {
    if (fd_ != invalid_native_socket) {
      CAF_LOG_DEBUG("close socket" << CAF_ARG(fd_));
      closesocket(fd_);
      fd_ = invalid_native_socket;
    }
  }

private:
  native_socket fd_;
};

auto addr_of(sockaddr_in& what) -> decltype(what.sin_addr)& {
  return what.sin_addr;
}

auto family_of(sockaddr_in& what) -> decltype(what.sin_family)& {
  return what.sin_family;
}

auto port_of(sockaddr_in& what) -> decltype(what.sin_port)& {
  return what.sin_port;
}

auto addr_of(sockaddr_in6& what) -> decltype(what.sin6_addr)& {
  return what.sin6_addr;
}

auto family_of(sockaddr_in6& what) -> decltype(what.sin6_family)& {
  return what.sin6_family;
}

auto port_of(sockaddr_in6& what) -> decltype(what.sin6_port)& {
  return what.sin6_port;
}

auto port_of(sockaddr& what) -> decltype(port_of(std::declval<sockaddr_in&>())) {
  switch (what.sa_family) {
    case AF_INET:
      return port_of(reinterpret_cast<sockaddr_in&>(what));
    case AF_INET6:
      return port_of(reinterpret_cast<sockaddr_in6&>(what));
    default:
      break;
  }
  CAF_CRITICAL("invalid protocol family");
}

template <int Family>
bool ip_connect(native_socket fd, const std::string& host, uint16_t port) {
  CAF_LOG_TRACE("Family =" << (Family == AF_INET ? "AF_INET" : "AF_INET6")
                << CAF_ARG(fd) << CAF_ARG(host));
  static_assert(Family == AF_INET || Family == AF_INET6, "invalid family");
  using sockaddr_type =
    typename std::conditional<
      Family == AF_INET,
      sockaddr_in,
      sockaddr_in6
    >::type;
  sockaddr_type sa;
  memset(&sa, 0, sizeof(sockaddr_type));
  inet_pton(Family, host.c_str(), &addr_of(sa));
  family_of(sa) = Family;
  port_of(sa)   = htons(port);
  return connect(fd, reinterpret_cast<const sockaddr*>(&sa), sizeof(sa)) == 0;
}

expected<native_socket>
new_tcp_connection(const std::string& host, uint16_t port,
                   optional<protocol::network> preferred) {
  CAF_LOG_TRACE(CAF_ARG(host) << CAF_ARG(port) << CAF_ARG(preferred));
  CAF_LOG_INFO("try to connect to:" << CAF_ARG(host) << CAF_ARG(port));
  auto res = interfaces::native_address(host, std::move(preferred));
  if (!res) {
    CAF_LOG_INFO("no such host");
    return make_error(sec::cannot_connect_to_node, "no such host", host, port);
  }
  auto proto = res->second;
  CAF_ASSERT(proto == ipv4 || proto == ipv6);
  CALL_CFUN(fd, cc_valid_socket, "socket",
            socket(proto == ipv4 ? AF_INET : AF_INET6, SOCK_STREAM, 0));
  socket_guard sguard(fd);
  if (proto == ipv6) {
    if (ip_connect<AF_INET6>(fd, res->first, port)) {
      CAF_LOG_INFO("successfully connected to host via IPv6");
      return sguard.release();
    }
    sguard.close();
    // IPv4 fallback
    return new_tcp_connection(host, port, ipv4);
  }
  if (!ip_connect<AF_INET>(fd, res->first, port)) {
    CAF_LOG_INFO("could not connect to:" << CAF_ARG(host) << CAF_ARG(port));
    return make_error(sec::cannot_connect_to_node,
                      "ip_connect failed", host, port);
  }
  CAF_LOG_INFO("successfully connected to host via IPv4");
  return sguard.release();
}

template <class SockAddrType>
expected<void> read_port(native_socket fd, SockAddrType& sa) {
  socklen_t len = sizeof(SockAddrType);
  CALL_CFUN(res, cc_zero, "getsockname",
            getsockname(fd, reinterpret_cast<sockaddr*>(&sa), &len));
  return unit;
}

expected<void> set_inaddr_any(native_socket, sockaddr_in& sa) {
  sa.sin_addr.s_addr = INADDR_ANY;
  return unit;
}

expected<void> set_inaddr_any(native_socket fd, sockaddr_in6& sa) {
  sa.sin6_addr = in6addr_any;
  // also accept ipv4 requests on this socket
  int off = 0;
  CALL_CFUN(res, cc_zero, "setsockopt",
            setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY,
                       reinterpret_cast<setsockopt_ptr>(&off),
                       static_cast<socklen_t>(sizeof(off))));
  return unit;
}

expected<int> send_buffer_size(native_socket fd) {
  int size;
  socklen_t ret_size = sizeof(size);
  CALL_CFUN(res, cc_zero, "getsockopt",
            getsockopt(fd, SOL_SOCKET, SO_SNDBUF,
            reinterpret_cast<getsockopt_ptr>(&size), &ret_size));
  return size;
}

expected<void> send_buffer_size(native_socket fd, int new_value) {
  CALL_CFUN(res, cc_zero, "setsockopt",
            setsockopt(fd, SOL_SOCKET, SO_SNDBUF,
                       reinterpret_cast<setsockopt_ptr>(&new_value),
                       static_cast<socklen_t>(sizeof(int))));
  return unit;
}

template <int Family, int SockType = SOCK_STREAM>
expected<native_socket> new_ip_acceptor_impl(uint16_t port, const char* addr,
                                             bool reuse_addr, bool any) {
  static_assert(Family == AF_INET || Family == AF_INET6, "invalid family");
  CAF_LOG_TRACE(CAF_ARG(port) << ", addr = " << (addr ? addr : "nullptr"));
  CALL_CFUN(fd, cc_valid_socket, "socket", socket(Family, SockType, 0));
  // sguard closes the socket in case of exception
  socket_guard sguard{fd};
  if (reuse_addr) {
    int on = 1;
    CALL_CFUN(tmp1, cc_zero, "setsockopt",
              setsockopt(fd, SOL_SOCKET, SO_REUSEADDR,
                         reinterpret_cast<setsockopt_ptr>(&on),
                         static_cast<socklen_t>(sizeof(on))));
  }
  using sockaddr_type =
    typename std::conditional<
      Family == AF_INET,
      sockaddr_in,
      sockaddr_in6
    >::type;
  sockaddr_type sa;
  memset(&sa, 0, sizeof(sockaddr_type));
  family_of(sa) = Family;
  if (any)
    set_inaddr_any(fd, sa);
  CALL_CFUN(tmp, cc_one, "inet_pton",
            inet_pton(Family, addr, &addr_of(sa)));
  port_of(sa) = htons(port);
  CALL_CFUN(res, cc_zero, "bind",
            bind(fd, reinterpret_cast<sockaddr*>(&sa),
                 static_cast<socklen_t>(sizeof(sa))));
  return sguard.release();
}

expected<native_socket> new_tcp_acceptor_impl(uint16_t port, const char* addr,
                                              bool reuse_addr) {
  CAF_LOG_TRACE(CAF_ARG(port) << ", addr = " << (addr ? addr : "nullptr"));
  auto addrs = interfaces::server_address(port, addr);
  auto addr_str = std::string{addr == nullptr ? "" : addr};
  if (addrs.empty())
    return make_error(sec::cannot_open_port, "No local interface available",
                      addr_str);
  bool any = addr_str.empty() || addr_str == "::" || addr_str == "0.0.0.0";
  auto fd = invalid_native_socket;
  for (auto& elem : addrs) {
    auto hostname = elem.first.c_str();
    auto p = elem.second == ipv4
           ? new_ip_acceptor_impl<AF_INET>(port, hostname, reuse_addr, any)
           : new_ip_acceptor_impl<AF_INET6>(port, hostname, reuse_addr, any);
    if (!p) {
      CAF_LOG_DEBUG(p.error());
      continue;
    }
    fd = *p;
    break;
  }
  if (fd == invalid_native_socket) {
    CAF_LOG_WARNING("could not open tcp socket on:" << CAF_ARG(port)
                    << CAF_ARG(addr_str));
    return make_error(sec::cannot_open_port, "tcp socket creation failed",
                      port, addr_str);
  }
  socket_guard sguard{fd};
  CALL_CFUN(tmp2, cc_zero, "listen", listen(fd, SOMAXCONN));
  // ok, no errors so far
  CAF_LOG_DEBUG(CAF_ARG(fd));
  return sguard.release();
}

expected<std::pair<native_socket, ip_endpoint>>
new_remote_udp_endpoint_impl(const std::string& host, uint16_t port,
                             optional<protocol::network> preferred) {
  CAF_LOG_TRACE(CAF_ARG(host) << CAF_ARG(port) << CAF_ARG(preferred));
  auto lep = new_local_udp_endpoint_impl(0, nullptr, false, preferred);
  if (!lep)
    return std::move(lep.error());
  socket_guard sguard{(*lep).first};
  std::pair<native_socket, ip_endpoint> info;
  memset(std::get<1>(info).address(), 0, sizeof(sockaddr_storage));
  if (!interfaces::get_endpoint(host, port, std::get<1>(info), (*lep).second))
    return make_error(sec::cannot_connect_to_node, "no such host", host, port);
  get<0>(info) = sguard.release();
  return info;
}

expected<std::pair<native_socket, protocol::network>>
new_local_udp_endpoint_impl(uint16_t port, const char* addr, bool reuse,
                            optional<protocol::network> preferred) {
  CAF_LOG_TRACE(CAF_ARG(port) << ", addr = " << (addr ? addr : "nullptr"));
  auto addrs = interfaces::server_address(port, addr, preferred);
  auto addr_str = std::string{addr == nullptr ? "" : addr};
  if (addrs.empty())
    return make_error(sec::cannot_open_port, "No local interface available",
                      addr_str);
  bool any = addr_str.empty() || addr_str == "::" || addr_str == "0.0.0.0";
  auto fd = invalid_native_socket;
  protocol::network proto;
  for (auto& elem : addrs) {
    auto host = elem.first.c_str();
    auto p = elem.second == ipv4
           ? new_ip_acceptor_impl<AF_INET, SOCK_DGRAM>(port, host, reuse, any)
           : new_ip_acceptor_impl<AF_INET6, SOCK_DGRAM>(port, host, reuse, any);
    if (!p) {
      CAF_LOG_DEBUG(p.error());
      continue;
    }
    fd = *p;
    proto = elem.second;
    break;
  }
  if (fd == invalid_native_socket) {
    CAF_LOG_WARNING("could not open udp socket on:" << CAF_ARG(port)
                    << CAF_ARG(addr_str));
    return make_error(sec::cannot_open_port, "udp socket creation failed",
                      port, addr_str);
  }
  CAF_LOG_DEBUG(CAF_ARG(fd));
  return std::make_pair(fd, proto);
}

expected<std::string> local_addr_of_fd(native_socket fd) {
  sockaddr_storage st;
  socklen_t st_len = sizeof(st);
  sockaddr* sa = reinterpret_cast<sockaddr*>(&st);
  CALL_CFUN(tmp1, cc_zero, "getsockname", getsockname(fd, sa, &st_len));
  char addr[INET6_ADDRSTRLEN] {0};
  switch (sa->sa_family) {
    case AF_INET:
      return inet_ntop(AF_INET, &reinterpret_cast<sockaddr_in*>(sa)->sin_addr,
                       addr, sizeof(addr));
    case AF_INET6:
      return inet_ntop(AF_INET6,
                       &reinterpret_cast<sockaddr_in6*>(sa)->sin6_addr,
                       addr, sizeof(addr));
    default:
      break;
  }
  return make_error(sec::invalid_protocol_family,
                    "local_addr_of_fd", sa->sa_family);
}

expected<uint16_t> local_port_of_fd(native_socket fd) {
  sockaddr_storage st;
  socklen_t st_len = sizeof(st);
  CALL_CFUN(tmp, cc_zero, "getsockname",
            getsockname(fd, reinterpret_cast<sockaddr*>(&st), &st_len));
  return ntohs(port_of(reinterpret_cast<sockaddr&>(st)));
}

expected<std::string> remote_addr_of_fd(native_socket fd) {
  sockaddr_storage st;
  socklen_t st_len = sizeof(st);
  sockaddr* sa = reinterpret_cast<sockaddr*>(&st);
  CALL_CFUN(tmp, cc_zero, "getpeername", getpeername(fd, sa, &st_len));
  char addr[INET6_ADDRSTRLEN] {0};
  switch (sa->sa_family) {
    case AF_INET:
      return inet_ntop(AF_INET, &reinterpret_cast<sockaddr_in*>(sa)->sin_addr,
                       addr, sizeof(addr));
    case AF_INET6:
      return inet_ntop(AF_INET6,
                       &reinterpret_cast<sockaddr_in6*>(sa)->sin6_addr,
                       addr, sizeof(addr));
    default:
      break;
  }
  return make_error(sec::invalid_protocol_family,
                    "remote_addr_of_fd", sa->sa_family);
}

expected<uint16_t> remote_port_of_fd(native_socket fd) {
  sockaddr_storage st;
  socklen_t st_len = sizeof(st);
  CALL_CFUN(tmp, cc_zero, "getpeername",
            getpeername(fd, reinterpret_cast<sockaddr*>(&st), &st_len));
  return ntohs(port_of(reinterpret_cast<sockaddr&>(st)));
}

// -- default doorman and scribe implementations -------------------------------

doorman_impl::doorman_impl(default_multiplexer& mx, native_socket sockfd)
    : doorman(network::accept_hdl_from_socket(sockfd)),
      acceptor_(mx, sockfd) {
  // nop
}

bool doorman_impl::new_connection() {
  CAF_LOG_TRACE("");
  if (detached())
    // we are already disconnected from the broker while the multiplexer
    // did not yet remove the socket, this can happen if an I/O event causes
    // the broker to call close_all() while the pollset contained
    // further activities for the broker
    return false;
  auto& dm = acceptor_.backend();
  auto sptr = dm.new_scribe(acceptor_.accepted_socket());
  auto hdl = sptr->hdl();
  parent()->add_scribe(std::move(sptr));
  return doorman::new_connection(&dm, hdl);
}

void doorman_impl::stop_reading() {
  CAF_LOG_TRACE("");
  acceptor_.stop_reading();
  detach(&acceptor_.backend(), false);
}

void doorman_impl::launch() {
  CAF_LOG_TRACE("");
  acceptor_.start(this);
}

std::string doorman_impl::addr() const {
  auto x = local_addr_of_fd(acceptor_.fd());
  if (!x)
    return "";
  return std::move(*x);
}

uint16_t doorman_impl::port() const {
  auto x = local_port_of_fd(acceptor_.fd());
  if (!x)
    return 0;
  return *x;
}

void doorman_impl::add_to_loop() {
  acceptor_.activate(this);
}

void doorman_impl::remove_from_loop() {
  acceptor_.passivate();
}

scribe_impl::scribe_impl(default_multiplexer& mx, native_socket sockfd)
    : scribe(network::conn_hdl_from_socket(sockfd)),
      launched_(false),
      stream_(mx, sockfd) {
  // nop
}

void scribe_impl::configure_read(receive_policy::config config) {
  CAF_LOG_TRACE("");
  stream_.configure_read(config);
  if (!launched_)
    launch();
}

void scribe_impl::ack_writes(bool enable) {
  CAF_LOG_TRACE(CAF_ARG(enable));
  stream_.ack_writes(enable);
}

std::vector<char>& scribe_impl::wr_buf() {
  return stream_.wr_buf();
}

std::vector<char>& scribe_impl::rd_buf() {
  return stream_.rd_buf();
}

void scribe_impl::stop_reading() {
  CAF_LOG_TRACE("");
  stream_.stop_reading();
  detach(&stream_.backend(), false);
}

void scribe_impl::flush() {
  CAF_LOG_TRACE("");
  stream_.flush(this);
}

std::string scribe_impl::addr() const {
  auto x = remote_addr_of_fd(stream_.fd());
  if (!x)
    return "";
  return *x;
}

uint16_t scribe_impl::port() const {
  auto x = remote_port_of_fd(stream_.fd());
  if (!x)
    return 0;
  return *x;
}

void scribe_impl::launch() {
  CAF_LOG_TRACE("");
  CAF_ASSERT(!launched_);
  launched_ = true;
  stream_.start(this);
}

void scribe_impl::add_to_loop() {
  stream_.activate(this);
}

void scribe_impl::remove_from_loop() {
  stream_.passivate();
}

datagram_servant_impl::datagram_servant_impl(default_multiplexer& mx,
                                             native_socket sockfd, int64_t id)
  : datagram_servant(datagram_handle::from_int(id)),
    launched_(false),
    handler_(mx, sockfd) {
  // nop
}

bool datagram_servant_impl::new_endpoint(network::receive_buffer& buf) {
  CAF_LOG_TRACE("");
  if (detached())
     // we are already disconnected from the broker while the multiplexer
     // did not yet remove the socket, this can happen if an I/O event
     // causes the broker to call close_all() while the pollset contained
     // further activities for the broker
     return false;
  // A datagram that has a source port of zero is valid and never requires a
  // reply. In the case of CAF we can simply drop it as nothing but the
  // handshake could be communicated which we could not reply to.
  // Source: TCP/IP Illustrated, Chapter 10.2
  if (network::port(handler_.sending_endpoint()) == 0)
    return true;
  auto& dm = handler_.backend();
  auto hdl = datagram_handle::from_int(dm.next_endpoint_id());
  add_endpoint(handler_.sending_endpoint(), hdl);
  parent()->add_hdl_for_datagram_servant(this, hdl);
  return consume(&dm, hdl, buf);
}

void datagram_servant_impl::ack_writes(bool enable) {
  CAF_LOG_TRACE(CAF_ARG(enable));
  handler_.ack_writes(enable);
}

std::vector<char>& datagram_servant_impl::wr_buf(datagram_handle hdl) {
  return handler_.wr_buf(hdl);
}

void datagram_servant_impl::enqueue_datagram(datagram_handle hdl,
                                             std::vector<char> buffer) {
  handler_.enqueue_datagram(hdl, std::move(buffer));
}

network::receive_buffer& datagram_servant_impl::rd_buf() {
  return handler_.rd_buf();
}

void datagram_servant_impl::stop_reading() {
  CAF_LOG_TRACE("");
  handler_.stop_reading();
  detach_handles();
  detach(&handler_.backend(), false);
}

void datagram_servant_impl::flush() {
  CAF_LOG_TRACE("");
  handler_.flush(this);
}

std::string datagram_servant_impl::addr() const {
  auto x = remote_addr_of_fd(handler_.fd());
  if (!x)
    return "";
  return *x;
}

uint16_t datagram_servant_impl::port(datagram_handle hdl) const {
  auto& eps = handler_.endpoints();
  auto itr = eps.find(hdl);
  if (itr == eps.end())
    return 0;
  return network::port(itr->second);
}

uint16_t datagram_servant_impl::local_port() const {
  auto x = local_port_of_fd(handler_.fd());
  if (!x)
    return 0;
  return *x;
}

std::vector<datagram_handle> datagram_servant_impl::hdls() const {
  std::vector<datagram_handle> result;
  result.reserve(handler_.endpoints().size());
  for (auto& p : handler_.endpoints())
    result.push_back(p.first);
  return result;
}

void datagram_servant_impl::add_endpoint(const ip_endpoint& ep,
                                         datagram_handle hdl) {
  handler_.add_endpoint(hdl, ep, this);
}

void datagram_servant_impl::remove_endpoint(datagram_handle hdl) {
  handler_.remove_endpoint(hdl);
}

void datagram_servant_impl::launch() {
  CAF_LOG_TRACE("");
  CAF_ASSERT(!launched_);
  launched_ = true;
  handler_.start(this);
}

void datagram_servant_impl::add_to_loop() {
  handler_.activate(this);
}

void datagram_servant_impl::remove_from_loop() {
  handler_.passivate();
}


void datagram_servant_impl::detach_handles() {
  for (auto& p : handler_.endpoints()) {
    if (p.first != hdl())
      parent()->erase(p.first);
  }
}

} // namespace network
} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/none.hpp"
#include "caf/config.hpp"
#include "caf/logger.hpp"
#include "caf/actor_system.hpp"
#include "caf/make_counted.hpp"
#include "caf/scheduler/abstract_coordinator.hpp"

#include "caf/io/broker.hpp"
#include "caf/io/middleman.hpp"

#include "caf/detail/scope_guard.hpp"
#include "caf/detail/sync_request_bouncer.hpp"

#include "caf/event_based_actor.hpp"

namespace caf {
namespace io {

void abstract_broker::enqueue(strong_actor_ptr src, message_id mid,
                              message msg, execution_unit*) {
  enqueue(make_mailbox_element(std::move(src), mid, {}, std::move(msg)),
          &backend());
}

void abstract_broker::enqueue(mailbox_element_ptr ptr, execution_unit*) {
  CAF_PUSH_AID(id());
  scheduled_actor::enqueue(std::move(ptr), &backend());
}

void abstract_broker::launch(execution_unit* eu, bool lazy, bool hide) {
  CAF_ASSERT(eu != nullptr);
  CAF_ASSERT(eu == &backend());
  CAF_LOG_TRACE(CAF_ARG(lazy) << CAF_ARG(hide));
  // add implicit reference count held by middleman/multiplexer
  if (!hide)
    register_at_system();
  if (lazy && mailbox().try_block())
    return;
  intrusive_ptr_add_ref(ctrl());
  eu->exec_later(this);
}

bool abstract_broker::cleanup(error&& reason, execution_unit* host) {
  CAF_LOG_TRACE(CAF_ARG(reason));
  close_all();
  CAF_ASSERT(doormen_.empty());
  CAF_ASSERT(scribes_.empty());
  CAF_ASSERT(datagram_servants_.empty());
  cache_.clear();
  return local_actor::cleanup(std::move(reason), host);
}

abstract_broker::~abstract_broker() {
  // nop
}

void abstract_broker::configure_read(connection_handle hdl,
                                     receive_policy::config cfg) {
  CAF_LOG_TRACE(CAF_ARG(hdl) << CAF_ARG(cfg));
  auto x = by_id(hdl);
  if (x)
    x->configure_read(cfg);
}

void abstract_broker::ack_writes(connection_handle hdl, bool enable) {
  CAF_LOG_TRACE(CAF_ARG(hdl) << CAF_ARG(enable));
  auto x = by_id(hdl);
  if (x)
    x->ack_writes(enable);
}

std::vector<char>& abstract_broker::wr_buf(connection_handle hdl) {
  auto x = by_id(hdl);
  if (!x) {
    CAF_LOG_ERROR("tried to access wr_buf() of an unknown connection_handle");
    return dummy_wr_buf_;
  }
  return x->wr_buf();
}

void abstract_broker::write(connection_handle hdl, size_t bs, const void* buf) {
  auto& out = wr_buf(hdl);
  auto first = reinterpret_cast<const char*>(buf);
  auto last = first + bs;
  out.insert(out.end(), first, last);
}

void abstract_broker::flush(connection_handle hdl) {
  auto x = by_id(hdl);
  if (x)
    x->flush();
}

void abstract_broker::ack_writes(datagram_handle hdl, bool enable) {
  CAF_LOG_TRACE(CAF_ARG(hdl) << CAF_ARG(enable));
  auto x = by_id(hdl);
  if (x)
    x->ack_writes(enable);
}

std::vector<char>& abstract_broker::wr_buf(datagram_handle hdl) {
  auto x = by_id(hdl);
  if (!x) {
    CAF_LOG_ERROR("tried to access wr_buf() of an unknown"
                  "datagram_handle");
    return dummy_wr_buf_;
  }
  return x->wr_buf(hdl);
}

void abstract_broker::enqueue_datagram(datagram_handle hdl,
                                       std::vector<char> buf) {
  auto x = by_id(hdl);
  if (!x)
    CAF_LOG_ERROR("tried to access datagram_buffer() of an unknown"
                  "datagram_handle");
  x->enqueue_datagram(hdl, std::move(buf));
}

void abstract_broker::write(datagram_handle hdl, size_t bs,
                            const void* buf) {
  auto& out = wr_buf(hdl);
  auto first = reinterpret_cast<const char*>(buf);
  auto last = first + bs;
  out.insert(out.end(), first, last);
}

void abstract_broker::flush(datagram_handle hdl) {
  auto x = by_id(hdl);
  if (x)
    x->flush();
}

std::vector<connection_handle> abstract_broker::connections() const {
  std::vector<connection_handle> result;
  result.reserve(scribes_.size());
  for (auto& kvp : scribes_) {
    result.push_back(kvp.first);
  }
  return result;
}

void abstract_broker::add_scribe(scribe_ptr ptr) {
  CAF_LOG_TRACE(CAF_ARG(ptr));
  add_servant(std::move(ptr));
}

connection_handle abstract_broker::add_scribe(network::native_socket fd) {
  CAF_LOG_TRACE(CAF_ARG(fd));
  return add_servant(backend().new_scribe(fd));
}

expected<connection_handle>
abstract_broker::add_tcp_scribe(const std::string& hostname, uint16_t port) {
  CAF_LOG_TRACE(CAF_ARG(hostname) << ", " << CAF_ARG(port));
  auto eptr = backend().new_tcp_scribe(hostname, port);
  if (eptr)
    return add_servant(std::move(*eptr));
  return std::move(eptr.error());
}
void abstract_broker::move_scribe(scribe_ptr ptr) {
  CAF_LOG_TRACE(CAF_ARG(ptr));
  move_servant(std::move(ptr));
}

void abstract_broker::add_doorman(doorman_ptr ptr) {
  CAF_LOG_TRACE(CAF_ARG(ptr));
  add_servant(std::move(ptr));
}

accept_handle abstract_broker::add_doorman(network::native_socket fd) {
  CAF_LOG_TRACE(CAF_ARG(fd));
  return add_servant(backend().new_doorman(fd));
}

expected<std::pair<accept_handle, uint16_t>>
abstract_broker::add_tcp_doorman(uint16_t port, const char* in,
                                 bool reuse_addr) {
  CAF_LOG_TRACE(CAF_ARG(port) << CAF_ARG(in) << CAF_ARG(reuse_addr));
  auto eptr = backend().new_tcp_doorman(port, in, reuse_addr);
  if (eptr) {
    auto ptr = std::move(*eptr);
    auto p = ptr->port();
    return std::make_pair(add_servant(std::move(ptr)), p);
  }
  return std::move(eptr.error());
}

void abstract_broker::add_datagram_servant(datagram_servant_ptr ptr) {
  CAF_LOG_TRACE(CAF_ARG(ptr));
  CAF_ASSERT(ptr != nullptr);
  CAF_ASSERT(ptr->parent() == nullptr);
  ptr->set_parent(this);
  auto hdls = ptr->hdls();
  launch_servant(ptr);
  for (auto& hdl : hdls)
    add_hdl_for_datagram_servant(ptr, hdl);
}

void abstract_broker::add_hdl_for_datagram_servant(datagram_servant_ptr ptr,
                                                   datagram_handle hdl) {
  CAF_LOG_TRACE(CAF_ARG(ptr) << CAF_ARG(hdl));
  CAF_ASSERT(ptr != nullptr);
  CAF_ASSERT(ptr->parent() == this);
  get_map(hdl).emplace(hdl, std::move(ptr));
}

datagram_handle abstract_broker::add_datagram_servant(network::native_socket fd) {
  CAF_LOG_TRACE(CAF_ARG(fd));
  auto ptr = backend().new_datagram_servant(fd);
  auto hdl = ptr->hdl();
  add_datagram_servant(std::move(ptr));
  return hdl;
}

datagram_handle
abstract_broker::add_datagram_servant_for_endpoint(network::native_socket fd,
                                                   const network::ip_endpoint& ep) {
  CAF_LOG_TRACE(CAF_ARG(fd));
  auto ptr = backend().new_datagram_servant_for_endpoint(fd, ep);
  auto hdl = ptr->hdl();
  add_datagram_servant(std::move(ptr));
  return hdl;
}

expected<datagram_handle>
abstract_broker::add_udp_datagram_servant(const std::string& host,
                                          uint16_t port) {
  CAF_LOG_TRACE(CAF_ARG(host) << CAF_ARG(port));
  auto eptr = backend().new_remote_udp_endpoint(host, port);
  if (eptr) {
    auto ptr = std::move(*eptr);
    auto hdl = ptr->hdl();
    add_datagram_servant(std::move(ptr));
    return hdl;
  }
  return std::move(eptr.error());
}

expected<std::pair<datagram_handle, uint16_t>>
abstract_broker::add_udp_datagram_servant(uint16_t port, const char* in,
                                          bool reuse_addr) {
  CAF_LOG_TRACE(CAF_ARG(port) << CAF_ARG(in) << CAF_ARG(reuse_addr));
  auto eptr = backend().new_local_udp_endpoint(port, in, reuse_addr);
  if (eptr) {
    auto ptr = std::move(*eptr);
    auto p = ptr->local_port();
    auto hdl = ptr->hdl();
    add_datagram_servant(std::move(ptr));
    return std::make_pair(hdl, p);
  }
  return std::move(eptr.error());
}

void abstract_broker::move_datagram_servant(datagram_servant_ptr ptr) {
  CAF_LOG_TRACE(CAF_ARG(ptr));
  CAF_ASSERT(ptr != nullptr);
  CAF_ASSERT(ptr->parent() != nullptr && ptr->parent() != this);
  ptr->set_parent(this);
  CAF_ASSERT(ptr->parent() == this);
  auto hdls = ptr->hdls();
  for (auto& hdl : hdls)
    add_hdl_for_datagram_servant(ptr, hdl);
}

std::string abstract_broker::remote_addr(connection_handle hdl) {
  auto i = scribes_.find(hdl);
  return i != scribes_.end() ? i->second->addr() : std::string{};
}

uint16_t abstract_broker::remote_port(connection_handle hdl) {
  auto i = scribes_.find(hdl);
  return i != scribes_.end() ? i->second->port() : 0;
}

std::string abstract_broker::local_addr(accept_handle hdl) {
  auto i = doormen_.find(hdl);
  return i != doormen_.end() ? i->second->addr() : std::string{};
}

uint16_t abstract_broker::local_port(accept_handle hdl) {
  auto i = doormen_.find(hdl);
  return i != doormen_.end() ? i->second->port() : 0;
}

accept_handle abstract_broker::hdl_by_port(uint16_t port) {
  for (auto& kvp : doormen_)
    if (kvp.second->port() == port)
      return kvp.first;
  return invalid_accept_handle;
}

datagram_handle abstract_broker::datagram_hdl_by_port(uint16_t port) {
  for (auto& kvp : datagram_servants_)
    if (kvp.second->port(kvp.first) == port)
      return kvp.first;
  return invalid_datagram_handle;
}

std::string abstract_broker::remote_addr(datagram_handle hdl) {
  auto i = datagram_servants_.find(hdl);
  return i != datagram_servants_.end() ? i->second->addr() : std::string{};
}

uint16_t abstract_broker::remote_port(datagram_handle hdl) {
  auto i = datagram_servants_.find(hdl);
  return i != datagram_servants_.end() ? i->second->port(hdl) : 0;
}

uint16_t abstract_broker::local_port(datagram_handle hdl) {
  auto i = datagram_servants_.find(hdl);
  return i != datagram_servants_.end() ? i->second->local_port() : 0;
}

bool abstract_broker::remove_endpoint(datagram_handle hdl) {
  auto x = by_id(hdl);
  if (!x)
    return false;
  x->remove_endpoint(hdl);
  return true;
}

void abstract_broker::close_all() {
  CAF_LOG_TRACE("");
  while (!doormen_.empty()) {
    // stop_reading will remove the doorman from doormen_
    doormen_.begin()->second->stop_reading();
  }
  while (!scribes_.empty()) {
    // stop_reading will remove the scribe from scribes_
    scribes_.begin()->second->stop_reading();
  }
  while (!datagram_servants_.empty()) {
    // stop reading will remove dgram servants from datagram_servants_
    datagram_servants_.begin()->second->stop_reading();
  }
}

resumable::subtype_t abstract_broker::subtype() const {
  return io_actor;
}

resumable::resume_result
abstract_broker::resume(execution_unit* ctx, size_t mt) {
  CAF_ASSERT(ctx != nullptr);
  CAF_ASSERT(ctx == &backend());
  return scheduled_actor::resume(ctx, mt);
}

const char* abstract_broker::name() const {
  return "broker";
}

void abstract_broker::init_broker() {
  CAF_LOG_TRACE("");
  setf(is_initialized_flag);
  // launch backends now, because user-defined initialization
  // might call functions like add_connection
  for (auto& kvp : doormen_)
    kvp.second->launch();
}

abstract_broker::abstract_broker(actor_config& cfg) : scheduled_actor(cfg) {
  // nop
}

network::multiplexer& abstract_broker::backend() {
  return system().middleman().backend();
}

void abstract_broker::launch_servant(doorman_ptr& ptr) {
  // A doorman needs to be launched in addition to being initialized. This
  // allows CAF to assign doorman to uninitialized brokers.
  if (getf(is_initialized_flag))
    ptr->launch();
}

void abstract_broker::launch_servant(datagram_servant_ptr& ptr) {
  if (getf(is_initialized_flag))
    ptr->launch();
}

} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/basp/routing_table.hpp"

#include "caf/io/middleman.hpp"

namespace caf {
namespace io {
namespace basp {

routing_table::routing_table(abstract_broker* parent)
  : parent_(parent) {
  // nop
}

routing_table::~routing_table() {
  // nop
}

optional<routing_table::route> routing_table::lookup(const node_id& target) {
  auto hdl = lookup_direct(target);
  if (hdl)
    return route{target, *hdl};
  // pick first available indirect route
  auto i = indirect_.find(target);
  if (i != indirect_.end()) {
    auto& hops = i->second;
    while (!hops.empty()) {
      auto& hop = *hops.begin();
      hdl = lookup_direct(hop);
      if (hdl)
        return route{hop, *hdl};
      hops.erase(hops.begin());
    }
  }
  return none;
}

node_id routing_table::lookup_direct(const endpoint_handle& hdl) const {
  return get_opt(direct_by_hdl_, hdl, none);
}

optional<routing_table::endpoint_handle>
routing_table::lookup_direct(const node_id& nid) const {
  auto i = direct_by_nid_.find(nid);
  if (i != direct_by_nid_.end())
    return i->second;
  return none;
}

node_id routing_table::lookup_indirect(const node_id& nid) const {
  auto i = indirect_.find(nid);
  if (i == indirect_.end())
    return none;
  if (i->second.empty())
    return none;
  return *i->second.begin();
}

void routing_table::blacklist(const node_id& hop, const node_id& dest) {
  blacklist_[dest].emplace(hop);
  auto i = indirect_.find(dest);
  if (i == indirect_.end())
    return;
  i->second.erase(hop);
  if (i->second.empty())
    indirect_.erase(i);
}

void routing_table::erase_direct(const endpoint_handle& hdl,
                                 erase_callback& cb) {
  auto i = direct_by_hdl_.find(hdl);
  if (i == direct_by_hdl_.end())
    return;
  cb(i->second);
  parent_->parent().notify<hook::connection_lost>(i->second);
  direct_by_nid_.erase(i->second);
  direct_by_hdl_.erase(i->first);
}

bool routing_table::erase_indirect(const node_id& dest) {
  auto i = indirect_.find(dest);
  if (i == indirect_.end())
    return false;
  if (parent_->parent().has_hook())
    for (auto& nid : i->second)
      parent_->parent().notify<hook::route_lost>(nid, dest);
  indirect_.erase(i);
  return true;
}

void routing_table::add_direct(const endpoint_handle& hdl,
                               const node_id& nid) {
  CAF_ASSERT(direct_by_hdl_.count(hdl) == 0);
  CAF_ASSERT(direct_by_nid_.count(nid) == 0);
  direct_by_hdl_.emplace(hdl, nid);
  direct_by_nid_.emplace(nid, hdl);
  parent_->parent().notify<hook::new_connection_established>(nid);
}

bool routing_table::add_indirect(const node_id& hop, const node_id& dest) {
  auto i = blacklist_.find(dest);
  if (i == blacklist_.end() || i->second.count(hop) == 0) {
    auto& hops = indirect_[dest];
    auto added_first = hops.empty();
    hops.emplace(hop);
    parent_->parent().notify<hook::new_route_added>(hop, dest);
    return added_first;
  }
  return false; // blacklisted
}

bool routing_table::reachable(const node_id& dest) {
  return direct_by_nid_.count(dest) > 0 || indirect_.count(dest) > 0;
}

size_t routing_table::erase(const node_id& dest, erase_callback& cb) {
  cb(dest);
  size_t res = 0;
  auto i = indirect_.find(dest);
  if (i != indirect_.end()) {
    res = i->second.size();
    for (auto& nid : i->second) {
      cb(nid);
      parent_->parent().notify<hook::route_lost>(nid, dest);
    }
    indirect_.erase(i);
  }
  auto hdl = lookup_direct(dest);
  if (hdl) {
    direct_by_hdl_.erase(*hdl);
    direct_by_nid_.erase(dest);
    parent_->parent().notify<hook::connection_lost>(dest);
    ++res;
  }
  return res;
}

} // namespace basp
} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/scribe.hpp"

#include "caf/logger.hpp"

namespace caf {
namespace io {

scribe::scribe(connection_handle conn_hdl) : scribe_base(conn_hdl) {
  // nop
}

scribe::~scribe() {
  CAF_LOG_TRACE("");
}

message scribe::detach_message() {
  return make_message(connection_closed_msg{hdl()});
}

bool scribe::consume(execution_unit* ctx, const void*, size_t num_bytes) {
  CAF_ASSERT(ctx != nullptr);
  CAF_LOG_TRACE(CAF_ARG(num_bytes));
  if (detached())
    // we are already disconnected from the broker while the multiplexer
    // did not yet remove the socket, this can happen if an I/O event causes
    // the broker to call close_all() while the pollset contained
    // further activities for the broker
    return false;
  // keep a strong reference to our parent until we leave scope
  // to avoid UB when becoming detached during invocation
  auto guard = parent_;
  auto& buf = rd_buf();
  CAF_ASSERT(buf.size() >= num_bytes);
  // make sure size is correct, swap into message, and then call client
  buf.resize(num_bytes);
  auto& msg_buf = msg().buf;
  msg_buf.swap(buf);
  auto result = invoke_mailbox_element(ctx);
  // swap buffer back to stream and implicitly flush wr_buf()
  msg_buf.swap(buf);
  flush();
  return result;
}

void scribe::data_transferred(execution_unit* ctx, size_t written,
                              size_t remaining) {
  CAF_LOG_TRACE(CAF_ARG(written) << CAF_ARG(remaining));
  if (detached())
    return;
  using transferred_t = data_transferred_msg;
  using tmp_t = mailbox_element_vals<data_transferred_msg>;
  tmp_t tmp{strong_actor_ptr{}, make_message_id(),
            mailbox_element::forwarding_stack{},
            transferred_t{hdl(), written, remaining}};
  invoke_mailbox_element_impl(ctx, tmp);
  //data_transferred_msg tmp{hdl(), written, remaining};
  //auto ptr = make_mailbox_element(nullptr, invalid_message_id, {}, tmp);
  //parent()->context(ctx);
  //parent()->consume(std::move(ptr));
}

void scribe::io_failure(execution_unit* ctx, network::operation op) {
  CAF_LOG_TRACE(CAF_ARG(hdl()) << CAF_ARG(op));
  // keep compiler happy when compiling w/o logging
  static_cast<void>(op);
  detach(ctx, true);
}

} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <chrono>

#include "caf/io/basp/instance.hpp"
#include "caf/io/connection_helper.hpp"

namespace caf {
namespace io {

namespace {

auto autoconnect_timeout = std::chrono::minutes(10);

} // namespace <anonymous>

const char* connection_helper_state::name = "connection_helper";

behavior datagram_connection_broker(broker* self, uint16_t port,
                                    network::address_listing addresses,
                                    actor system_broker) {
  auto& mx = self->system().middleman().backend();
  auto& this_node = self->system().node();
  auto& app_id = self->system().config().middleman_app_identifier;
  for (auto& kvp : addresses) {
    for (auto& addr : kvp.second) {
      auto eptr = mx.new_remote_udp_endpoint(addr, port);
      if (eptr) {
        auto hdl = (*eptr)->hdl();
        self->add_datagram_servant(std::move(*eptr));
        basp::instance::write_client_handshake(self->context(),
                                               self->wr_buf(hdl),
                                               none, this_node,
                                               app_id);
      }
    }
  }
  return {
    [=](new_datagram_msg& msg) {
      auto hdl = msg.handle;
      self->send(system_broker, std::move(msg), self->take(hdl), port);
      self->quit();
    },
    after(autoconnect_timeout) >> [=]() {
      CAF_LOG_TRACE(CAF_ARG(""));
      // nothing heard in about 10 minutes... just a call it a day, then
      CAF_LOG_INFO("aborted direct connection attempt after 10min");
      self->quit(exit_reason::user_shutdown);
    }
  };
}

behavior connection_helper(stateful_actor<connection_helper_state>* self,
                           actor b) {
  CAF_LOG_TRACE(CAF_ARG(b));
  self->monitor(b);
  self->set_down_handler([=](down_msg& dm) {
    CAF_LOG_TRACE(CAF_ARG(dm));
    self->quit(std::move(dm.reason));
  });
  return {
    // this config is send from the remote `ConfigServ`
    [=](const std::string& item, message& msg) {
      CAF_LOG_TRACE(CAF_ARG(item) << CAF_ARG(msg));
      CAF_LOG_DEBUG("received requested config:" << CAF_ARG(msg));
      // whatever happens, we are done afterwards
      self->quit();
      msg.apply({
        [&](uint16_t port, network::address_listing& addresses) {
          if (item == "basp.default-connectivity-tcp") {
            auto& mx = self->system().middleman().backend();
            for (auto& kvp : addresses) {
              for (auto& addr : kvp.second) {
                auto hdl = mx.new_tcp_scribe(addr, port);
                if (hdl) {
                  // gotcha! send scribe to our BASP broker
                  // to initiate handshake etc.
                  CAF_LOG_INFO("connected directly:" << CAF_ARG(addr));
                  self->send(b, connect_atom::value, *hdl, port);
                  return;
                }
              }
            }
            CAF_LOG_INFO("could not connect to node directly");
          } else if (item == "basp.default-connectivity-udp") {
            // create new broker to try addresses for communication via UDP
            if (self->system().config().middleman_detach_utility_actors) {
              self->system().middleman().spawn_broker<detached + hidden>(
                datagram_connection_broker, port, std::move(addresses), b
              );
            } else {
              self->system().middleman().spawn_broker<hidden>(
                datagram_connection_broker, port, std::move(addresses), b
              );
            }
          } else {
            CAF_LOG_INFO("aborted direct connection attempt, unknown item: "
                         << CAF_ARG(item));
          }
        }
      });
    },
    after(autoconnect_timeout) >> [=] {
      CAF_LOG_TRACE(CAF_ARG(""));
      // nothing heard in about 10 minutes... just a call it a day, then
      CAF_LOG_INFO("aborted direct connection attempt after 10min");
      self->quit(exit_reason::user_shutdown);
    }
  };
}

} // namespace io
} // namespace caf

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/middleman_actor_impl.hpp"

#include <tuple>
#include <stdexcept>
#include <utility>

#include "caf/sec.hpp"
#include "caf/send.hpp"
#include "caf/actor.hpp"
#include "caf/logger.hpp"
#include "caf/node_id.hpp"
#include "caf/actor_proxy.hpp"
#include "caf/actor_system_config.hpp"
#include "caf/typed_event_based_actor.hpp"

#include "caf/io/basp_broker.hpp"
#include "caf/io/system_messages.hpp"

#include "caf/io/network/interfaces.hpp"
#include "caf/io/network/default_multiplexer.hpp"

namespace caf {
namespace io {

middleman_actor_impl::middleman_actor_impl(actor_config& cfg,
                                           actor default_broker)
    : middleman_actor::base(cfg),
      broker_(std::move(default_broker)) {
  set_down_handler([=](down_msg& dm) {
    auto i = cached_tcp_.begin();
    auto e = cached_tcp_.end();
    while (i != e) {
      if (get<1>(i->second) == dm.source)
        i = cached_tcp_.erase(i);
      else
        ++i;
    }
    i = cached_udp_.begin();
    e = cached_udp_.end();
    while (i != e) {
      if (get<1>(i->second) == dm.source)
        i = cached_udp_.erase(i);
      else
        ++i;
    }
  });
  set_exit_handler([=](exit_msg&) {
    // ignored, the MM links group nameservers
    // to this actor for proper shutdown ordering
  });
}

void middleman_actor_impl::on_exit() {
  CAF_LOG_TRACE("");
  broker_ = nullptr;
}

const char* middleman_actor_impl::name() const {
  return "middleman_actor";
}

auto middleman_actor_impl::make_behavior() -> behavior_type {
  CAF_LOG_TRACE("");
  return {
    [=](publish_atom, uint16_t port, strong_actor_ptr& whom, mpi_set& sigs,
        std::string& addr, bool reuse) -> put_res {
      CAF_LOG_TRACE("");
      if (!system().config().middleman_enable_tcp)
        return make_error(sec::feature_disabled);
      return put(port, whom, sigs, addr.c_str(), reuse);
    },
    [=](open_atom, uint16_t port, std::string& addr, bool reuse) -> put_res {
      CAF_LOG_TRACE("");
      if (!system().config().middleman_enable_tcp)
        return make_error(sec::feature_disabled);
      strong_actor_ptr whom;
      mpi_set sigs;
      return put(port, whom, sigs, addr.c_str(), reuse);
    },
    [=](connect_atom, std::string& hostname, uint16_t port) -> get_res {
      CAF_LOG_TRACE(CAF_ARG(hostname) << CAF_ARG(port));
      if (!system().config().middleman_enable_tcp)
        return make_error(sec::feature_disabled);
      auto rp = make_response_promise();
      endpoint key{std::move(hostname), port};
      // respond immediately if endpoint is cached
      auto x = cached_tcp(key);
      if (x) {
        CAF_LOG_DEBUG("found cached entry" << CAF_ARG(*x));
        rp.deliver(get<0>(*x), get<1>(*x), get<2>(*x));
        return get_delegated{};
      }
      // attach this promise to a pending request if possible
      auto rps = pending(key);
      if (rps) {
        CAF_LOG_DEBUG("attach to pending request");
        rps->emplace_back(std::move(rp));
        return get_delegated{};
      }
      // connect to endpoint and initiate handhsake etc.
      auto r = connect(key.first, port);
      if (!r) {
        rp.deliver(std::move(r.error()));
        return get_delegated{};
      }
      auto& ptr = *r;
      std::vector<response_promise> tmp{std::move(rp)};
      pending_.emplace(key, std::move(tmp));
      request(broker_, infinite, connect_atom::value, std::move(ptr), port)
        .then(
          [=](node_id& nid, strong_actor_ptr& addr, mpi_set& sigs) {
            auto i = pending_.find(key);
            if (i == pending_.end())
              return;
            if (nid && addr) {
              monitor(addr);
              cached_tcp_.emplace(key, std::make_tuple(nid, addr, sigs));
            }
            auto res = make_message(std::move(nid), std::move(addr),
                                    std::move(sigs));
            for (auto& promise : i->second)
              promise.deliver(res);
            pending_.erase(i);
          },
          [=](error& err) {
            auto i = pending_.find(key);
            if (i == pending_.end())
              return;
            for (auto& promise : i->second)
              promise.deliver(err);
            pending_.erase(i);
          });
      return get_delegated{};
    },
    [=](publish_udp_atom, uint16_t port, strong_actor_ptr& whom,
        mpi_set& sigs, std::string& addr, bool reuse) -> put_res {
      CAF_LOG_TRACE("");
      if (!system().config().middleman_enable_udp)
        return make_error(sec::feature_disabled);
      return put_udp(port, whom, sigs, addr.c_str(), reuse);
    },
    [=](contact_atom, std::string& hostname, uint16_t port) -> get_res {
      CAF_LOG_TRACE(CAF_ARG(hostname) << CAF_ARG(port));
      if (!system().config().middleman_enable_udp)
        return make_error(sec::feature_disabled);
      auto rp = make_response_promise();
      endpoint key{std::move(hostname), port};
      // respond immediately if endpoint is cached
      auto x = cached_udp(key);
      if (x) {
        CAF_LOG_DEBUG("found cached entry" << CAF_ARG(*x));
        rp.deliver(get<0>(*x), get<1>(*x), get<2>(*x));
        return get_delegated{};
      }
      // attach this promise to a pending request if possible
      auto rps = pending(key);
      if (rps) {
        CAF_LOG_DEBUG("attach to pending request");
        rps->emplace_back(std::move(rp));
        return get_delegated{};
      }
      // connect to endpoint and initiate handshake etc.
      auto r = contact(key.first, port);
      if (!r) {
        rp.deliver(std::move(r.error()));
        return get_delegated{};
      }
      auto& ptr = *r;
      std::vector<response_promise> tmp{std::move(rp)};
      pending_.emplace(key, std::move(tmp));
      request(broker_, infinite, contact_atom::value, std::move(ptr), port)
        .then(
          [=](node_id& nid, strong_actor_ptr& addr, mpi_set& sigs) {
            auto i = pending_.find(key);
            if (i == pending_.end())
              return;
            if (nid && addr) {
              monitor(addr);
              cached_udp_.emplace(key, std::make_tuple(nid, addr, sigs));
            }
            auto res = make_message(std::move(nid), std::move(addr),
                                    std::move(sigs));
            for (auto& promise : i->second)
              promise.deliver(res);
            pending_.erase(i);
          },
          [=](error& err) {
            auto i = pending_.find(key);
            if (i == pending_.end())
              return;
            for (auto& promise : i->second)
              promise.deliver(err);
            pending_.erase(i);
          });
      return get_delegated{};
    },
    [=](unpublish_atom atm, actor_addr addr, uint16_t p) -> del_res {
      CAF_LOG_TRACE("");
      delegate(broker_, atm, std::move(addr), p);
      return {};
    },
    [=](unpublish_udp_atom atm, actor_addr addr, uint16_t p) -> del_res {
      CAF_LOG_TRACE("");
      delegate(broker_, atm, std::move(addr), p);
      return {};
    },
    [=](close_atom atm, uint16_t p) -> del_res {
      CAF_LOG_TRACE("");
      delegate(broker_, atm, p);
      return {};
    },
    [=](spawn_atom atm, node_id& nid, std::string& str, message& msg,
        std::set<std::string>& ifs) -> delegated<strong_actor_ptr> {
      CAF_LOG_TRACE("");
      delegate(
        broker_, forward_atom::value, nid, atom("SpawnServ"),
        make_message(atm, std::move(str), std::move(msg), std::move(ifs)));
      return {};
    },
    [=](get_atom atm,
        node_id nid) -> delegated<node_id, std::string, uint16_t> {
      CAF_LOG_TRACE("");
      delegate(broker_, atm, std::move(nid));
      return {};
    }
  };
}

middleman_actor_impl::put_res
middleman_actor_impl::put(uint16_t port, strong_actor_ptr& whom, mpi_set& sigs,
                          const char* in, bool reuse_addr) {
  CAF_LOG_TRACE(CAF_ARG(port) << CAF_ARG(whom) << CAF_ARG(sigs)
                << CAF_ARG(in) << CAF_ARG(reuse_addr));
  uint16_t actual_port;
  // treat empty strings like nullptr
  if (in != nullptr && in[0] == '\0')
    in = nullptr;
  auto res = open(port, in, reuse_addr);
  if (!res)
    return std::move(res.error());
  auto& ptr = *res;
  actual_port = ptr->port();
  anon_send(broker_, publish_atom::value, std::move(ptr), actual_port,
            std::move(whom), std::move(sigs));
  return actual_port;
}

middleman_actor_impl::put_res
middleman_actor_impl::put_udp(uint16_t port, strong_actor_ptr& whom,
                              mpi_set& sigs, const char* in, bool reuse_addr) {
  CAF_LOG_TRACE(CAF_ARG(port) << CAF_ARG(whom) << CAF_ARG(sigs)
                << CAF_ARG(in) << CAF_ARG(reuse_addr));
  uint16_t actual_port;
  // treat empty strings like nullptr
  if (in != nullptr && in[0] == '\0')
    in = nullptr;
  auto res = open_udp(port, in, reuse_addr);
  if (!res)
    return std::move(res.error());
  auto& ptr = *res;
  actual_port = ptr->local_port();
  anon_send(broker_, publish_udp_atom::value, std::move(ptr), actual_port,
            std::move(whom), std::move(sigs));
  return actual_port;
}

optional<middleman_actor_impl::endpoint_data&>
middleman_actor_impl::cached_tcp(const endpoint& ep) {
  auto i = cached_tcp_.find(ep);
  if (i != cached_tcp_.end())
    return i->second;
  return none;
}

optional<middleman_actor_impl::endpoint_data&>
middleman_actor_impl::cached_udp(const endpoint& ep) {
  auto i = cached_udp_.find(ep);
  if (i != cached_udp_.end())
    return i->second;
  return none;
}

optional<std::vector<response_promise>&>
middleman_actor_impl::pending(const endpoint& ep) {
  auto i = pending_.find(ep);
  if (i != pending_.end())
    return i->second;
  return none;
}

expected<scribe_ptr> middleman_actor_impl::connect(const std::string& host,
                                                   uint16_t port) {
  return system().middleman().backend().new_tcp_scribe(host, port);
}

expected<datagram_servant_ptr>
middleman_actor_impl::contact(const std::string& host, uint16_t port) {
  return system().middleman().backend().new_remote_udp_endpoint(host, port);
}

expected<doorman_ptr>
middleman_actor_impl::open(uint16_t port, const char* addr, bool reuse) {
  return system().middleman().backend().new_tcp_doorman(port, addr, reuse);
}

expected<datagram_servant_ptr>
middleman_actor_impl::open_udp(uint16_t port, const char* addr, bool reuse) {
  return system().middleman().backend().new_local_udp_endpoint(port, addr,
                                                               reuse);
}

} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/network/ip_endpoint.hpp"

#include "caf/sec.hpp"
#include "caf/logger.hpp"

#ifdef CAF_WINDOWS
# include <winsock2.h>
# include <windows.h>
# include <ws2tcpip.h>
# include <ws2ipdef.h>
#else
# include <unistd.h>
# include <cerrno>
# include <arpa/inet.h>
# include <sys/socket.h>
# include <netinet/in.h>
# include <netinet/ip.h>
#endif

#ifdef CAF_WINDOWS
using sa_family_t = short;
#endif

namespace {

template <class SizeType = size_t>
struct hash_conf {
  template <class T = SizeType>
  static constexpr caf::detail::enable_if_t<(sizeof(T) == 4), size_t> basis() {
    return 2166136261u;
  }
  template <class T = SizeType>
  static constexpr caf::detail::enable_if_t<(sizeof(T) == 4), size_t> prime() {
    return 16777619u;
  }
  template <class T = SizeType>
  static constexpr caf::detail::enable_if_t<(sizeof(T) == 8), size_t> basis() {
    return 14695981039346656037u;
  }
  template <class T = SizeType>
  static constexpr caf::detail::enable_if_t<(sizeof(T) == 8), size_t> prime() {
    return 1099511628211u;
  }
};

constexpr uint8_t static_bytes[] = {
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xFF, 0xFF
};

constexpr size_t prehash(int i = 11) {
  return (i > 0)
    ? (prehash(i - 1) * hash_conf<>::prime()) ^ static_bytes[i]
    : (hash_conf<>::basis() * hash_conf<>::prime()) ^ static_bytes[i];
}

} // namespace <anonymous>

namespace caf {
namespace io {
namespace network {

struct ip_endpoint::impl {
  sockaddr_storage addr;
  size_t len;
};

ip_endpoint::ip_endpoint() : ptr_(new ip_endpoint::impl) {
  // nop
}

ip_endpoint::ip_endpoint(const ip_endpoint& other) {
  ptr_.reset(new ip_endpoint::impl);
  memcpy(address(), other.caddress(), sizeof(sockaddr_storage));
  *length() = *other.clength();
}

ip_endpoint& ip_endpoint::operator=(const ip_endpoint& other) {
  ptr_.reset(new ip_endpoint::impl);
  memcpy(address(), other.caddress(), sizeof(sockaddr_storage));
  *length() = *other.clength();
  return *this;
}

sockaddr* ip_endpoint::address() {
  return reinterpret_cast<struct sockaddr*>(&ptr_->addr);
}

const sockaddr* ip_endpoint::caddress() const {
  return reinterpret_cast<const struct sockaddr*>(&ptr_->addr);
}

size_t* ip_endpoint::length() {
  return &ptr_->len;
}

const size_t* ip_endpoint::clength() const {
  return &ptr_->len;
}

void ip_endpoint::clear() {
  memset(&ptr_->addr, 0, sizeof(sockaddr_storage));
  ptr_->len = 0;
}

void ip_endpoint::impl_deleter::operator()(ip_endpoint::impl *ptr) const {
  delete ptr;
}

ep_hash::ep_hash() {
  // nop
}

size_t ep_hash::operator()(const sockaddr& sa) const noexcept {
  switch (sa.sa_family) {
    case AF_INET:
      return hash(reinterpret_cast<const struct sockaddr_in*>(&sa));
    case AF_INET6:
      return hash(reinterpret_cast<const struct sockaddr_in6*>(&sa));
    default:
      CAF_LOG_ERROR("Only IPv4 and IPv6 are supported.");
      return 0;
  }
}

size_t ep_hash::hash(const sockaddr_in* sa) const noexcept {
  auto& addr = sa->sin_addr;
  size_t res = prehash();
  // the first loop was replaces with `constexpr size_t prehash()`
  for (int i = 0; i < 4; ++i) {
    res = res * hash_conf<>::prime();
    res = res ^ ((addr.s_addr >> i) & 0xFF);
  }
  res = res * hash_conf<>::prime();
  res = res ^ (sa->sin_port >> 1);
  res = res * hash_conf<>::prime();
  res = res ^ (sa->sin_port & 0xFF);
  return res;
}

size_t ep_hash::hash(const sockaddr_in6* sa) const noexcept {
  auto& addr = sa->sin6_addr;
  size_t res = hash_conf<>::basis();
  for (int i = 0; i < 16; ++i) {
    res = res * hash_conf<>::prime();
    res = res ^ addr.s6_addr[i];
  }
  res = res * hash_conf<>::prime();
  res = res ^ (sa->sin6_port >> 1);
  res = res * hash_conf<>::prime();
  res = res ^ (sa->sin6_port & 0xFF);
  return res;
}

bool operator==(const ip_endpoint& lhs, const ip_endpoint& rhs) {
  auto same = false;
  if (*lhs.clength() == *rhs.clength() &&
      lhs.caddress()->sa_family == rhs.caddress()->sa_family) {
    switch (lhs.caddress()->sa_family) {
      case AF_INET: {
        auto* la = reinterpret_cast<const sockaddr_in*>(lhs.caddress());
        auto* ra = reinterpret_cast<const sockaddr_in*>(rhs.caddress());
        same = (0 == memcmp(&la->sin_addr, &ra->sin_addr, sizeof(in_addr)))
               && (la->sin_port == ra->sin_port);
        break;
      }
      case AF_INET6: {
        auto* la = reinterpret_cast<const sockaddr_in6*>(lhs.caddress());
        auto* ra = reinterpret_cast<const sockaddr_in6*>(rhs.caddress());
        same = (0 == memcmp(&la->sin6_addr, &ra->sin6_addr, sizeof(in6_addr)))
               && (la->sin6_port == ra->sin6_port);
        break;
      }
      default:
        break;
    }
  }
  return same;
}

std::string to_string(const ip_endpoint& ep) {
  return host(ep) + ":" + std::to_string(port(ep));
}

std::string host(const ip_endpoint& ep) {
  char addr[INET6_ADDRSTRLEN];
  if (*ep.clength() == 0)
    return "";
  switch(ep.caddress()->sa_family) {
    case AF_INET:
      inet_ntop(AF_INET,
                &const_cast<sockaddr_in*>(reinterpret_cast<const sockaddr_in*>(ep.caddress()))->sin_addr,
                addr, static_cast<socklen_t>(*ep.clength()));
      break;
    case AF_INET6:
      inet_ntop(AF_INET6,
                &const_cast<sockaddr_in6*>(reinterpret_cast<const sockaddr_in6*>(ep.caddress()))->sin6_addr,
                addr, static_cast<socklen_t>(*ep.clength()));
      break;
    default:
      addr[0] = '\0';
      break;
  }
  return std::string(addr);
}

uint16_t port(const ip_endpoint& ep) {
  uint16_t port = 0;
  if (*ep.clength() == 0)
    return 0;
  switch(ep.caddress()->sa_family) {
    case AF_INET:
      port = ntohs(reinterpret_cast<const sockaddr_in*>(ep.caddress())->sin_port);
      break;
    case AF_INET6:
      port = ntohs(reinterpret_cast<const sockaddr_in6*>(ep.caddress())->sin6_port);
      break;
    default:
      // nop
      break;
  }
  return port;
}

uint32_t family(const ip_endpoint& ep) {
  if (*ep.clength() == 0)
    return 0;
  return ep.caddress()->sa_family;
}

error load_endpoint(ip_endpoint& ep, uint32_t& f, std::string& h,
                    uint16_t& p, size_t& l) {
  ep.clear();
  if (l > 0) {
    *ep.length() = l;
    switch(f) {
      case AF_INET: {
        auto* addr = reinterpret_cast<sockaddr_in*>(ep.address());
        inet_pton(AF_INET, h.c_str(), &addr->sin_addr);
        addr->sin_port = htons(p);
        addr->sin_family = static_cast<sa_family_t>(f);
        break;
      }
      case AF_INET6: {
        auto* addr = reinterpret_cast<sockaddr_in6*>(ep.address());
        inet_pton(AF_INET6, h.c_str(), &addr->sin6_addr);
        addr->sin6_port = htons(p);
        addr->sin6_family = static_cast<sa_family_t>(f);
        break;
      }
      default:
        return sec::invalid_argument;
    }
  }
  return none;
}

error save_endpoint(ip_endpoint& ep, uint32_t& f, std::string& h,
                    uint16_t& p, size_t& l) {
  if (*ep.length() > 0) {
    f = family(ep);
    h = host(ep);
    p = port(ep);
    l = *ep.length();
  } else {
    f = 0;
    h = "";
    p = 0;
    l = 0;
  }
  return none;
}

} // namespace network
} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/middleman_actor.hpp"

#include <tuple>
#include <stdexcept>
#include <utility>

#include "caf/actor_system.hpp"
#include "caf/spawn_options.hpp"
#include "caf/actor_system_config.hpp"

#include "caf/io/middleman_actor_impl.hpp"

namespace caf {
namespace io {

middleman_actor make_middleman_actor(actor_system& sys, actor db) {
  return sys.config().middleman_detach_utility_actors
             ? sys.spawn<middleman_actor_impl, detached + hidden>(std::move(db))
             : sys.spawn<middleman_actor_impl, hidden>(std::move(db));
}

} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/network/test_multiplexer.hpp"

#include "caf/scheduler/abstract_coordinator.hpp"

#include "caf/io/scribe.hpp"
#include "caf/io/doorman.hpp"
#include "caf/io/datagram_servant.hpp"

namespace caf {
namespace io {
namespace network {

namespace {

constexpr size_t receive_buffer_size = std::numeric_limits<uint16_t>::max();

} // namespace anonymous

test_multiplexer::scribe_data::scribe_data(shared_buffer_type input,
                                           shared_buffer_type output)
    : vn_buf_ptr(std::move(input)),
      wr_buf_ptr(std::move(output)),
      vn_buf(*vn_buf_ptr),
      wr_buf(*wr_buf_ptr),
      stopped_reading(false),
      passive_mode(false),
      ack_writes(false) {
  // nop
}

test_multiplexer::doorman_data::doorman_data()
    : port(0),
      stopped_reading(false),
      passive_mode(false) {
  // nop
}

test_multiplexer::datagram_data::
  datagram_data(shared_job_queue_type input,
                        shared_job_queue_type output)
    : vn_buf_ptr(std::move(input)),
      wr_buf_ptr(std::move(output)),
      vn_buf(*vn_buf_ptr),
      wr_buf(*wr_buf_ptr),
      rd_buf(datagram_handle::from_int(0), receive_buffer_size),
      stopped_reading(false),
      passive_mode(false),
      ack_writes(false),
      port(0),
      local_port(0),
      datagram_size(receive_buffer_size) {
  // nop
}

test_multiplexer::test_multiplexer(actor_system* sys)
    : multiplexer(sys),
      tid_(std::this_thread::get_id()),
      inline_runnables_(0),
      servant_ids_(0) {
  CAF_ASSERT(sys != nullptr);
}

test_multiplexer::~test_multiplexer() {
  // get rid of extra ref count
  for (auto& ptr : resumables_)
    intrusive_ptr_release(ptr.get());
}

scribe_ptr test_multiplexer::new_scribe(native_socket) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_CRITICAL("test_multiplexer::add_tcp_scribe called with native socket");
}

scribe_ptr test_multiplexer::new_scribe(connection_handle hdl) {
  CAF_LOG_TRACE(CAF_ARG(hdl));
  class impl : public scribe {
  public:
    impl(connection_handle ch, test_multiplexer* mpx) : scribe(ch), mpx_(mpx) {
      // nop
    }
    void configure_read(receive_policy::config config) override {
      mpx_->read_config(hdl()) = config;
    }
    void ack_writes(bool enable) override {
      mpx_->ack_writes(hdl()) = enable;
    }
    std::vector<char>& wr_buf() override {
      return mpx_->output_buffer(hdl());
    }
    std::vector<char>& rd_buf() override {
      return mpx_->input_buffer(hdl());
    }
    void stop_reading() override {
      mpx_->stopped_reading(hdl()) = true;
      detach(mpx_, false);
    }
    void flush() override {
      // nop
    }
    std::string addr() const override {
      return "test";
    }
    uint16_t port() const override {
      return static_cast<uint16_t>(hdl().id());
    }
    void add_to_loop() override {
      mpx_->passive_mode(hdl()) = false;
    }
    void remove_from_loop() override {
      mpx_->passive_mode(hdl()) = true;
    }
  private:
    test_multiplexer* mpx_;
  };
  CAF_LOG_DEBUG(CAF_ARG(hdl));
  auto sptr = make_counted<impl>(hdl, this);
  { // lifetime scope of guard
    guard_type guard{mx_};
    impl_ptr(hdl) = sptr;
  }
  CAF_LOG_INFO("opened connection" << sptr->hdl());
  return sptr;
}

expected<scribe_ptr> test_multiplexer::new_tcp_scribe(const std::string& host,
                                                      uint16_t port) {
  CAF_LOG_TRACE(CAF_ARG(host) << CAF_ARG(port));
  connection_handle hdl;
  { // lifetime scope of guard
    guard_type guard{mx_};
    auto i = scribes_.find(std::make_pair(host, port));
    if (i != scribes_.end()) {
      hdl = i->second;
      scribes_.erase(i);
    } else {
      return sec::cannot_connect_to_node;
    }
  }
  return new_scribe(hdl);
}

doorman_ptr test_multiplexer::new_doorman(native_socket) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_CRITICAL("test_multiplexer::add_tcp_doorman called with native socket");
}

doorman_ptr test_multiplexer::new_doorman(accept_handle hdl, uint16_t port) {
  CAF_LOG_TRACE(CAF_ARG(hdl));
  class impl : public doorman {
  public:
    impl(accept_handle ah, test_multiplexer* mpx) : doorman(ah), mpx_(mpx) {
      // nop
    }
    bool new_connection() override {
      connection_handle ch;
      { // Try to get a connection handle of a pending connect.
        guard_type guard{mpx_->mx_};
        auto& pc = mpx_->pending_connects();
        auto i = pc.find(hdl());
        if (i == pc.end())
          return false;
        ch = i->second;
        pc.erase(i);
      }
      CAF_LOG_INFO("accepted connection" << ch << "on acceptor" << hdl());
      parent()->add_scribe(mpx_->new_scribe(ch));
      return doorman::new_connection(mpx_, ch);
    }
    void stop_reading() override {
      mpx_->stopped_reading(hdl()) = true;
      detach(mpx_, false);
    }
    void launch() override {
      // nop
    }
    std::string addr() const override {
      return "test";
    }
    uint16_t port() const override {
      guard_type guard{mpx_->mx_};
      return mpx_->port(hdl());
    }
    void add_to_loop() override {
      mpx_->passive_mode(hdl()) = false;
    }
    void remove_from_loop() override {
      mpx_->passive_mode(hdl()) = true;
    }
  private:
    test_multiplexer* mpx_;
  };
  auto dptr = make_counted<impl>(hdl, this);
  { // lifetime scope of guard
    guard_type guard{mx_};
    auto& ref = doorman_data_[hdl];
    ref.ptr = dptr;
    ref.port = port;
  }
  CAF_LOG_INFO("opened port" << port << "on acceptor" << hdl);
  return dptr;
}

expected<doorman_ptr> test_multiplexer::new_tcp_doorman(uint16_t desired_port,
                                                        const char*, bool) {
  CAF_LOG_TRACE(CAF_ARG(desired_port));
  accept_handle hdl;
  uint16_t port = 0;
  { // Lifetime scope of guard.
    guard_type guard{mx_};
    if (desired_port == 0) {
      // Start with largest possible port and reverse iterate until we find a
      // port that's not assigned to a known doorman.
      port = std::numeric_limits<uint16_t>::max();
      while (is_known_port(port))
        --port;
      // Do the same for finding an acceptor handle.
      auto y = std::numeric_limits<int64_t>::max();
      while (is_known_handle(accept_handle::from_int(y)))
        --y;
      hdl = accept_handle::from_int(y);
    } else {
      auto i = doormen_.find(desired_port);
      if (i != doormen_.end()) {
        hdl = i->second;
        doormen_.erase(i);
        port = desired_port;
      } else {
        return sec::cannot_open_port;
      }
    }
  }
  return new_doorman(hdl, port);
}

datagram_servant_ptr test_multiplexer::new_datagram_servant(native_socket) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_CRITICAL("test_multiplexer::new_datagram_servant called with native socket");
}

datagram_servant_ptr
test_multiplexer::new_datagram_servant_for_endpoint(native_socket,
                                                    const ip_endpoint&) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_CRITICAL("test_multiplexer::new_datagram_servant_for_endpoint called with "
               "native socket");
}

expected<datagram_servant_ptr>
test_multiplexer::new_remote_udp_endpoint(const std::string& host,
                                          uint16_t port) {
  CAF_LOG_TRACE(CAF_ARG(host) << CAF_ARG(port));
  datagram_handle hdl;
  { // lifetime scope of guard
    guard_type guard{mx_};
    auto i = remote_endpoints_.find(std::make_pair(host, port));
    if (i != remote_endpoints_.end()) {
      hdl = i->second;
      remote_endpoints_.erase(i);
    } else {
      return sec::cannot_connect_to_node;
    }
  }
  auto ptr = new_datagram_servant(hdl, port);
  // Set state in the struct to enable direct communication?
  { // lifetime scope of guard
    guard_type guard{mx_};
    auto data = data_for_hdl(hdl);
    data->servants.emplace(hdl);
    local_port(hdl) = data->local_port;
  }
  return ptr;
}

expected<datagram_servant_ptr>
test_multiplexer::new_local_udp_endpoint(uint16_t desired_port,
                                         const char*, bool) {
  CAF_LOG_TRACE(CAF_ARG(desired_port));
  datagram_handle hdl;
  uint16_t port = 0;
  { // Lifetime scope of guard.
    guard_type guard{mx_};
    if (desired_port == 0) {
      // Start with largest possible port and reverse iterate until we find a
      // port that's not assigned to a known doorman.
      port = std::numeric_limits<uint16_t>::max();
      while (is_known_port(port))
        --port;
      // Do the same for finding a local dgram handle
      auto y = std::numeric_limits<int64_t>::max();
      while (is_known_handle(datagram_handle::from_int(y)))
        --y;
      hdl = datagram_handle::from_int(y);
    } else {
      auto i = local_endpoints_.find(desired_port);
      if (i != local_endpoints_.end()) {
        hdl = i->second;
        local_endpoints_.erase(i);
        port = desired_port;
      } else {
        return sec::cannot_open_port;
      }
    }
  }
  return new_datagram_servant(hdl, port);
}

datagram_servant_ptr test_multiplexer::new_datagram_servant(datagram_handle hdl,
                                                            uint16_t port) {
  CAF_LOG_TRACE(CAF_ARG(hdl));
  class impl : public datagram_servant {
  public:
    impl(datagram_handle dh, test_multiplexer* mpx)
        : datagram_servant(dh), mpx_(mpx) {
      // nop
    }
    bool new_endpoint(network::receive_buffer& buf) override {
      datagram_handle dhdl;
      { // Try to get a connection handle of a pending connect.
        guard_type guard{mpx_->mx_};
        auto& pe = mpx_->pending_endpoints();
        auto i = pe.find(hdl().id());
        if (i == pe.end())
          return false;
        dhdl = i->second;
        pe.erase(i);
      }
      auto data = mpx_->data_for_hdl(hdl());
      data->servants.emplace(dhdl);
      mpx_->datagram_data_.emplace(dhdl, data);
      parent()->add_hdl_for_datagram_servant(this, dhdl);
      return consume(mpx_, dhdl, buf);
    }
    void ack_writes(bool enable) override {
      mpx_->ack_writes(hdl()) = enable;
    }
    std::vector<char>& wr_buf(datagram_handle dh) override {
      auto& buf = mpx_->output_buffer(dh);
      buf.first = dh;
      return buf.second;
    }
    void enqueue_datagram(datagram_handle dh,
                          std::vector<char> buf) override {
      auto& q = mpx_->output_queue(dh);
      q.emplace_back(dh, std::move(buf));
    }
    network::receive_buffer& rd_buf() override {
      auto& buf = mpx_->input_buffer(hdl());
      return buf.second;
    }
    void stop_reading() override {
      mpx_->stopped_reading(hdl()) = true;
      detach_handles();
      detach(mpx_, false);
    }
    void launch() override {
      // nop
    }
    void flush() override {
      // nop
    }
    std::string addr() const override {
      return "test";
    }
    uint16_t port(datagram_handle dh) const override {
      return static_cast<uint16_t>(dh.id());
    }
    uint16_t local_port() const override {
      guard_type guard{mpx_->mx_};
      return mpx_->local_port(hdl());
    }
    std::vector<datagram_handle> hdls() const override {
      auto data = mpx_->data_for_hdl(hdl());
      std::vector<datagram_handle> result(data->servants.begin(),
                                          data->servants.end());
      return result;
    }
    void add_to_loop() override {
      mpx_->passive_mode(hdl()) = false;
    }
    void remove_from_loop() override {
      mpx_->passive_mode(hdl()) = true;
    }
    void add_endpoint(const ip_endpoint&, datagram_handle) override {
      CAF_CRITICAL("datagram_servant impl::add_endpoint called with ip_endpoint");
    }
    void remove_endpoint(datagram_handle dh) override {
      auto data = mpx_->data_for_hdl(hdl());
      { // lifetime scope of guard
        guard_type guard{mpx_->mx_};
        auto itr = std::find(data->servants.begin(), data->servants.end(), dh);
        if (itr != data->servants.end())
          data->servants.erase(itr);
      }
    }
    void detach_handles() override {
      auto data = mpx_->data_for_hdl(hdl());
      for (auto& p : data->servants)
        if (p != hdl())
          parent()->erase(p);
      data->servants.clear();
      data->servants.emplace(hdl());
    }
  private:
    test_multiplexer* mpx_;
  };
  auto dptr = make_counted<impl>(hdl, this);
  CAF_LOG_INFO("new datagram servant" << hdl);
  auto data = data_for_hdl(hdl);
  { // lifetime scope of guard
    guard_type guard{mx_};
    data->ptr = dptr;
    data->port = port;
    data->servants.emplace(hdl);
  }
  return dptr;
}

datagram_servant_ptr test_multiplexer::new_datagram_servant(datagram_handle,
                                                            const std::string&,
                                                            uint16_t) {
  CAF_CRITICAL("This has no implementation in the test multiplexer");
}

int64_t test_multiplexer::next_endpoint_id() {
  return servant_ids_++;
}


bool test_multiplexer::is_known_port(uint16_t x) const {
  auto pred1 = [&](const doorman_data_map::value_type& y) {
    return x == y.second.port;
  };
  auto pred2 = [&](const datagram_data_map::value_type& y) {
    return x == y.second->port;
  };
  return (doormen_.count(x) + local_endpoints_.count(x)) > 0
         || std::any_of(doorman_data_.begin(), doorman_data_.end(), pred1)
         || std::any_of(datagram_data_.begin(), datagram_data_.end(), pred2);
}

bool test_multiplexer::is_known_handle(accept_handle x) const {
  auto pred = [&](const pending_doorman_map::value_type& y) {
    return x == y.second;
  };
  return doorman_data_.count(x) > 0
         || std::any_of(doormen_.begin(), doormen_.end(), pred);
}

bool test_multiplexer::is_known_handle(datagram_handle x) const {
  auto pred1 = [&](const pending_local_datagram_endpoints_map::value_type& y) {
    return x == y.second;
  };
  auto pred2 = [&](const pending_remote_datagram_endpoints_map::value_type& y) {
    return x == y.second;
  };
  return datagram_data_.count(x) > 0
    || std::any_of(local_endpoints_.begin(), local_endpoints_.end(), pred1)
    || std::any_of(remote_endpoints_.begin(), remote_endpoints_.end(), pred2);
}

auto test_multiplexer::make_supervisor() -> supervisor_ptr {
  // not needed
  return nullptr;
}

bool test_multiplexer::try_run_once() {
  return try_exec_runnable() || try_read_data() || try_accept_connection();
}

void test_multiplexer::run_once() {
  try_run_once();
}

void test_multiplexer::run() {
  // nop
}

void test_multiplexer::provide_scribe(std::string host, uint16_t desired_port,
                                      connection_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_LOG_TRACE(CAF_ARG(host) << CAF_ARG(desired_port) << CAF_ARG(hdl));
  guard_type guard{mx_};
  scribes_.emplace(std::make_pair(std::move(host), desired_port), hdl);
}

void test_multiplexer::provide_acceptor(uint16_t desired_port,
                                        accept_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  doormen_.emplace(desired_port, hdl);
  doorman_data_[hdl].port = desired_port;
}

void test_multiplexer::provide_datagram_servant(uint16_t desired_port,
                                                datagram_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_LOG_TRACE(CAF_ARG(desired_port) << CAF_ARG(hdl));
  guard_type guard{mx_};
  local_endpoints_.emplace(desired_port, hdl);
  auto data = data_for_hdl(hdl);
  data->local_port = desired_port;
}

void test_multiplexer::provide_datagram_servant(std::string host,
                                                uint16_t desired_port,
                                                datagram_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_LOG_TRACE(CAF_ARG(host) << CAF_ARG(desired_port) << CAF_ARG(hdl));
  guard_type guard{mx_};
  remote_endpoints_.emplace(std::make_pair(std::move(host), desired_port), hdl);
}

/// The external input buffer should be filled by
/// the test program.
test_multiplexer::buffer_type&
test_multiplexer::virtual_network_buffer(connection_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  return scribe_data_[hdl].vn_buf;
}

test_multiplexer::write_job_queue_type&
test_multiplexer::virtual_network_buffer(datagram_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  return data_for_hdl(hdl)->vn_buf;
}

test_multiplexer::buffer_type&
test_multiplexer::output_buffer(connection_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  return scribe_data_[hdl].wr_buf;
}

test_multiplexer::buffer_type&
test_multiplexer::input_buffer(connection_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  return scribe_data_[hdl].rd_buf;
}

test_multiplexer::write_job_type&
test_multiplexer::output_buffer(datagram_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  auto& buf = data_for_hdl(hdl)->wr_buf;
  buf.emplace_back();
  return buf.back();
}

test_multiplexer::write_job_queue_type&
test_multiplexer::output_queue(datagram_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  return data_for_hdl(hdl)->wr_buf;
}

test_multiplexer::read_job_type&
test_multiplexer::input_buffer(datagram_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  return data_for_hdl(hdl)->rd_buf;
}

receive_policy::config& test_multiplexer::read_config(connection_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  return scribe_data_[hdl].recv_conf;
}

bool& test_multiplexer::ack_writes(connection_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  return scribe_data_[hdl].ack_writes;
}

bool& test_multiplexer::ack_writes(datagram_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  return data_for_hdl(hdl)->ack_writes;
}

bool& test_multiplexer::stopped_reading(connection_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  return scribe_data_[hdl].stopped_reading;
}

bool& test_multiplexer::stopped_reading(datagram_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  return data_for_hdl(hdl)->stopped_reading;
}

bool& test_multiplexer::passive_mode(connection_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  return scribe_data_[hdl].passive_mode;
}

bool& test_multiplexer::passive_mode(datagram_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  return data_for_hdl(hdl)->passive_mode;
}

scribe_ptr& test_multiplexer::impl_ptr(connection_handle hdl) {
  return scribe_data_[hdl].ptr;
}

uint16_t& test_multiplexer::port(accept_handle hdl) {
  return doorman_data_[hdl].port;
}

uint16_t& test_multiplexer::port(datagram_handle hdl) {
  return data_for_hdl(hdl)->port;
}

uint16_t& test_multiplexer::local_port(datagram_handle hdl) {
  return data_for_hdl(hdl)->local_port;
}

datagram_servant_ptr& test_multiplexer::impl_ptr(datagram_handle hdl) {
  return data_for_hdl(hdl)->ptr;
}

std::set<datagram_handle>& test_multiplexer::servants(datagram_handle hdl) {
  return data_for_hdl(hdl)->servants;
}

bool& test_multiplexer::stopped_reading(accept_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  return doorman_data_[hdl].stopped_reading;
}

bool& test_multiplexer::passive_mode(accept_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  return doorman_data_[hdl].passive_mode;
}

doorman_ptr& test_multiplexer::impl_ptr(accept_handle hdl) {
  return doorman_data_[hdl].ptr;
}

void test_multiplexer::add_pending_connect(accept_handle src,
                                           connection_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  pending_connects_.emplace(src, hdl);
}

std::shared_ptr<test_multiplexer::datagram_data>
test_multiplexer::data_for_hdl(datagram_handle hdl) {
  auto itr = datagram_data_.find(hdl);
  if (itr != datagram_data_.end())
    return itr->second;
  // if it does not exist, create a new entry
  datagram_data_.emplace(hdl, std::make_shared<datagram_data>());
  return datagram_data_[hdl];
}

void test_multiplexer::prepare_connection(accept_handle src,
                                          connection_handle hdl,
                                          test_multiplexer& peer,
                                          std::string host, uint16_t port,
                                          connection_handle peer_hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_ASSERT(this != &peer);
  CAF_LOG_TRACE(CAF_ARG(src) << CAF_ARG(hdl) << CAF_ARG(host) << CAF_ARG(port)
                << CAF_ARG(peer_hdl));
  auto input = std::make_shared<buffer_type>();
  auto output = std::make_shared<buffer_type>();
  CAF_LOG_DEBUG("insert scribe data for" << CAF_ARG(hdl));
  auto res1 = scribe_data_.emplace(hdl, scribe_data{input, output});
  if (!res1.second)
    CAF_RAISE_ERROR("prepare_connection: handle already in use");
  CAF_LOG_DEBUG("insert scribe data on peer for" << CAF_ARG(peer_hdl));
  auto res2 = peer.scribe_data_.emplace(peer_hdl, scribe_data{output, input});
  if (!res2.second)
    CAF_RAISE_ERROR("prepare_connection: peer handle already in use");
  CAF_LOG_INFO("acceptor" << src << "has connection" << hdl
               << "ready for incoming connect from" << host << ":"
               << port << "from peer with connection handle" << peer_hdl);
  if (doormen_.count(port) == 0)
    provide_acceptor(port, src);
  add_pending_connect(src, hdl);
  peer.provide_scribe(std::move(host), port, peer_hdl);
}

void test_multiplexer::add_pending_endpoint(datagram_handle src,
                                            datagram_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  pending_endpoints_.emplace(src.id(), hdl);
}

test_multiplexer::pending_connects_map& test_multiplexer::pending_connects() {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  return pending_connects_;
}

test_multiplexer::pending_endpoints_map& test_multiplexer::pending_endpoints() {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  return pending_endpoints_;
}

bool test_multiplexer::has_pending_scribe(std::string x, uint16_t y) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  guard_type guard{mx_};
  return scribes_.count(std::make_pair(std::move(x), y)) > 0;
}

bool test_multiplexer::has_pending_remote_endpoint(std::string x,
                                                   uint16_t y) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  guard_type guard{mx_};
  return remote_endpoints_.count(std::make_pair(std::move(x), y)) > 0;
}

void test_multiplexer::accept_connection(accept_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_LOG_TRACE(CAF_ARG(hdl));
  // Filled / initialized in the critical section.
  doorman_data* dd;
  { // Access `doorman_data_` and `pending_connects_` while holding `mx_`.
    guard_type guard{mx_};
    dd = &doorman_data_[hdl];
  }
  CAF_ASSERT(dd->ptr != nullptr);
  if (!dd->ptr->new_connection())
    dd->passive_mode = true;
}

bool test_multiplexer::try_accept_connection() {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  // Filled / initialized in the critical section.
  std::vector<doorman_data*> doormen;
  { // Access `doorman_data_` and `pending_connects_` while holding `mx_`.
    guard_type guard{mx_};
    doormen.reserve(doorman_data_.size());
    for (auto& kvp : doorman_data_)
      doormen.emplace_back(&kvp.second);
  }
  // Try accepting a new connection on all existing doorman.
  return std::any_of(doormen.begin(), doormen.end(),
                     [](doorman_data* x) { return x->ptr->new_connection(); });
}

bool test_multiplexer::try_read_data() {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_LOG_TRACE("");
  // scribe_data might change while we traverse it
  std::vector<connection_handle> xs;
  xs.reserve(scribe_data_.size());
  for (auto& kvp : scribe_data_)
    xs.emplace_back(kvp.first);
  for (auto x : xs)
    if (try_read_data(x))
      return true;
  return false;
}

bool test_multiplexer::try_read_data(connection_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_LOG_TRACE(CAF_ARG(hdl));
  scribe_data& sd = scribe_data_[hdl];
  if (sd.passive_mode || sd.ptr == nullptr || sd.ptr->parent() == nullptr
      || !sd.ptr->parent()->getf(abstract_actor::is_initialized_flag)) {
    return false;
  }
  switch (sd.recv_conf.first) {
    case receive_policy_flag::exactly:
      if (sd.vn_buf.size() >= sd.recv_conf.second) {
        sd.rd_buf.clear();
        auto first = sd.vn_buf.begin();
        auto last = first + static_cast<ptrdiff_t>(sd.recv_conf.second);
        sd.rd_buf.insert(sd.rd_buf.end(), first, last);
        sd.vn_buf.erase(first, last);
        if (!sd.ptr->consume(this, sd.rd_buf.data(), sd.rd_buf.size()))
          sd.passive_mode = true;
        return true;
      }
      break;
    case receive_policy_flag::at_least:
      if (sd.vn_buf.size() >= sd.recv_conf.second) {
        sd.rd_buf.clear();
        sd.rd_buf.swap(sd.vn_buf);
        if (!sd.ptr->consume(this, sd.rd_buf.data(), sd.rd_buf.size()))
          sd.passive_mode = true;
        return true;
      }
      break;
    case receive_policy_flag::at_most:
      auto max_bytes = static_cast<ptrdiff_t>(sd.recv_conf.second);
      if (!sd.vn_buf.empty()) {
        sd.rd_buf.clear();
        auto xbuf_size = static_cast<ptrdiff_t>(sd.vn_buf.size());
        auto first = sd.vn_buf.begin();
        auto last = (max_bytes < xbuf_size) ? first + max_bytes
                                            : sd.vn_buf.end();
        sd.rd_buf.insert(sd.rd_buf.end(), first, last);
        sd.vn_buf.erase(first, last);
        if (!sd.ptr->consume(this, sd.rd_buf.data(), sd.rd_buf.size()))
          sd.passive_mode = true;
        return true;
      }
  }
  return false;
}

bool test_multiplexer::read_data() {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_LOG_TRACE("");
  // scribe_data might change while we traverse it
  std::vector<connection_handle> xs;
  xs.reserve(scribe_data_.size());
  for (auto& kvp : scribe_data_)
    xs.emplace_back(kvp.first);
  long hits = 0;
  for (auto x : xs)
    if (scribe_data_.count(x) > 0)
      if (read_data(x))
        ++hits;
  return hits > 0;
}

bool test_multiplexer::read_data(connection_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_LOG_TRACE(CAF_ARG(hdl));
  flush_runnables();
  if (passive_mode(hdl))
    return false;
  scribe_data& sd = scribe_data_[hdl];
  if (sd.ptr == nullptr || sd.ptr->parent() == nullptr
      || !sd.ptr->parent()->getf(abstract_actor::is_initialized_flag)) {
    return false;
  }
  // count how many data packets we could dispatch
  long hits = 0;
  for (;;) {
    switch (sd.recv_conf.first) {
      case receive_policy_flag::exactly:
        if (sd.vn_buf.size() >= sd.recv_conf.second) {
          ++hits;
          sd.rd_buf.clear();
          auto first = sd.vn_buf.begin();
          auto last = first + static_cast<ptrdiff_t>(sd.recv_conf.second);
          sd.rd_buf.insert(sd.rd_buf.end(), first, last);
          sd.vn_buf.erase(first, last);
          if (!sd.ptr->consume(this, sd.rd_buf.data(), sd.rd_buf.size()))
            passive_mode(hdl) = true;
        } else {
          return hits > 0;
        }
        break;
      case receive_policy_flag::at_least:
        if (sd.vn_buf.size() >= sd.recv_conf.second) {
          ++hits;
          sd.rd_buf.clear();
          sd.rd_buf.swap(sd.vn_buf);
          if (!sd.ptr->consume(this, sd.rd_buf.data(), sd.rd_buf.size()))
            passive_mode(hdl) = true;
        } else {
          return hits > 0;
        }
        break;
      case receive_policy_flag::at_most:
        auto max_bytes = static_cast<ptrdiff_t>(sd.recv_conf.second);
        if (!sd.vn_buf.empty()) {
          ++hits;
          sd.rd_buf.clear();
          auto xbuf_size = static_cast<ptrdiff_t>(sd.vn_buf.size());
          auto first = sd.vn_buf.begin();
          auto last = (max_bytes < xbuf_size) ? first + max_bytes
                                              : sd.vn_buf.end();
          sd.rd_buf.insert(sd.rd_buf.end(), first, last);
          sd.vn_buf.erase(first, last);
          if (!sd.ptr->consume(this, sd.rd_buf.data(), sd.rd_buf.size()))
            passive_mode(hdl) = true;
        } else {
          return hits > 0;
        }
    }
  }
}

bool test_multiplexer::read_data(datagram_handle hdl) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_LOG_TRACE(CAF_ARG(hdl));
  flush_runnables();
  if (passive_mode(hdl))
    return false;
  auto ditr = datagram_data_.find(hdl);
  if (ditr == datagram_data_.end() || ditr->second->ptr->parent() == nullptr
      || !ditr->second->ptr->parent()->getf(abstract_actor::is_initialized_flag))
    return false;
  auto& data = ditr->second;
  if (data->vn_buf.back().second.empty())
    return false;
  // Since we can't swap std::vector and caf::io::network::receive_buffer
  // just copy over the data. This is for testing and not performance critical.
  auto& from = data->vn_buf.front();
  auto& to = data->rd_buf;
  to.first = from.first;
  CAF_ASSERT(to.second.capacity() > from.second.size());
  to.second.resize(from.second.size());
  std::copy(from.second.begin(), from.second.end(), to.second.begin());
  data->vn_buf.pop_front();
  auto sitr = datagram_data_.find(data->rd_buf.first);
  if (sitr == datagram_data_.end()) {
    if (!data->ptr->new_endpoint(data->rd_buf.second))
      passive_mode(hdl) = true;
  } else {
    if (!data->ptr->consume(this, data->rd_buf.first, data->rd_buf.second))
      passive_mode(hdl) = true;
  }
  return true;
}

void test_multiplexer::virtual_send(connection_handle hdl,
                                    const buffer_type& buf) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_LOG_TRACE(CAF_ARG(hdl));
  auto& vb = virtual_network_buffer(hdl);
  vb.insert(vb.end(), buf.begin(), buf.end());
  read_data(hdl);
}

void test_multiplexer::virtual_send(datagram_handle dst, datagram_handle ep,
                                    const buffer_type& buf) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_LOG_TRACE(CAF_ARG(dst) << CAF_ARG(ep));
  auto& vb = virtual_network_buffer(dst);
  vb.emplace_back(ep, buf);
  read_data(dst);
}

void test_multiplexer::exec_runnable() {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_LOG_TRACE("");
  resumable_ptr ptr;
  { // critical section
    guard_type guard{mx_};
    while (resumables_.empty())
      cv_.wait(guard);
    resumables_.front().swap(ptr);
    resumables_.pop_front();
  }
  exec(ptr);
}

bool test_multiplexer::try_exec_runnable() {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_LOG_TRACE("");
  resumable_ptr ptr;
  { // critical section
    guard_type guard{mx_};
    if (resumables_.empty())
      return false;
    resumables_.front().swap(ptr);
    resumables_.pop_front();
  }
  exec(ptr);
  return true;
}

void test_multiplexer::flush_runnables() {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_LOG_TRACE("");
  // execute runnables in bursts, pick a small size to
  // minimize time in the critical section
  constexpr size_t max_runnable_count = 8;
  std::vector<resumable_ptr> runnables;
  runnables.reserve(max_runnable_count);
  // runnables can create new runnables, so we need to double-check
  // that `runnables_` is empty after each burst
  do {
    runnables.clear();
    { // critical section
      guard_type guard{mx_};
      while (!resumables_.empty() && runnables.size() < max_runnable_count) {
        runnables.emplace_back(std::move(resumables_.front()));
        resumables_.pop_front();
      }
    }
    for (auto& ptr : runnables)
      exec(ptr);
  } while (!runnables.empty());
}

void test_multiplexer::exec_later(resumable* ptr) {
  CAF_ASSERT(ptr != nullptr);
  CAF_LOG_TRACE("");
  switch (ptr->subtype()) {
    case resumable::io_actor:
    case resumable::function_object: {
      if (inline_runnables_ > 0) {
        --inline_runnables_;
        resumable_ptr tmp{ptr};
        exec(tmp);
        if (inline_runnable_callback_) {
          using std::swap;
          std::function<void()> f;
          swap(f, inline_runnable_callback_);
          f();
        }
      } else {
        std::list<resumable_ptr> tmp;
        tmp.emplace_back(ptr);
        guard_type guard{mx_};
        resumables_.splice(resumables_.end(), std::move(tmp));
        cv_.notify_all();
      }
      break;
    }
    default:
      system().scheduler().enqueue(ptr);
  }
}

void test_multiplexer::exec(resumable_ptr& ptr) {
  CAF_ASSERT(std::this_thread::get_id() == tid_);
  CAF_ASSERT(ptr != nullptr);
  CAF_LOG_TRACE("");
  switch (ptr->resume(this, 1)) {
    case resumable::resume_later:
      exec_later(ptr.get());
      break;
    case resumable::done:
    case resumable::awaiting_message:
      intrusive_ptr_release(ptr.get());
      break;
    default:
      ; // ignored
  }
}

} // namespace network
} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/hook.hpp"

#include "caf/message_id.hpp"

namespace caf {
namespace io {

hook::hook(actor_system& sys) : system_(sys) {
  // nop
}

hook::~hook() {
  // nop
}

void hook::message_received_cb(const node_id&, const strong_actor_ptr&,
                               const strong_actor_ptr&, message_id,
                               const message&) {
  // nop
}

void hook::message_sent_cb(const strong_actor_ptr&, const node_id&,
                           const strong_actor_ptr&, message_id,
                           const message&) {
  // nop
}

void hook::message_forwarded_cb(const basp::header&, const std::vector<char>*) {
  // nop
}

void hook::message_forwarding_failed_cb(const basp::header&,
                                        const std::vector<char>*) {
  // nop
}

void hook::message_sending_failed_cb(const strong_actor_ptr&,
                                     const strong_actor_ptr&,
                                     message_id, const message&) {
  // nop
}

void hook::actor_published_cb(const strong_actor_ptr&,
                              const std::set<std::string>&, uint16_t) {
  // nop
}

void hook::new_remote_actor_cb(const strong_actor_ptr&) {
  // nop
}

void hook::new_connection_established_cb(const node_id&) {
  // nop
}

void hook::new_route_added_cb(const node_id&, const node_id&) {
  // nop
}

void hook::connection_lost_cb(const node_id&) {
  // nop
}

void hook::route_lost_cb(const node_id&, const node_id&) {
  // nop
}

void hook::invalid_message_received_cb(const node_id&, const strong_actor_ptr&,
                                       actor_id, message_id, const message&) {
  // nop
}

void hook::before_shutdown_cb() {
  // nop
}

} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/doorman.hpp"

#include "caf/logger.hpp"

#include "caf/io/abstract_broker.hpp"

namespace caf {
namespace io {

doorman::doorman(accept_handle acc_hdl) : doorman_base(acc_hdl) {
  // nop
}

doorman::~doorman() {
  // nop
}

message doorman::detach_message() {
  return make_message(acceptor_closed_msg{hdl()});
}

void doorman::io_failure(execution_unit* ctx, network::operation op) {
  CAF_LOG_TRACE(CAF_ARG(hdl().id()) << CAF_ARG(op));
  // keep compiler happy when compiling w/o logging
  static_cast<void>(op);
  detach(ctx, true);
}

bool doorman::new_connection(execution_unit* ctx, connection_handle x) {
  msg().handle = x;
  return invoke_mailbox_element(ctx);
}

} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/network/protocol.hpp"

namespace caf {
namespace io {
namespace network {

std::string to_string(const protocol& x) {
  std::string result;
  result += to_string(x.trans);
  result += "/";
  result += to_string(x.net);
  return result;
}

} // namespace network
} // namespace io
} // namespace caf

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <algorithm>

#include "caf/config.hpp"

#include "caf/io/network/receive_buffer.hpp"

namespace {

constexpr size_t min_size = 1;

} // namespace anonymous

namespace caf {
namespace io {
namespace network {

receive_buffer::receive_buffer()
    : buffer_(nullptr),
      capacity_(0),
      size_(0) {
  // nop
}

receive_buffer::receive_buffer(size_type size)
    : buffer_(new value_type[size]),
      capacity_(size),
      size_(0) {
  // nop
}

receive_buffer::receive_buffer(receive_buffer&& other) noexcept
    : capacity_(std::move(other.capacity_)),
      size_(std::move(other.size_)) {
  buffer_ = std::move(other.buffer_);
  other.size_ = 0;
  other.capacity_ = 0;
  other.buffer_.reset();
}

receive_buffer::receive_buffer(const receive_buffer& other)
    : capacity_(other.capacity_),
      size_(other.size_) {
  if (other.size_ == 0) {
    buffer_.reset();
  } else {
    buffer_.reset(new value_type[other.size_]);
    std::copy(other.cbegin(), other.cend(), buffer_.get());
  }
}

receive_buffer& receive_buffer::operator=(receive_buffer&& other) noexcept {
  size_ = std::move(other.size_);
  capacity_ = std::move(other.capacity_);
  buffer_ = std::move(other.buffer_);
  other.clear();
  return *this;
}

receive_buffer& receive_buffer::operator=(const receive_buffer& other) {
  size_ = other.size_;
  capacity_ = other.capacity_;
  if (other.size_ == 0) {
    buffer_.reset();
  } else {
    buffer_.reset(new value_type[other.size_]);
    std::copy(other.cbegin(), other.cend(), buffer_.get());
  }
  return *this;
}

void receive_buffer::resize(size_type new_size) {
  if (new_size > capacity_)
    increase_by(new_size - capacity_);
  size_ = new_size;
}

void receive_buffer::reserve(size_type new_size) {
  if (new_size > capacity_)
    increase_by(new_size  - capacity_);
}

void receive_buffer::shrink_to_fit() {
  if (capacity_ > size_)
    shrink_by(capacity_ - size_);
}

void receive_buffer::clear() {
  size_ = 0;
  buffer_ptr new_buffer{new value_type[capacity_]};
  std::swap(buffer_, new_buffer);
}

void receive_buffer::swap(receive_buffer& other) noexcept {
  std::swap(capacity_, other.capacity_);
  std::swap(size_, other.size_);
  std::swap(buffer_, other.buffer_);
}

void receive_buffer::push_back(value_type value) {
  if (size_ == capacity_)
    increase_by(std::max(capacity_, min_size));
  buffer_.get()[size_] = value;
  ++size_;
}

void receive_buffer::increase_by(size_t bytes) {
  if (bytes == 0)
    return;
  if (!buffer_) {
    buffer_.reset(new value_type[bytes]);
  } else {
    buffer_ptr new_buffer{new value_type[capacity_ + bytes]};
    std::copy(begin(), end(), new_buffer.get());
    std::swap(buffer_, new_buffer);
  }
  capacity_ += bytes;
}

void receive_buffer::shrink_by(size_t bytes) {
  CAF_ASSERT(bytes <= capacity_);
  size_t new_size = capacity_ - bytes;
  if (new_size == 0) {
    buffer_.reset();
  } else {
    buffer_ptr new_buffer{new value_type[new_size]};
    std::copy(begin(), begin() + new_size, new_buffer.get());
    std::swap(buffer_, new_buffer);
  }
  capacity_ = new_size;
}

receive_buffer::iterator receive_buffer::insert(iterator pos, value_type value) {
  if (size_ == capacity_) {
    auto dist = (pos == nullptr) ? 0 : std::distance(begin(), pos);
    increase_by(std::max(capacity_, min_size));
    pos = begin() + dist;
  }
  std::copy(pos, end(), pos + 1);
  *pos = value;
  ++size_;
  return pos;
}

} // namepsace network
} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/basp/header.hpp"

#include <sstream>

namespace caf {
namespace io {
namespace basp {

const uint8_t header::named_receiver_flag;

std::string to_bin(uint8_t x) {
  std::string res;
  for (auto offset = 7; offset > -1; --offset)
    res += std::to_string((x >> offset) & 0x01);
  return res;
}

std::string to_string(const header &hdr) {
  std::ostringstream oss;
  oss << "{"
      << to_string(hdr.operation) << ", "
      << to_bin(hdr.flags) << ", "
      << hdr.payload_len << ", "
      << hdr.operation_data << ", "
      << to_string(hdr.source_node) << ", "
      << to_string(hdr.dest_node) << ", "
      << hdr.source_actor << ", "
      << hdr.dest_actor << ", "
      << hdr.sequence_number
      << "}";
  return oss.str();
}

bool operator==(const header& lhs, const header& rhs) {
  return lhs.operation == rhs.operation
      && lhs.flags == rhs.flags
      && lhs.payload_len == rhs.payload_len
      && lhs.operation_data == rhs.operation_data
      && lhs.source_node == rhs.source_node
      && lhs.dest_node == rhs.dest_node
      && lhs.source_actor == rhs.source_actor
      && lhs.dest_actor == rhs.dest_actor
      && lhs.sequence_number == rhs.sequence_number;
}

namespace {

bool valid(const node_id& val) {
  return val != none;
}

template <class T>
bool zero(T val) {
  return val == 0;
}

bool server_handshake_valid(const header& hdr) {
  return  valid(hdr.source_node)
       && zero(hdr.dest_actor)
       && !zero(hdr.operation_data);
}

bool client_handshake_valid(const header& hdr) {
  return  valid(hdr.source_node)
       && hdr.source_node != hdr.dest_node
       && zero(hdr.source_actor)
       && zero(hdr.dest_actor);
}

bool dispatch_message_valid(const header& hdr) {
  return  valid(hdr.dest_node)
       && (!zero(hdr.dest_actor) || hdr.has(header::named_receiver_flag))
       && !zero(hdr.payload_len);
}

bool announce_proxy_instance_valid(const header& hdr) {
  return  valid(hdr.source_node)
       && valid(hdr.dest_node)
       && hdr.source_node != hdr.dest_node
       && zero(hdr.source_actor)
       && !zero(hdr.dest_actor)
       && zero(hdr.payload_len)
       && zero(hdr.operation_data);
}

bool kill_proxy_instance_valid(const header& hdr) {
  return  valid(hdr.source_node)
       && valid(hdr.dest_node)
       && hdr.source_node != hdr.dest_node
       && !zero(hdr.source_actor)
       && zero(hdr.dest_actor)
       && !zero(hdr.payload_len)
       && zero(hdr.operation_data);
}

bool heartbeat_valid(const header& hdr) {
  return  valid(hdr.source_node)
       && valid(hdr.dest_node)
       && hdr.source_node != hdr.dest_node
       && zero(hdr.source_actor)
       && zero(hdr.dest_actor)
       && zero(hdr.payload_len)
       && zero(hdr.operation_data);
}

} // namespace <anonymous>

bool valid(const header& hdr) {
  switch (hdr.operation) {
    default:
      return false; // invalid operation field
    case message_type::server_handshake:
      return server_handshake_valid(hdr);
    case message_type::client_handshake:
      return client_handshake_valid(hdr);
    case message_type::dispatch_message:
      return dispatch_message_valid(hdr);
    case message_type::announce_proxy:
      return announce_proxy_instance_valid(hdr);
    case message_type::kill_proxy:
      return kill_proxy_instance_valid(hdr);
    case message_type::heartbeat:
      return heartbeat_valid(hdr);
  }
}

} // namespace basp
} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/basp_broker.hpp"

#include <limits>
#include <chrono>

#include "caf/sec.hpp"
#include "caf/send.hpp"
#include "caf/after.hpp"
#include "caf/make_counted.hpp"
#include "caf/event_based_actor.hpp"
#include "caf/actor_system_config.hpp"
#include "caf/forwarding_actor_proxy.hpp"

#include "caf/actor_registry.hpp"
#include "caf/detail/sync_request_bouncer.hpp"

#include "caf/io/basp/all.hpp"
#include "caf/io/middleman.hpp"
#include "caf/io/connection_helper.hpp"

#include "caf/io/network/interfaces.hpp"

namespace caf {
namespace io {

namespace {

// visitors to access handle variant of the context
struct seq_num_visitor {
  using result_type = basp::sequence_type;
  seq_num_visitor(basp_broker_state* ptr) : state(ptr) { }
  template <class T>
  result_type operator()(const T& hdl) {
    return state->next_sequence_number(hdl);
  }
  basp_broker_state* state;
};

struct close_visitor {
  using result_type = void;
  close_visitor(broker* ptr) : b(ptr) { }
  template <class T>
  result_type operator()(const T& hdl) {
    b->close(hdl);
  }
  broker* b;
};

} // namespace anonymous

const char* basp_broker_state::name = "basp_broker";

/******************************************************************************
 *                             basp_broker_state                              *
 ******************************************************************************/

basp_broker_state::basp_broker_state(broker* selfptr)
    : basp::instance::callee(selfptr->system(),
                             static_cast<proxy_registry::backend&>(*this)),
      self(selfptr),
      instance(selfptr, *this),
      max_buffers(self->system().config().middleman_cached_udp_buffers),
      max_pending_messages(self->system().config().middleman_max_pending_msgs) {
  CAF_ASSERT(this_node() != none);
}

basp_broker_state::~basp_broker_state() {
  // make sure all spawn servers are down
  for (auto& kvp : spawn_servers)
    anon_send_exit(kvp.second, exit_reason::kill);
}

strong_actor_ptr basp_broker_state::make_proxy(node_id nid, actor_id aid) {
  CAF_LOG_TRACE(CAF_ARG(nid) << CAF_ARG(aid));
  CAF_ASSERT(nid != this_node());
  if (nid == none || aid == invalid_actor_id)
    return nullptr;
  // this member function is being called whenever we deserialize a
  // payload received from a remote node; if a remote node A sends
  // us a handle to a third node B, then we assume that A offers a route to B
  if (nid != this_context->id
      && !instance.tbl().lookup_direct(nid)
      && instance.tbl().add_indirect(this_context->id, nid))
    learned_new_node_indirectly(nid);
  // we need to tell remote side we are watching this actor now;
  // use a direct route if possible, i.e., when talking to a third node
  auto path = instance.tbl().lookup(nid);
  if (!path) {
    // this happens if and only if we don't have a path to `nid`
    // and current_context_->hdl has been blacklisted
    CAF_LOG_INFO("cannot create a proxy instance for an actor "
                 "running on a node we don't have a route to");
    return nullptr;
  }
  // create proxy and add functor that will be called if we
  // receive a kill_proxy_instance message
  auto mm = &system().middleman();
  actor_config cfg;
  auto res = make_actor<forwarding_actor_proxy, strong_actor_ptr>(
    aid, nid, &(self->home_system()), cfg, self);
  strong_actor_ptr selfptr{self->ctrl()};
  res->get()->attach_functor([=](const error& rsn) {
    mm->backend().post([=] {
      // using res->id() instead of aid keeps this actor instance alive
      // until the original instance terminates, thus preventing subtle
      // bugs with attachables
      auto bptr = static_cast<basp_broker*>(selfptr->get());
      if (!bptr->getf(abstract_actor::is_terminated_flag))
        bptr->state.proxies().erase(nid, res->id(), rsn);
    });
  });
  CAF_LOG_INFO("successfully created proxy instance, "
               "write announce_proxy_instance:"
               << CAF_ARG(nid) << CAF_ARG(aid));
  auto& ctx = *this_context;
  // tell remote side we are monitoring this actor now
  instance.write_announce_proxy(self->context(),
                                get_buffer(this_context->hdl),
                                nid, aid,
                                ctx.requires_ordering ? ctx.seq_outgoing++ : 0);
  instance.flush(*path);
  mm->notify<hook::new_remote_actor>(res);
  return res;
}

execution_unit* basp_broker_state::registry_context() {
  return self->context();
}

void basp_broker_state::finalize_handshake(const node_id& nid, actor_id aid,
                                           std::set<std::string>& sigs) {
  CAF_LOG_TRACE(CAF_ARG(nid) << CAF_ARG(aid) << CAF_ARG(sigs));
  CAF_ASSERT(this_context != nullptr);
  this_context->id = nid;
  auto& cb = this_context->callback;
  if (cb == none)
    return;
  strong_actor_ptr ptr;
  // aid can be invalid when connecting to the default port of a node
  if (aid != invalid_actor_id) {
    if (nid == this_node()) {
      // connected to self
      ptr = actor_cast<strong_actor_ptr>(system().registry().get(aid));
      CAF_LOG_INFO_IF(!ptr, "actor not found:" << CAF_ARG(aid));
    } else {
      ptr = namespace_.get_or_put(nid, aid);
      CAF_LOG_ERROR_IF(!ptr, "creating actor in finalize_handshake failed");
    }
  }
  cb->deliver(nid, std::move(ptr), std::move(sigs));
  cb = none;
}

void basp_broker_state::purge_state(const node_id& nid) {
  CAF_LOG_TRACE(CAF_ARG(nid));
  // Destroy all proxies of the lost node.
  namespace_.erase(nid);
  // Cleanup all remaining references to the lost node.
  for (auto& kvp : monitored_actors)
    kvp.second.erase(nid);
}

void basp_broker_state::send_kill_proxy_instance(const node_id& nid,
                                                 actor_id aid, error rsn) {
  CAF_LOG_TRACE(CAF_ARG(nid) << CAF_ARG(aid) << CAF_ARG(rsn));
  if (rsn == none)
    rsn = exit_reason::unknown;
  auto path = instance.tbl().lookup(nid);
  if (!path) {
    CAF_LOG_INFO("cannot send exit message for proxy, no route to host:"
                 << CAF_ARG(nid));
    return;
  }
  instance.write_kill_proxy(self->context(),
                            get_buffer(path->hdl),
                            nid, aid, rsn,
                            visit(seq_num_visitor{this}, path->hdl));
  instance.flush(*path);
}

void basp_broker_state::proxy_announced(const node_id& nid, actor_id aid) {
  CAF_LOG_TRACE(CAF_ARG(nid) << CAF_ARG(aid));
  // source node has created a proxy for one of our actors
  auto ptr = system().registry().get(aid);
  if (ptr == nullptr) {
    CAF_LOG_DEBUG("kill proxy immediately");
    // kill immediately if actor has already terminated
    send_kill_proxy_instance(nid, aid, exit_reason::unknown);
  } else {
    auto entry = ptr->address();
    auto i = monitored_actors.find(entry);
    if (i == monitored_actors.end()) {
      self->monitor(ptr);
      std::unordered_set<node_id> tmp{nid};
      monitored_actors.emplace(entry, std::move(tmp));
    } else {
      i->second.emplace(nid);
    }
  }
}

void basp_broker_state::handle_down_msg(down_msg& dm) {
  auto i = monitored_actors.find(dm.source);
  if (i == monitored_actors.end())
    return;
  for (auto& nid : i->second)
    send_kill_proxy_instance(nid, dm.source.id(), dm.reason);
  monitored_actors.erase(i);
}

void basp_broker_state::deliver(const node_id& src_nid, actor_id src_aid,
                                actor_id dest_aid, message_id mid,
                                std::vector<strong_actor_ptr>& stages,
                                message& msg) {
  CAF_LOG_TRACE(CAF_ARG(src_nid) << CAF_ARG(src_aid)
                << CAF_ARG(dest_aid) << CAF_ARG(msg) << CAF_ARG(mid));
  deliver(src_nid, src_aid, system().registry().get(dest_aid),
          mid, stages, msg);
}

void basp_broker_state::deliver(const node_id& src_nid, actor_id src_aid,
                                atom_value dest_name, message_id mid,
                                std::vector<strong_actor_ptr>& stages,
                                message& msg) {
  CAF_LOG_TRACE(CAF_ARG(src_nid) << CAF_ARG(src_aid)
                << CAF_ARG(dest_name) << CAF_ARG(msg) << CAF_ARG(mid));
  deliver(src_nid, src_aid, system().registry().get(dest_name),
          mid, stages, msg);
}

void basp_broker_state::deliver(const node_id& src_nid, actor_id src_aid,
                                strong_actor_ptr dest, message_id mid,
                                std::vector<strong_actor_ptr>& stages,
                                message& msg) {
  CAF_LOG_TRACE(CAF_ARG(src_nid) << CAF_ARG(src_aid) << CAF_ARG(dest)
                << CAF_ARG(msg) << CAF_ARG(mid));
  auto src = src_nid == this_node() ? system().registry().get(src_aid)
                                    : proxies().get_or_put(src_nid, src_aid);
  // Intercept link messages. Forwarding actor proxies signalize linking
  // by sending link_atom/unlink_atom message with src = dest.
  if (msg.type_token() == make_type_token<atom_value, strong_actor_ptr>()) {
    switch (static_cast<uint64_t>(msg.get_as<atom_value>(0))) {
      default:
        break;
      case link_atom::value.uint_value(): {
        if (src_nid != this_node()) {
          CAF_LOG_WARNING("received link message for another node");
          return;
        }
        auto ptr = msg.get_as<strong_actor_ptr>(1);
        if (!ptr) {
          CAF_LOG_WARNING("received link message with invalid target");
          return;
        }
        if (!src) {
          CAF_LOG_DEBUG("received link for invalid actor, report error");
          anon_send(actor_cast<actor>(ptr),
                    make_error(sec::remote_linking_failed));
          return;
        }
        static_cast<actor_proxy*>(ptr->get())->add_link(src->get());
        return;
      }
      case unlink_atom::value.uint_value(): {
        if (src_nid != this_node()) {
          CAF_LOG_WARNING("received unlink message for an other node");
          return;
        }
        const auto& ptr = msg.get_as<strong_actor_ptr>(1);
        if (!ptr) {
          CAF_LOG_DEBUG("received unlink message with invalid target");
          return;
        }
        if (!src) {
          CAF_LOG_DEBUG("received unlink for invalid actor, report error");
          return;
        }
        static_cast<actor_proxy*>(ptr->get())->remove_link(src->get());
        return;
      }
    }
  }
  if (!dest) {
    auto rsn = exit_reason::remote_link_unreachable;
    CAF_LOG_INFO("cannot deliver message, destination not found");
    self->parent().notify<hook::invalid_message_received>(src_nid, src,
                                                          invalid_actor_id,
                                                          mid, msg);
    if (mid.valid() && src) {
      detail::sync_request_bouncer srb{rsn};
      srb(src, mid);
    }
    return;
  }
  self->parent().notify<hook::message_received>(src_nid, src, dest, mid, msg);
  dest->enqueue(make_mailbox_element(std::move(src), mid, std::move(stages),
                                     std::move(msg)),
                nullptr);
}

void basp_broker_state::learned_new_node(const node_id& nid) {
  CAF_LOG_TRACE(CAF_ARG(nid));
  if (spawn_servers.count(nid) > 0) {
    CAF_LOG_ERROR("learned_new_node called for known node " << CAF_ARG(nid));
    return;
  }
  auto tmp = system().spawn<hidden>([=](event_based_actor* tself) -> behavior {
    CAF_LOG_TRACE("");
    // terminate when receiving a down message
    tself->set_down_handler([=](down_msg& dm) {
      CAF_LOG_TRACE(CAF_ARG(dm));
      tself->quit(std::move(dm.reason));
    });
    // skip messages until we receive the initial ok_atom
    tself->set_default_handler(skip);
    return {
      [=](ok_atom, const std::string& /* key == "info" */,
          const strong_actor_ptr& config_serv, const std::string& /* name */) {
        CAF_LOG_TRACE(CAF_ARG(config_serv));
        // drop unexpected messages from this point on
        tself->set_default_handler(print_and_drop);
        if (!config_serv)
          return;
        tself->monitor(config_serv);
        tself->become(
          [=](spawn_atom, std::string& type, message& args)
          -> delegated<strong_actor_ptr, std::set<std::string>> {
            CAF_LOG_TRACE(CAF_ARG(type) << CAF_ARG(args));
            tself->delegate(actor_cast<actor>(std::move(config_serv)),
                            get_atom::value, std::move(type),
                            std::move(args));
            return {};
          }
        );
      },
      after(std::chrono::minutes(5)) >> [=] {
        CAF_LOG_INFO("no spawn server found:" << CAF_ARG(nid));
        tself->quit();
      }
    };
  });
  spawn_servers.emplace(nid, tmp);
  using namespace detail;
  system().registry().put(tmp.id(), actor_cast<strong_actor_ptr>(tmp));
  auto writer = make_callback([](serializer& sink) -> error {
    auto name_atm = atom("SpawnServ");
    std::vector<actor_id> stages;
    auto msg = make_message(sys_atom::value, get_atom::value, "info");
    return sink(name_atm, stages, msg);
  });
  auto path = instance.tbl().lookup(nid);
  if (!path) {
    CAF_LOG_ERROR("learned_new_node called, but no route to nid");
    return;
  }
  // send message to SpawnServ of remote node
  basp::header hdr{basp::message_type::dispatch_message,
                   basp::header::named_receiver_flag,
                   0, 0, this_node(), nid, tmp.id(), invalid_actor_id,
                   visit(seq_num_visitor{this}, path->hdl)};
  // writing std::numeric_limits<actor_id>::max() is a hack to get
  // this send-to-named-actor feature working with older CAF releases
  instance.write(self->context(), get_buffer(path->hdl),
                 hdr, &writer);
  instance.flush(*path);
}

void basp_broker_state::learned_new_node_directly(const node_id& nid,
                                                  bool was_indirectly_before) {
  CAF_ASSERT(this_context != nullptr);
  CAF_LOG_TRACE(CAF_ARG(nid));
  if (!was_indirectly_before)
    learned_new_node(nid);
}

void basp_broker_state::learned_new_node_indirectly(const node_id& nid) {
  CAF_ASSERT(this_context != nullptr);
  CAF_LOG_TRACE(CAF_ARG(nid));
  learned_new_node(nid);
  if (!enable_automatic_connections)
    return;
  // this member function gets only called once, after adding a new
  // indirect connection to the routing table; hence, spawning
  // our helper here exactly once and there is no need to track
  // in-flight connection requests
  auto path = instance.tbl().lookup(nid);
  if (!path) {
    CAF_LOG_ERROR("learned_new_node_indirectly called, but no route to nid");
    return;
  }
  if (path->next_hop == nid) {
    CAF_LOG_ERROR("learned_new_node_indirectly called with direct connection");
    return;
  }
  using namespace detail;
  auto try_connect = [&](std::string item) {
    auto tmp = system().config().middleman_detach_utility_actors
               ? system().spawn<detached + hidden>(connection_helper, self)
               : system().spawn<hidden>(connection_helper, self);
    system().registry().put(tmp.id(), actor_cast<strong_actor_ptr>(tmp));
    auto writer = make_callback([&item](serializer& sink) -> error {
      auto name_atm = atom("ConfigServ");
      std::vector<actor_id> stages;
      auto msg = make_message(get_atom::value, std::move(item));
      return sink(name_atm, stages, msg);
    });
    basp::header hdr{basp::message_type::dispatch_message,
                     basp::header::named_receiver_flag,
                     0, 0, this_node(), nid, tmp.id(), invalid_actor_id,
                     visit(seq_num_visitor{this}, path->hdl)};
    instance.write(self->context(), get_buffer(path->hdl),
                   hdr, &writer);
    instance.flush(*path);
  };
  if (enable_tcp)
    try_connect("basp.default-connectivity-tcp");
  if (enable_udp)
    try_connect("basp.default-connectivity-udp");
}

void basp_broker_state::set_context(connection_handle hdl) {
  CAF_LOG_TRACE(CAF_ARG(hdl));
  auto i = ctx_tcp.find(hdl);
  if (i == ctx_tcp.end()) {
    CAF_LOG_INFO("create new BASP context:" << CAF_ARG(hdl));
    i = ctx_tcp.emplace(
      hdl,
      basp::endpoint_context{
        basp::await_header,
        basp::header{basp::message_type::server_handshake, 0,
                     0, 0, none, none,
                     invalid_actor_id, invalid_actor_id},
        hdl, none, 0, 0, none, false, 0, 0,
        basp::endpoint_context::pending_map(), false
      }
    ).first;
  }
  this_context = &i->second;
}

void basp_broker_state::set_context(datagram_handle hdl) {
  CAF_LOG_TRACE(CAF_ARG(hdl));
  auto i = ctx_udp.find(hdl);
  if (i == ctx_udp.end()) {
    CAF_LOG_INFO("create new BASP context:" << CAF_ARG(hdl));
    i = ctx_udp.emplace(
      hdl,
      basp::endpoint_context{
        basp::await_header,
        basp::header{basp::message_type::server_handshake,
                     0, 0, 0, none, none,
                     invalid_actor_id, invalid_actor_id},
        hdl, none, 0, 0, none, true, 0, 0,
        basp::endpoint_context::pending_map(), false
      }
    ).first;
  }
  this_context = &i->second;
}

void basp_broker_state::cleanup(connection_handle hdl) {
  CAF_LOG_TRACE(CAF_ARG(hdl));
  // Remove handle from the routing table and clean up any node-specific state
  // we might still have.
  auto cb = make_callback([&](const node_id& nid) -> error {
    purge_state(nid);
    return none;
  });
  instance.tbl().erase_direct(hdl, cb);
  // Remove the context for `hdl`, making sure clients receive an error in case
  // this connection was closed during handshake.
  auto i = ctx_tcp.find(hdl);
  if (i != ctx_tcp.end()) {
    auto& ref = i->second;
    CAF_ASSERT(i->first == ref.hdl);
    if (ref.callback) {
      CAF_LOG_DEBUG("connection closed during handshake");
      ref.callback->deliver(sec::disconnect_during_handshake);
    }
    ctx_tcp.erase(i);
  }
}

void basp_broker_state::cleanup(datagram_handle hdl) {
  CAF_LOG_TRACE(CAF_ARG(hdl));
  // Remove handle from the routing table and clean up any node-specific state
  // we might still have.
  auto cb = make_callback([&](const node_id& nid) -> error {
    purge_state(nid);
    return none;
  });
  instance.tbl().erase_direct(hdl, cb);
  // Remove the context for `hdl`, making sure clients receive an error in case
  // this connection was closed during handshake.
  auto i = ctx_udp.find(hdl);
  if (i != ctx_udp.end()) {
    auto& ref = i->second;
    CAF_ASSERT(i->first == ref.hdl);
    if (ref.callback) {
      CAF_LOG_DEBUG("connection closed during handshake");
      ref.callback->deliver(sec::disconnect_during_handshake);
    }
    ctx_udp.erase(i);
  }
}

basp::sequence_type basp_broker_state::next_sequence_number(connection_handle) {
  return 0;
}

basp::sequence_type
basp_broker_state::next_sequence_number(datagram_handle hdl) {
  auto i = ctx_udp.find(hdl);
  if (i != ctx_udp.end() && i->second.requires_ordering)
    return i->second.seq_outgoing++;
  return 0;
}

void basp_broker_state::add_pending(execution_unit* ctx,
                                    basp::endpoint_context& ep,
                                    basp::sequence_type seq,
                                    basp::header hdr,
                                    std::vector<char> payload) {
  if (!ep.requires_ordering)
    return;
  ep.pending.emplace(seq, std::make_pair(std::move(hdr), std::move(payload)));
  if (ep.pending.size() >= max_pending_messages)
    deliver_pending(ctx, ep, true);
  else if (!ep.did_set_timeout)
    self->delayed_send(self, pending_to, pending_atom::value,
                       get<datagram_handle>(ep.hdl));
}

bool basp_broker_state::deliver_pending(execution_unit* ctx,
                                        basp::endpoint_context& ep,
                                        bool force) {
  if (!ep.requires_ordering || ep.pending.empty())
    return true;
  std::vector<char>* payload = nullptr;
  auto i = ep.pending.begin();
  // Force delivery of at least the first messages, if desired.
  if (force)
    ep.seq_incoming = i->first;
  while (i != ep.pending.end() && i->first == ep.seq_incoming) {
    ep.hdr = std::move(i->second.first);
    payload = &i->second.second;
    if (!instance.handle(ctx, get<datagram_handle>(ep.hdl),
                         ep.hdr, payload, false, ep, none))
      return false;
    i = ep.pending.erase(i);
    ep.seq_incoming += 1;
  }
  // Set a timeout if there are still pending messages.
  if (!ep.pending.empty() && !ep.did_set_timeout)
    self->delayed_send(self, pending_to, pending_atom::value,
                       get<datagram_handle>(ep.hdl));
  return true;
}

void basp_broker_state::drop_pending(basp::endpoint_context& ep,
                                     basp::sequence_type seq) {
  if (!ep.requires_ordering)
    return;
  ep.pending.erase(seq);
}

basp_broker_state::buffer_type&
basp_broker_state::get_buffer(endpoint_handle hdl) {
  if (hdl.is<connection_handle>())
    return get_buffer(get<connection_handle>(hdl));
  else
    return get_buffer(get<datagram_handle>(hdl));
}

basp_broker_state::buffer_type&
basp_broker_state::get_buffer(datagram_handle) {
  if (cached_buffers.empty())
    cached_buffers.emplace();
  return cached_buffers.top();
}

basp_broker_state::buffer_type&
basp_broker_state::get_buffer(connection_handle hdl) {
  return self->wr_buf(hdl);
}

basp_broker_state::buffer_type
basp_broker_state::pop_datagram_buffer(datagram_handle) {
  std::vector<char> res;
  std::swap(res, cached_buffers.top());
  cached_buffers.pop();
  return res;
}

void basp_broker_state::flush(endpoint_handle hdl) {
  if (hdl.is<connection_handle>())
    flush(get<connection_handle>(hdl));
  else
    flush(get<datagram_handle>(hdl));
}

void basp_broker_state::flush(datagram_handle hdl) {
  if (!cached_buffers.empty() && !cached_buffers.top().empty())
    self->enqueue_datagram(hdl, pop_datagram_buffer(hdl));
  self->flush(hdl);
}

void basp_broker_state::flush(connection_handle hdl) {
  self->flush(hdl);
}

/******************************************************************************
 *                                basp_broker                                 *
 ******************************************************************************/

basp_broker::basp_broker(actor_config& cfg)
    : stateful_actor<basp_broker_state, broker>(cfg) {
  set_down_handler([](local_actor* ptr, down_msg& x) {
    static_cast<basp_broker*>(ptr)->state.handle_down_msg(x);
  });
}

behavior basp_broker::make_behavior() {
  CAF_LOG_TRACE(CAF_ARG(system().node()));
  state.enable_tcp = system().config().middleman_enable_tcp;
  state.enable_udp = system().config().middleman_enable_udp;
  if (system().config().middleman_enable_automatic_connections) {
    CAF_LOG_INFO("enable automatic connections");
    // open a random port and store a record for our peers how to
    // connect to this broker directly in the configuration server
    if (state.enable_tcp) {
      auto res = add_tcp_doorman(uint16_t{0});
      if (res) {
        auto port = res->second;
        auto addrs = network::interfaces::list_addresses(false);
        auto config_server = system().registry().get(atom("ConfigServ"));
        send(actor_cast<actor>(config_server), put_atom::value,
             "basp.default-connectivity-tcp",
             make_message(port, std::move(addrs)));
      }
    }
    if (state.enable_udp) {
      auto res = add_udp_datagram_servant(uint16_t{0});
      if (res) {
        auto port = res->second;
        auto addrs = network::interfaces::list_addresses(false);
        auto config_server = system().registry().get(atom("ConfigServ"));
        send(actor_cast<actor>(config_server), put_atom::value,
              "basp.default-connectivity-udp",
              make_message(port, std::move(addrs)));
      }
    }
    state.enable_automatic_connections = true;
  }
  auto heartbeat_interval = system().config().middleman_heartbeat_interval;
  if (heartbeat_interval > 0) {
    CAF_LOG_INFO("enable heartbeat" << CAF_ARG(heartbeat_interval));
    send(this, tick_atom::value, heartbeat_interval);
  }
  return {
    // received from underlying broker implementation
    [=](new_data_msg& msg) {
      CAF_LOG_TRACE(CAF_ARG(msg.handle));
      state.set_context(msg.handle);
      auto& ctx = *state.this_context;
      auto next = state.instance.handle(context(), msg, ctx.hdr,
                                        ctx.cstate == basp::await_payload);
      if (next == basp::close_connection) {
        state.cleanup(msg.handle);
        close(msg.handle);
        return;
      }
      if (next != ctx.cstate) {
        auto rd_size = next == basp::await_payload
                       ? ctx.hdr.payload_len
                       : basp::header_size;
        configure_read(msg.handle, receive_policy::exactly(rd_size));
        ctx.cstate = next;
      }
    },
    // received from auto connect broker for UDP communication
    [=](new_datagram_msg& msg, datagram_servant_ptr ptr, uint16_t port) {
      CAF_LOG_TRACE(CAF_ARG(msg.handle));
      auto hdl = ptr->hdl();
      move_datagram_servant(ptr);
      auto& ctx = state.ctx_udp[hdl];
      ctx.hdl = hdl;
      ctx.remote_port = port;
      ctx.local_port = local_port(hdl);
      ctx.requires_ordering = true;
      ctx.seq_incoming = 0;
      ctx.seq_outgoing = 1; // already sent the client handshake
      // Let's not implement this twice
      send(this, std::move(msg));
    },
    // received from underlying broker implementation
    [=](new_datagram_msg& msg) {
      CAF_LOG_TRACE(CAF_ARG(msg.handle));
      state.set_context(msg.handle);
      auto& ctx = *state.this_context;
      if (ctx.local_port == 0)
        ctx.local_port = local_port(msg.handle);
      if (!state.instance.handle(context(), msg, ctx)) {
        if (ctx.callback) {
          CAF_LOG_WARNING("failed to handshake with remote node"
                          << CAF_ARG(msg.handle));
          ctx.callback->deliver(make_error(sec::disconnect_during_handshake));
        }
        state.cleanup(msg.handle);
        close(msg.handle);
      }
    },
    // received from the underlying broker implementation
    [=](datagram_sent_msg& msg) {
      if (state.cached_buffers.size() < state.max_buffers)
        state.cached_buffers.emplace(std::move(msg.buf));
    },
    // received from proxy instances
    [=](forward_atom, strong_actor_ptr& src,
        const std::vector<strong_actor_ptr>& fwd_stack,
        strong_actor_ptr& dest, message_id mid, const message& msg) {
      CAF_LOG_TRACE(CAF_ARG(src) << CAF_ARG(dest)
                    << CAF_ARG(mid) << CAF_ARG(msg));
      if (!dest || system().node() == dest->node()) {
        CAF_LOG_WARNING("cannot forward to invalid or local actor:"
                        << CAF_ARG(dest));
        return;
      }
      if (src && system().node() == src->node())
        system().registry().put(src->id(), src);
      if (!state.instance.dispatch(context(), src, fwd_stack,
                                   dest, mid, msg)
          && mid.is_request()) {
        detail::sync_request_bouncer srb{exit_reason::remote_link_unreachable};
        srb(src, mid);
      }
    },
    // received from some system calls like whereis
    [=](forward_atom, const node_id& dest_node, atom_value dest_name,
        const message& msg) -> result<message> {
      auto cme = current_mailbox_element();
      if (cme == nullptr)
        return sec::invalid_argument;
      auto& src = cme->sender;
      CAF_LOG_TRACE(CAF_ARG(src)
                    << ", " << CAF_ARG(dest_node)
                    << ", " << CAF_ARG(dest_name)
                    << ", " << CAF_ARG(msg));
      if (!src)
        return sec::invalid_argument;
      auto path = this->state.instance.tbl().lookup(dest_node);
      if (!path) {
        CAF_LOG_ERROR("no route to receiving node");
        return sec::no_route_to_receiving_node;
      }
      if (system().node() == src->node())
        system().registry().put(src->id(), src);
      auto writer = make_callback([&](serializer& sink) -> error {
        return sink(dest_name, cme->stages, const_cast<message&>(msg));
      });
      basp::header hdr{basp::message_type::dispatch_message,
                       basp::header::named_receiver_flag,
                       0, cme->mid.integer_value(), state.this_node(),
                       dest_node, src->id(), invalid_actor_id,
                       visit(seq_num_visitor{&state}, path->hdl)};
      state.instance.write(context(), state.get_buffer(path->hdl),
                           hdr, &writer);
      state.instance.flush(*path);
      return delegated<message>();
    },
    // received from underlying broker implementation
    [=](const new_connection_msg& msg) {
      CAF_LOG_TRACE(CAF_ARG(msg.handle));
      auto& bi = state.instance;
      bi.write_server_handshake(context(), state.get_buffer(msg.handle),
                                local_port(msg.source));
      state.flush(msg.handle);
      configure_read(msg.handle, receive_policy::exactly(basp::header_size));
    },
    // received from underlying broker implementation
    [=](const connection_closed_msg& msg) {
      CAF_LOG_TRACE(CAF_ARG(msg.handle));
      state.cleanup(msg.handle);
    },
    // received from underlying broker implementation
    [=](const acceptor_closed_msg& msg) {
      CAF_LOG_TRACE("");
      auto port = local_port(msg.handle);
      state.instance.remove_published_actor(port);
    },
    // received from middleman actor
    [=](publish_atom, doorman_ptr& ptr, uint16_t port,
        const strong_actor_ptr& whom, std::set<std::string>& sigs) {
      CAF_LOG_TRACE(CAF_ARG(ptr) << CAF_ARG(port)
                    << CAF_ARG(whom) << CAF_ARG(sigs));
      CAF_ASSERT(ptr != nullptr);
      add_doorman(std::move(ptr));
      if (whom)
        system().registry().put(whom->id(), whom);
      state.instance.add_published_actor(port, whom, std::move(sigs));
    },
    // received from middleman actor (delegated)
    [=](connect_atom, scribe_ptr& ptr, uint16_t port) {
      CAF_LOG_TRACE(CAF_ARG(ptr) << CAF_ARG(port));
      CAF_ASSERT(ptr != nullptr);
      auto rp = make_response_promise();
      auto hdl = ptr->hdl();
      add_scribe(std::move(ptr));
      auto& ctx = state.ctx_tcp[hdl];
      ctx.hdl = hdl;
      ctx.remote_port = port;
      ctx.cstate = basp::await_header;
      ctx.callback = rp;
      ctx.requires_ordering = false;
      // await server handshake
      configure_read(hdl, receive_policy::exactly(basp::header_size));
    },
    [=](publish_udp_atom, datagram_servant_ptr& ptr, uint16_t port,
        const strong_actor_ptr& whom, std::set<std::string>& sigs) {
      CAF_LOG_TRACE(CAF_ARG(ptr) << CAF_ARG(port)
                    << CAF_ARG(whom) << CAF_ARG(sigs));
      CAF_ASSERT(ptr != nullptr);
      add_datagram_servant(std::move(ptr));
      if (whom)
        system().registry().put(whom->id(), whom);
      state.instance.add_published_actor(port, whom, std::move(sigs));
    },
    // received from middleman actor (delegated)
    [=](contact_atom, datagram_servant_ptr& ptr, uint16_t port) {
      CAF_LOG_TRACE(CAF_ARG(ptr) << CAF_ARG(port));
      auto rp = make_response_promise();
      auto hdl = ptr->hdl();
      add_datagram_servant(std::move(ptr));
      auto& ctx = state.ctx_udp[hdl];
      ctx.hdl = hdl;
      ctx.remote_port = port;
      ctx.local_port = local_port(hdl);
      ctx.callback = rp;
      ctx.requires_ordering = true;
      ctx.seq_incoming = 0;
      ctx.seq_outgoing = 0;
      auto& bi = state.instance;
      bi.write_client_handshake(context(), state.get_buffer(hdl),
                                none, ctx.seq_outgoing++);
      state.flush(hdl);
    },
    // received from underlying broker implementation
    [=](const datagram_servant_closed_msg& msg) {
      CAF_LOG_TRACE("");
      // since all handles share a port, we can take any of them to query for
      // port information
      CAF_ASSERT(msg.handles.size() > 0);
      auto port = local_port(msg.handles.front());
      state.instance.remove_published_actor(port);
    },
    [=](delete_atom, const node_id& nid, actor_id aid) {
      CAF_LOG_TRACE(CAF_ARG(nid) << ", " << CAF_ARG(aid));
      state.proxies().erase(nid, aid);
    },
    [=](unpublish_atom, const actor_addr& whom, uint16_t port) -> result<void> {
      CAF_LOG_TRACE(CAF_ARG(whom) << CAF_ARG(port));
      auto cb = make_callback(
        [&](const strong_actor_ptr&, uint16_t x) -> error {
          close(hdl_by_port(x));
          return none;
        }
      );
      if (state.instance.remove_published_actor(whom, port, &cb) == 0)
        return sec::no_actor_published_at_port;
      return unit;
    },
    [=](unpublish_udp_atom, const actor_addr& whom, uint16_t port) -> result<void> {
      CAF_LOG_TRACE(CAF_ARG(whom) << CAF_ARG(port));
      auto cb = make_callback(
        [&](const strong_actor_ptr&, uint16_t x) -> error {
          close(datagram_hdl_by_port(x));
          return none;
        }
      );
      if (state.instance.remove_published_actor(whom, port, &cb) == 0)
        return sec::no_actor_published_at_port;
      return unit;
    },
    [=](close_atom, uint16_t port) -> result<void> {
      if (port == 0)
        return sec::cannot_close_invalid_port;
      // it is well-defined behavior to not have an actor published here,
      // hence the result can be ignored safely
      state.instance.remove_published_actor(port, nullptr);
      auto res = close(hdl_by_port(port));
      if (res)
        return unit;
      return sec::cannot_close_invalid_port;
    },
    [=](get_atom, const node_id& x)
    -> std::tuple<node_id, std::string, uint16_t> {
      std::string addr;
      uint16_t port = 0;
      auto hdl = state.instance.tbl().lookup_direct(x);
      if (hdl) {
        addr = visit(addr_visitor{this}, *hdl);
        port = visit(port_visitor{this}, *hdl);
      }
      return std::make_tuple(x, std::move(addr), port);
    },
    [=](tick_atom, size_t interval) {
      state.instance.handle_heartbeat(context());
      delayed_send(this, std::chrono::milliseconds{interval},
                   tick_atom::value, interval);
    },
    [=](pending_atom, datagram_handle hdl) {
      auto& ep = state.ctx_udp[hdl];
      ep.did_set_timeout = false;
      if (ep.pending.empty())
        return;
      auto i = ep.pending.begin();
      auto seq = i->first;
      if (seq == ep.seq_incoming ||
          basp::instance::is_greater(seq, ep.seq_incoming)) {
        // Skip missing messages and force delivery.
        state.deliver_pending(context(), ep, true);
      } else {
        state.drop_pending(ep, seq);
      }
    }
  };
}

resumable::resume_result basp_broker::resume(execution_unit* ctx, size_t mt) {
  ctx->proxy_registry_ptr(&state.instance.proxies());
  auto guard = detail::make_scope_guard([=] {
    ctx->proxy_registry_ptr(nullptr);
  });
  return super::resume(ctx, mt);
}

proxy_registry* basp_broker::proxy_registry_ptr() {
  return &state.instance.proxies();
}

} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/network/stream_manager.hpp"

namespace caf {
namespace io {
namespace network {

stream_manager::~stream_manager() {
  // nop
}

} // namespace network
} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/none.hpp"
#include "caf/config.hpp"
#include "caf/make_counted.hpp"

#include "caf/logger.hpp"
#include "caf/detail/scope_guard.hpp"

#include "caf/io/broker.hpp"
#include "caf/io/middleman.hpp"

#include "caf/actor_registry.hpp"
#include "caf/detail/sync_request_bouncer.hpp"

namespace caf {
namespace io {

void broker::initialize() {
  CAF_LOG_TRACE("");
  init_broker();
  auto bhvr = make_behavior();
  CAF_LOG_DEBUG_IF(!bhvr, "make_behavior() did not return a behavior:"
                           << CAF_ARG(has_behavior()));
  if (bhvr) {
    // make_behavior() did return a behavior instead of using become()
    CAF_LOG_DEBUG("make_behavior() did return a valid behavior");
    become(std::move(bhvr));
  }
}

broker::broker(actor_config& cfg) : super(cfg) {
  // nop
}


behavior broker::make_behavior() {
  behavior res;
  if (initial_behavior_fac_) {
    res = initial_behavior_fac_(this);
    initial_behavior_fac_ = nullptr;
  }
  return res;
}

} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/middleman.hpp"

#include <tuple>
#include <cerrno>
#include <memory>
#include <cstring>
#include <sstream>
#include <stdexcept>

#include "caf/sec.hpp"
#include "caf/send.hpp"
#include "caf/actor.hpp"
#include "caf/after.hpp"
#include "caf/config.hpp"
#include "caf/logger.hpp"
#include "caf/node_id.hpp"
#include "caf/actor_proxy.hpp"
#include "caf/make_counted.hpp"
#include "caf/scoped_actor.hpp"
#include "caf/function_view.hpp"
#include "caf/actor_registry.hpp"
#include "caf/event_based_actor.hpp"
#include "caf/actor_system_config.hpp"
#include "caf/raw_event_based_actor.hpp"
#include "caf/typed_event_based_actor.hpp"

#include "caf/io/basp_broker.hpp"
#include "caf/io/system_messages.hpp"

#include "caf/io/network/interfaces.hpp"
#include "caf/io/network/test_multiplexer.hpp"
#include "caf/io/network/default_multiplexer.hpp"

#include "caf/scheduler/abstract_coordinator.hpp"

#include "caf/detail/ripemd_160.hpp"
#include "caf/detail/safe_equal.hpp"
#include "caf/detail/get_root_uuid.hpp"
#include "caf/detail/get_mac_addresses.hpp"

#ifdef CAF_USE_ASIO
#include "caf/io/network/asio_multiplexer.hpp"
#include "caf/io/network/asio_multiplexer_impl.hpp"
#endif // CAF_USE_ASIO

#ifdef CAF_WINDOWS
#include <io.h>
#include <fcntl.h>
#endif // CAF_WINDOWS

namespace caf {
namespace io {

namespace {

template <class T>
class mm_impl : public middleman {
public:
  mm_impl(actor_system& ref) : middleman(ref), backend_(&ref) {
    // nop
  }

  network::multiplexer& backend() override {
    return backend_;
  }

private:
  T backend_;
};

} // namespace <anonymous>

actor_system::module* middleman::make(actor_system& sys, detail::type_list<>) {
  switch (atom_uint(sys.config().middleman_network_backend)) {
# ifdef CAF_USE_ASIO
    case atom_uint(atom("asio")):
      return new mm_impl<network::asio_multiplexer>(sys);
# endif // CAF_USE_ASIO
    case atom_uint(atom("testing")):
      return new mm_impl<network::test_multiplexer>(sys);
    default:
      return new mm_impl<network::default_multiplexer>(sys);
  }
}

middleman::middleman(actor_system& sys) : system_(sys) {
  // nop
}

expected<strong_actor_ptr> middleman::remote_spawn_impl(const node_id& nid,
                                                        std::string& name,
                                                        message& args,
                                                        std::set<std::string> s,
                                                        duration timeout) {
  auto f = make_function_view(actor_handle(), timeout);
  return f(spawn_atom::value, nid, std::move(name),
           std::move(args), std::move(s));
}

expected<uint16_t> middleman::open(uint16_t port, const char* in, bool reuse) {
  std::string str;
  if (in != nullptr)
    str = in;
  auto f = make_function_view(actor_handle());
  return f(open_atom::value, port, std::move(str), reuse);
}

expected<void> middleman::close(uint16_t port) {
  auto f = make_function_view(actor_handle());
  return f(close_atom::value, port);
}

expected<node_id> middleman::connect(std::string host, uint16_t port) {
  auto f = make_function_view(actor_handle());
  auto res = f(connect_atom::value, std::move(host), port);
  if (!res)
    return std::move(res.error());
  return std::get<0>(*res);
}

expected<uint16_t> middleman::publish(const strong_actor_ptr& whom,
                                      std::set<std::string> sigs, uint16_t port,
                                      const char* cstr, bool ru) {
  CAF_LOG_TRACE(CAF_ARG(whom) << CAF_ARG(sigs) << CAF_ARG(port));
  if (!whom)
    return sec::cannot_publish_invalid_actor;
  std::string in;
  if (cstr != nullptr)
    in = cstr;
  auto f = make_function_view(actor_handle());
  return f(publish_atom::value, port, std::move(whom), std::move(sigs), in, ru);
}

expected<uint16_t> middleman::publish_udp(const strong_actor_ptr& whom,
                                          std::set<std::string> sigs,
                                          uint16_t port, const char* cstr,
                                          bool ru) {
  CAF_LOG_TRACE(CAF_ARG(whom) << CAF_ARG(sigs) << CAF_ARG(port));
  if (!whom)
    return sec::cannot_publish_invalid_actor;
  std::string in;
  if (cstr != nullptr)
    in = cstr;
  auto f = make_function_view(actor_handle());
  return f(publish_udp_atom::value, port, std::move(whom),
           std::move(sigs), in, ru);
}

expected<uint16_t> middleman::publish_local_groups(uint16_t port,
                                                   const char* in, bool reuse) {
  CAF_LOG_TRACE(CAF_ARG(port) << CAF_ARG(in));
  auto group_nameserver = [](event_based_actor* self) -> behavior {
    return {
      [self](get_atom, const std::string& name) {
        return self->system().groups().get_local(name);
      }
    };
  };
  auto gn = system().spawn<hidden>(group_nameserver);
  auto result = publish(gn, port, in, reuse);
  // link gn to our manager
  if (result)
    manager_->add_link(actor_cast<abstract_actor*>(gn));
  else
    anon_send_exit(gn, exit_reason::user_shutdown);
  return result;
}

expected<void> middleman::unpublish(const actor_addr& whom, uint16_t port) {
  CAF_LOG_TRACE(CAF_ARG(whom) << CAF_ARG(port));
  auto f = make_function_view(actor_handle());
  return f(unpublish_atom::value, whom, port);
}

expected<void> middleman::unpublish_udp(const actor_addr& whom, uint16_t port) {
  CAF_LOG_TRACE(CAF_ARG(whom) << CAF_ARG(port));
  auto f = make_function_view(actor_handle());
  return f(unpublish_udp_atom::value, whom, port);
}

expected<strong_actor_ptr> middleman::remote_actor(std::set<std::string> ifs,
                                                   std::string host,
                                                   uint16_t port) {
  CAF_LOG_TRACE(CAF_ARG(ifs) << CAF_ARG(host) << CAF_ARG(port));
  auto f = make_function_view(actor_handle());
  auto res = f(connect_atom::value, std::move(host), port);
  if (!res)
    return std::move(res.error());
  strong_actor_ptr ptr = std::move(std::get<1>(*res));
  if (!ptr)
    return make_error(sec::no_actor_published_at_port, port);
  if (!system().assignable(std::get<2>(*res), ifs))
    return make_error(sec::unexpected_actor_messaging_interface, std::move(ifs),
                      std::move(std::get<2>(*res)));
  return ptr;
}

expected<strong_actor_ptr>
middleman::remote_actor_udp(std::set<std::string> ifs, std::string host,
                            uint16_t port) {
  CAF_LOG_TRACE(CAF_ARG(ifs) << CAF_ARG(host) << CAF_ARG(port));
  auto f = make_function_view(actor_handle());
  auto res = f(contact_atom::value, std::move(host), port);
  if (!res)
    return std::move(res.error());
  strong_actor_ptr ptr = std::move(std::get<1>(*res));
  if (!ptr)
    return make_error(sec::no_actor_published_at_port, port);
  if (!system().assignable(std::get<2>(*res), ifs))
    return make_error(sec::unexpected_actor_messaging_interface, std::move(ifs),
                      std::move(std::get<2>(*res)));
  return ptr;
}

expected<group> middleman::remote_group(const std::string& group_uri) {
  CAF_LOG_TRACE(CAF_ARG(group_uri));
  // format of group_identifier is group@host:port
  // a regex would be the natural choice here, but we want to support
  // older compilers that don't have <regex> implemented (e.g. GCC < 4.9)
  auto pos1 = group_uri.find('@');
  auto pos2 = group_uri.find(':');
  auto last = std::string::npos;
  if (pos1 == last || pos2 == last || pos1 >= pos2)
    return make_error(sec::invalid_argument, "invalid URI format", group_uri);
  auto name = group_uri.substr(0, pos1);
  auto host = group_uri.substr(pos1 + 1, pos2 - pos1 - 1);
  auto port = static_cast<uint16_t>(std::stoi(group_uri.substr(pos2 + 1)));
  return remote_group(name, host, port);
}

expected<group> middleman::remote_group(const std::string& group_identifier,
                                        const std::string& host, uint16_t port) {
  CAF_LOG_TRACE(CAF_ARG(group_identifier) << CAF_ARG(host) << CAF_ARG(port));
  auto group_server = remote_actor(host, port);
  if (!group_server)
    return std::move(group_server.error());
  scoped_actor self{system(), true};
  self->send(*group_server, get_atom::value, group_identifier);
  expected<group> result{sec::cannot_connect_to_node};
  self->receive(
    [&](group& grp) {
      result = std::move(grp);
    },
    [&](error& err) {
      result = std::move(err);
    }
  );
  return result;
}

strong_actor_ptr middleman::remote_lookup(atom_value name, const node_id& nid) {
  CAF_LOG_TRACE(CAF_ARG(name) << CAF_ARG(nid));
  if (system().node() == nid)
    return system().registry().get(name);
  auto basp = named_broker<basp_broker>(atom("BASP"));
  strong_actor_ptr result;
  scoped_actor self{system(), true};
  self->send(basp, forward_atom::value, nid, atom("ConfigServ"),
             make_message(get_atom::value, name));
  self->receive(
    [&](strong_actor_ptr& addr) {
      result = std::move(addr);
    },
    after(std::chrono::minutes(5)) >> [] {
      // nop
    }
  );
  return result;
}

void middleman::start() {
  CAF_LOG_TRACE("");
  // Create hooks.
  for (auto& f : system().config().hook_factories)
    hooks_.emplace_back(f(system_));
  // Launch backend.
  if (system_.config().middleman_detach_multiplexer)
    backend_supervisor_ = backend().make_supervisor();
  if (!backend_supervisor_) {
    // The only backend that returns a `nullptr` is the `test_multiplexer`
    // which does not have its own thread but uses the main thread instead.
    // Other backends can set `middleman_detach_multiplexer` to false to
    // suppress creation of the supervisor.
    backend().thread_id(std::this_thread::get_id());
  } else {
    std::atomic<bool> init_done{false};
    std::mutex mtx;
    std::condition_variable cv;
    thread_ = std::thread{[&,this] {
      CAF_SET_LOGGER_SYS(&system());
      system().thread_started();
      CAF_LOG_TRACE("");
      {
        std::unique_lock<std::mutex> guard{mtx};
        backend().thread_id(std::this_thread::get_id());
        init_done = true;
        cv.notify_one();
      }
      backend().run();
      system().thread_terminates();
    }};
    std::unique_lock<std::mutex> guard{mtx};
    while (init_done == false)
      cv.wait(guard);
  }
  // Spawn utility actors.
  auto basp = named_broker<basp_broker>(atom("BASP"));
  manager_ = make_middleman_actor(system(), basp);
  auto hdl = actor_cast<actor>(basp);
}

void middleman::stop() {
  CAF_LOG_TRACE("");
  backend().dispatch([=] {
    CAF_LOG_TRACE("");
    notify<hook::before_shutdown>();
    // managers_ will be modified while we are stopping each manager,
    // because each manager will call remove(...)
    for (auto& kvp : named_brokers_) {
      auto& hdl = kvp.second;
      auto ptr = static_cast<broker*>(actor_cast<abstract_actor*>(hdl));
      if (!ptr->getf(abstract_actor::is_terminated_flag)) {
        ptr->context(&backend());
        ptr->setf(abstract_actor::is_terminated_flag);
        ptr->finalize();
      }
    }
  });
  if (system_.config().middleman_detach_multiplexer) {
    backend_supervisor_.reset();
    if (thread_.joinable())
      thread_.join();
  } else {
    while (backend().try_run_once())
      ; // nop
  }
  hooks_.clear();
  named_brokers_.clear();
  scoped_actor self{system(), true};
  self->send_exit(manager_, exit_reason::kill);
  if (system().config().middleman_detach_utility_actors)
    self->wait_for(manager_);
  destroy(manager_);
}

void middleman::init(actor_system_config& cfg) {
  // never detach actors when using the testing multiplexer
  if (cfg.middleman_network_backend == atom("testing"))
    cfg.middleman_detach_utility_actors = false;
  // add remote group module to config
  struct remote_groups : group_module {
  public:
    remote_groups(middleman& parent)
        : group_module(parent.system(), "remote"),
          parent_(parent) {
      // nop
    }

    void stop() override {
      // nop
    }

    expected<group> get(const std::string& group_name) override {
      return parent_.remote_group(group_name);
    }

    error load(deserializer&, group&) override {
      // never called, because we hand out group instances of the local module
      return sec::no_such_group_module;
    }

  private:
    middleman& parent_;
  };
  auto gfactory = [=]() -> group_module* { return new remote_groups(*this); };
  cfg.group_module_factories.emplace_back(gfactory);
  // logging not available at this stage
  // add I/O-related types to config
  cfg.add_message_type<network::protocol>("@protocol")
     .add_message_type<network::address_listing>("@address_listing")
     .add_message_type<network::receive_buffer>("@receive_buffer")
     .add_message_type<new_data_msg>("@new_data_msg")
     .add_message_type<new_connection_msg>("@new_connection_msg")
     .add_message_type<acceptor_closed_msg>("@acceptor_closed_msg")
     .add_message_type<connection_closed_msg>("@connection_closed_msg")
     .add_message_type<accept_handle>("@accept_handle")
     .add_message_type<connection_handle>("@connection_handle")
     .add_message_type<connection_passivated_msg>("@connection_passivated_msg")
     .add_message_type<acceptor_passivated_msg>("@acceptor_passivated_msg");
  // compute and set ID for this network node
  node_id this_node{node_id::data::create_singleton()};
  system().node_.swap(this_node);
  // give config access to slave mode implementation
  cfg.slave_mode_fun = &middleman::exec_slave_mode;
}

actor_system::module::id_t middleman::id() const {
  return module::middleman;
}

void* middleman::subtype_ptr() {
  return this;
}

middleman::~middleman() {
  // nop
}

middleman_actor middleman::actor_handle() {
  return manager_;
}

int middleman::exec_slave_mode(actor_system&, const actor_system_config&) {
  // TODO
  return 0;
}

} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/network/multiplexer.hpp"
#include "caf/io/network/default_multiplexer.hpp" // default singleton

namespace caf {
namespace io {
namespace network {

multiplexer::multiplexer(actor_system* sys) : execution_unit(sys) {
  // nop
}

multiplexer_ptr multiplexer::make(actor_system& sys) {
  CAF_LOG_TRACE("");
  return multiplexer_ptr{new default_multiplexer(&sys)};
}

multiplexer_backend* multiplexer::pimpl() {
  return nullptr;
}

multiplexer::supervisor::~supervisor() {
  // nop
}

resumable::subtype_t multiplexer::runnable::subtype() const {
  return resumable::function_object;
}

void multiplexer::runnable::intrusive_ptr_add_ref_impl() {
  intrusive_ptr_add_ref(this);
}

void multiplexer::runnable::intrusive_ptr_release_impl() {
  intrusive_ptr_release(this);
}

} // namespace network
} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/basp/message_type.hpp"

#include "caf/detail/enum_to_string.hpp"

namespace caf {
namespace io {
namespace basp {

namespace {

const char* message_type_strings[] = {
  "server_handshake",
  "client_handshake",
  "dispatch_message",
  "announce_proxy_instance",
  "kill_proxy_instance",
  "heartbeat"
};

} // namespace <anonymous>

std::string to_string(message_type x) {
  return detail::enum_to_string(x, message_type_strings);
}

} // namespace basp
} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/datagram_servant.hpp"

#include "caf/logger.hpp"

namespace caf {
namespace io {

datagram_servant::datagram_servant(datagram_handle hdl)
  : datagram_servant_base(hdl) {
  // nop
}

datagram_servant::~datagram_servant() {
  // nop
}

message datagram_servant::detach_message() {
  return make_message(datagram_servant_closed_msg{hdls()});
}

bool datagram_servant::consume(execution_unit* ctx, datagram_handle hdl,
                               network::receive_buffer& buf) {
  CAF_ASSERT(ctx != nullptr);
  CAF_LOG_TRACE(CAF_ARG(buf.size()));
  if (detached()) {
    // we are already disconnected from the broker while the multiplexer
    // did not yet remove the socket, this can happen if an I/O event causes
    // the broker to call close_all() while the pollset contained
    // further activities for the broker
    return false;
  }
  // keep a strong reference to our parent until we leave scope
  // to avoid UB when becoming detached during invocation
  auto guard = parent_;
  msg().handle = hdl;
  auto& msg_buf = msg().buf;
  msg_buf.swap(buf);
  auto result = invoke_mailbox_element(ctx);
  // swap buffer back to stream and implicitly flush wr_buf()
  msg_buf.swap(buf);
  flush();
  return result;
}

void datagram_servant::datagram_sent(execution_unit* ctx, datagram_handle hdl,
                                     size_t written, std::vector<char> buffer) {
  CAF_LOG_TRACE(CAF_ARG(written));
  if (detached())
    return;
  using sent_t = datagram_sent_msg;
  using tmp_t = mailbox_element_vals<datagram_sent_msg>;
  tmp_t tmp{strong_actor_ptr{}, make_message_id(),
            mailbox_element::forwarding_stack{},
            sent_t{hdl, written, std::move(buffer)}};
  invoke_mailbox_element_impl(ctx, tmp);
}

void datagram_servant::io_failure(execution_unit* ctx, network::operation op) {
  CAF_LOG_TRACE(CAF_ARG(hdl()) << CAF_ARG(op));
  // keep compiler happy when compiling w/o logging
  static_cast<void>(op);
  detach(ctx, true);
}

} // namespace io
} // namespace caf

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/basp/instance.hpp"

#include "caf/streambuf.hpp"
#include "caf/binary_serializer.hpp"
#include "caf/binary_deserializer.hpp"
#include "caf/actor_system_config.hpp"

#include "caf/io/basp/version.hpp"

namespace caf {
namespace io {
namespace basp {

namespace {

struct seq_num_visitor {
  using result_type = uint16_t;
  seq_num_visitor(instance::callee& c) : cal(c) { }
  template <class T>
  result_type operator()(const T& hdl) {
    return cal.next_sequence_number(hdl);
  }
  instance::callee& cal;
};

} // namespace <anonymous>

instance::callee::callee(actor_system& sys, proxy_registry::backend& backend)
    : namespace_(sys, backend) {
  // nop
}

instance::callee::~callee() {
  // nop
}

instance::instance(abstract_broker* parent, callee& lstnr)
    : tbl_(parent),
      this_node_(parent->system().node()),
      callee_(lstnr) {
  CAF_ASSERT(this_node_ != none);
}

connection_state instance::handle(execution_unit* ctx,
                                  new_data_msg& dm, header& hdr,
                                  bool is_payload) {
  CAF_LOG_TRACE(CAF_ARG(dm) << CAF_ARG(is_payload));
  // function object providing cleanup code on errors
  auto err = [&]() -> connection_state {
    auto cb = make_callback([&](const node_id& nid) -> error {
      callee_.purge_state(nid);
      return none;
    });
    tbl_.erase_direct(dm.handle, cb);
    return close_connection;
  };
  std::vector<char>* payload = nullptr;
  if (is_payload) {
    payload = &dm.buf;
    if (payload->size() != hdr.payload_len) {
      CAF_LOG_WARNING("received invalid payload, expected"
                      << hdr.payload_len << "bytes, got" << payload->size());
      return err();
    }
  } else {
    binary_deserializer bd{ctx, dm.buf};
    auto e = bd(hdr);
    if (e || !valid(hdr)) {
      CAF_LOG_WARNING("received invalid header:" << CAF_ARG(hdr));
      return err();
    }
    if (hdr.payload_len > 0) {
      CAF_LOG_DEBUG("await payload before processing further");
      return await_payload;
    }
  }
  CAF_LOG_DEBUG(CAF_ARG(hdr));
  // needs forwarding?
  if (!is_handshake(hdr) && !is_heartbeat(hdr) && hdr.dest_node != this_node_) {
    CAF_LOG_DEBUG("forward message");
    auto path = lookup(hdr.dest_node);
    if (path) {
      binary_serializer bs{ctx, callee_.get_buffer(path->hdl)};
      auto e = bs(hdr);
      if (e)
        return err();
      if (payload != nullptr)
        bs.apply_raw(payload->size(), payload->data());
      flush(*path);
      notify<hook::message_forwarded>(hdr, payload);
    } else {
      CAF_LOG_INFO("cannot forward message, no route to destination");
      if (hdr.source_node != this_node_) {
        // TODO: signalize error back to sending node
        auto reverse_path = lookup(hdr.source_node);
        if (!reverse_path) {
          CAF_LOG_WARNING("cannot send error message: no route to source");
        } else {
          CAF_LOG_WARNING("not implemented yet: signalize forward failure");
        }
      } else {
        CAF_LOG_WARNING("lost packet with probably spoofed source");
      }
      notify<hook::message_forwarding_failed>(hdr, payload);
    }
    return await_header;
  }
  if (!handle(ctx, dm.handle, hdr, payload, true, none, none))
    return err();
  return await_header;
}

bool instance::handle(execution_unit* ctx, new_datagram_msg& dm,
                      endpoint_context& ep) {
  using itr_t = network::receive_buffer::iterator;
  // function object providing cleanup code on errors
  auto err = [&]() -> bool {
    auto cb = make_callback([&](const node_id& nid) -> error {
      callee_.purge_state(nid);
      return none;
    });
    tbl_.erase_direct(dm.handle, cb);
    return false;
  };
  // extract payload
  std::vector<char> pl_buf{std::move_iterator<itr_t>(std::begin(dm.buf) +
                                                     basp::header_size),
                           std::move_iterator<itr_t>(std::end(dm.buf))};
  // resize header
  dm.buf.resize(basp::header_size);
  // extract header
  binary_deserializer bd{ctx, dm.buf};
  auto e = bd(ep.hdr);
  if (e || !valid(ep.hdr)) {
    CAF_LOG_WARNING("received invalid header:" << CAF_ARG(ep.hdr));
    return err();
  }
  CAF_LOG_DEBUG(CAF_ARG(ep.hdr));
  std::vector<char>* payload = nullptr;
  if (ep.hdr.payload_len > 0) {
    payload = &pl_buf;
    if (payload->size() != ep.hdr.payload_len) {
      CAF_LOG_WARNING("received invalid payload");
      return err();
    }
  }
  // Handle ordering of datagrams.
  if (is_greater(ep.hdr.sequence_number, ep.seq_incoming)) {
    // Add early messages to the pending message buffer.
    auto s = ep.hdr.sequence_number;
    callee_.add_pending(ctx, ep, s, std::move(ep.hdr), std::move(pl_buf));
    return true;
  } else if (ep.hdr.sequence_number != ep.seq_incoming) {
    // Drop messages that arrive late.
    CAF_LOG_DEBUG("dropping message " << CAF_ARG(dm));
    return true;
  }
  // This is the expected message.
  ep.seq_incoming += 1;
  // TODO: add optional reliability here
  if (!is_handshake(ep.hdr) && !is_heartbeat(ep.hdr)
      && ep.hdr.dest_node != this_node_) {
    CAF_LOG_DEBUG("forward message");
    auto path = lookup(ep.hdr.dest_node);
    if (path) {
      binary_serializer bs{ctx, callee_.get_buffer(path->hdl)};
      auto ex = bs(ep.hdr);
      if (ex)
        return err();
      if (payload != nullptr)
        bs.apply_raw(payload->size(), payload->data());
      flush(*path);
      notify<hook::message_forwarded>(ep.hdr, payload);
    } else {
      CAF_LOG_INFO("cannot forward message, no route to destination");
      if (ep.hdr.source_node != this_node_) {
        // TODO: signalize error back to sending node
        auto reverse_path = lookup(ep.hdr.source_node);
        if (!reverse_path) {
          CAF_LOG_WARNING("cannot send error message: no route to source");
        } else {
          CAF_LOG_WARNING("not implemented yet: signalize forward failure");
        }
      } else {
        CAF_LOG_WARNING("lost packet with probably spoofed source");
      }
      notify<hook::message_forwarding_failed>(ep.hdr, payload);
    }
    return true;
  }
  if (!handle(ctx, dm.handle, ep.hdr, payload, false, ep, ep.local_port))
    return err();
  // See if the next message was delivered early and is already bufferd.
  if (!callee_.deliver_pending(ctx, ep, false))
    return err();
  return true;
};

void instance::handle_heartbeat(execution_unit* ctx) {
  CAF_LOG_TRACE("");
  for (auto& kvp: tbl_.direct_by_hdl_) {
    CAF_LOG_TRACE(CAF_ARG(kvp.first) << CAF_ARG(kvp.second));
    write_heartbeat(ctx, callee_.get_buffer(kvp.first),
                    kvp.second, visit(seq_num_visitor{callee_}, kvp.first));
    callee_.flush(kvp.first);
  }
}

optional<routing_table::route> instance::lookup(const node_id& target) {
  return tbl_.lookup(target);
}

void instance::flush(const routing_table::route& path) {
  callee_.flush(path.hdl);
}

void instance::write(execution_unit* ctx, const routing_table::route& r,
                     header& hdr, payload_writer* writer) {
  CAF_LOG_TRACE(CAF_ARG(hdr));
  CAF_ASSERT(hdr.payload_len == 0 || writer != nullptr);
  write(ctx, callee_.get_buffer(r.hdl), hdr, writer);
  flush(r);
}

void instance::add_published_actor(uint16_t port,
                                   strong_actor_ptr published_actor,
                                   std::set<std::string> published_interface) {
  CAF_LOG_TRACE(CAF_ARG(port) << CAF_ARG(published_actor)
                << CAF_ARG(published_interface));
  using std::swap;
  auto& entry = published_actors_[port];
  swap(entry.first, published_actor);
  swap(entry.second, published_interface);
  notify<hook::actor_published>(entry.first, entry.second, port);
}

size_t instance::remove_published_actor(uint16_t port,
                                        removed_published_actor* cb) {
  CAF_LOG_TRACE(CAF_ARG(port));
  auto i = published_actors_.find(port);
  if (i == published_actors_.end())
    return 0;
  if (cb != nullptr)
    (*cb)(i->second.first, i->first);
  published_actors_.erase(i);
  return 1;
}

size_t instance::remove_published_actor(const actor_addr& whom,
                                        uint16_t port,
                                        removed_published_actor* cb) {
  CAF_LOG_TRACE(CAF_ARG(whom) << CAF_ARG(port));
  size_t result = 0;
  if (port != 0) {
    auto i = published_actors_.find(port);
    if (i != published_actors_.end() && i->second.first == whom) {
      if (cb != nullptr)
        (*cb)(i->second.first, port);
      published_actors_.erase(i);
      result = 1;
    }
  } else {
    auto i = published_actors_.begin();
    while (i != published_actors_.end()) {
      if (i->second.first == whom) {
        if (cb != nullptr)
          (*cb)(i->second.first, i->first);
        i = published_actors_.erase(i);
        ++result;
      } else {
        ++i;
      }
    }
  }
  return result;
}

bool instance::is_greater(sequence_type lhs, sequence_type rhs,
                          sequence_type max_distance) {
  // distance between lhs and rhs is smaller than max_distance.
  return ((lhs > rhs) && (lhs - rhs <= max_distance)) ||
         ((lhs < rhs) && (rhs - lhs > max_distance));
}

bool instance::dispatch(execution_unit* ctx, const strong_actor_ptr& sender,
                        const std::vector<strong_actor_ptr>& forwarding_stack,
                        const strong_actor_ptr& receiver, message_id mid,
                        const message& msg) {
  CAF_LOG_TRACE(CAF_ARG(sender) << CAF_ARG(receiver)
                << CAF_ARG(mid) << CAF_ARG(msg));
  CAF_ASSERT(receiver && system().node() != receiver->node());
  auto path = lookup(receiver->node());
  if (!path) {
    notify<hook::message_sending_failed>(sender, receiver, mid, msg);
    return false;
  }
  auto writer = make_callback([&](serializer& sink) -> error {
    return sink(const_cast<std::vector<strong_actor_ptr>&>(forwarding_stack),
                const_cast<message&>(msg));
  });
  header hdr{message_type::dispatch_message, 0, 0, mid.integer_value(),
             sender ? sender->node() : this_node(), receiver->node(),
             sender ? sender->id() : invalid_actor_id, receiver->id(),
             visit(seq_num_visitor{callee_}, path->hdl)};
  write(ctx, callee_.get_buffer(path->hdl), hdr, &writer);
  flush(*path);
  notify<hook::message_sent>(sender, path->next_hop, receiver, mid, msg);
  return true;
}

void instance::write(execution_unit* ctx, buffer_type& buf,
                     header& hdr, payload_writer* pw) {
  CAF_LOG_TRACE(CAF_ARG(hdr));
  error err;
  if (pw != nullptr) {
    auto pos = buf.size();
    // write payload first (skip first 72 bytes and write header later)
    char placeholder[basp::header_size];
    buf.insert(buf.end(), std::begin(placeholder), std::end(placeholder));
    binary_serializer bs{ctx, buf};
    (*pw)(bs);
    auto plen = buf.size() - pos - basp::header_size;
    CAF_ASSERT(plen <= std::numeric_limits<uint32_t>::max());
    hdr.payload_len = static_cast<uint32_t>(plen);
    stream_serializer<charbuf> out{ctx, buf.data() + pos, basp::header_size};
    err = out(hdr);
  } else {
    binary_serializer bs{ctx, buf};
    err = bs(hdr);
  }
  if (err)
    CAF_LOG_ERROR(CAF_ARG(err));
}

void instance::write_server_handshake(execution_unit* ctx,
                                      buffer_type& out_buf,
                                      optional<uint16_t> port,
                                      uint16_t sequence_number) {
  CAF_LOG_TRACE(CAF_ARG(port));
  using namespace detail;
  published_actor* pa = nullptr;
  if (port) {
    auto i = published_actors_.find(*port);
    if (i != published_actors_.end())
      pa = &i->second;
  }
  CAF_LOG_DEBUG_IF(!pa && port, "no actor published");
  auto writer = make_callback([&](serializer& sink) -> error {
    auto& ref = callee_.system().config().middleman_app_identifier;
    auto e = sink(const_cast<std::string&>(ref));
    if (e)
      return e;
    if (pa != nullptr) {
      auto i = pa->first ? pa->first->id() : invalid_actor_id;
      return sink(i, pa->second);
    }
    auto aid = invalid_actor_id;
    std::set<std::string> tmp;
    return sink(aid, tmp);
  });
  header hdr{message_type::server_handshake, 0, 0, version,
             this_node_, none,
             (pa != nullptr) && pa->first ? pa->first->id() : invalid_actor_id,
             invalid_actor_id, sequence_number};
  write(ctx, out_buf, hdr, &writer);
}

void instance::write_client_handshake(execution_unit* ctx,
                                      buffer_type& buf,
                                      const node_id& remote_side,
                                      const node_id& this_node,
                                      const std::string& app_identifier,
                                      uint16_t sequence_number) {
  CAF_LOG_TRACE(CAF_ARG(remote_side));
  auto writer = make_callback([&](serializer& sink) -> error {
    return sink(const_cast<std::string&>(app_identifier));
  });
  header hdr{message_type::client_handshake, 0, 0, 0,
             this_node, remote_side, invalid_actor_id, invalid_actor_id,
             sequence_number};
  write(ctx, buf, hdr, &writer);
}

void instance::write_client_handshake(execution_unit* ctx,
                                      buffer_type& buf,
                                      const node_id& remote_side,
                                      uint16_t sequence_number) {
  write_client_handshake(ctx, buf, remote_side, this_node_,
                         callee_.system().config().middleman_app_identifier,
                         sequence_number);
}

void instance::write_announce_proxy(execution_unit* ctx, buffer_type& buf,
                                    const node_id& dest_node, actor_id aid,
                                    uint16_t sequence_number) {
  CAF_LOG_TRACE(CAF_ARG(dest_node) << CAF_ARG(aid));
  header hdr{message_type::announce_proxy, 0, 0, 0,
             this_node_, dest_node, invalid_actor_id, aid,
             sequence_number};
  write(ctx, buf, hdr);
}

void instance::write_kill_proxy(execution_unit* ctx, buffer_type& buf,
                                const node_id& dest_node, actor_id aid,
                                const error& rsn, uint16_t sequence_number) {
  CAF_LOG_TRACE(CAF_ARG(dest_node) << CAF_ARG(aid) << CAF_ARG(rsn));
  auto writer = make_callback([&](serializer& sink) -> error {
    return sink(const_cast<error&>(rsn));
  });
  header hdr{message_type::kill_proxy, 0, 0, 0,
             this_node_, dest_node, aid, invalid_actor_id,
             sequence_number};
  write(ctx, buf, hdr, &writer);
}

void instance::write_heartbeat(execution_unit* ctx,
                               buffer_type& buf,
                               const node_id& remote_side,
                               uint16_t sequence_number) {
  CAF_LOG_TRACE(CAF_ARG(remote_side));
  header hdr{message_type::heartbeat, 0, 0, 0,
             this_node_, remote_side, invalid_actor_id, invalid_actor_id,
             sequence_number};
  write(ctx, buf, hdr);
}

} // namespace basp
} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/network/interfaces.hpp"

#include "caf/config.hpp"

#include <cerrno>
#include <cstdlib>
#include <cstring>
#include <algorithm>

#ifdef CAF_WINDOWS
# ifndef _WIN32_WINNT
#   define _WIN32_WINNT 0x0600
# endif
# include <iostream>
# include <winsock2.h>
# include <ws2tcpip.h>
# include <iphlpapi.h>
#else
# include <sys/socket.h>
# include <netinet/in.h>
# include <net/if.h>
# include <unistd.h>
# include <netdb.h>
# include <ifaddrs.h>
# include <sys/ioctl.h>
# include <arpa/inet.h>
#endif

#include <memory>
#include <utility>

#include "caf/detail/get_mac_addresses.hpp"

#include "caf/io/network/ip_endpoint.hpp"

namespace caf {
namespace io {
namespace network {

// {interface_name => {protocol => address}}
using interfaces_map = std::map<std::string,
                                std::map<protocol::network,
                                         std::vector<std::string>>>;

template <class T>
void* vptr(T* ptr) {
  return static_cast<void*>(ptr);
}

void* fetch_in_addr(int family, sockaddr* addr) {
  if (family == AF_INET)
    return vptr(&reinterpret_cast<sockaddr_in*>(addr)->sin_addr);
  return vptr(&reinterpret_cast<sockaddr_in6*>(addr)->sin6_addr);
}

int fetch_addr_str(bool get_ipv4, bool get_ipv6,
                   char (&buf)[INET6_ADDRSTRLEN],
                   sockaddr* addr) {
  if (addr == nullptr)
    return AF_UNSPEC;
  auto family = addr->sa_family;
  auto in_addr = fetch_in_addr(family, addr);
  return ((family == AF_INET && get_ipv4) || (family == AF_INET6 && get_ipv6))
         && inet_ntop(family, in_addr, buf, INET6_ADDRSTRLEN) == buf
         ? family
         : AF_UNSPEC;
}

#ifdef CAF_WINDOWS

// F consumes `{interface_name, protocol, is_localhost, address}` entries.
template <class F>
void for_each_address(bool get_ipv4, bool get_ipv6, F fun) {
  ULONG tmp_size = 16 * 1024; // try 16kb buffer first
  IP_ADAPTER_ADDRESSES* tmp = nullptr;
  constexpr size_t max_tries = 3;
  size_t try_nr = 0;
  int retval = 0;
  do {
    if (tmp)
      free(tmp);
    tmp = reinterpret_cast<IP_ADAPTER_ADDRESSES*>(malloc(tmp_size));
    if (!tmp)
      CAF_RAISE_ERROR("malloc() failed");
    retval = GetAdaptersAddresses(AF_UNSPEC, GAA_FLAG_INCLUDE_PREFIX,
                                  nullptr, tmp, &tmp_size);
  } while (retval == ERROR_BUFFER_OVERFLOW && ++try_nr < max_tries);
  std::unique_ptr<IP_ADAPTER_ADDRESSES, decltype(free)*> ifs{tmp, free};
  if (retval != NO_ERROR) {
    std::cerr << "Call to GetAdaptersAddresses failed with error: "
              << retval << std::endl;
    if (retval == ERROR_NO_DATA) {
      std::cerr << "No addresses were found for the requested parameters"
                << std::endl;
    } else {
      void* msgbuf = nullptr;
      if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_SYSTEM
                        | FORMAT_MESSAGE_IGNORE_INSERTS,
                        nullptr, retval,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPTSTR) &msgbuf, 0, nullptr)) {
        printf("Error: %s", static_cast<char*>(msgbuf));
        LocalFree(msgbuf);
      }
    }
    return;
  }
  char buffer[INET6_ADDRSTRLEN];
  for (auto i = ifs.get(); i != nullptr; i = i->Next) {
    for (auto j = i->FirstUnicastAddress; j != nullptr; j = j->Next) {
      auto addr = j->Address.lpSockaddr;
      auto family = fetch_addr_str(get_ipv4, get_ipv6, buffer, addr);
      if (family != AF_UNSPEC)
        fun(i->AdapterName, family == AF_INET ? protocol::ipv4 : protocol::ipv6,
            false, buffer);
    }
  }
}

#else // ifdef CAF_WINDOWS

// F consumes `{interface_name, protocol, is_localhost, address}` entries.
template <class F>
void for_each_address(bool get_ipv4, bool get_ipv6, F fun) {
  ifaddrs* tmp = nullptr;
  if (getifaddrs(&tmp) != 0) {
    perror("getifaddrs");
    return;
  }
  char buffer[INET6_ADDRSTRLEN];
  std::unique_ptr<ifaddrs, decltype(freeifaddrs)*> ifs{tmp, freeifaddrs};
  for (auto i = ifs.get(); i != nullptr; i = i->ifa_next) {
    auto family = fetch_addr_str(get_ipv4, get_ipv6, buffer, i->ifa_addr);
    if (family != AF_UNSPEC)
      fun(i->ifa_name, family == AF_INET ? protocol::ipv4 : protocol::ipv6,
          (i->ifa_flags & IFF_LOOPBACK) != 0,
          buffer);
  }
}

#endif // ifdef CAF_WINDOWS

namespace {

template <class F>
void traverse_impl(std::initializer_list<protocol::network> ps, F f) {
  auto get_ipv4 = std::find(ps.begin(), ps.end(), protocol::ipv4) != ps.end();
  auto get_ipv6 = std::find(ps.begin(), ps.end(), protocol::ipv6) != ps.end();
  for_each_address(get_ipv4, get_ipv6, f);
}

} // namespace <anonymous>

void interfaces::traverse(std::initializer_list<protocol::network> ps,
                          consumer f) {
  traverse_impl(ps, std::move(f));
}

void interfaces::traverse(consumer f) {
  traverse_impl({protocol::ipv4, protocol::ipv6}, std::move(f));
}

interfaces_map interfaces::list_all(bool include_localhost) {
  interfaces_map result;
  traverse_impl(
    {protocol::ipv4, protocol::ipv6},
    [&](const char* name, protocol::network p, bool lo, const char* addr) {
      if (include_localhost || !lo)
        result[name][p].emplace_back(addr);
    });
  return result;
}

std::map<protocol::network, std::vector<std::string>>
interfaces::list_addresses(bool include_localhost) {
  std::map<protocol::network, std::vector<std::string>> result;
  traverse_impl(
    {protocol::ipv4, protocol::ipv6},
    [&](const char*, protocol::network p, bool lo, const char* addr) {
      if (include_localhost || !lo)
        result[p].emplace_back(addr);
    });
  return result;
}

std::vector<std::string>
interfaces::list_addresses(std::initializer_list<protocol::network> procs,
                           bool include_localhost) {
  std::vector<std::string> result;
  traverse_impl(procs,
                [&](const char*, protocol::network, bool lo, const char* addr) {
                  if (include_localhost || !lo)
                    result.emplace_back(addr);
                });
  return result;
}

std::vector<std::string> interfaces::list_addresses(protocol::network proc,
                                                    bool include_localhost) {
  return list_addresses({proc}, include_localhost);
}

optional<std::pair<std::string, protocol::network>>
interfaces::native_address(const std::string& host,
                           optional<protocol::network> preferred) {
  addrinfo hint;
  memset(&hint, 0, sizeof(hint));
  hint.ai_socktype = SOCK_STREAM;
  if (preferred)
    hint.ai_family = *preferred == protocol::ipv4 ? AF_INET : AF_INET6;
  addrinfo* tmp = nullptr;
  if (getaddrinfo(host.c_str(), nullptr, &hint, &tmp) != 0)
    return none;
  std::unique_ptr<addrinfo, decltype(freeaddrinfo)*> addrs{tmp, freeaddrinfo};
  char buffer[INET6_ADDRSTRLEN];
  for (auto i = addrs.get(); i != nullptr; i = i->ai_next) {
    auto family = fetch_addr_str(true, true, buffer, i->ai_addr);
    if (family != AF_UNSPEC)
      return std::make_pair(buffer, family == AF_INET ? protocol::ipv4
                                                      : protocol::ipv6);
  }
  return none;
}

std::vector<std::pair<std::string, protocol::network>>
interfaces::server_address(uint16_t port, const char* host,
                           optional<protocol::network> preferred) {
  using addr_pair = std::pair<std::string, protocol::network>;
  addrinfo hint;
  memset(&hint, 0, sizeof(hint));
  hint.ai_socktype = SOCK_STREAM;
  if (preferred)
    hint.ai_family = *preferred == protocol::ipv4 ? AF_INET : AF_INET6;
  else
    hint.ai_family = AF_UNSPEC;
  if (host == nullptr)
    hint.ai_flags = AI_PASSIVE;
  auto port_str = std::to_string(port);
  addrinfo* tmp = nullptr;
  if (getaddrinfo(host, port_str.c_str(), &hint, &tmp) != 0)
    return {};
  std::unique_ptr<addrinfo, decltype(freeaddrinfo)*> addrs{tmp, freeaddrinfo};
  char buffer[INET6_ADDRSTRLEN];
  // Take the first ipv6 address or the first available address otherwise
  std::vector<addr_pair> results;
  for (auto i = addrs.get(); i != nullptr; i = i->ai_next) {
    auto family = fetch_addr_str(true, true, buffer, i->ai_addr);
    if (family != AF_UNSPEC) {
      results.emplace_back(std::string{buffer},
                           family == AF_INET ? protocol::ipv4
                                             : protocol::ipv6);
    }
  }
  std::stable_sort(std::begin(results), std::end(results),
                   [](const addr_pair& lhs, const addr_pair& rhs) {
                     return lhs.second > rhs.second;
                   });
  return results;
}

bool interfaces::get_endpoint(const std::string& host, uint16_t port,
                              ip_endpoint& ep,
                              optional<protocol::network> preferred) {
  static_assert(sizeof(uint16_t) == sizeof(unsigned short int),
                "uint16_t cannot be printed with %hu in snprintf");
  addrinfo hint;
  // max port is 2^16 which needs 5 characters plus null terminator
  char port_hint[6];
  sprintf(port_hint, "%hu", port);
  memset(&hint, 0, sizeof(hint));
  hint.ai_socktype = SOCK_DGRAM;
  if (preferred)
    hint.ai_family = *preferred == protocol::network::ipv4 ? AF_INET : AF_INET6;
  if (hint.ai_family == AF_INET6)
    hint.ai_flags = AI_V4MAPPED;
  addrinfo* tmp = nullptr;
  if (getaddrinfo(host.c_str(), port_hint, &hint, &tmp) != 0)
    return false;
  std::unique_ptr<addrinfo, decltype(freeaddrinfo)*> addrs{tmp, freeaddrinfo};
  for (auto i = addrs.get(); i != nullptr; i = i->ai_next) {
    if (i->ai_family != AF_UNSPEC) {
      memcpy(ep.address(), i->ai_addr, i->ai_addrlen);
      *ep.length() = i->ai_addrlen;
      return true;
    }
  }
  return false;
}

} // namespace network
} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/network/acceptor_manager.hpp"

namespace caf {
namespace io {
namespace network {

acceptor_manager::~acceptor_manager() {
  // nop
}

} // namespace network
} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/network/datagram_manager.hpp"

namespace caf {
namespace io {
namespace network {

datagram_manager::~datagram_manager() {
  // nop
}

} // namespace network
} // namespace io
} // namespace caf

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/network/manager.hpp"

#include "caf/logger.hpp"

#include "caf/io/abstract_broker.hpp"

namespace caf {
namespace io {
namespace network {

manager::manager() : parent_(nullptr) {
  // nop
}

manager::~manager() {
  // nop
}

void manager::set_parent(abstract_broker* ptr) {
  parent_ = ptr != nullptr ? ptr->ctrl() : nullptr;
}

abstract_broker* manager::parent() {
  return parent_ ? static_cast<abstract_broker*>(parent_->get()) : nullptr;
}

void manager::detach(execution_unit*, bool invoke_disconnect_message) {
  CAF_LOG_TRACE("");
  if (!detached()) {
    CAF_LOG_DEBUG("disconnect servant from broker");
    auto raw_ptr = parent();
    // keep the strong reference until we go out of scope
    strong_actor_ptr ptr;
    ptr.swap(parent_);
    detach_from(raw_ptr);
    if (invoke_disconnect_message) {
      auto mptr = make_mailbox_element(nullptr, invalid_message_id,
                                       {}, detach_message());
      switch (raw_ptr->consume(*mptr)) {
        case im_success:
          raw_ptr->finalize();
          break;
        case im_skipped:
          raw_ptr->push_to_cache(std::move(mptr));
          break;
        case im_dropped:
          CAF_LOG_INFO("broker dropped disconnect message");
          break;
      }
    }
  }
}

} // namespace network
} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE io_http_broker
#include "caf/test/unit_test.hpp"

#include <cassert>
#include <algorithm>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

using std::cout;
using std::cerr;
using std::endl;

using namespace caf;
using namespace caf::io;

namespace {

constexpr char http_valid_get[] = "GET / HTTP/1.1";

constexpr char http_get[] = "GET / HTTP/1.1\r\n"
                            "Host: localhost\r\n"
                            "Connection: close\r\n"
                            "Accept: text/plain\r\n"
                            "User-Agent: CAF/0.14\r\n"
                            "Accept-Language: en-US\r\n"
                            "\r\n";

constexpr char http_ok[] = "HTTP/1.1 200 OK\r\n"
                           "Content-Type: text/plain\r\n"
                           "Connection: close\r\n"
                           "Transfer-Encoding: chunked\r\n"
                           "\r\n"
                           "d\r\n"
                           "Hi there! :)\r\n"
                           "\r\n"
                           "0\r\n"
                           "\r\n"
                           "\r\n";

constexpr char http_error[] = "HTTP/1.1 404 Not Found\r\n"
                              "Connection: close\r\n"
                              "\r\n";

constexpr char newline[2] = {'\r', '\n'};

enum parser_state {
  receive_new_line,
  receive_continued_line,
  receive_second_newline_half
};

struct http_state {
  http_state(abstract_broker* self) : self_(self) {
    // nop
  }

  ~http_state() {
    aout(self_) << "http worker is destroyed";
  }

  std::vector<std::string> lines;
  parser_state ps = receive_new_line;
  abstract_broker* self_;
};

using http_broker = caf::stateful_actor<http_state, broker>;

behavior http_worker(http_broker* self, connection_handle hdl) {
  // tell network backend to receive any number of bytes between 1 and 1024
  self->configure_read(hdl, receive_policy::at_most(1024));
  return {
    [=](const new_data_msg& msg) {
      assert(!msg.buf.empty());
      assert(msg.handle == hdl);
      // extract lines from received buffer
      auto& lines = self->state.lines;
      auto i = msg.buf.begin();
      auto e = msg.buf.end();
      // search position of first newline in data chunk
      auto nl = std::search(i, e, std::begin(newline), std::end(newline));
      // store whether we are continuing a previously started line
      auto append_to_last_line = self->state.ps == receive_continued_line;
      // check whether our last chunk ended between \r and \n
      if (self->state.ps == receive_second_newline_half) {
        if (msg.buf.front() == '\n') {
          // simply skip this character
          ++i;
        }
      }
      // read line by line from our data chunk
      do {
        if (append_to_last_line) {
          append_to_last_line = false;
          auto& back = lines.back();
          back.insert(back.end(), i, nl);
        } else {
          lines.emplace_back(i, nl);
        }
        // if our last search didn't found a newline, we're done
        if (nl != e) {
          // skip newline and seek the next one
          i = nl + sizeof(newline);
          nl = std::search(i, e, std::begin(newline), std::end(newline));
        }
      } while (nl != e);
      // store current state of our parser
      if (msg.buf.back() == '\r') {
        self->state.ps = receive_second_newline_half;
        self->state.lines.pop_back(); // drop '\r' from our last read line
      } else if (msg.buf.back() == '\n') {
        self->state.ps = receive_new_line; // we've got a clean cut
      } else {
        self->state.ps = receive_continued_line; // interrupted in the middle
      }
      // we don't need to check for completion in any intermediate state
      if (self->state.ps != receive_new_line)
        return;
      // we have received the HTTP header if we have an empty line at the end
      if (lines.size() > 1 && lines.back().empty()) {
        auto& out = self->wr_buf(hdl);
        // we only look at the first line in our example and reply with our
        // OK message if we receive exactly "GET / HTTP/1.1", otherwise
        // we send a 404 HTTP response
        if (lines.front() == http_valid_get)
          out.insert(out.end(), std::begin(http_ok), std::end(http_ok));
        else
          out.insert(out.end(), std::begin(http_error), std::end(http_error));
        // write data and close connection
        self->flush(hdl);
        self->quit();
      }
    },
    [=](const connection_closed_msg&) {
      self->quit();
    }
  };
}

behavior server(broker* self) {
  CAF_MESSAGE("server up and running");
  return {
    [=](const new_connection_msg& ncm) {
      CAF_MESSAGE("fork on new connection");
      self->fork(http_worker, ncm.handle);
    }
  };
}


class fixture {
public:
  fixture() : system(cfg.load<io::middleman, network::test_multiplexer>()) {
    mpx_ = dynamic_cast<network::test_multiplexer*>(&system.middleman().backend());
    CAF_REQUIRE(mpx_ != nullptr);
    // spawn the actor-under-test
    aut_ = system.middleman().spawn_broker(server);
    // assign the acceptor handle to the AUT
    aut_ptr_ = static_cast<abstract_broker*>(actor_cast<abstract_actor*>(aut_));
    aut_ptr_->add_doorman(mpx_->new_doorman(acceptor_, 1u));
    // "open" a new connection to our server
    mpx_->add_pending_connect(acceptor_, connection_);
    mpx_->accept_connection(acceptor_);
  }

  ~fixture() {
    anon_send_exit(aut_, exit_reason::kill);
    // run the exit message and other pending messages explicitly,
    // since we do not invoke any "I/O" from this point on that would
    // trigger the exit message implicitly
    mpx_->flush_runnables();
  }

  // helper class for a nice-and-easy "mock(...).expect(...)" syntax
  class mock_t {
  public:
    mock_t(fixture* thisptr) : this_(thisptr) {
      // nop
    }

    mock_t(const mock_t&) = default;

    mock_t& expect(const std::string& x) {
      auto& buf = this_->mpx_->output_buffer(this_->connection_);
      CAF_REQUIRE((buf.size() >= x.size()));
      CAF_REQUIRE((std::equal(buf.begin(),
                              buf.begin() + static_cast<ptrdiff_t>(x.size()),
                              x.begin())));
      buf.erase(buf.begin(), buf.begin() + static_cast<ptrdiff_t>(x.size()));
      return *this;
    }

    fixture* this_;
  };

  // mocks some input for our AUT and allows to
  // check the output for this operation
  mock_t mock(const char* what) {
    std::vector<char> buf;
    for (char c = *what++; c != '\0'; c = *what++)
      buf.push_back(c);
    mpx_->virtual_send(connection_, std::move(buf));
    return {this};
  }

  actor_system_config cfg;
  actor_system system;
  actor aut_;
  abstract_broker* aut_ptr_;
  network::test_multiplexer* mpx_;
  accept_handle acceptor_ = accept_handle::from_int(1);
  connection_handle connection_ = connection_handle::from_int(1);
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(http_tests, fixture)

CAF_TEST(valid_response) {
  // write a GET message and expect an OK message as result
  mock(http_get).expect(http_ok);
}

CAF_TEST(invalid_response) {
  // write a GET with invalid path and expect a 404 message as result
  mock("GET /kitten.gif HTTP/1.1\r\n\r\n").expect(http_error);
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE io_typed_broker
#include "caf/test/unit_test.hpp"

#include <memory>
#include <iostream>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

#include "caf/string_algorithms.hpp"

using namespace std;
using namespace caf;
using namespace caf::io;

namespace {

using publish_atom = atom_constant<atom("publish")>;
using ping_atom = caf::atom_constant<atom("ping")>;
using pong_atom = caf::atom_constant<atom("pong")>;
using kickoff_atom = caf::atom_constant<atom("kickoff")>;

using peer = connection_handler::extend<reacts_to<ping_atom, int>,
                                        reacts_to<pong_atom, int>>;

using acceptor = accept_handler::extend<replies_to<publish_atom>::with<uint16_t>>;

using ping_actor = typed_actor<replies_to<pong_atom, int>::with<ping_atom, int>>;

using pong_actor = typed_actor<replies_to<ping_atom, int>::with<pong_atom, int>>;

behavior ping(event_based_actor* self, size_t num_pings) {
  CAF_MESSAGE("num_pings: " << num_pings);
  auto count = std::make_shared<size_t>(0);
  return {
    [=](kickoff_atom, const peer& pong) {
      CAF_MESSAGE("received `kickoff_atom`");
      self->send(pong, ping_atom::value, 1);
      self->become(
        [=](pong_atom, int value) -> std::tuple<ping_atom, int> {
          if (++*count >= num_pings) {
            CAF_MESSAGE("received " << num_pings
                        << " pings, call self->quit");
            self->quit();
          }
          return std::make_tuple(ping_atom::value, value + 1);
        }
      );
    }
  };
}

behavior pong(event_based_actor* self) {
  CAF_MESSAGE("pong actor started");
  self->set_down_handler([=](down_msg& dm) {
    CAF_MESSAGE("received: " << to_string(dm.reason));
    self->quit(dm.reason);
  });
  return {
    [=](ping_atom, int value) -> std::tuple<atom_value, int> {
      CAF_MESSAGE("received: 'ping', " << value);
      self->monitor(self->current_sender());
      // set next behavior
      self->become(
        [](ping_atom, int val) {
          //CAF_MESSAGE("received: 'ping', " << val);
          return std::make_tuple(pong_atom::value, val);
        }
      );
      // reply to 'ping'
      return std::make_tuple(pong_atom::value, value);
    }
  };
}

peer::behavior_type peer_fun(peer::broker_pointer self, connection_handle hdl,
                             const actor& buddy) {
  CAF_MESSAGE("peer_fun called");
  self->monitor(buddy);
  // assume exactly one connection
  CAF_REQUIRE_EQUAL(self->connections().size(), 1u);
  self->configure_read(
    hdl, receive_policy::exactly(sizeof(atom_value) + sizeof(int)));
  auto write = [=](atom_value x, int y) {
    auto& buf = self->wr_buf(hdl);
    binary_serializer sink{self->system(), buf};
    auto e = sink(x, y);
    CAF_REQUIRE(!e);
    self->flush(hdl);
  };
  self->set_down_handler([=](down_msg& dm) {
    CAF_MESSAGE("received down_msg");
    if (dm.source == buddy)
      self->quit(std::move(dm.reason));
  });
  return {
    [=](const connection_closed_msg&) {
      CAF_MESSAGE("received connection_closed_msg");
      self->quit();
    },
    [=](const new_data_msg& msg) {
      CAF_MESSAGE("received new_data_msg");
      atom_value x;
      int y;
      binary_deserializer source{self->system(), msg.buf};
      auto e = source(x, y);
      CAF_REQUIRE(!e);
      if (x == pong_atom::value)
        self->send(actor_cast<ping_actor>(buddy), pong_atom::value, y);
      else
        self->send(actor_cast<pong_actor>(buddy), ping_atom::value, y);
    },
    [=](ping_atom, int value) {
      CAF_MESSAGE("received: 'ping', " << value);
      write(ping_atom::value, value);
    },
    [=](pong_atom, int value) {
      CAF_MESSAGE("received: 'pong', " << value);
      write(pong_atom::value, value);
    }
  };
}

acceptor::behavior_type acceptor_fun(acceptor::broker_pointer self,
                                     const actor& buddy) {
  CAF_MESSAGE("peer_acceptor_fun");
  return {
    [=](const new_connection_msg& msg) {
      CAF_MESSAGE("received `new_connection_msg`");
      self->fork(peer_fun, msg.handle, buddy);
      self->quit();
    },
    [](const acceptor_closed_msg&) {
      // nop
    },
    [=](publish_atom) -> expected<uint16_t> {
      auto dm = self->add_tcp_doorman(0, "127.0.0.1");
      if (dm)
        return get<1>(*dm);
      return std::move(dm.error());
    }
  };
}

void run_client(int argc, char** argv, uint16_t port) {
  actor_system_config cfg;
  actor_system system{cfg.load<io::middleman>().parse(argc, argv)};
  auto p = system.spawn(ping, size_t{10});
  CAF_MESSAGE("spawn_client_typed...");
  CAF_EXP_THROW(cl, system.middleman().spawn_client(peer_fun, "localhost",
                                                    port, p));
  CAF_MESSAGE("spawn_client_typed finished");
  anon_send(p, kickoff_atom::value, cl);
  CAF_MESSAGE("`kickoff_atom` has been send");
}

void run_server(int argc, char** argv) {
  actor_system_config cfg;
  actor_system system{cfg.load<io::middleman>().parse(argc, argv)};
  scoped_actor self{system};
  auto serv = system.middleman().spawn_broker(acceptor_fun, system.spawn(pong));
  std::thread child;
  self->request(serv, infinite, publish_atom::value).receive(
    [&](uint16_t port) {
      CAF_MESSAGE("server is running on port " << port);
      child = std::thread([=] {
        run_client(argc, argv, port);
      });
    },
    [&](error& err) {
      CAF_FAIL("error: " << system.render(err));
    }
  );
  self->await_all_other_actors_done();
  CAF_MESSAGE("wait for client system");
  child.join();
}

} // namespace <anonymous>

CAF_TEST(test_typed_broker) {
  auto argc = test::engine::argc();
  auto argv = test::engine::argv();
  run_server(argc, argv);
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <vector>

#include "caf/config.hpp"

#define CAF_SUITE io_ip_endpoint
#include "caf/test/unit_test.hpp"

#include "caf/actor_system.hpp"
#include "caf/actor_system_config.hpp"
#include "caf/binary_serializer.hpp"
#include "caf/binary_deserializer.hpp"

#include "caf/io/middleman.hpp"
#include "caf/io/network/interfaces.hpp"
#include "caf/io/network/ip_endpoint.hpp"

using namespace caf;
using namespace caf::io;

namespace {

class config : public actor_system_config {
public:
  config() {
    // this will call WSAStartup for network initialization on Windows
    load<io::middleman>();
  }
};

struct fixture {

template <class T, class... Ts>
std::vector<char> serialize(T& x, Ts&... xs) {
  std::vector<char> buf;
  binary_serializer bs{&context, buf};
  bs(x, xs...);
  return buf;
}

template <class T, class... Ts>
void deserialize(const std::vector<char>& buf, T& x, Ts&... xs) {
  binary_deserializer bd{&context, buf};
  bd(x, xs...);
}

fixture() : cfg(), system(cfg), context(&system) {

}

config cfg;
actor_system system;
scoped_execution_unit context;

};

} // namespace anonymous

CAF_TEST_FIXTURE_SCOPE(ep_endpoint_tests, fixture)

CAF_TEST(ip_endpoint) {
  // create an empty endpoint
  network::ip_endpoint ep;
  ep.clear();
  CAF_CHECK_EQUAL("", network::host(ep));
  CAF_CHECK_EQUAL(uint16_t{0}, network::port(ep));
  CAF_CHECK_EQUAL(size_t{0}, *ep.length());
  // fill it with data from a local endpoint
  network::interfaces::get_endpoint("localhost", 12345, ep);
  // save the data
  auto h = network::host(ep);
  auto p = network::port(ep);
  auto l = *ep.length();
  CAF_CHECK("localhost" == h || "127.0.0.1" == h || "::1" == h);
  CAF_CHECK_EQUAL(12345, p);
  CAF_CHECK(0 < l);
  // serialize the endpoint and clear it
  std::vector<char> buf = serialize(ep);
  auto save = ep;
  ep.clear();
  CAF_CHECK_EQUAL("", network::host(ep));
  CAF_CHECK_EQUAL(uint16_t{0}, network::port(ep));
  CAF_CHECK_EQUAL(size_t{0}, *ep.length());
  // deserialize the data and check if it was load successfully
  deserialize(buf, ep);
  CAF_CHECK_EQUAL(h, network::host(ep));
  CAF_CHECK_EQUAL(uint16_t{p}, network::port(ep));
  CAF_CHECK_EQUAL(size_t{l}, *ep.length());
  CAF_CHECK_EQUAL(save, ep);
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE io_dynamic_remote_actor_udp
#include "caf/test/unit_test.hpp"

#include <vector>
#include <sstream>
#include <utility>
#include <algorithm>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

using namespace caf;

namespace {

constexpr char local_host[] = "127.0.0.1";

class config : public actor_system_config {
public:
  config() {
    load<io::middleman>();
    set("middleman.enable-udp", true);
    add_message_type<std::vector<int>>("std::vector<int>");
    actor_system_config::parse(test::engine::argc(),
                               test::engine::argv());
  }
};

struct fixture {
  config server_side_config;
  actor_system server_side{server_side_config};
  config client_side_config;
  actor_system client_side{client_side_config};
  io::middleman& server_side_mm = server_side.middleman();
  io::middleman& client_side_mm = client_side.middleman();
};

behavior make_pong_behavior() {
  return {
    [](int val) -> int {
      ++val;
      CAF_MESSAGE("pong with " << val);
      return val;
    }
  };
}

behavior make_ping_behavior(event_based_actor* self, const actor& pong) {
  CAF_MESSAGE("ping with " << 0);
  self->send(pong, 0);
  return {
    [=](int val) -> int {
      if (val == 3) {
        CAF_MESSAGE("ping with exit");
        self->send_exit(self->current_sender(),
                        exit_reason::user_shutdown);
        CAF_MESSAGE("ping quits");
        self->quit();
      }
      CAF_MESSAGE("ping with " << val);
      return val;
    }
  };
}

behavior make_sort_behavior() {
  return {
    [](std::vector<int>& vec) -> std::vector<int> {
      CAF_MESSAGE("sorter received: " << deep_to_string(vec));
      std::sort(vec.begin(), vec.end());
      CAF_MESSAGE("sorter sent: " << deep_to_string(vec));
      return std::move(vec);
    }
  };
}

behavior make_sort_requester_behavior(event_based_actor* self,
                                      const actor& sorter) {
  self->send(sorter, std::vector<int>{5, 4, 3, 2, 1});
  return {
    [=](const std::vector<int>& vec) {
      CAF_MESSAGE("sort requester received: " << deep_to_string(vec));
      std::vector<int> expected_vec{1, 2, 3, 4, 5};
      CAF_CHECK_EQUAL(vec, expected_vec);
      self->send_exit(sorter, exit_reason::user_shutdown);
      self->quit();
    }
  };
}

behavior fragile_mirror(event_based_actor* self) {
  return {
    [=](int i) {
      self->quit(exit_reason::user_shutdown);
      return i;
    }
  };
}

behavior linking_actor(event_based_actor* self, const actor& buddy) {
  CAF_MESSAGE("link to mirror and send dummy message");
  self->link_to(buddy);
  self->send(buddy, 42);
  return {
    [](int i) {
      CAF_CHECK_EQUAL(i, 42);
    }
  };
}

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(dynamic_remote_actor_tests_udp, fixture)

CAF_TEST(identity_semantics_udp) {
  // server side
  auto server = server_side.spawn(make_pong_behavior);
  CAF_EXP_THROW(port1, server_side_mm.publish_udp(server, 0, local_host));
  CAF_EXP_THROW(port2, server_side_mm.publish_udp(server, 0, local_host));
  CAF_REQUIRE_NOT_EQUAL(port1, port2);
  CAF_EXP_THROW(same_server, server_side_mm.remote_actor_udp(local_host, port2));
  CAF_REQUIRE_EQUAL(same_server, server);
  CAF_CHECK_EQUAL(same_server->node(), server_side.node());
  CAF_EXP_THROW(server1, client_side_mm.remote_actor_udp(local_host, port1));
  CAF_EXP_THROW(server2, client_side_mm.remote_actor_udp(local_host, port2));
  CAF_CHECK_EQUAL(server1, client_side_mm.remote_actor_udp(local_host, port1));
  CAF_CHECK_EQUAL(server2, client_side_mm.remote_actor_udp(local_host, port2));
  anon_send_exit(server, exit_reason::user_shutdown);
}

CAF_TEST(ping_pong_udp) {
  // server side
  CAF_EXP_THROW(port,
                server_side_mm.publish_udp(server_side.spawn(make_pong_behavior),
                                           0, local_host));
  // client side
  CAF_EXP_THROW(pong, client_side_mm.remote_actor_udp(local_host, port));
  client_side.spawn(make_ping_behavior, pong);
}

CAF_TEST(custom_message_type_udp) {
  // server side
  CAF_EXP_THROW(port,
                server_side_mm.publish_udp(server_side.spawn(make_sort_behavior),
                                           0, local_host));
  // client side
  CAF_EXP_THROW(sorter, client_side_mm.remote_actor_udp(local_host, port));
  client_side.spawn(make_sort_requester_behavior, sorter);
}

CAF_TEST(remote_link_udp) {
  // server side
  CAF_EXP_THROW(port,
                server_side_mm.publish_udp(server_side.spawn(fragile_mirror),
                                           0, local_host));
  // client side
  CAF_EXP_THROW(mirror, client_side_mm.remote_actor_udp(local_host, port));
  auto linker = client_side.spawn(linking_actor, mirror);
  scoped_actor self{client_side};
  self->wait_for(linker);
  CAF_MESSAGE("linker exited");
  self->wait_for(mirror);
  CAF_MESSAGE("mirror exited");
}

CAF_TEST(multiple_endpoints_udp) {
  config cfg;
  // setup server
  CAF_MESSAGE("creating server");
  actor_system server_sys{cfg};
  auto mirror = server_sys.spawn([]() -> behavior {
    return {
      [] (std::string str) {
        std::reverse(begin(str), end(str));
        return str;
      }
    };
  });
  server_sys.middleman().publish_udp(mirror, 12345);
  auto client_fun = [](event_based_actor* self) -> behavior {
    return {
      [=](actor s) {
        self->send(s, "hellow, world");
      },
      [=](const std::string& str) {
        CAF_CHECK_EQUAL(str, "dlrow ,wolleh");
        self->quit();
        CAF_MESSAGE("done");
      }
    };
  };
  // setup client a
  CAF_MESSAGE("creating first client");
  config client_cfg;
  actor_system client_sys{client_cfg};
  auto client = client_sys.spawn(client_fun);
  // acquire remote actor from the server
  auto client_srv = client_sys.middleman().remote_actor_udp("localhost", 12345);
  CAF_REQUIRE(client_srv);
  // setup other clients
  for (int i = 0; i < 5; ++i) {
    config other_cfg;
    actor_system other_sys{other_cfg};
    CAF_MESSAGE("creating new client");
    auto other = other_sys.spawn(client_fun);
    // acquire remote actor from the server
    auto other_srv = other_sys.middleman().remote_actor_udp("localhost", 12345);
    CAF_REQUIRE(other_srv);
    // establish communication and exit
    CAF_MESSAGE("client contacts server and exits");
    anon_send(other, *other_srv);
    other_sys.await_all_actors_done();
  }
  // establish communication and exit
  CAF_MESSAGE("first client contacts server and exits");
  anon_send(client, *client_srv);
  client_sys.await_all_actors_done();
  anon_send_exit(mirror, exit_reason::user_shutdown);
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE io_dynamic_remote_group
#include "caf/test/unit_test.hpp"

#include <vector>
#include <algorithm>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

using namespace caf;

namespace {

constexpr char local_host[] = "127.0.0.1";

class config : public caf::actor_system_config {
public:
  config() {
    load<caf::io::middleman>();
    add_message_type<std::vector<actor>>("std::vector<actor>");
  }

  config& parse() {
    actor_system_config::parse(caf::test::engine::argc(),
                               caf::test::engine::argv());
    return *this;
  }
};

struct fixture {
  config server_side_cfg;
  caf::actor_system server_side{server_side_cfg.parse()};
  config client_side_cfg;
  caf::actor_system client_side{client_side_cfg.parse()};
  io::middleman& server_side_mm = server_side.middleman();
  io::middleman& client_side_mm = client_side.middleman();
};

behavior make_reflector_behavior(event_based_actor* self) {
  self->set_default_handler(reflect_and_quit);
  return {
    [] {
      // nop
    }
  };
}

using spawn_atom = atom_constant<atom("Spawn")>;
using get_group_atom = atom_constant<atom("GetGroup")>;

struct await_reflector_reply_behavior {
  event_based_actor* self;
  int cnt;
  int downs;
  std::vector<actor> vec;

  void operator()(const std::string& str, double val) {
    CAF_CHECK_EQUAL(str, "Hello reflector!");
    CAF_CHECK_EQUAL(val, 5.0);
    if (++cnt == 7) {
      for (const auto& actor : vec)
        self->monitor(actor);
      self->set_down_handler([=](down_msg&) {
        if (++downs == 5)
          self->quit();
      });
    }
  }
};

// `grp` may be either local or remote
void make_client_behavior(event_based_actor* self,
                          const actor& server, group grp) {
  self->set_default_handler(skip);
  self->spawn_in_group(grp, make_reflector_behavior);
  self->spawn_in_group(grp, make_reflector_behavior);
  self->request(server, infinite, spawn_atom::value, grp).then(
    [=](const std::vector<actor>& vec) {
      auto is_remote = [=](actor actor) {
        return actor->node() != self->node();
      };
      CAF_CHECK(std::all_of(vec.begin(), vec.end(), is_remote));
      self->send(grp, "Hello reflector!", 5.0);
      self->become(await_reflector_reply_behavior{self, 0, 0, vec});
    }
  );
}

behavior make_server_behavior(event_based_actor* self) {
  return {
    [=](get_group_atom) {
      return self->system().groups().get_local("foobar");
    },
    [=](spawn_atom, group group) -> std::vector<actor> {
      std::vector<actor> vec;
      for (auto i = 0; i < 5; ++i) {
        vec.push_back(self->spawn_in_group(group, make_reflector_behavior));
      }
      self->quit();
      return vec;
    }
  };
}

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(dynamic_remote_group_tests, fixture)

CAF_TEST(remote_group_conn) {
  // server side
  CAF_EXP_THROW(port, server_side_mm.publish_local_groups(0));
  CAF_REQUIRE(port != 0);
  // client side
  CAF_CHECK(client_side_mm.remote_group("whatever", local_host, port));
}

CAF_TEST(server_side_group_comm) {
  // server side
  CAF_EXP_THROW(port,
                server_side_mm.publish(server_side.spawn(make_server_behavior),
                                       0, local_host));
  CAF_REQUIRE(port != 0);
  // client side
  CAF_EXP_THROW(server, client_side_mm.remote_actor(local_host, port));
  scoped_actor group_resolver(client_side, true);
  group grp;
  group_resolver->request(server, infinite, get_group_atom::value).receive(
    [&](const group& x) {
      grp = x;
    },
    [&](error& err) {
      CAF_FAIL("error: " << client_side.render(err));
    }
  );
  client_side.spawn(make_client_behavior, server, grp);
}

CAF_TEST(client_side_group_comm) {
  // server side
  CAF_EXP_THROW(port,
                server_side_mm.publish(server_side.spawn(make_server_behavior),
                                       0, local_host));
  CAF_REQUIRE(port != 0);
  // client side
  CAF_EXP_THROW(server, client_side_mm.remote_actor(local_host, port));
  client_side.spawn(make_client_behavior, server,
                    client_side.groups().get_local("foobar"));
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE io_basp_tcp
#include "caf/test/dsl.hpp"

#include <array>
#include <mutex>
#include <memory>
#include <limits>
#include <vector>
#include <iostream>
#include <condition_variable>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

#include "caf/deep_to_string.hpp"

#include "caf/io/network/interfaces.hpp"
#include "caf/io/network/test_multiplexer.hpp"

namespace {

struct anything { };

anything any_vals;

template <class T>
using maybe = caf::variant<anything, T>;

constexpr uint8_t no_flags = 0;
constexpr uint32_t no_payload = 0;
constexpr uint64_t no_operation_data = 0;

constexpr auto basp_atom = caf::atom("BASP");
constexpr auto spawn_serv_atom = caf::atom("SpawnServ");
constexpr auto config_serv_atom = caf::atom("ConfigServ");

} // namespace <anonymous>

namespace std {

ostream& operator<<(ostream& out, const caf::io::basp::message_type& x) {
  return out << to_string(x);
}

template <class T>
ostream& operator<<(ostream& out, const maybe<T>& x) {
  using std::to_string;
  using caf::to_string;
  using caf::io::basp::to_string;
  if (caf::get_if<anything>(&x) != nullptr)
    return out << "*";
  return out << to_string(get<T>(x));
}

} // namespace std

namespace caf {

template <class T, class U>
bool operator==(const maybe<T>& x, const U& y) {
  return get_if<anything>(&x) != nullptr || get<T>(x) == y;
}

template <class T, class U>
bool operator==(const T& x, const maybe<U>& y) {
  return (y == x);
}

template <class T>
std::string to_string(const maybe<T>& x) {
  return !get_if<anything>(&x) ? std::string{"*"} : deep_to_string(get<T>(x));
}

} // namespace caf

using namespace std;
using namespace caf;
using namespace caf::io;

namespace {

constexpr uint32_t num_remote_nodes = 2;

using buffer = std::vector<char>;

std::string hexstr(const buffer& buf) {
  return deep_to_string(meta::hex_formatted(), buf);
}

struct node {
  std::string name;
  node_id id;
  connection_handle connection;
  union { scoped_actor dummy_actor; };

  node() {
    // nop
  }

  ~node() {
    // nop
  }
};

class fixture {
public:
  fixture(bool autoconn = false)
      : sys(cfg.load<io::middleman, network::test_multiplexer>()
                  .set("middleman.enable-automatic-connections", autoconn)
                  .set("scheduler.policy", autoconn ? caf::atom("testing")
                                                    : caf::atom("stealing"))
                  .set("middleman.detach-utility-actors", !autoconn)) {
    auto& mm = sys.middleman();
    mpx_ = dynamic_cast<network::test_multiplexer*>(&mm.backend());
    CAF_REQUIRE(mpx_ != nullptr);
    CAF_REQUIRE(&sys == &mpx_->system());
    auto hdl = mm.named_broker<basp_broker>(basp_atom);
    aut_ = static_cast<basp_broker*>(actor_cast<abstract_actor*>(hdl));
    this_node_ = sys.node();
    self_.reset(new scoped_actor{sys});
    ahdl_ = accept_handle::from_int(1);
    aut_->add_doorman(mpx_->new_doorman(ahdl_, 1u));
    registry_ = &sys.registry();
    registry_->put((*self_)->id(), actor_cast<strong_actor_ptr>(*self_));
    // first remote node is everything of this_node + 1, then +2, etc.
    for (uint32_t i = 0; i < num_remote_nodes; ++i) {
      auto& n = nodes_[i];
      node_id::host_id_type tmp = this_node_.host_id();
      for (auto& c : tmp)
        c = static_cast<uint8_t>(c + i + 1);
      n.id = node_id{this_node_.process_id() + i + 1, tmp};
      n.connection = connection_handle::from_int(i + 1);
      new (&n.dummy_actor) scoped_actor(sys);
      // register all pseudo remote actors in the registry
      registry_->put(n.dummy_actor->id(),
                     actor_cast<strong_actor_ptr>(n.dummy_actor));
    }
    // make sure all init messages are handled properly
    mpx_->flush_runnables();
    nodes_[0].name = "Jupiter";
    nodes_[1].name = "Mars";
    CAF_REQUIRE_NOT_EQUAL(jupiter().connection, mars().connection);
    CAF_MESSAGE("Earth:   " << to_string(this_node_));
    CAF_MESSAGE("Jupiter: " << to_string(jupiter().id));
    CAF_MESSAGE("Mars:    " << to_string(mars().id));
    CAF_REQUIRE_NOT_EQUAL(this_node_, jupiter().id);
    CAF_REQUIRE_NOT_EQUAL(jupiter().id,  mars().id);
  }

  ~fixture() {
    this_node_ = none;
    self_.reset();
    for (auto& n : nodes_) {
      n.id = none;
      n.dummy_actor.~scoped_actor();
    }
  }

  uint32_t serialized_size(const message& msg) {
    buffer buf;
    binary_serializer bs{mpx_, buf};
    auto e = bs(const_cast<message&>(msg));
    CAF_REQUIRE(!e);
    return static_cast<uint32_t>(buf.size());
  }

  node& jupiter() {
    return nodes_[0];
  }

  node& mars() {
    return nodes_[1];
  }

  // our "virtual communication backend"
  network::test_multiplexer* mpx() {
    return mpx_;
  }

  // actor-under-test
  basp_broker* aut() {
    return aut_;
  }

  // our node ID
  node_id& this_node() {
    return this_node_;
  }

  // an actor reference representing a local actor
  scoped_actor& self() {
    return *self_;
  }

  // implementation of the Binary Actor System Protocol
  basp::instance& instance() {
    return aut()->state.instance;
  }

  // our routing table (filled by BASP)
  basp::routing_table& tbl() {
    return aut()->state.instance.tbl();
  }

  // access to proxy instances
  proxy_registry& proxies() {
    return aut()->state.proxies();
  }

  // stores the singleton pointer for convenience
  actor_registry* registry() {
    return registry_;
  }

  using payload_writer = basp::instance::payload_writer;

  template <class... Ts>
  void to_payload(binary_serializer& bs, const Ts&... xs) {
    bs(const_cast<Ts&>(xs)...);
  }

  template <class... Ts>
  void to_payload(buffer& buf, const Ts&... xs) {
    binary_serializer bs{mpx_, buf};
    to_payload(bs, xs...);
  }

  void to_buf(buffer& buf, basp::header& hdr, payload_writer* writer) {
    instance().write(mpx_, buf, hdr, writer);
  }

  template <class T, class... Ts>
  void to_buf(buffer& buf, basp::header& hdr, payload_writer* writer,
              const T& x, const Ts&... xs) {
    auto pw = make_callback([&](serializer& sink) -> error {
      if (writer)
        return error::eval([&] { return (*writer)(sink); },
                           [&] { return sink(const_cast<T&>(x)); });
      return sink(const_cast<T&>(x));
    });
    to_buf(buf, hdr, &pw, xs...);
  }

  std::pair<basp::header, buffer> from_buf(const buffer& buf) {
    basp::header hdr;
    binary_deserializer bd{mpx_, buf};
    auto e = bd(hdr);
    CAF_REQUIRE(!e);
    buffer payload;
    if (hdr.payload_len > 0) {
      std::copy(buf.begin() + basp::header_size, buf.end(),
                std::back_inserter(payload));
    }
    return {hdr, std::move(payload)};
  }

  void connect_node(node& n,
                    optional<accept_handle> ax = none,
                    actor_id published_actor_id = invalid_actor_id,
                    const set<string>& published_actor_ifs = std::set<std::string>{}) {
    auto src = ax ? *ax : ahdl_;
    CAF_MESSAGE("connect remote node " << n.name
                << ", connection ID = " << n.connection.id()
                << ", acceptor ID = " << src.id());
    auto hdl = n.connection;
    mpx_->add_pending_connect(src, hdl);
    mpx_->accept_connection(src);
    // technically, the server handshake arrives
    // before we send the client handshake
    mock(hdl,
         {basp::message_type::client_handshake, 0, 0, 0,
          n.id, this_node(),
          invalid_actor_id, invalid_actor_id}, std::string{})
    .receive(hdl,
            basp::message_type::server_handshake, no_flags,
            any_vals, basp::version, this_node(), node_id{none},
            published_actor_id, invalid_actor_id, std::string{},
            published_actor_id,
            published_actor_ifs)
    // upon receiving our client handshake, BASP will check
    // whether there is a SpawnServ actor on this node
    .receive(hdl,
            basp::message_type::dispatch_message,
            basp::header::named_receiver_flag, any_vals,
            no_operation_data,
            this_node(), n.id,
            any_vals, invalid_actor_id,
            spawn_serv_atom,
            std::vector<actor_addr>{},
            make_message(sys_atom::value, get_atom::value, "info"));
    // test whether basp instance correctly updates the
    // routing table upon receiving client handshakes
    auto path = tbl().lookup(n.id);
    CAF_REQUIRE(path);
    CAF_CHECK_EQUAL(path->hdl, n.connection);
    CAF_CHECK_EQUAL(path->next_hop, n.id);
  }

  std::pair<basp::header, buffer> read_from_out_buf(connection_handle hdl) {
    CAF_MESSAGE("read from output buffer for connection " << hdl.id());
    auto& buf = mpx_->output_buffer(hdl);
    while (buf.size() < basp::header_size)
      mpx()->exec_runnable();
    auto result = from_buf(buf);
    buf.erase(buf.begin(),
              buf.begin() + basp::header_size + result.first.payload_len);
    return result;
  }

  void dispatch_out_buf(connection_handle hdl) {
    basp::header hdr;
    buffer buf;
    std::tie(hdr, buf) = read_from_out_buf(hdl);
    CAF_MESSAGE("dispatch output buffer for connection " << hdl.id());
    CAF_REQUIRE(hdr.operation == basp::message_type::dispatch_message);
    binary_deserializer source{mpx_, buf};
    std::vector<strong_actor_ptr> stages;
    message msg;
    auto e = source(stages, msg);
    CAF_REQUIRE(!e);
    auto src = actor_cast<strong_actor_ptr>(registry_->get(hdr.source_actor));
    auto dest = registry_->get(hdr.dest_actor);
    CAF_REQUIRE(dest);
    dest->enqueue(make_mailbox_element(src, make_message_id(),
                                       std::move(stages), std::move(msg)),
                  nullptr);
  }

  class mock_t {
  public:
    mock_t(fixture* thisptr) : this_(thisptr) {
      // nop
    }

    mock_t(mock_t&&) = default;

    ~mock_t() {
      if (num > 1)
        CAF_MESSAGE("implementation under test responded with "
                    << (num - 1) << " BASP message" << (num > 2 ? "s" : ""));
    }

    template <class... Ts>
    mock_t& receive(connection_handle hdl,
                    maybe<basp::message_type> operation,
                    maybe<uint8_t> flags,
                    maybe<uint32_t> payload_len,
                    maybe<uint64_t> operation_data,
                    maybe<node_id> source_node,
                    maybe<node_id> dest_node,
                    maybe<actor_id> source_actor,
                    maybe<actor_id> dest_actor,
                    const Ts&... xs) {
      CAF_MESSAGE("expect #" << num);
      buffer buf;
      this_->to_payload(buf, xs...);
      buffer& ob = this_->mpx()->output_buffer(hdl);
      while (ob.size() < basp::header_size)
        this_->mpx()->exec_runnable();
      CAF_MESSAGE("output buffer has " << ob.size() << " bytes");
      basp::header hdr;
      { // lifetime scope of source
        binary_deserializer source{this_->mpx(), ob};
        auto e = source(hdr);
        CAF_REQUIRE_EQUAL(e, none);
      }
      buffer payload;
      if (hdr.payload_len > 0) {
        CAF_REQUIRE(ob.size() >= (basp::header_size + hdr.payload_len));
        auto first = ob.begin() + basp::header_size;
        auto end = first + hdr.payload_len;
        payload.assign(first, end);
        CAF_MESSAGE("erase " << std::distance(ob.begin(), end)
                         << " bytes from output buffer");
        ob.erase(ob.begin(), end);
      } else {
        ob.erase(ob.begin(), ob.begin() + basp::header_size);
      }
      CAF_CHECK_EQUAL(operation, hdr.operation);
      CAF_CHECK_EQUAL(flags, static_cast<size_t>(hdr.flags));
      CAF_CHECK_EQUAL(payload_len, hdr.payload_len);
      CAF_CHECK_EQUAL(operation_data, hdr.operation_data);
      CAF_CHECK_EQUAL(source_node, hdr.source_node);
      CAF_CHECK_EQUAL(dest_node, hdr.dest_node);
      CAF_CHECK_EQUAL(source_actor, hdr.source_actor);
      CAF_CHECK_EQUAL(dest_actor, hdr.dest_actor);
      CAF_REQUIRE_EQUAL(buf.size(), payload.size());
      CAF_REQUIRE_EQUAL(hexstr(buf), hexstr(payload));
      ++num;
      return *this;
    }

  private:
    fixture* this_;
    size_t num = 1;
  };

  template <class... Ts>
  mock_t mock(connection_handle hdl, basp::header hdr, const Ts&... xs) {
    buffer buf;
    to_buf(buf, hdr, nullptr, xs...);
    CAF_MESSAGE("virtually send " << to_string(hdr.operation)
                << " with " << (buf.size() - basp::header_size)
                << " bytes payload");
    mpx()->virtual_send(hdl, buf);
    return {this};
  }

  mock_t mock() {
    return {this};
  }

  actor_system_config cfg;
  actor_system sys;

private:
  basp_broker* aut_;
  accept_handle ahdl_;
  network::test_multiplexer* mpx_;
  node_id this_node_;
  unique_ptr<scoped_actor> self_;
  array<node, num_remote_nodes> nodes_;
  /*
  array<node_id, num_remote_nodes> remote_node_;
  array<connection_handle, num_remote_nodes> remote_hdl_;
  array<unique_ptr<scoped_actor>, num_remote_nodes> pseudo_remote_;
  */
  actor_registry* registry_;
};

class autoconn_enabled_fixture : public fixture {
public:
  using scheduler_type = caf::scheduler::test_coordinator;

  scheduler_type& sched;
  middleman_actor mma;


  autoconn_enabled_fixture()
    : fixture(true),
      sched(dynamic_cast<scheduler_type&>(sys.scheduler())),
      mma(sys.middleman().actor_handle()) {
    // nop
  }

  void publish(const actor& whom, uint16_t port) {
    using sig_t = std::set<std::string>;
    scoped_actor tmp{sys};
    sig_t sigs;
    tmp->send(mma, publish_atom::value, port,
              actor_cast<strong_actor_ptr>(whom), std::move(sigs), "", false);
    expect((atom_value, uint16_t, strong_actor_ptr, sig_t, std::string, bool),
           from(tmp).to(mma).with(_));
    expect((uint16_t), from(mma).to(tmp).with(port));
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(basp_tests, fixture)

CAF_TEST(empty_server_handshake) {
  // test whether basp instance correctly sends a
  // server handshake when there's no actor published
  buffer buf;
  instance().write_server_handshake(mpx(), buf, none);
  basp::header hdr;
  buffer payload;
  std::tie(hdr, payload) = from_buf(buf);
  basp::header expected{basp::message_type::server_handshake, 0,
                        static_cast<uint32_t>(payload.size()),
                        basp::version,
                        this_node(), none,
                        invalid_actor_id, invalid_actor_id};
  CAF_CHECK(basp::valid(hdr));
  CAF_CHECK(basp::is_handshake(hdr));
  CAF_CHECK_EQUAL(to_string(hdr), to_string(expected));
}

CAF_TEST(non_empty_server_handshake) {
  // test whether basp instance correctly sends a
  // server handshake with published actors
  buffer buf;
  instance().add_published_actor(4242, actor_cast<strong_actor_ptr>(self()),
                                 {"caf::replies_to<@u16>::with<@u16>"});
  instance().write_server_handshake(mpx(), buf, uint16_t{4242});
  buffer expected_buf;
  basp::header expected{basp::message_type::server_handshake, 0, 0,
                        basp::version, this_node(), none,
                        self()->id(), invalid_actor_id};
  to_buf(expected_buf, expected, nullptr, std::string{},
         self()->id(), set<string>{"caf::replies_to<@u16>::with<@u16>"});
  CAF_CHECK_EQUAL(hexstr(buf), hexstr(expected_buf));
}

CAF_TEST(remote_address_and_port) {
  CAF_MESSAGE("connect to Mars");
  connect_node(mars());
  auto mm = sys.middleman().actor_handle();
  CAF_MESSAGE("ask MM about node ID of Mars");
  self()->send(mm, get_atom::value, mars().id);
  do {
    mpx()->exec_runnable();
  } while (!self()->has_next_message());
  CAF_MESSAGE("receive result of MM");
  self()->receive(
    [&](const node_id& nid, const std::string& addr, uint16_t port) {
      CAF_CHECK_EQUAL(nid, mars().id);
      // all test nodes have address "test" and connection handle ID as port
      CAF_CHECK_EQUAL(addr, "test");
      CAF_CHECK_EQUAL(port, mars().connection.id());
    }
  );
}

CAF_TEST(client_handshake_and_dispatch) {
  CAF_MESSAGE("connect to Jupiter");
  connect_node(jupiter());
  // send a message via `dispatch` from node 0
  mock(jupiter().connection,
       {basp::message_type::dispatch_message, 0, 0, 0,
        jupiter().id, this_node(), jupiter().dummy_actor->id(), self()->id()},
       std::vector<actor_addr>{},
       make_message(1, 2, 3))
  .receive(jupiter().connection,
          basp::message_type::announce_proxy, no_flags, no_payload,
          no_operation_data, this_node(), jupiter().id,
          invalid_actor_id, jupiter().dummy_actor->id());
  // must've created a proxy for our remote actor
  CAF_REQUIRE(proxies().count_proxies(jupiter().id) == 1);
  // must've send remote node a message that this proxy is monitored now
  // receive the message
  self()->receive(
    [](int a, int b, int c) {
      CAF_CHECK_EQUAL(a, 1);
      CAF_CHECK_EQUAL(b, 2);
      CAF_CHECK_EQUAL(c, 3);
      return a + b + c;
    }
  );
  CAF_MESSAGE("exec message of forwarding proxy");
  mpx()->exec_runnable();
  // deserialize and send message from out buf
  dispatch_out_buf(jupiter().connection);
  jupiter().dummy_actor->receive(
    [](int i) {
      CAF_CHECK_EQUAL(i, 6);
    }
  );
}

CAF_TEST(message_forwarding) {
  // connect two remote nodes
  connect_node(jupiter());
  connect_node(mars());
  auto msg = make_message(1, 2, 3);
  // send a message from node 0 to node 1, forwarded by this node
  mock(jupiter().connection,
       {basp::message_type::dispatch_message, 0, 0, 0,
        jupiter().id, mars().id,
        invalid_actor_id, mars().dummy_actor->id()},
       msg)
  .receive(mars().connection,
          basp::message_type::dispatch_message, no_flags, any_vals,
          no_operation_data, jupiter().id, mars().id,
          invalid_actor_id, mars().dummy_actor->id(),
          msg);
}

CAF_TEST(publish_and_connect) {
  auto ax = accept_handle::from_int(4242);
  mpx()->provide_acceptor(4242, ax);
  auto res = sys.middleman().publish(self(), 4242);
  CAF_REQUIRE(res == 4242);
  mpx()->flush_runnables(); // process publish message in basp_broker
  connect_node(jupiter(), ax, self()->id());
}

CAF_TEST(remote_actor_and_send) {
  constexpr const char* lo = "localhost";
  CAF_MESSAGE("self: " << to_string(self()->address()));
  mpx()->provide_scribe(lo, 4242, jupiter().connection);
  CAF_REQUIRE(mpx()->has_pending_scribe(lo, 4242));
  auto mm1 = sys.middleman().actor_handle();
  actor result;
  auto f = self()->request(mm1, infinite,
                           connect_atom::value, lo, uint16_t{4242});
  // wait until BASP broker has received and processed the connect message
  while (!aut()->valid(jupiter().connection))
    mpx()->exec_runnable();
  CAF_REQUIRE(!mpx()->has_pending_scribe(lo, 4242));
  // build a fake server handshake containing the id of our first pseudo actor
  CAF_MESSAGE("server handshake => client handshake + proxy announcement");
  auto na = registry()->named_actors();
  mock(jupiter().connection,
       {basp::message_type::server_handshake, 0, 0, basp::version,
        jupiter().id, none,
        jupiter().dummy_actor->id(), invalid_actor_id},
       std::string{},
       jupiter().dummy_actor->id(),
       uint32_t{0})
  .receive(jupiter().connection,
          basp::message_type::client_handshake, no_flags, 1u,
          no_operation_data, this_node(), jupiter().id,
          invalid_actor_id, invalid_actor_id, std::string{})
  .receive(jupiter().connection,
          basp::message_type::dispatch_message,
          basp::header::named_receiver_flag, any_vals,
          no_operation_data, this_node(), jupiter().id,
          any_vals, invalid_actor_id,
          spawn_serv_atom,
          std::vector<actor_id>{},
          make_message(sys_atom::value, get_atom::value, "info"))
  .receive(jupiter().connection,
          basp::message_type::announce_proxy, no_flags, no_payload,
          no_operation_data, this_node(), jupiter().id,
          invalid_actor_id, jupiter().dummy_actor->id());
  CAF_MESSAGE("BASP broker should've send the proxy");
  f.receive(
    [&](node_id nid, strong_actor_ptr res, std::set<std::string> ifs) {
      CAF_REQUIRE(res);
      auto aptr = actor_cast<abstract_actor*>(res);
      CAF_REQUIRE(dynamic_cast<forwarding_actor_proxy*>(aptr) != nullptr);
      CAF_CHECK_EQUAL(proxies().count_proxies(jupiter().id), 1u);
      CAF_CHECK_EQUAL(nid, jupiter().id);
      CAF_CHECK_EQUAL(res->node(), jupiter().id);
      CAF_CHECK_EQUAL(res->id(), jupiter().dummy_actor->id());
      CAF_CHECK(ifs.empty());
      auto proxy = proxies().get(jupiter().id, jupiter().dummy_actor->id());
      CAF_REQUIRE(proxy != nullptr);
      CAF_REQUIRE(proxy == res);
      result = actor_cast<actor>(res);
    },
    [&](error& err) {
      CAF_FAIL("error: " << sys.render(err));
    }
  );
  CAF_MESSAGE("send message to proxy");
  anon_send(actor_cast<actor>(result), 42);
  mpx()->flush_runnables();
//  mpx()->exec_runnable(); // process forwarded message in basp_broker
  mock()
  .receive(jupiter().connection,
          basp::message_type::dispatch_message, no_flags, any_vals,
          no_operation_data, this_node(), jupiter().id,
          invalid_actor_id, jupiter().dummy_actor->id(),
          std::vector<actor_id>{},
          make_message(42));
  auto msg = make_message("hi there!");
  CAF_MESSAGE("send message via BASP (from proxy)");
  mock(jupiter().connection,
       {basp::message_type::dispatch_message, 0, 0, 0,
        jupiter().id, this_node(),
        jupiter().dummy_actor->id(), self()->id()},
       std::vector<actor_id>{},
       make_message("hi there!"));
  self()->receive(
    [&](const string& str) {
      CAF_CHECK_EQUAL(to_string(self()->current_sender()), to_string(result));
      CAF_CHECK_EQUAL(self()->current_sender(), result.address());
      CAF_CHECK_EQUAL(str, "hi there!");
    }
  );
}

CAF_TEST(actor_serialize_and_deserialize) {
  auto testee_impl = [](event_based_actor* testee_self) -> behavior {
    testee_self->set_default_handler(reflect_and_quit);
    return {
      [] {
        // nop
      }
    };
  };
  connect_node(jupiter());
  auto prx = proxies().get_or_put(jupiter().id, jupiter().dummy_actor->id());
  mock()
  .receive(jupiter().connection,
          basp::message_type::announce_proxy, no_flags, no_payload,
          no_operation_data, this_node(), prx->node(),
          invalid_actor_id, prx->id());
  CAF_CHECK_EQUAL(prx->node(), jupiter().id);
  CAF_CHECK_EQUAL(prx->id(), jupiter().dummy_actor->id());
  auto testee = sys.spawn(testee_impl);
  registry()->put(testee->id(), actor_cast<strong_actor_ptr>(testee));
  CAF_MESSAGE("send message via BASP (from proxy)");
  auto msg = make_message(actor_cast<actor_addr>(prx));
  mock(jupiter().connection,
       {basp::message_type::dispatch_message, 0, 0, 0,
        prx->node(), this_node(),
        prx->id(), testee->id()},
       std::vector<actor_id>{},
       msg);
  // testee must've responded (process forwarded message in BASP broker)
  CAF_MESSAGE("wait until BASP broker writes to its output buffer");
  while (mpx()->output_buffer(jupiter().connection).empty())
    mpx()->exec_runnable(); // process forwarded message in basp_broker
  // output buffer must contain the reflected message
  mock()
  .receive(jupiter().connection,
          basp::message_type::dispatch_message, no_flags, any_vals,
          no_operation_data, this_node(), prx->node(), testee->id(), prx->id(),
          std::vector<actor_id>{}, msg);
}

CAF_TEST(indirect_connections) {
  // this node receives a message from jupiter via mars and responds via mars
  // and any ad-hoc automatic connection requests are ignored
  CAF_MESSAGE("self: " << to_string(self()->address()));
  CAF_MESSAGE("publish self at port 4242");
  auto ax = accept_handle::from_int(4242);
  mpx()->provide_acceptor(4242, ax);
  sys.middleman().publish(self(), 4242);
  mpx()->flush_runnables(); // process publish message in basp_broker
  CAF_MESSAGE("connect to Mars");
  connect_node(mars(), ax, self()->id());
  CAF_MESSAGE("actor from Jupiter sends a message to us via Mars");
  auto mx = mock(mars().connection,
                 {basp::message_type::dispatch_message, 0, 0, 0,
                  jupiter().id, this_node(),
                  jupiter().dummy_actor->id(), self()->id()},
                 std::vector<actor_id>{},
                 make_message("hello from jupiter!"));
  CAF_MESSAGE("expect ('sys', 'get', \"info\") from Earth to Jupiter at Mars");
  // this asks Jupiter if it has a 'SpawnServ'
  mx.receive(mars().connection,
             basp::message_type::dispatch_message,
             basp::header::named_receiver_flag, any_vals,
             no_operation_data, this_node(), jupiter().id,
             any_vals, invalid_actor_id,
             spawn_serv_atom,
             std::vector<actor_id>{},
             make_message(sys_atom::value, get_atom::value, "info"));
  CAF_MESSAGE("expect announce_proxy message at Mars from Earth to Jupiter");
  mx.receive(mars().connection,
             basp::message_type::announce_proxy, no_flags, no_payload,
             no_operation_data, this_node(), jupiter().id,
             invalid_actor_id, jupiter().dummy_actor->id());
  CAF_MESSAGE("receive message from jupiter");
  self()->receive(
    [](const std::string& str) -> std::string {
      CAF_CHECK_EQUAL(str, "hello from jupiter!");
      return "hello from earth!";
    }
  );
  mpx()->exec_runnable(); // process forwarded message in basp_broker
  mock()
  .receive(mars().connection,
           basp::message_type::dispatch_message, no_flags, any_vals,
           no_operation_data, this_node(), jupiter().id,
           self()->id(), jupiter().dummy_actor->id(),
           std::vector<actor_id>{},
           make_message("hello from earth!"));
}

CAF_TEST_FIXTURE_SCOPE_END()

CAF_TEST_FIXTURE_SCOPE(basp_tests_with_autoconn, autoconn_enabled_fixture)

CAF_TEST(automatic_connection) {
  // this tells our BASP broker to enable the automatic connection feature
  //anon_send(aut(), ok_atom::value,
  //          "middleman.enable-automatic-connections", make_message(true));
  //mpx()->exec_runnable(); // process publish message in basp_broker
  // jupiter [remote hdl 0] -> mars [remote hdl 1] -> earth [this_node]
  // (this node receives a message from jupiter via mars and responds via mars,
  //  but then also establishes a connection to jupiter directly)
  auto check_node_in_tbl = [&](node& n) {
    io::id_visitor id_vis;
    auto hdl = tbl().lookup_direct(n.id);
    CAF_REQUIRE(hdl);
    CAF_CHECK_EQUAL(visit(id_vis, *hdl), n.connection.id());
  };
  mpx()->provide_scribe("jupiter", 8080, jupiter().connection);
  CAF_CHECK(mpx()->has_pending_scribe("jupiter", 8080));
  CAF_MESSAGE("self: " << to_string(self()->address()));
  auto ax = accept_handle::from_int(4242);
  mpx()->provide_acceptor(4242, ax);
  publish(self(), 4242);
  mpx()->flush_runnables(); // process publish message in basp_broker
  CAF_MESSAGE("connect to mars");
  connect_node(mars(), ax, self()->id());
  //CAF_CHECK_EQUAL(tbl().lookup_direct(mars().id).id(), mars().connection.id());
  check_node_in_tbl(mars());
  CAF_MESSAGE("simulate that an actor from jupiter "
              "sends a message to us via mars");
  mock(mars().connection,
       {basp::message_type::dispatch_message, 0, 0, 0,
        jupiter().id, this_node(),
        jupiter().dummy_actor->id(), self()->id()},
       std::vector<actor_id>{},
       make_message("hello from jupiter!"))
  .receive(mars().connection,
          basp::message_type::dispatch_message,
          basp::header::named_receiver_flag, any_vals, no_operation_data,
          this_node(), jupiter().id, any_vals, invalid_actor_id,
          spawn_serv_atom,
          std::vector<actor_id>{},
          make_message(sys_atom::value, get_atom::value, "info"))
  .receive(mars().connection,
          basp::message_type::dispatch_message,
          basp::header::named_receiver_flag, any_vals,
          no_operation_data, this_node(), jupiter().id,
          any_vals, // actor ID of an actor spawned by the BASP broker
          invalid_actor_id,
          config_serv_atom,
          std::vector<actor_id>{},
          make_message(get_atom::value, "basp.default-connectivity-tcp"))
  .receive(mars().connection,
          basp::message_type::announce_proxy, no_flags, no_payload,
          no_operation_data, this_node(), jupiter().id,
          invalid_actor_id, jupiter().dummy_actor->id());
  CAF_CHECK_EQUAL(mpx()->output_buffer(mars().connection).size(), 0u);
  CAF_CHECK_EQUAL(tbl().lookup_indirect(jupiter().id), mars().id);
  CAF_CHECK_EQUAL(tbl().lookup_indirect(mars().id), none);
  auto connection_helper_actor = sys.latest_actor_id();
  CAF_CHECK_EQUAL(mpx()->output_buffer(mars().connection).size(), 0u);
  // create a dummy config server and respond to the name lookup
  CAF_MESSAGE("receive ConfigServ of jupiter");
  network::address_listing res;
  res[network::protocol::ipv4].emplace_back("jupiter");
  mock(mars().connection,
       {basp::message_type::dispatch_message, 0, 0, 0,
        this_node(), this_node(),
        invalid_actor_id, connection_helper_actor},
       std::vector<actor_id>{},
       make_message("basp.default-connectivity-tcp",
                    make_message(uint16_t{8080}, std::move(res))));
  // our connection helper should now connect to jupiter and
  // send the scribe handle over to the BASP broker
  while (mpx()->has_pending_scribe("jupiter", 8080)) {
    sched.run();
    mpx()->flush_runnables();
  }
  CAF_REQUIRE(mpx()->output_buffer(mars().connection).empty());
  // send handshake from jupiter
  mock(jupiter().connection,
       {basp::message_type::server_handshake, 0, 0, basp::version,
        jupiter().id, none,
        jupiter().dummy_actor->id(), invalid_actor_id},
       std::string{},
       jupiter().dummy_actor->id(),
       uint32_t{0})
  .receive(jupiter().connection,
          basp::message_type::client_handshake, no_flags, 1u,
          no_operation_data, this_node(), jupiter().id,
          invalid_actor_id, invalid_actor_id, std::string{});
  CAF_CHECK_EQUAL(tbl().lookup_indirect(jupiter().id), none);
  CAF_CHECK_EQUAL(tbl().lookup_indirect(mars().id), none);
  check_node_in_tbl(jupiter());
  check_node_in_tbl(mars());
  CAF_MESSAGE("receive message from jupiter");
  self()->receive(
    [](const std::string& str) -> std::string {
      CAF_CHECK_EQUAL(str, "hello from jupiter!");
      return "hello from earth!";
    }
  );
  mpx()->exec_runnable(); // process forwarded message in basp_broker
  CAF_MESSAGE("response message must take direct route now");
  mock()
  .receive(jupiter().connection,
          basp::message_type::dispatch_message, no_flags, any_vals,
          no_operation_data, this_node(), jupiter().id,
          self()->id(), jupiter().dummy_actor->id(),
          std::vector<actor_id>{},
          make_message("hello from earth!"));
  CAF_CHECK_EQUAL(mpx()->output_buffer(mars().connection).size(), 0u);
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE io_typed_remote_actor
#include "caf/test/dsl.hpp"

#include <thread>
#include <string>
#include <cstring>
#include <sstream>
#include <iostream>
#include <functional>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

using namespace std;
using namespace caf;

struct ping {
  int32_t value;
};

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, ping& x) {
  return f(meta::type_name("ping"), x.value);
}

bool operator==(const ping& lhs, const ping& rhs) {
  return lhs.value == rhs.value;
}

struct pong {
  int32_t value;
};

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, pong& x) {
  return f(meta::type_name("pong"), x.value);
}

bool operator==(const pong& lhs, const pong& rhs) {
  return lhs.value == rhs.value;
}

using server_type = typed_actor<replies_to<ping>::with<pong>>;

using client_type = typed_actor<>;

server_type::behavior_type server() {
  return {
    [](const ping & p) -> pong {
      CAF_CHECK_EQUAL(p.value, 42);
      return pong{p.value};
    }
  };
}

void run_client(int argc, char** argv, uint16_t port) {
  actor_system_config cfg;
  cfg.load<io::middleman>()
     .add_message_type<ping>("ping")
     .add_message_type<pong>("pong")
     .parse(argc, argv);
  actor_system system{cfg};
  // check whether invalid_argument is thrown
  // when trying to connect to get an untyped
  // handle to the server
  auto res = system.middleman().remote_actor("127.0.0.1", port);
  CAF_REQUIRE(!res);
  CAF_MESSAGE(system.render(res.error()));
  CAF_MESSAGE("connect to typed_remote_actor");
  CAF_EXP_THROW(serv,
                system.middleman().remote_actor<server_type>("127.0.0.1",
                                                             port));
  auto f = make_function_view(serv);
  CAF_CHECK_EQUAL(f(ping{42}), pong{42});
  anon_send_exit(serv, exit_reason::user_shutdown);
}

void run_server(int argc, char** argv) {
  actor_system_config cfg;
  cfg.load<io::middleman>()
     .add_message_type<ping>("ping")
     .add_message_type<pong>("pong")
     .parse(argc, argv);
  actor_system system{cfg};
  CAF_EXP_THROW(port, system.middleman().publish(system.spawn(server),
                                                 0, "127.0.0.1"));
  CAF_REQUIRE(port != 0);
  CAF_MESSAGE("running on port " << port << ", start client");
  std::thread child{[=] { run_client(argc, argv, port); }};
  child.join();
}

CAF_TEST(test_typed_remote_actor) {
  auto argc = test::engine::argc();
  auto argv = test::engine::argv();
  run_server(argc, argv);
}

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE io_receive_buffer
#include "caf/test/unit_test.hpp"

#include <algorithm>

#include "caf/io/network/receive_buffer.hpp"

using namespace caf;
using caf::io::network::receive_buffer;

struct fixture {

receive_buffer a;
receive_buffer b;
std::vector<char> vec;

fixture()
  : a{},
    b{1024ul},
    vec{'h', 'a', 'l', 'l', 'o'} {
  // nop
}

};


CAF_TEST_FIXTURE_SCOPE(receive_buffer_tests, fixture)

CAF_TEST(constuctors) {
  CAF_CHECK_EQUAL(a.size(), 0ul);
  CAF_CHECK_EQUAL(a.capacity(), 0ul);
  CAF_CHECK_EQUAL(a.data(), nullptr);
  CAF_CHECK(a.empty());
  CAF_CHECK_EQUAL(b.size(), 0ul);
  CAF_CHECK_EQUAL(b.capacity(), 1024ul);
  CAF_CHECK(b.data() != nullptr);
  CAF_CHECK(b.empty());
  receive_buffer other{std::move(b)};
  CAF_CHECK_EQUAL(other.size(), 0ul);
  CAF_CHECK_EQUAL(other.capacity(), 1024ul);
  CAF_CHECK(other.data() != nullptr);
  CAF_CHECK(other.empty());
}

CAF_TEST(reserve) {
  a.reserve(0);
  CAF_CHECK_EQUAL(a.size(), 0ul);
  CAF_CHECK_EQUAL(a.capacity(), 0ul);
  CAF_CHECK(a.data() == nullptr);
  CAF_CHECK(a.empty());
  a.reserve(1024);
  CAF_CHECK_EQUAL(a.size(), 0ul);
  CAF_CHECK_EQUAL(a.capacity(), 1024ul);
  CAF_CHECK(a.data() != nullptr);
  CAF_CHECK_EQUAL(a.begin(), a.end());
  CAF_CHECK(a.empty());
  a.reserve(512);
  CAF_CHECK_EQUAL(a.size(), 0ul);
  CAF_CHECK_EQUAL(a.capacity(), 1024ul);
  CAF_CHECK(a.data() != nullptr);
  CAF_CHECK_EQUAL(a.begin(), a.end());
  CAF_CHECK(a.empty());
}

CAF_TEST(resize) {
  a.resize(512);
  CAF_CHECK_EQUAL(a.size(), 512ul);
  CAF_CHECK_EQUAL(a.capacity(), 512ul);
  CAF_CHECK(a.data() != nullptr);
  CAF_CHECK(!a.empty());
  b.resize(512);
  CAF_CHECK_EQUAL(b.size(), 512ul);
  CAF_CHECK_EQUAL(b.capacity(), 1024ul);
  CAF_CHECK(b.data() != nullptr);
  CAF_CHECK(!b.empty());
  a.resize(1024);
  std::fill(a.begin(), a.end(), 'a');
  auto cnt = 0;
  CAF_CHECK(std::all_of(a.begin(), a.end(),
                        [&](char c) {
                          ++cnt;
                          return c == 'a';
                        }));
  CAF_CHECK_EQUAL(cnt, 1024);
  a.resize(10);
  cnt = 0;
  CAF_CHECK(std::all_of(a.begin(), a.end(),
                        [&](char c) {
                          ++cnt;
                          return c == 'a';
                        }));
  CAF_CHECK_EQUAL(cnt, 10);
  a.resize(1024);
  cnt = 0;
  CAF_CHECK(std::all_of(a.begin(), a.end(),
                        [&](char c) {
                          ++cnt;
                          return c == 'a';
                        }));
  CAF_CHECK_EQUAL(cnt, 1024);
}

CAF_TEST(push_back) {
  for (auto c : vec)
    a.push_back(c);
  CAF_CHECK_EQUAL(vec.size(), a.size());
  CAF_CHECK_EQUAL(a.capacity(), 8ul);
  CAF_CHECK(a.data() != nullptr);
  CAF_CHECK(!a.empty());
  CAF_CHECK(std::equal(vec.begin(), vec.end(), a.begin()));
}

CAF_TEST(insert) {
  for (auto c: vec)
    a.insert(a.end(), c);
  CAF_CHECK_EQUAL(*(a.data() + 0), 'h');
  CAF_CHECK_EQUAL(*(a.data() + 1), 'a');
  CAF_CHECK_EQUAL(*(a.data() + 2), 'l');
  CAF_CHECK_EQUAL(*(a.data() + 3), 'l');
  CAF_CHECK_EQUAL(*(a.data() + 4), 'o');
  a.insert(a.begin(), '!');
  CAF_CHECK_EQUAL(*(a.data() + 0), '!');
  CAF_CHECK_EQUAL(*(a.data() + 1), 'h');
  CAF_CHECK_EQUAL(*(a.data() + 2), 'a');
  CAF_CHECK_EQUAL(*(a.data() + 3), 'l');
  CAF_CHECK_EQUAL(*(a.data() + 4), 'l');
  CAF_CHECK_EQUAL(*(a.data() + 5), 'o');
  a.insert(a.begin() + 4, '-');
  CAF_CHECK_EQUAL(*(a.data() + 0), '!');
  CAF_CHECK_EQUAL(*(a.data() + 1), 'h');
  CAF_CHECK_EQUAL(*(a.data() + 2), 'a');
  CAF_CHECK_EQUAL(*(a.data() + 3), 'l');
  CAF_CHECK_EQUAL(*(a.data() + 4), '-');
  CAF_CHECK_EQUAL(*(a.data() + 5), 'l');
  CAF_CHECK_EQUAL(*(a.data() + 6), 'o');
}

CAF_TEST(shrink_to_fit) {
  a.shrink_to_fit();
  CAF_CHECK_EQUAL(a.size(), 0ul);
  CAF_CHECK_EQUAL(a.capacity(), 0ul);
  CAF_CHECK(a.data() == nullptr);
  CAF_CHECK(a.empty());
}

CAF_TEST(swap) {
  for (auto c : vec)
    a.push_back(c);
  std::swap(a, b);
  CAF_CHECK_EQUAL(a.size(), 0ul);
  CAF_CHECK_EQUAL(a.capacity(), 1024ul);
  CAF_CHECK(a.data() != nullptr);
  CAF_CHECK_EQUAL(b.size(), vec.size());
  CAF_CHECK_EQUAL(std::distance(b.begin(), b.end()),
                  static_cast<receive_buffer::difference_type>(vec.size()));
  CAF_CHECK_EQUAL(b.capacity(), 8ul);
  CAF_CHECK(b.data() != nullptr);
  CAF_CHECK_EQUAL(*(b.data() + 0), 'h');
  CAF_CHECK_EQUAL(*(b.data() + 1), 'a');
  CAF_CHECK_EQUAL(*(b.data() + 2), 'l');
  CAF_CHECK_EQUAL(*(b.data() + 3), 'l');
  CAF_CHECK_EQUAL(*(b.data() + 4), 'o');
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE io_remote_spawn
#include "caf/test/unit_test.hpp"

#include <thread>
#include <string>
#include <cstring>
#include <sstream>
#include <iostream>
#include <functional>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

using namespace caf;

namespace {

using add_atom = atom_constant<atom("add")>;
using sub_atom = atom_constant<atom("sub")>;

using calculator = typed_actor<replies_to<add_atom, int, int>::with<int>,
                               replies_to<sub_atom, int, int>::with<int>>;

// function-based, dynamically typed, event-based API
behavior calculator_fun(event_based_actor*) {
  return behavior{
    [](add_atom, int a, int b) {
      return a + b;
    },
    [](sub_atom, int a, int b) {
      return a - b;
    }
  };
}

// function-based, statically typed, event-based API
calculator::behavior_type typed_calculator_fun() {
  return {
    [](add_atom, int a, int b) {
      return a + b;
    },
    [](sub_atom, int a, int b) {
      return a - b;
    }
  };
}

struct config : actor_system_config {
  config(int argc, char** argv) {
    parse(argc, argv);
    load<io::middleman>();
    add_actor_type("calculator", calculator_fun);
    add_actor_type("typed_calculator", typed_calculator_fun);
  }
};

void run_client(int argc, char** argv, uint16_t port) {
  config cfg{argc, argv};
  actor_system system{cfg};
  auto& mm = system.middleman();
  auto nid = mm.connect("localhost", port);
  CAF_REQUIRE(nid);
  CAF_REQUIRE_NOT_EQUAL(system.node(), *nid);
  auto calc = mm.remote_spawn<calculator>(*nid, "calculator", make_message());
  CAF_REQUIRE_EQUAL(calc, sec::unexpected_actor_messaging_interface);
  calc = mm.remote_spawn<calculator>(*nid, "typed_calculator", make_message());
  CAF_REQUIRE(calc);
  auto f1 = make_function_view(*calc);
  CAF_REQUIRE_EQUAL(f1(add_atom::value, 10, 20), 30);
  CAF_REQUIRE_EQUAL(f1(sub_atom::value, 10, 20), -10);
  f1.reset();
  anon_send_exit(*calc, exit_reason::kill);
  mm.close(port);
}

void run_server(int argc, char** argv) {
  config cfg{argc, argv};
  actor_system system{cfg};
  CAF_EXP_THROW(port, system.middleman().open(0));
  std::thread child{[=] { run_client(argc, argv, port); }};
  child.join();
}

} // namespace <anonymous>

CAF_TEST(remote_spawn) {
  auto argc = test::engine::argc();
  auto argv = test::engine::argv();
  run_server(argc, argv);
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE io_unpublish
#include "caf/test/unit_test.hpp"

#include <new>
#include <thread>
#include <atomic>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

using namespace caf;

namespace {

std::atomic<long> s_dtor_called;

class dummy : public event_based_actor {
public:
  dummy(actor_config& cfg) : event_based_actor(cfg) {
    // nop
  }

  ~dummy() override {
    ++s_dtor_called;
  }

  behavior make_behavior() override {
    return {
      [] {
        // nop
      }
    };
  }
};

struct fixture {
  fixture() {
    new (&system) actor_system(cfg.load<io::middleman>()
                                  .parse(test::engine::argc(),
                                         test::engine::argv()));
    testee = system.spawn<dummy>();
  }

  ~fixture() {
    anon_send_exit(testee, exit_reason::user_shutdown);
    destroy(testee);
    system.~actor_system();
    CAF_CHECK_EQUAL(s_dtor_called.load(), 2);
  }

  actor remote_actor(const char* hostname, uint16_t port,
                     bool expect_fail = false) {
    actor result;
    scoped_actor self{system, true};
    self->request(system.middleman().actor_handle(), infinite,
                  connect_atom::value, hostname, port).receive(
      [&](node_id&, strong_actor_ptr& res, std::set<std::string>& xs) {
        CAF_REQUIRE(xs.empty());
        if (res)
          result = actor_cast<actor>(std::move(res));
      },
      [&](error&) {
        // nop
      }
    );
    if (expect_fail)
      CAF_REQUIRE(!result);
    else
      CAF_REQUIRE(result);
    return result;
  }

  actor_system_config cfg;
  union { actor_system system; }; // manually control ctor/dtor
  actor testee;
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(unpublish_tests, fixture)

CAF_TEST(unpublishing) {
  CAF_EXP_THROW(port, system.middleman().publish(testee, 0));
  CAF_REQUIRE(port != 0);
  CAF_MESSAGE("published actor on port " << port);
  CAF_MESSAGE("test invalid unpublish");
  auto testee2 = system.spawn<dummy>();
  system.middleman().unpublish(testee2, port);
  auto x0 = remote_actor("127.0.0.1", port);
  CAF_CHECK_NOT_EQUAL(x0, testee2);
  CAF_CHECK_EQUAL(x0, testee);
  anon_send_exit(testee2, exit_reason::kill);
  CAF_MESSAGE("unpublish testee");
  system.middleman().unpublish(testee, port);
  CAF_MESSAGE("check whether testee is still available via cache");
  auto x1 = remote_actor("127.0.0.1", port);
  CAF_CHECK_EQUAL(x1, testee);
  CAF_MESSAGE("fake death of testee and check if testee becomes unavailable");
  anon_send(actor_cast<actor>(system.middleman().actor_handle()),
            down_msg{testee.address(), exit_reason::normal});
  // must fail now
  auto x2 = remote_actor("127.0.0.1", port, true);
  CAF_CHECK(!x2);
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE io_basp_udp
#include "caf/test/dsl.hpp"

#include <array>
#include <mutex>
#include <memory>
#include <limits>
#include <vector>
#include <iostream>
#include <condition_variable>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

#include "caf/io/datagram_handle.hpp"
#include "caf/io/datagram_servant.hpp"

#include "caf/deep_to_string.hpp"

#include "caf/io/network/interfaces.hpp"
#include "caf/io/network/ip_endpoint.hpp"
#include "caf/io/network/test_multiplexer.hpp"

namespace {

struct anything { };

anything any_vals;

template <class T>
using maybe = caf::variant<anything, T>;

constexpr uint8_t no_flags = 0;
constexpr uint32_t no_payload = 0;
constexpr uint64_t no_operation_data = 0;

constexpr auto basp_atom = caf::atom("BASP");
constexpr auto spawn_serv_atom = caf::atom("SpawnServ");
constexpr auto config_serv_atom = caf::atom("ConfigServ");

} // namespace <anonymous>

namespace caf {

template <class T, class U>
bool operator==(const maybe<T>& x, const U& y) {
  return get_if<anything>(&x) != nullptr || get<T>(x) == y;
}

template <class T, class U>
bool operator==(const T& x, const maybe<U>& y) {
  return (y == x);
}

template <class T>
std::string to_string(const maybe<T>& x) {
  return !get_if<anything>(&x) ? std::string{"*"} : deep_to_string(get<T>(x));
}

} // namespace caf

using namespace std;
using namespace caf;
using namespace caf::io;

namespace {

constexpr uint32_t num_remote_nodes = 2;

using buffer = std::vector<char>;

std::string hexstr(const buffer& buf) {
  return deep_to_string(meta::hex_formatted(), buf);
}

struct node {
  std::string name;
  node_id id;
  datagram_handle endpoint;
  union { scoped_actor dummy_actor; };

  node() {
    // nop
  }

  ~node() {
    // nop
  }
};

class fixture {
public:
  fixture(bool autoconn = false, bool use_test_coordinator = false)
      : sys(cfg.load<io::middleman, network::test_multiplexer>()
          .set("middleman.enable-automatic-connections", autoconn)
          .set("middleman.enable-udp", true)
          .set("middleman.enable-tcp", false)
          .set("scheduler.policy", autoconn || use_test_coordinator
                                    ? caf::atom("testing")
                                    : caf::atom("stealing"))
          .set("middleman.detach-utility-actors",
               !(autoconn || use_test_coordinator))) {
    auto& mm = sys.middleman();
    mpx_ = dynamic_cast<network::test_multiplexer*>(&mm.backend());
    CAF_REQUIRE(mpx_ != nullptr);
    CAF_REQUIRE(&sys == &mpx_->system());
    auto hdl = mm.named_broker<basp_broker>(basp_atom);
    aut_ = static_cast<basp_broker*>(actor_cast<abstract_actor*>(hdl));
    this_node_ = sys.node();
    self_.reset(new scoped_actor{sys});
    dhdl_ = datagram_handle::from_int(1);
    aut_->add_datagram_servant(mpx_->new_datagram_servant(dhdl_, 1u));
    registry_ = &sys.registry();
    registry_->put((*self_)->id(), actor_cast<strong_actor_ptr>(*self_));
    // first remote node is everything of this_node + 1, then +2, etc.
    for (uint32_t i = 0; i < num_remote_nodes; ++i) {
      auto& n = nodes_[i];
      node_id::host_id_type tmp = this_node_.host_id();
      for (auto& c : tmp)
        c = static_cast<uint8_t>(c + i + 1);
      n.id = node_id{this_node_.process_id() + i + 1, tmp};
      n.endpoint = datagram_handle::from_int(i + 2);
      new (&n.dummy_actor) scoped_actor(sys);
      // register all pseudo remote actors in the registry
      registry_->put(n.dummy_actor->id(),
                     actor_cast<strong_actor_ptr>(n.dummy_actor));
    }
    // make sure all init messages are handled properly
    mpx_->flush_runnables();
    nodes_[0].name = "Jupiter";
    nodes_[1].name = "Mars";
    CAF_REQUIRE_NOT_EQUAL(jupiter().endpoint, mars().endpoint);
    CAF_MESSAGE("Earth:   " << to_string(this_node_) << ", ID = "
                << endpoint_handle().id());
    CAF_MESSAGE("Jupiter: " << to_string(jupiter().id) << ", ID = "
                << jupiter().endpoint.id());
    CAF_MESSAGE("Mars:    " << to_string(mars().id) << ", ID = "
                << mars().endpoint.id());
    CAF_REQUIRE_NOT_EQUAL(this_node_, jupiter().id);
    CAF_REQUIRE_NOT_EQUAL(jupiter().id,  mars().id);
  }

  ~fixture() {
    this_node_ = none;
    self_.reset();
    for (auto& n : nodes_) {
      n.id = none;
      n.dummy_actor.~scoped_actor();
    }
  }

  uint32_t serialized_size(const message& msg) {
    buffer buf;
    binary_serializer bs{mpx_, buf};
    auto e = bs(const_cast<message&>(msg));
    CAF_REQUIRE(!e);
    return static_cast<uint32_t>(buf.size());
  }

  node& jupiter() {
    return nodes_[0];
  }

  node& mars() {
    return nodes_[1];
  }

  // our "virtual communication backend"
  network::test_multiplexer* mpx() {
    return mpx_;
  }

  // actor-under-test
  basp_broker* aut() {
    return aut_;
  }

  // our node ID
  node_id& this_node() {
    return this_node_;
  }

  // an actor reference representing a local actor
  scoped_actor& self() {
    return *self_;
  }

  datagram_handle endpoint_handle() {
    return dhdl_;
  }

  // implementation of the Binary Actor System Protocol
  basp::instance& instance() {
    return aut()->state.instance;
  }

  // our routing table (filled by BASP)
  basp::routing_table& tbl() {
    return aut()->state.instance.tbl();
  }

  // access to proxy instances
  proxy_registry& proxies() {
    return aut()->state.proxies();
  }

  // stores the singleton pointer for convenience
  actor_registry* registry() {
    return registry_;
  }

  using payload_writer = basp::instance::payload_writer;

  template <class... Ts>
  void to_payload(binary_serializer& bs, const Ts&... xs) {
    bs(const_cast<Ts&>(xs)...);
  }

  template <class... Ts>
  void to_payload(buffer& buf, const Ts&... xs) {
    binary_serializer bs{mpx_, buf};
    to_payload(bs, xs...);
  }

  void to_buf(buffer& buf, basp::header& hdr, payload_writer* writer) {
    instance().write(mpx_, buf, hdr, writer);
  }

  template <class T, class... Ts>
  void to_buf(buffer& buf, basp::header& hdr, payload_writer* writer,
              const T& x, const Ts&... xs) {
    auto pw = make_callback([&](serializer& sink) -> error {
      if (writer)
        return error::eval([&] { return (*writer)(sink); },
                           [&] { return sink(const_cast<T&>(x)); });
      return sink(const_cast<T&>(x));
    });
    to_buf(buf, hdr, &pw, xs...);
  }

  std::pair<basp::header, buffer> from_buf(const buffer& buf) {
    basp::header hdr;
    binary_deserializer bd{mpx_, buf};
    auto e = bd(hdr);
    CAF_REQUIRE(!e);
    buffer payload;
    if (hdr.payload_len > 0) {
      std::copy(buf.begin() + basp::header_size, buf.end(),
                std::back_inserter(payload));
    }
    return {hdr, std::move(payload)};
  }

  void establish_communication(node& n,
                               optional<datagram_handle> dx = none,
                               actor_id published_actor_id = invalid_actor_id,
                               const set<string>& published_actor_ifs
                                 = std::set<std::string>{}) {
    auto src = dx ? *dx : dhdl_;
    CAF_MESSAGE("establish communication on node " << n.name
                << ", delegated servant ID = " << n.endpoint.id()
                << ", initial servant ID = " << src.id());
    // send the client handshake and receive the server handshake
    // and a dispatch_message as answers
    auto hdl = n.endpoint;
    mpx_->add_pending_endpoint(src, hdl);
    CAF_MESSAGE("Send client handshake");
    mock(src, hdl,
         {basp::message_type::client_handshake, 0, 0, 0,
          n.id, this_node(),
          invalid_actor_id, invalid_actor_id}, std::string{})
    // upon receiving the client handshake, the server should answer
    // with the server handshake and send the dispatch_message blow
    .receive(hdl,
             basp::message_type::server_handshake, no_flags,
             any_vals, basp::version, this_node(), node_id{none},
             published_actor_id, invalid_actor_id, std::string{},
             published_actor_id, published_actor_ifs)
    // upon receiving our client handshake, BASP will check
    // whether there is a SpawnServ actor on this node
    .receive(hdl,
             basp::message_type::dispatch_message,
             basp::header::named_receiver_flag, any_vals,
             no_operation_data,
             this_node(), n.id,
             any_vals, invalid_actor_id,
             spawn_serv_atom,
             std::vector<actor_addr>{},
             make_message(sys_atom::value, get_atom::value, "info"));
    // test whether basp instance correctly updates the
    // routing table upon receiving client handshakes
    auto path = tbl().lookup(n.id);
    CAF_REQUIRE(path);
    CAF_CHECK_EQUAL(path->hdl, n.endpoint);
    CAF_CHECK_EQUAL(path->next_hop, n.id);
  }

  std::pair<basp::header, buffer> read_from_out_buf(datagram_handle hdl) {
    CAF_MESSAGE("read from output buffer for endpoint " << hdl.id());
    auto& que = mpx_->output_queue(hdl);
    while (que.empty())
      mpx()->exec_runnable();
    auto result = from_buf(que.front().second);
    que.pop_front();
    return result;
  }

  void dispatch_out_buf(datagram_handle hdl) {
    basp::header hdr;
    buffer buf;
    std::tie(hdr, buf) = read_from_out_buf(hdl);
    CAF_MESSAGE("dispatch output buffer for endpoint " << hdl.id());
    CAF_REQUIRE(hdr.operation == basp::message_type::dispatch_message);
    binary_deserializer source{mpx_, buf};
    std::vector<strong_actor_ptr> stages;
    message msg;
    auto e = source(stages, msg);
    CAF_REQUIRE(!e);
    auto src = actor_cast<strong_actor_ptr>(registry_->get(hdr.source_actor));
    auto dest = registry_->get(hdr.dest_actor);
    CAF_REQUIRE(dest);
    dest->enqueue(make_mailbox_element(src, make_message_id(),
                                       std::move(stages), std::move(msg)),
                  nullptr);
  }

  class mock_t {
  public:
    mock_t(fixture* thisptr) : this_(thisptr) {
      // nop
    }

    mock_t(mock_t&&) = default;

    ~mock_t() {
      if (num > 1)
        CAF_MESSAGE("implementation under test responded with "
                    << (num - 1) << " BASP message" << (num > 2 ? "s" : ""));
    }

    template <class... Ts>
    mock_t& receive(datagram_handle hdl,
                    maybe<basp::message_type> operation,
                    maybe<uint8_t> flags,
                    maybe<uint32_t> payload_len,
                    maybe<uint64_t> operation_data,
                    maybe<node_id> source_node,
                    maybe<node_id> dest_node,
                    maybe<actor_id> source_actor,
                    maybe<actor_id> dest_actor,
                    const Ts&... xs) {
      CAF_MESSAGE("expect #" << num << " on endpoint ID = " << hdl.id());
      buffer buf;
      this_->to_payload(buf, xs...);
      auto& oq = this_->mpx()->output_queue(hdl);
      while (oq.empty())
        this_->mpx()->exec_runnable();
      CAF_MESSAGE("output queue has " << oq.size() << " messages");
      auto dh = oq.front().first;
      buffer& ob = oq.front().second;
      CAF_MESSAGE("next datagram has " << ob.size()
                  << " bytes, servant ID = " << dh.id());
      CAF_CHECK_EQUAL(dh.id(), hdl.id());
      basp::header hdr;
      { // lifetime scope of source
        binary_deserializer source{this_->mpx(), ob};
        auto e = source(hdr);
        CAF_REQUIRE_EQUAL(e, none);
      }
      buffer payload;
      if (hdr.payload_len > 0) {
        CAF_REQUIRE(ob.size() >= (basp::header_size + hdr.payload_len));
        auto first = ob.begin() + basp::header_size;
        auto end = first + hdr.payload_len;
        payload.assign(first, end);
      }
      CAF_MESSAGE("erase message from output queue");
      oq.pop_front();
      CAF_CHECK_EQUAL(operation, hdr.operation);
      CAF_CHECK_EQUAL(flags, static_cast<size_t>(hdr.flags));
      CAF_CHECK_EQUAL(payload_len, hdr.payload_len);
      CAF_CHECK_EQUAL(operation_data, hdr.operation_data);
      CAF_CHECK_EQUAL(source_node, hdr.source_node);
      CAF_CHECK_EQUAL(dest_node, hdr.dest_node);
      CAF_CHECK_EQUAL(source_actor, hdr.source_actor);
      CAF_CHECK_EQUAL(dest_actor, hdr.dest_actor);
      CAF_REQUIRE_EQUAL(buf.size(), payload.size());
      CAF_REQUIRE_EQUAL(hexstr(buf), hexstr(payload));
      ++num;
      return *this;
    }

    template <class... Ts>
    mock_t& enqueue_back(datagram_handle hdl, datagram_handle ep,
                         basp::header hdr, const Ts&... xs) {
      buffer buf;
      this_->to_buf(buf, hdr, nullptr, xs...);
      CAF_MESSAGE("adding msg " << to_string(hdr.operation)
                  << " with " << (buf.size() - basp::header_size)
                  << " bytes payload to back of queue");
      this_->mpx()->virtual_network_buffer(hdl).emplace_back(ep, buf);
      return *this;
    }

    template <class... Ts>
    mock_t& enqueue_back(datagram_handle hdl, basp::header hdr,
                         Ts&&... xs) {
      return enqueue_back(hdl, hdl, hdr, std::forward<Ts>(xs)...);
    }

    template <class... Ts>
    mock_t& enqueue_front(datagram_handle hdl, datagram_handle ep,
                          basp::header hdr, const Ts&... xs) {
      buffer buf;
      this_->to_buf(buf, hdr, nullptr, xs...);
      CAF_MESSAGE("adding msg " << to_string(hdr.operation)
                  << " with " << (buf.size() - basp::header_size)
                  << " bytes payload to front of queue");
      this_->mpx()->virtual_network_buffer(hdl).emplace_front(ep, buf);
      return *this;
    }

    template <class... Ts>
    mock_t& enqueue_front(datagram_handle hdl, basp::header hdr,
                          Ts&&... xs) {
      return enqueue_front(hdl, hdl, hdr, std::forward<Ts>(xs)...);
    }

    mock_t& deliver(datagram_handle hdl, size_t num_messages = 1) {
      for (size_t i = 0; i < num_messages; ++i)
        this_->mpx()->read_data(hdl);
      return *this;
    }

  private:
    fixture* this_;
    size_t num = 1;
  };

  template <class... Ts>
  mock_t mock(datagram_handle hdl, basp::header hdr,
              const Ts&... xs) {
    buffer buf;
    to_buf(buf, hdr, nullptr, xs...);
    CAF_MESSAGE("virtually send " << to_string(hdr.operation)
                << " with " << (buf.size() - basp::header_size)
                << " bytes payload");
    mpx()->virtual_send(hdl, hdl, buf);
    return {this};
  }

  template <class... Ts>
  mock_t mock(datagram_handle hdl, datagram_handle ep, basp::header hdr,
              const Ts&... xs) {
    buffer buf;
    to_buf(buf, hdr, nullptr, xs...);
    CAF_MESSAGE("virtually send " << to_string(hdr.operation)
                << " with " << (buf.size() - basp::header_size)
                << " bytes payload");
    mpx()->virtual_send(hdl, ep, buf);
    return {this};
  }

  mock_t mock() {
    return {this};
  }

  actor_system_config cfg;
  actor_system sys;

private:
  basp_broker* aut_;
  datagram_handle dhdl_;
  network::test_multiplexer* mpx_;
  node_id this_node_;
  unique_ptr<scoped_actor> self_;
  array<node, num_remote_nodes> nodes_;
  /*
  array<node_id, num_remote_nodes> remote_node_;
  array<connection_handle, num_remote_nodes> remote_hdl_;
  array<unique_ptr<scoped_actor>, num_remote_nodes> pseudo_remote_;
  */
  actor_registry* registry_;
};


class manual_timer_fixture : public fixture {
public:
  using scheduler_type = caf::scheduler::test_coordinator;

  scheduler_type& sched;

  manual_timer_fixture()
    : fixture(false, true),
      sched(dynamic_cast<scheduler_type&>(sys.scheduler())) {
    // nop
  }
};

class autoconn_enabled_fixture : public fixture {
public:
  using scheduler_type = caf::scheduler::test_coordinator;

  scheduler_type& sched;
  middleman_actor mma;


  autoconn_enabled_fixture()
    : fixture(true),
      sched(dynamic_cast<scheduler_type&>(sys.scheduler())),
      mma(sys.middleman().actor_handle()) {
    // nop
  }

  void publish(const actor& whom, uint16_t port, bool is_udp = false) {
    using sig_t = std::set<std::string>;
    scoped_actor tmp{sys};
    sig_t sigs;
    CAF_MESSAGE("publish whom on port " << port);
    if (is_udp)
      tmp->send(mma, publish_udp_atom::value, port,
                actor_cast<strong_actor_ptr>(whom), std::move(sigs), "", false);
    else
      tmp->send(mma, publish_atom::value, port,
                actor_cast<strong_actor_ptr>(whom), std::move(sigs), "", false);
    CAF_MESSAGE("publish from tmp to mma with port _");
    expect((atom_value, uint16_t, strong_actor_ptr, sig_t, std::string, bool),
           from(tmp).to(mma).with(_));
    CAF_MESSAGE("publish: from mma to tmp with port " << port);
    expect((uint16_t), from(mma).to(tmp).with(port));
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(basp_udp_tests, fixture)

CAF_TEST(empty_server_handshake_udp) {
  // test whether basp instance correctly sends a
  // client handshake when there's no actor published
  buffer buf;
  instance().write_server_handshake(mpx(), buf, none);
  basp::header hdr;
  buffer payload;
  std::tie(hdr, payload) = from_buf(buf);
  basp::header expected{basp::message_type::server_handshake, 0,
                        static_cast<uint32_t>(payload.size()),
                        basp::version,
                        this_node(), none,
                        invalid_actor_id, invalid_actor_id,
                        0};
  CAF_CHECK(basp::valid(hdr));
  CAF_CHECK(basp::is_handshake(hdr));
  CAF_CHECK_EQUAL(to_string(hdr), to_string(expected));
}

CAF_TEST(empty_client_handshake_udp) {
  // test whether basp instance correctly sends a
  // client handshake when there's no actor published
  buffer buf;
  instance().write_client_handshake(mpx(), buf, none);
  basp::header hdr;
  buffer payload;
  std::tie(hdr, payload) = from_buf(buf);
  basp::header expected{basp::message_type::client_handshake, 0,
                        static_cast<uint32_t>(payload.size()), 0,
                        this_node(), none,
                        invalid_actor_id, invalid_actor_id,
                        0};
  CAF_CHECK(basp::valid(hdr));
  CAF_CHECK(basp::is_handshake(hdr));
  CAF_MESSAGE("got      : " << to_string(hdr));
  CAF_MESSAGE("expecting: " << to_string(expected));
  CAF_CHECK_EQUAL(to_string(hdr), to_string(expected));
}

CAF_TEST(non_empty_server_handshake_udp) {
  // test whether basp instance correctly sends a
  // server handshake with published actors
  buffer buf;
  instance().add_published_actor(4242, actor_cast<strong_actor_ptr>(self()),
                                 {"caf::replies_to<@u16>::with<@u16>"});
  instance().write_server_handshake(mpx(), buf, uint16_t{4242});
  buffer expected_buf;
  basp::header expected{basp::message_type::server_handshake, 0, 0,
                        basp::version, this_node(), none,
                        self()->id(), invalid_actor_id, 0};
  to_buf(expected_buf, expected, nullptr, std::string{},
         self()->id(), set<string>{"caf::replies_to<@u16>::with<@u16>"});
  CAF_CHECK_EQUAL(hexstr(buf), hexstr(expected_buf));
}

CAF_TEST(remote_address_and_port_udp) {
  CAF_MESSAGE("connect to Mars");
  establish_communication(mars());
  auto mm = sys.middleman().actor_handle();
  CAF_MESSAGE("ask MM about node ID of Mars");
  self()->send(mm, get_atom::value, mars().id);
  do {
    mpx()->exec_runnable();
  } while (!self()->has_next_message());
  CAF_MESSAGE("receive result of MM");
  self()->receive(
    [&](const node_id& nid, const std::string& addr, uint16_t port) {
      CAF_CHECK_EQUAL(nid, mars().id);
      // all test nodes have address "test" and connection handle ID as port
      CAF_CHECK_EQUAL(addr, "test");
      CAF_CHECK_EQUAL(port, mars().endpoint.id());
    }
  );
}

CAF_TEST(client_handshake_and_dispatch_udp) {
  CAF_MESSAGE("establish communication with Jupiter");
  establish_communication(jupiter());
  CAF_MESSAGE("send dispatch message");
  // send a message via `dispatch` from node 0 on endpoint 1
  mock(endpoint_handle(), jupiter().endpoint,
       {basp::message_type::dispatch_message, 0, 0, 0,
        jupiter().id, this_node(), jupiter().dummy_actor->id(), self()->id(),
        1}, // increment sequence number
       std::vector<actor_addr>{},
       make_message(1, 2, 3))
  .receive(jupiter().endpoint,
          basp::message_type::announce_proxy, no_flags, no_payload,
          no_operation_data, this_node(), jupiter().id,
          invalid_actor_id, jupiter().dummy_actor->id());
  // must've created a proxy for our remote actor
  CAF_REQUIRE(proxies().count_proxies(jupiter().id) == 1);
  // must've send remote node a message that this proxy is monitored now
  // receive the message
  self()->receive(
    [](int a, int b, int c) {
      CAF_CHECK_EQUAL(a, 1);
      CAF_CHECK_EQUAL(b, 2);
      CAF_CHECK_EQUAL(c, 3);
      return a + b + c;
    }
  );
  CAF_MESSAGE("exec message of forwarding proxy");
  mpx()->exec_runnable();
  // deserialize and send message from out buf
  dispatch_out_buf(jupiter().endpoint);
  jupiter().dummy_actor->receive(
    [](int i) {
      CAF_CHECK_EQUAL(i, 6);
    }
  );
}

CAF_TEST(message_forwarding_udp) {
  // connect two remote nodes
  CAF_MESSAGE("establish communication with Jupiter");
  establish_communication(jupiter());
  CAF_MESSAGE("establish communication with Mars");
  establish_communication(mars());
  CAF_MESSAGE("send dispatch message to ... ");
  auto msg = make_message(1, 2, 3);
  // send a message from node 0 to node 1, forwarded by this node
  mock(endpoint_handle(), jupiter().endpoint,
       {basp::message_type::dispatch_message, 0, 0, 0,
        jupiter().id, mars().id,
        invalid_actor_id, mars().dummy_actor->id(),
        1}, // increment sequence number
       msg)
  .receive(mars().endpoint,
           basp::message_type::dispatch_message, no_flags, any_vals,
           no_operation_data, jupiter().id, mars().id,
           invalid_actor_id, mars().dummy_actor->id(),
           msg);
}

CAF_TEST(publish_and_connect_udp) {
  auto dx = datagram_handle::from_int(4242);
  mpx()->provide_datagram_servant(4242, dx);
  auto res = sys.middleman().publish_udp(self(), 4242);
  CAF_REQUIRE(res == 4242);
  mpx()->flush_runnables(); // process publish message in basp_broker
  establish_communication(jupiter(), dx, self()->id());
}

CAF_TEST(remote_actor_and_send_udp) {
  constexpr const char* lo = "localhost";
  CAF_MESSAGE("self: " << to_string(self()->address()));
  mpx()->provide_datagram_servant(lo, 4242, jupiter().endpoint);
  CAF_REQUIRE(mpx()->has_pending_remote_endpoint(lo, 4242));
  auto mm1 = sys.middleman().actor_handle();
  actor result;
  auto f = self()->request(mm1, infinite, contact_atom::value,
                           lo, uint16_t{4242});
  // wait until BASP broker has received and processed the connect message
  while (!aut()->valid(jupiter().endpoint))
    mpx()->exec_runnable();
  CAF_REQUIRE(!mpx()->has_pending_scribe(lo, 4242));
  // build a fake server handshake containing the id of our first pseudo actor
  CAF_MESSAGE("client handshake => server handshake => proxy announcement");
  auto na = registry()->named_actors();
  mock()
  .receive(jupiter().endpoint,
           basp::message_type::client_handshake, no_flags, 1u,
           no_operation_data, this_node(), node_id(),
           invalid_actor_id, invalid_actor_id, std::string{});
  mock(jupiter().endpoint,
       {basp::message_type::server_handshake, 0, 0, basp::version,
        jupiter().id, none,
        jupiter().dummy_actor->id(), invalid_actor_id,
        0}, // sequence number, first message
       std::string{},
       jupiter().dummy_actor->id(),
       uint32_t{0})
  .receive(jupiter().endpoint,
           basp::message_type::dispatch_message,
           basp::header::named_receiver_flag, any_vals,
           no_operation_data, this_node(), jupiter().id,
           any_vals, invalid_actor_id,
           spawn_serv_atom,
           std::vector<actor_id>{},
           make_message(sys_atom::value, get_atom::value, "info"))
  .receive(jupiter().endpoint,
           basp::message_type::announce_proxy, no_flags, no_payload,
           no_operation_data, this_node(), jupiter().id,
           invalid_actor_id, jupiter().dummy_actor->id());
  CAF_MESSAGE("BASP broker should've send the proxy");
  f.receive(
    [&](node_id nid, strong_actor_ptr res, std::set<std::string> ifs) {
      CAF_REQUIRE(res);
      auto aptr = actor_cast<abstract_actor*>(res);
      CAF_REQUIRE(dynamic_cast<forwarding_actor_proxy*>(aptr) != nullptr);
      CAF_CHECK_EQUAL(proxies().count_proxies(jupiter().id), 1u);
      CAF_CHECK_EQUAL(nid, jupiter().id);
      CAF_CHECK_EQUAL(res->node(), jupiter().id);
      CAF_CHECK_EQUAL(res->id(), jupiter().dummy_actor->id());
      CAF_CHECK(ifs.empty());
      auto proxy = proxies().get(jupiter().id, jupiter().dummy_actor->id());
      CAF_REQUIRE(proxy != nullptr);
      CAF_REQUIRE(proxy == res);
      result = actor_cast<actor>(res);
    },
    [&](error& err) {
      CAF_FAIL("error: " << sys.render(err));
    }
  );
  CAF_MESSAGE("send message to proxy");
  anon_send(actor_cast<actor>(result), 42);
  mpx()->flush_runnables();
  mock()
  .receive(jupiter().endpoint,
           basp::message_type::dispatch_message, no_flags, any_vals,
           no_operation_data, this_node(), jupiter().id,
           invalid_actor_id, jupiter().dummy_actor->id(),
           std::vector<actor_id>{},
           make_message(42));
  auto msg = make_message("hi there!");
  CAF_MESSAGE("send message via BASP (from proxy)");
  mock(jupiter().endpoint,
       {basp::message_type::dispatch_message, 0, 0, 0,
        jupiter().id, this_node(),
        jupiter().dummy_actor->id(), self()->id(),
        1}, // sequence number, second message
       std::vector<actor_id>{},
       make_message("hi there!"));
  self()->receive(
    [&](const string& str) {
      CAF_CHECK_EQUAL(to_string(self()->current_sender()), to_string(result));
      CAF_CHECK_EQUAL(self()->current_sender(), result.address());
      CAF_CHECK_EQUAL(str, "hi there!");
    }
  );
}

CAF_TEST(actor_serialize_and_deserialize_udp) {
  auto testee_impl = [](event_based_actor* testee_self) -> behavior {
    testee_self->set_default_handler(reflect_and_quit);
    return {
      [] {
        // nop
      }
    };
  };
  establish_communication(jupiter());
  auto prx = proxies().get_or_put(jupiter().id, jupiter().dummy_actor->id());
  mock()
  .receive(jupiter().endpoint,
          basp::message_type::announce_proxy, no_flags, no_payload,
          no_operation_data, this_node(), prx->node(),
          invalid_actor_id, prx->id());
  CAF_CHECK_EQUAL(prx->node(), jupiter().id);
  CAF_CHECK_EQUAL(prx->id(), jupiter().dummy_actor->id());
  auto testee = sys.spawn(testee_impl);
  registry()->put(testee->id(), actor_cast<strong_actor_ptr>(testee));
  CAF_MESSAGE("send message via BASP (from proxy)");
  auto msg = make_message(actor_cast<actor_addr>(prx));
  mock(endpoint_handle(), jupiter().endpoint,
       {basp::message_type::dispatch_message, 0, 0, 0,
        prx->node(), this_node(),
        prx->id(), testee->id(),
        1}, // sequence number, first message after handshake
       std::vector<actor_id>{},
       msg);
  // testee must've responded (process forwarded message in BASP broker)
  CAF_MESSAGE("wait until BASP broker writes to its output buffer");
  while (mpx()->output_queue(jupiter().endpoint).empty())
    mpx()->exec_runnable(); // process forwarded message in basp_broker
  // output buffer must contain the reflected message
  mock()
  .receive(jupiter().endpoint,
          basp::message_type::dispatch_message, no_flags, any_vals,
          no_operation_data, this_node(), prx->node(), testee->id(), prx->id(),
          std::vector<actor_id>{}, msg);
}

CAF_TEST(indirect_connections_udp) {
  // this node receives a message from jupiter via mars and responds via mars
  // and any ad-hoc automatic connection requests are ignored
  CAF_MESSAGE("self: " << to_string(self()->address()));
  auto dx = datagram_handle::from_int(4242);
  mpx()->provide_datagram_servant(4242, dx);
  sys.middleman().publish_udp(self(), 4242);
  mpx()->flush_runnables(); // process publish message in basp_broker
  CAF_MESSAGE("connect to Mars");
  establish_communication(mars(), dx, self()->id());
  CAF_MESSAGE("actor from Jupiter sends a message to us via Mars");
  auto mx = mock(dx, mars().endpoint,
                 {basp::message_type::dispatch_message, 0, 0, 0,
                  jupiter().id, this_node(),
                  jupiter().dummy_actor->id(), self()->id(),
                  1}, // sequence number
                 std::vector<actor_id>{},
                 make_message("hello from jupiter!"));
  CAF_MESSAGE("expect ('sys', 'get', \"info\") from Earth to Jupiter at Mars");
  // this asks Jupiter if it has a 'SpawnServ'
  mx.receive(mars().endpoint,
             basp::message_type::dispatch_message,
             basp::header::named_receiver_flag, any_vals,
             no_operation_data, this_node(), jupiter().id,
             any_vals, invalid_actor_id,
             spawn_serv_atom,
             std::vector<actor_id>{},
             make_message(sys_atom::value, get_atom::value, "info"));
  CAF_MESSAGE("expect announce_proxy message at Mars from Earth to Jupiter");
  mx.receive(mars().endpoint,
             basp::message_type::announce_proxy, no_flags, no_payload,
             no_operation_data, this_node(), jupiter().id,
             invalid_actor_id, jupiter().dummy_actor->id());
  CAF_MESSAGE("receive message from jupiter");
  self()->receive(
    [](const std::string& str) -> std::string {
      CAF_CHECK_EQUAL(str, "hello from jupiter!");
      return "hello from earth!";
    }
  );
  mpx()->exec_runnable(); // process forwarded message in basp_broker
  mock()
  .receive(mars().endpoint,
           basp::message_type::dispatch_message, no_flags, any_vals,
           no_operation_data, this_node(), jupiter().id,
           self()->id(), jupiter().dummy_actor->id(),
           std::vector<actor_id>{},
           make_message("hello from earth!"));
}


CAF_TEST_FIXTURE_SCOPE_END()


CAF_TEST_FIXTURE_SCOPE(basp_udp_tests_with_manual_timer, manual_timer_fixture)

CAF_TEST(out_of_order_delivery_udp) {
  // This test uses the test_coordinator to get control over the
  // timeouts that deliver pending message.
  constexpr const char* lo = "localhost";
  CAF_MESSAGE("self: " << to_string(self()->address()));
  mpx()->provide_datagram_servant(lo, 4242, jupiter().endpoint);
  CAF_REQUIRE(mpx()->has_pending_remote_endpoint(lo, 4242));
  auto mm1 = sys.middleman().actor_handle();
  actor result;
  auto f = self()->request(mm1, infinite, contact_atom::value,
                           lo, uint16_t{4242});
  // wait until BASP broker has received and processed the connect message
  while (!aut()->valid(jupiter().endpoint)) {
    sched.run();
    mpx()->exec_runnable();
  }
  CAF_REQUIRE(!mpx()->has_pending_scribe(lo, 4242));
  // build a fake server handshake containing the id of our first pseudo actor
  CAF_MESSAGE("client handshake => server handshake => proxy announcement");
  auto na = registry()->named_actors();
  mock()
  .receive(jupiter().endpoint,
           basp::message_type::client_handshake, no_flags, 1u,
           no_operation_data, this_node(), node_id(),
           invalid_actor_id, invalid_actor_id, std::string{});
  mock(jupiter().endpoint, jupiter().endpoint,
       {basp::message_type::server_handshake, 0, 0, basp::version,
        jupiter().id, none,
        jupiter().dummy_actor->id(), invalid_actor_id,
        0}, // sequence number, first message
       std::string{},
       jupiter().dummy_actor->id(),
       uint32_t{0})
  .receive(jupiter().endpoint,
           basp::message_type::dispatch_message,
           basp::header::named_receiver_flag, any_vals,
           no_operation_data, this_node(), jupiter().id,
           any_vals, invalid_actor_id,
           spawn_serv_atom,
           std::vector<actor_id>{},
           make_message(sys_atom::value, get_atom::value, "info"))
  .receive(jupiter().endpoint,
           basp::message_type::announce_proxy, no_flags, no_payload,
           no_operation_data, this_node(), jupiter().id,
           invalid_actor_id, jupiter().dummy_actor->id());
  sched.run();
  CAF_MESSAGE("BASP broker should've send the proxy");
  f.receive(
    [&](node_id nid, strong_actor_ptr res, std::set<std::string> ifs) {
      CAF_REQUIRE(res);
      auto aptr = actor_cast<abstract_actor*>(res);
      CAF_REQUIRE(dynamic_cast<forwarding_actor_proxy*>(aptr) != nullptr);
      CAF_CHECK_EQUAL(proxies().count_proxies(jupiter().id), 1u);
      CAF_CHECK_EQUAL(nid, jupiter().id);
      CAF_CHECK_EQUAL(res->node(), jupiter().id);
      CAF_CHECK_EQUAL(res->id(), jupiter().dummy_actor->id());
      CAF_CHECK(ifs.empty());
      auto proxy = proxies().get(jupiter().id, jupiter().dummy_actor->id());
      CAF_REQUIRE(proxy != nullptr);
      CAF_REQUIRE(proxy == res);
      result = actor_cast<actor>(res);
    },
    [&](error& err) {
      CAF_FAIL("error: " << sys.render(err));
    }
  );
  CAF_MESSAGE("send message to proxy");
  anon_send(actor_cast<actor>(result), 42);
  mpx()->flush_runnables();
  mock()
  .receive(jupiter().endpoint,
           basp::message_type::dispatch_message, no_flags, any_vals,
           no_operation_data, this_node(), jupiter().id,
           invalid_actor_id, jupiter().dummy_actor->id(),
           std::vector<actor_id>{},
           make_message(42));
  auto header_with_seq = [&](uint16_t seq) -> basp::header {
    return {basp::message_type::dispatch_message, 0, 0, 0,
            jupiter().id, this_node(),
            jupiter().dummy_actor->id(), self()->id(),
            seq};
  };
  CAF_MESSAGE("send 10 messages out of order");
  mock()
  .enqueue_back(jupiter().endpoint, header_with_seq(1),
                std::vector<actor_id>{}, make_message(0))
  .enqueue_back(jupiter().endpoint, header_with_seq(2),
                std::vector<actor_id>{}, make_message(1))
  .enqueue_front(jupiter().endpoint, header_with_seq(3),
                 std::vector<actor_id>{}, make_message(2))
  .enqueue_back(jupiter().endpoint, header_with_seq(4),
                std::vector<actor_id>{}, make_message(3))
  .enqueue_back(jupiter().endpoint, header_with_seq(5),
                std::vector<actor_id>{}, make_message(4))
  .enqueue_back(jupiter().endpoint, header_with_seq(6),
                std::vector<actor_id>{}, make_message(5))
  .enqueue_front(jupiter().endpoint, header_with_seq(7),
                 std::vector<actor_id>{}, make_message(6))
  .enqueue_back(jupiter().endpoint, header_with_seq(8),
                std::vector<actor_id>{}, make_message(7))
  .enqueue_back(jupiter().endpoint, header_with_seq(9),
                std::vector<actor_id>{}, make_message(8))
  .enqueue_front(jupiter().endpoint, header_with_seq(10),
                 std::vector<actor_id>{}, make_message(9))
  .deliver(jupiter().endpoint, 10);
  int expected_next = 0;
  self()->receive_while([&] { return expected_next < 10; }) (
    [&](int val) {
      CAF_CHECK_EQUAL(to_string(self()->current_sender()), to_string(result));
      CAF_CHECK_EQUAL(self()->current_sender(), result.address());
      CAF_CHECK_EQUAL(expected_next, val);
      ++expected_next;
    }
  );
  sched.dispatch();
  mpx()->flush_runnables();
  CAF_MESSAGE("force delivery via timeout that skips messages");
  const basp::sequence_type seq_and_payload = 23;
  mock()
  .enqueue_back(jupiter().endpoint, header_with_seq(seq_and_payload),
                std::vector<actor_id>{}, make_message(seq_and_payload))
  .deliver(jupiter().endpoint, 1);
  sched.dispatch();
  mpx()->exec_runnable();
  self()->receive(
    [&](basp::sequence_type val) {
      CAF_CHECK_EQUAL(to_string(self()->current_sender()), to_string(result));
      CAF_CHECK_EQUAL(self()->current_sender(), result.address());
      CAF_CHECK_EQUAL(seq_and_payload, val);
    }
  );
}

CAF_TEST_FIXTURE_SCOPE_END()


CAF_TEST_FIXTURE_SCOPE(basp_udp_tests_with_autoconn, autoconn_enabled_fixture)

CAF_TEST(automatic_connection_udp) {
  // this tells our BASP broker to enable the automatic connection feature
  //anon_send(aut(), ok_atom::value,
  //          "middleman.enable-automatic-connections", make_message(true));
  //mpx()->exec_runnable(); // process publish message in basp_broker
  // jupiter [remote hdl 0] -> mars [remote hdl 1] -> earth [this_node]
  // (this node receives a message from jupiter via mars and responds via mars,
  //  but then also establishes a connection to jupiter directly)
  auto check_node_in_tbl = [&](node& n) {
    io::id_visitor id_vis;
    auto hdl = tbl().lookup_direct(n.id);
    CAF_REQUIRE(hdl);
    CAF_CHECK_EQUAL(visit(id_vis, *hdl), n.endpoint.id());
  };
  mpx()->provide_datagram_servant("jupiter", 8080, jupiter().endpoint);
  CAF_CHECK(mpx()->has_pending_remote_endpoint("jupiter", 8080));
  CAF_MESSAGE("self: " << to_string(self()->address()));
  auto dx = datagram_handle::from_int(4242);
  mpx()->provide_datagram_servant(4242, dx);
  publish(self(), 4242, true);
  mpx()->flush_runnables(); // process publish message in basp_broker
  CAF_MESSAGE("connect to mars");
  establish_communication(mars(), dx, self()->id());
  //CAF_CHECK_EQUAL(tbl().lookup_direct(mars().id).id(), mars().connection.id());
  check_node_in_tbl(mars());
  CAF_MESSAGE("simulate that an actor from jupiter "
              "sends a message to us via mars");
  mock(dx, mars().endpoint,
       {basp::message_type::dispatch_message, 0, 0, 0,
        jupiter().id, this_node(),
        jupiter().dummy_actor->id(), self()->id(),
        1}, // sequence number
       std::vector<actor_id>{},
       make_message("hello from jupiter!"))
  .receive(mars().endpoint,
           basp::message_type::dispatch_message,
           basp::header::named_receiver_flag, any_vals, no_operation_data,
           this_node(), jupiter().id, any_vals, invalid_actor_id,
           spawn_serv_atom,
           std::vector<actor_id>{},
           make_message(sys_atom::value, get_atom::value, "info"))
  // if we do not disable TCP, we would receive a second message here asking
  // for the tcp related addresses
  .receive(mars().endpoint,
           basp::message_type::dispatch_message,
           basp::header::named_receiver_flag, any_vals,
           no_operation_data, this_node(), jupiter().id,
           any_vals, // actor ID of an actor spawned by the BASP broker
           invalid_actor_id,
           config_serv_atom,
           std::vector<actor_id>{},
           make_message(get_atom::value, "basp.default-connectivity-udp"))
  .receive(mars().endpoint,
           basp::message_type::announce_proxy, no_flags, no_payload,
           no_operation_data, this_node(), jupiter().id,
           invalid_actor_id, jupiter().dummy_actor->id());
  CAF_CHECK_EQUAL(mpx()->output_queue(mars().endpoint).size(), 0u);
  CAF_CHECK_EQUAL(tbl().lookup_indirect(jupiter().id), mars().id);
  CAF_CHECK_EQUAL(tbl().lookup_indirect(mars().id), none);
  auto connection_helper_actor = sys.latest_actor_id();
  CAF_CHECK_EQUAL(mpx()->output_queue(mars().endpoint).size(), 0u);
  // create a dummy config server and respond to the name lookup
  CAF_MESSAGE("receive ConfigServ of jupiter");
  network::address_listing res;
  res[network::protocol::ipv4].emplace_back("jupiter");
  mock(dx, mars().endpoint,
       {basp::message_type::dispatch_message, 0, 0, 0,
        this_node(), this_node(),
        invalid_actor_id, connection_helper_actor,
        2}, // sequence number
       std::vector<actor_id>{},
       make_message("basp.default-connectivity-udp",
                    make_message(uint16_t{8080}, std::move(res))));
  // our connection helper should now connect to jupiter and
  // send the scribe handle over to the BASP broker
  while (mpx()->has_pending_remote_endpoint("jupiter", 8080)) {
    sched.run();
    mpx()->flush_runnables();
  }
  CAF_REQUIRE(mpx()->output_queue(mars().endpoint).empty());
  CAF_MESSAGE("Let's do the handshake.");
  mock()
  .receive(jupiter().endpoint,
           basp::message_type::client_handshake, no_flags, 1u,
           no_operation_data, this_node(), node_id(),
           invalid_actor_id, invalid_actor_id, std::string{});
  CAF_MESSAGE("Received client handshake.");
  // send handshake from jupiter
  mock(jupiter().endpoint, jupiter().endpoint,
       {basp::message_type::server_handshake, 0, 0, basp::version,
        jupiter().id, none,
        jupiter().dummy_actor->id(), invalid_actor_id},
       std::string{},
       jupiter().dummy_actor->id(),
       uint32_t{0});
  mpx()->exec_runnable(); // Receive message from connection helper
  mpx()->exec_runnable(); // Process BASP server handshake
  CAF_CHECK_EQUAL(tbl().lookup_indirect(jupiter().id), none);
  CAF_CHECK_EQUAL(tbl().lookup_indirect(mars().id), none);
  check_node_in_tbl(jupiter());
  check_node_in_tbl(mars());
  CAF_MESSAGE("receive message from jupiter");
  self()->receive(
    [](const std::string& str) -> std::string {
      CAF_CHECK_EQUAL(str, "hello from jupiter!");
      return "hello from earth!";
    }
  );
  mpx()->exec_runnable(); // process forwarded message in basp_broker
  CAF_MESSAGE("response message must take direct route now");
  mock()
  .receive(jupiter().endpoint,
          basp::message_type::dispatch_message, no_flags, any_vals,
          no_operation_data, this_node(), jupiter().id,
          self()->id(), jupiter().dummy_actor->id(),
          std::vector<actor_id>{},
          make_message("hello from earth!"));
  CAF_CHECK_EQUAL(mpx()->output_queue(mars().endpoint).size(), 0u);
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE io_automatic_connection
#include "caf/test/unit_test.hpp"

#include <set>
#include <thread>
#include <vector>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

#include "caf/io/network/interfaces.hpp"
#include "caf/io/network/test_multiplexer.hpp"

using namespace caf;
using namespace caf::io;

using std::string;

using ping_atom = atom_constant<atom("ping")>;
using pong_atom = atom_constant<atom("pong")>;

/*

  This test checks whether automatic connections work as expected
  by first connecting three nodes "in line". In step 2, we send a
  message across the line, forcing the nodes to build a mesh. In step 3,
  we disconnect the node that originally connected the other two and expect
  that the other two nodes communicate uninterrupted.

  1) Initial setup:

    Earth ---- Mars ---- Jupiter

  2) After Jupiter has send a message to Earth:

    Earth ---- Mars
       \       /
        \     /
         \   /
        Jupiter

  3) After Earth has received the message and disconnected Mars:

    Earth ---- Jupiter

*/

/*
std::thread run_prog(const char* arg, uint16_t port, bool use_asio) {
  return detail::run_sub_unit_test(invalid_actor,
                                   test::engine::path(),
                                   test::engine::max_runtime(),
                                   CAF_XSTR(CAF_SUITE),
                                   use_asio,
                                   {"--port=" + std::to_string(port), arg});
}

// we run the same code on all three nodes, a simple ping-pong client
struct testee_state {
  std::set<actor> buddies;
  uint16_t port = 0;
  const char* name = "testee";
};

behavior testee(stateful_actor<testee_state>* self) {
  return {
    [self](ping_atom, actor buddy, bool please_broadcast) -> message {
      if (please_broadcast)
        for (auto& x : self->state.buddies)
          if (x != buddy)
            send_as(buddy, x, ping_atom::value, buddy, false);
      self->state.buddies.emplace(std::move(buddy));
      return make_message(pong_atom::value, self);
    },
    [self](pong_atom, actor buddy) {
      self->state.buddies.emplace(std::move(buddy));
    },
    [self](put_atom, uint16_t new_port) {
      self->state.port = new_port;
    },
    [self](get_atom) {
      return self->state.port;
    }
  };
}

void run_earth(bool use_asio, bool as_server, uint16_t pub_port) {
  scoped_actor self{system};
  struct captain : hook {
  public:
    captain(actor parent) : parent_(std::move(parent)) {
      // nop
    }

    void new_connection_established_cb(const node_id& node) override {
      anon_send(parent_, put_atom::value, node);
      call_next<hook::new_connection_established>(node);
    }

    void new_remote_actor_cb(const actor_addr& addr) override {
      anon_send(parent_, put_atom::value, addr);
      call_next<hook::new_remote_actor>(addr);
    }

    void connection_lost_cb(const node_id& dest) override {
      anon_send(parent_, delete_atom::value, dest);
    }

  private:
    actor parent_;
  };
  middleman::instance()->add_hook<captain>(self);
  auto aut = system.spawn(testee);
  auto port = publish(aut, pub_port);
  CAF_MESSAGE("published testee at port " << port);
  std::thread mars_process;
  std::thread jupiter_process;
  // launch process for Mars
  if (!as_server) {
    CAF_MESSAGE("launch process for Mars");
    mars_process = run_prog("--mars", port, use_asio);
  }
  CAF_MESSAGE("wait for Mars to connect");
  node_id mars;
  self->receive(
    [&](put_atom, const node_id& nid) {
      mars = nid;
      CAF_MESSAGE(CAF_ARG(mars));
    }
  );
  actor_addr mars_addr;
  uint16_t mars_port;
  self->receive_while([&] { return mars_addr == invalid_actor_addr; })(
    [&](put_atom, const actor_addr& addr) {
      auto hdl = actor_cast<actor>(addr);
      self->request(hdl, sys_atom::value, get_atom::value, "info").then(
        [&](ok_atom, const string&, const actor_addr&, const string& name) {
          if (name != "testee")
            return;
          mars_addr = addr;
          CAF_MESSAGE(CAF_ARG(mars_addr));
          self->request(actor_cast<actor>(mars_addr), get_atom::value).then(
            [&](uint16_t mp) {
              CAF_MESSAGE("mars published its actor at port " << mp);
              mars_port = mp;
            }
          );
        }
      );
    }
  );
  // launch process for Jupiter
  if (!as_server) {
    CAF_MESSAGE("launch process for Jupiter");
    jupiter_process = run_prog("--jupiter", mars_port, use_asio);
  }
  CAF_MESSAGE("wait for Jupiter to connect");
  self->receive(
    [](put_atom, const node_id& jupiter) {
      CAF_MESSAGE(CAF_ARG(jupiter));
    }
  );
  actor_addr jupiter_addr;
  self->receive_while([&] { return jupiter_addr == invalid_actor_addr; })(
    [&](put_atom, const actor_addr& addr) {
      auto hdl = actor_cast<actor>(addr);
      self->request(hdl, sys_atom::value, get_atom::value, "info").then(
        [&](ok_atom, const string&, const actor_addr&, const string& name) {
          if (name != "testee")
            return;
          jupiter_addr = addr;
          CAF_MESSAGE(CAF_ARG(jupiter_addr));
        }
      );
    }
  );
  CAF_MESSAGE("shutdown Mars");
  anon_send_exit(mars_addr, exit_reason::kill);
  if (mars_process.joinable())
    mars_process.join();
  self->receive(
    [&](delete_atom, const node_id& nid) {
      CAF_CHECK(nid == mars);
    }
  );
  CAF_MESSAGE("check whether we still can talk to Jupiter");
  self->send(aut, ping_atom::value, self, true);
  std::set<actor_addr> found;
  int i = 0;
  self->receive_for(i, 2)(
    [&](pong_atom, const actor&) {
      found.emplace(self->current_sender());
    }
  );
  std::set<actor_addr> expected{aut.address(), jupiter_addr};
  CAF_CHECK(found == expected);
  CAF_MESSAGE("shutdown Jupiter");
  anon_send_exit(jupiter_addr, exit_reason::kill);
  if (jupiter_process.joinable())
    jupiter_process.join();
  anon_send_exit(aut, exit_reason::kill);
}

void run_mars(uint16_t port_to_earth, uint16_t pub_port) {
  auto aut = system.spawn(testee);
  auto port = publish(aut, pub_port);
  anon_send(aut, put_atom::value, port);
  CAF_MESSAGE("published testee at port " << port);
  auto earth = remote_actor("localhost", port_to_earth);
  send_as(aut, earth, ping_atom::value, aut, false);
}

void run_jupiter(uint16_t port_to_mars) {
  auto aut = system.spawn(testee);
  auto mars = remote_actor("localhost", port_to_mars);
  send_as(aut, mars, ping_atom::value, aut, true);
}
*/

CAF_TEST(triangle_setup) {
  // this unit test is temporarily disabled until problems
  // with OBS are sorted out or new actor_system API is in place
}

/*
CAF_TEST(triangle_setup) {
  uint16_t port = 0;
  uint16_t publish_port = 0;
  auto argv = test::engine::argv();
  auto argc = test::engine::argc();
  auto r = message_builder(argv, argv + argc).extract_opts({
    {"port,p", "port of remote side (when running mars or jupiter)", port},
    {"mars", "run mars"},
    {"jupiter", "run jupiter"},
    {"use-asio", "use ASIO network backend (if available)"},
    {"server,s", "run in server mode (don't run clients)", publish_port}
  });
  // check arguments
  bool is_mars = r.opts.count("mars") > 0;
  bool is_jupiter = r.opts.count("jupiter") > 0;
  bool has_port = r.opts.count("port") > 0;
  if (((is_mars || is_jupiter) && !has_port) || (is_mars && is_jupiter)) {
    CAF_ERROR("need a port when running Mars or Jupiter and cannot "
              "both at the same time");
    return;
  }
  // enable automatic connections
  anon_send(whereis(atom("ConfigServ")), put_atom::value,
            "middleman.enable-automatic-connections", make_message(true));
  auto use_asio = r.opts.count("use-asio") > 0;
# ifdef CAF_USE_ASIO
  if (use_asio) {
    CAF_MESSAGE("enable ASIO backend");
    set_middleman<network::asio_multiplexer>();
  }
# endif // CAF_USE_ASIO
  auto as_server = r.opts.count("server") > 0;
  if (is_mars)
    run_mars(port, publish_port);
  else if (is_jupiter)
    run_jupiter(port);
  else
    run_earth(use_asio, as_server, publish_port);
  await_all_actors_done();
  shutdown();
}
*/
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE io_triggering
#include "caf/test/unit_test.hpp"

#include <memory>
#include <iostream>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

using namespace std;
using namespace caf;
using namespace caf::io;

namespace {

// -- client implementation, used for both test servers ------------------------

behavior client(broker* self, connection_handle hdl) {
  std::vector<char> buf;
  buf.resize(200);
  std::iota(buf.begin(), buf.end(), 0);
  self->write(hdl, buf.size(), buf.data());
  CAF_REQUIRE_EQUAL(self->wr_buf(hdl).size(), 200u);
  self->configure_read(hdl, receive_policy::at_least(1));
  self->flush(hdl);
  return {
    [=](const new_data_msg&) {
      CAF_FAIL("server unexpectedly sent data");
    },
    [=](const connection_closed_msg&) {
      self->quit();
    }
  };
}

// -- first test server --------------------------------------------------------

struct server1_state {
  size_t received = 0;
  connection_handle peer = invalid_connection_handle;
};

// consumes 5 more tokens, then waits for passivated message to shutdown
behavior server1_stage4(stateful_actor<server1_state, broker>* self) {
  CAF_MESSAGE("enter server stage 4");
  self->trigger(self->state.peer, 5);
  return {
    [=](const new_data_msg& dm) {
      CAF_REQUIRE_EQUAL(dm.buf.size(), 10u);
      self->state.received += 1;
    },
    [=](const connection_passivated_msg& cp) {
      CAF_REQUIRE_EQUAL(cp.handle, self->state.peer);
      CAF_REQUIRE_EQUAL(self->state.received, 15u);
      CAF_REQUIRE_NOT_EQUAL(self->state.peer, invalid_connection_handle);
      // delay new tokens to force MM to remove this broker from its loop
      CAF_MESSAGE("server is done");
      self->quit();
    }
  };
}

// consumes 5 more tokens, then waits for passivated message to send itself
// a message that generates 5 more (force MM to actually remove this broker
// from its event loop and then re-adding it)
behavior server1_stage3(stateful_actor<server1_state, broker>* self) {
  CAF_MESSAGE("enter server stage 3");
  self->trigger(self->state.peer, 5);
  return {
    [=](const new_data_msg& dm) {
      CAF_REQUIRE_EQUAL(dm.buf.size(), 10u);
      self->state.received += 1;
    },
    [=](const connection_passivated_msg& cp) {
      CAF_REQUIRE_EQUAL(cp.handle, self->state.peer);
      CAF_REQUIRE_EQUAL(self->state.received, 10u);
      CAF_REQUIRE_NOT_EQUAL(self->state.peer, invalid_connection_handle);
      // delay new tokens to force MM to remove this broker from its loop
      self->send(self, ok_atom::value);
    },
    [=](ok_atom) {
      self->become(server1_stage4(self));
    }
  };
}

// consumes 5 tokens, then waits for passivated message and generates 5 more
behavior server1_stage2(stateful_actor<server1_state, broker>* self) {
  CAF_MESSAGE("enter server stage 2");
  self->trigger(self->state.peer, 5);
  return {
    [=](const new_data_msg& dm) {
      CAF_REQUIRE_EQUAL(dm.buf.size(), 10u);
      self->state.received += 1;
    },
    [=](const connection_passivated_msg& cp) {
      CAF_REQUIRE_EQUAL(cp.handle, self->state.peer);
      CAF_REQUIRE_EQUAL(self->state.received, 5u);
      CAF_REQUIRE_NOT_EQUAL(self->state.peer, invalid_connection_handle);
      self->become(server1_stage3(self));
    }
  };
}

// waits for the connection to the client
behavior server1(stateful_actor<server1_state, broker>* self) {
  return {
    [=](const new_connection_msg& nc) {
      CAF_REQUIRE_EQUAL(self->state.peer, invalid_connection_handle);
      self->state.peer = nc.handle;
      self->configure_read(nc.handle, receive_policy::exactly(10));
      self->become(server1_stage2(self));
    }
  };
}

// -- second test server -------------------------------------------------------

struct server2_state {
  size_t accepted = 0;
};

// consumes 5 more tokens, then waits for passivated message to shutdown
behavior server2_stage4(stateful_actor<server2_state, broker>* self) {
  CAF_MESSAGE("enter server stage 4");
  return {
    [=](const new_connection_msg&) {
      self->state.accepted += 1;
    },
    [=](const acceptor_passivated_msg&) {
      CAF_REQUIRE_EQUAL(self->state.accepted, 16u);
      CAF_MESSAGE("server is done");
      self->quit();
    }
  };
}

// consumes 5 more tokens, then waits for passivated message to send itself
// a message that generates 5 more (force MM to actually remove this broker
// from its event loop and then re-adding it)
behavior server2_stage3(stateful_actor<server2_state, broker>* self) {
  CAF_MESSAGE("enter server stage 3");
  return {
    [=](const new_connection_msg&) {
      self->state.accepted += 1;
    },
    [=](const acceptor_passivated_msg& cp) {
      CAF_REQUIRE_EQUAL(self->state.accepted, 11u);
      // delay new tokens to force MM to remove this broker from its loop
      self->send(self, ok_atom::value, cp.handle);
    },
    [=](ok_atom, accept_handle hdl) {
      self->trigger(hdl, 5);
      self->become(server2_stage4(self));
    }
  };
}

// consumes 5 tokens, then waits for passivated message and generates 5 more
behavior server2_stage2(stateful_actor<server2_state, broker>* self) {
  CAF_MESSAGE("enter server stage 2");
  CAF_REQUIRE_EQUAL(self->state.accepted, 1u);
  return {
    [=](const new_connection_msg&) {
      self->state.accepted += 1;
    },
    [=](const acceptor_passivated_msg& cp) {
      CAF_REQUIRE_EQUAL(self->state.accepted, 6u);
      self->trigger(cp.handle, 5);
      self->become(server2_stage3(self));
    }
  };
}

// waits for the connection to the client
behavior server2(stateful_actor<server2_state, broker>* self) {
  return {
    [=](const new_connection_msg& nc) {
      self->state.accepted += 1;
      self->trigger(nc.source, 5);
      self->become(server2_stage2(self));
    }
  };
}

// -- config and fixture -------------------------------------------------------

struct config : actor_system_config {
  config() {
    auto argc = test::engine::argc();
    auto argv = test::engine::argv();
    load<io::middleman>();
    parse(argc, argv);
  }
};

struct fixture {
  config client_cfg;
  actor_system client_system;
  config server_cfg;
  actor_system server_system;

  fixture() : client_system(client_cfg), server_system(server_cfg) {
    // nop
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(trigger_tests, fixture)

CAF_TEST(trigger_connection) {
  CAF_MESSAGE("spawn server");
  uint16_t port = 0;
  auto serv = server_system.middleman().spawn_server(server1, port);
  CAF_REQUIRE(serv);
  CAF_REQUIRE_NOT_EQUAL(port, 0);
  CAF_MESSAGE("server spawned at port " << port);
  std::thread child{[&] {
    auto cl = client_system.middleman().spawn_client(client, "localhost", port);
    CAF_REQUIRE(cl);
  }};
  child.join();
}

CAF_TEST(trigger_acceptor) {
  CAF_MESSAGE("spawn server");
  uint16_t port = 0;
  auto serv = server_system.middleman().spawn_server(server2, port);
  CAF_REQUIRE(serv);
  CAF_REQUIRE_NOT_EQUAL(port, 0);
  CAF_MESSAGE("server spawned at port " << port);
  std::thread child{[&] {
    // 16 clients will succeed to connect
    for (int i = 0; i < 16; ++i) {
      auto cl = client_system.middleman().spawn_client(client,
                                                       "localhost", port);
      CAF_REQUIRE(cl);
    }
  }};
  child.join();
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE io_dynamic_remote_actor_tcp
#include "caf/test/unit_test.hpp"

#include <vector>
#include <sstream>
#include <utility>
#include <algorithm>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

using namespace caf;

namespace {

constexpr char local_host[] = "127.0.0.1";

class config : public actor_system_config {
public:
  config() {
    load<io::middleman>();
    add_message_type<std::vector<int>>("std::vector<int>");
    actor_system_config::parse(test::engine::argc(),
                               test::engine::argv());
  }
};

struct fixture {
  config server_side_config;
  actor_system server_side{server_side_config};
  config client_side_config;
  actor_system client_side{client_side_config};
  io::middleman& server_side_mm = server_side.middleman();
  io::middleman& client_side_mm = client_side.middleman();
};

behavior make_pong_behavior() {
  return {
    [](int val) -> int {
      ++val;
      CAF_MESSAGE("pong with " << val);
      return val;
    }
  };
}

behavior make_ping_behavior(event_based_actor* self, const actor& pong) {
  CAF_MESSAGE("ping with " << 0);
  self->send(pong, 0);
  return {
    [=](int val) -> int {
      if (val == 3) {
        CAF_MESSAGE("ping with exit");
        self->send_exit(self->current_sender(),
                        exit_reason::user_shutdown);
        CAF_MESSAGE("ping quits");
        self->quit();
      }
      CAF_MESSAGE("ping with " << val);
      return val;
    }
  };
}

behavior make_sort_behavior() {
  return {
    [](std::vector<int>& vec) -> std::vector<int> {
      CAF_MESSAGE("sorter received: " << deep_to_string(vec));
      std::sort(vec.begin(), vec.end());
      CAF_MESSAGE("sorter sent: " << deep_to_string(vec));
      return std::move(vec);
    }
  };
}

behavior make_sort_requester_behavior(event_based_actor* self,
                                      const actor& sorter) {
  self->send(sorter, std::vector<int>{5, 4, 3, 2, 1});
  return {
    [=](const std::vector<int>& vec) {
      CAF_MESSAGE("sort requester received: " << deep_to_string(vec));
      std::vector<int> expected_vec{1, 2, 3, 4, 5};
      CAF_CHECK_EQUAL(vec, expected_vec);
      self->send_exit(sorter, exit_reason::user_shutdown);
      self->quit();
    }
  };
}

behavior fragile_mirror(event_based_actor* self) {
  return {
    [=](int i) {
      self->quit(exit_reason::user_shutdown);
      return i;
    }
  };
}

behavior linking_actor(event_based_actor* self, const actor& buddy) {
  CAF_MESSAGE("link to mirror and send dummy message");
  self->link_to(buddy);
  self->send(buddy, 42);
  return {
    [](int i) {
      CAF_CHECK_EQUAL(i, 42);
    }
  };
}

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(dynamic_remote_actor_tests, fixture)

CAF_TEST(identity_semantics_tcp) {
  // server side
  auto server = server_side.spawn(make_pong_behavior);
  CAF_EXP_THROW(port1, server_side_mm.publish(server, 0, local_host));
  CAF_EXP_THROW(port2, server_side_mm.publish(server, 0, local_host));
  CAF_REQUIRE_NOT_EQUAL(port1, port2);
  CAF_EXP_THROW(same_server, server_side_mm.remote_actor(local_host, port2));
  CAF_REQUIRE_EQUAL(same_server, server);
  CAF_CHECK_EQUAL(same_server->node(), server_side.node());
  CAF_EXP_THROW(server1, client_side_mm.remote_actor(local_host, port1));
  CAF_EXP_THROW(server2, client_side_mm.remote_actor(local_host, port2));
  CAF_CHECK_EQUAL(server1, client_side_mm.remote_actor(local_host, port1));
  CAF_CHECK_EQUAL(server2, client_side_mm.remote_actor(local_host, port2));
  anon_send_exit(server, exit_reason::user_shutdown);
}

CAF_TEST(ping_pong_tcp) {
  // server side
  CAF_EXP_THROW(port,
                server_side_mm.publish(server_side.spawn(make_pong_behavior),
                                       0, local_host));
  // client side
  CAF_EXP_THROW(pong, client_side_mm.remote_actor(local_host, port));
  client_side.spawn(make_ping_behavior, pong);
}

CAF_TEST(custom_message_type_tcp) {
  // server side
  CAF_EXP_THROW(port, server_side_mm.publish(server_side.spawn(make_sort_behavior),
                                             0, local_host));
  // client side
  CAF_EXP_THROW(sorter, client_side_mm.remote_actor(local_host, port));
  client_side.spawn(make_sort_requester_behavior, sorter);
}

CAF_TEST(remote_link_tcp) {
  // server side
  CAF_EXP_THROW(port, server_side_mm.publish(server_side.spawn(fragile_mirror),
                                             0, local_host));
  // client side
  CAF_EXP_THROW(mirror, client_side_mm.remote_actor(local_host, port));
  auto linker = client_side.spawn(linking_actor, mirror);
  scoped_actor self{client_side};
  self->wait_for(linker);
  CAF_MESSAGE("linker exited");
  self->wait_for(mirror);
  CAF_MESSAGE("mirror exited");
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE io_dynamic_broker
#include "caf/test/unit_test.hpp"

#include <memory>
#include <iostream>

#include "caf/all.hpp"
#include "caf/io/all.hpp"

#include "caf/string_algorithms.hpp"

using namespace std;
using namespace caf;
using namespace caf::io;

namespace {

using ping_atom = caf::atom_constant<caf::atom("ping")>;
using pong_atom = caf::atom_constant<caf::atom("pong")>;
using publish_atom = caf::atom_constant<caf::atom("publish")>;
using kickoff_atom = caf::atom_constant<caf::atom("kickoff")>;

void ping(event_based_actor* self, size_t num_pings) {
  CAF_MESSAGE("num_pings: " << num_pings);
  auto count = std::make_shared<size_t>(0);
  self->become(
    [=](kickoff_atom, const actor& pong) {
      CAF_MESSAGE("received `kickoff_atom`");
      self->send(pong, ping_atom::value, 1);
      self->become(
        [=](pong_atom, int value)->std::tuple<atom_value, int> {
          if (++*count >= num_pings) {
            CAF_MESSAGE("received " << num_pings
                        << " pings, call self->quit");
            self->quit();
          }
          return std::make_tuple(ping_atom::value, value + 1);
        }
      );
    }
  );
}

void pong(event_based_actor* self) {
  CAF_MESSAGE("pong actor started");
  self->set_down_handler([=](down_msg& dm) {
    CAF_MESSAGE("received down_msg{" << to_string(dm.reason) << "}");
    self->quit(dm.reason);
  });
  self->become(
    [=](ping_atom, int value) -> std::tuple<atom_value, int> {
      CAF_MESSAGE("received `ping_atom`");
      self->monitor(self->current_sender());
      // set next behavior
      self->become(
        [](ping_atom, int val) {
          return std::make_tuple(pong_atom::value, val);
        }
      );
      // reply to 'ping'
      return std::make_tuple(pong_atom::value, value);
    }
  );
}

void peer_fun(broker* self, connection_handle hdl, const actor& buddy) {
  CAF_MESSAGE("peer_fun called");
  CAF_REQUIRE(self->subtype() == resumable::io_actor);
  CAF_CHECK(self != nullptr);
  self->monitor(buddy);
  // assume exactly one connection
  CAF_REQUIRE(self->connections().size() == 1);
  self->configure_read(
    hdl, receive_policy::exactly(sizeof(atom_value) + sizeof(int)));
  auto write = [=](atom_value type, int value) {
    auto& buf = self->wr_buf(hdl);
    auto first = reinterpret_cast<char*>(&type);
    buf.insert(buf.end(), first, first + sizeof(atom_value));
    first = reinterpret_cast<char*>(&value);
    buf.insert(buf.end(), first, first + sizeof(int));
    self->flush(hdl);
  };
  self->set_down_handler([=](down_msg& dm) {
    CAF_MESSAGE("received: " << to_string(dm));
    if (dm.source == buddy)
      self->quit(dm.reason);
  });
  self->become(
    [=](const connection_closed_msg&) {
      CAF_MESSAGE("received connection_closed_msg");
      self->quit();
    },
    [=](const new_data_msg& msg) {
      CAF_MESSAGE("received new_data_msg");
      atom_value type;
      int value;
      memcpy(&type, msg.buf.data(), sizeof(atom_value));
      memcpy(&value, msg.buf.data() + sizeof(atom_value), sizeof(int));
      self->send(buddy, type, value);
    },
    [=](ping_atom, int value) {
      CAF_MESSAGE("received: ping " << value);
      write(ping_atom::value, value);
    },
    [=](pong_atom, int value) {
      CAF_MESSAGE("received: pong " << value);
      write(pong_atom::value, value);
    }
  );
}

behavior peer_acceptor_fun(broker* self, const actor& buddy) {
  CAF_MESSAGE("peer_acceptor_fun");
  return {
    [=](const new_connection_msg& msg) {
      CAF_MESSAGE("received `new_connection_msg`");
      self->fork(peer_fun, msg.handle, buddy);
      self->quit();
    },
    [=](publish_atom) -> expected<uint16_t> {
      auto res = self->add_tcp_doorman(0, "127.0.0.1");
      if (!res)
        return std::move(res.error());
      return res->second;
    }
  };
}

void run_client(int argc, char** argv, uint16_t port) {
  actor_system_config cfg;
  actor_system system{cfg.load<io::middleman>().parse(argc, argv)};
  auto p = system.spawn(ping, size_t{10});
  CAF_MESSAGE("spawn_client...");
  CAF_EXP_THROW(cl, system.middleman().spawn_client(peer_fun, "127.0.0.1",
                                                    port, p));
  CAF_MESSAGE("spawn_client finished");
  anon_send(p, kickoff_atom::value, cl);
  CAF_MESSAGE("`kickoff_atom` has been send");
}

void run_server(int argc, char** argv) {
  actor_system_config cfg;
  actor_system system{cfg.load<io::middleman>().parse(argc, argv)};
  scoped_actor self{system};
  CAF_MESSAGE("spawn peer acceptor");
  auto serv = system.middleman().spawn_broker(peer_acceptor_fun,
                                              system.spawn(pong));
  std::thread child;
  self->request(serv, infinite, publish_atom::value).receive(
    [&](uint16_t port) {
      CAF_MESSAGE("server is running on port " << port);
      child = std::thread([=] {
        run_client(argc, argv, port);
      });
    },
    [&](const error& err) {
      CAF_ERROR("Error: " << self->system().render(err));
    }
  );
  self->await_all_other_actors_done();
  child.join();
}

} // namespace <anonymous>

CAF_TEST(test_broker) {
  auto argc = test::engine::argc();
  auto argv = test::engine::argv();
  run_server(argc, argv);
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_DOORMAN_HPP
#define CAF_IO_DOORMAN_HPP

#include <cstddef>
#include <cstdint>

#include "caf/message.hpp"
#include "caf/mailbox_element.hpp"

#include "caf/io/accept_handle.hpp"
#include "caf/io/broker_servant.hpp"
#include "caf/io/system_messages.hpp"
#include "caf/io/network/acceptor_manager.hpp"

namespace caf {
namespace io {

using doorman_base = broker_servant<network::acceptor_manager, accept_handle,
                                    new_connection_msg>;

/// Manages incoming connections.
/// @ingroup Broker
class doorman : public doorman_base {
public:
  doorman(accept_handle acc_hdl);

  ~doorman() override;

  void io_failure(execution_unit* ctx, network::operation op) override;

  using doorman_base::new_connection;

  bool new_connection(execution_unit* ctx, connection_handle x);

  /// Starts listening on the selected port.
  virtual void launch() = 0;

protected:
  message detach_message() override;
};

using doorman_ptr = intrusive_ptr<doorman>;

} // namespace io
} // namespace caf

// Allows the `middleman_actor` to create a `doorman` and then send it to the
// BASP broker.
CAF_ALLOW_UNSAFE_MESSAGE_TYPE(caf::io::doorman_ptr)

#endif // CAF_IO_DOORMAN_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_UNPUBLISH_HPP
#define CAF_IO_UNPUBLISH_HPP

#include <cstdint>

#include "caf/actor_system.hpp"

#include "caf/io/middleman.hpp"

namespace caf {
namespace io {

/// Unpublishes `whom` by closing `port` or all assigned ports if `port == 0`.
/// @param whom Actor that should be unpublished at `port`.
/// @param port TCP port.
template <class Handle>
expected<void> unpublish(const Handle& whom, uint16_t port = 0) {
  if (!whom)
    return sec::invalid_argument;
  return whom.home_system().middleman().unpublish(whom, port);
}

} // namespace io
} // namespace caf

#endif // CAF_IO_UNPUBLISH_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_CLOSE_HPP
#define CAF_IO_CLOSE_HPP

#include <cstdint>

#include "caf/actor_system.hpp"

#include "caf/io/middleman.hpp"

namespace caf {
namespace io {

/// Closes port `port` regardless of whether an actor is published to it.
inline expected<void> close(actor_system& sys, uint16_t port) {
  return sys.middleman().close(port);
}

} // namespace io
} // namespace caf

#endif // CAF_IO_CLOSE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_VISITORS_HPP
#define CAF_IO_VISITORS_HPP

#include "caf/io/abstract_broker.hpp"

namespace caf {
namespace io {

struct addr_visitor {
  using result_type = std::string;
  addr_visitor(abstract_broker* ptr) : ptr_(ptr) { }
  template <class Handle>
  result_type operator()(const Handle& hdl) { return ptr_->remote_addr(hdl); }
  abstract_broker* ptr_;
};

struct port_visitor {
  using result_type = uint16_t;
  port_visitor(abstract_broker* ptr) : ptr_(ptr) { }
  template <class Handle>
  result_type operator()(const Handle& hdl) { return ptr_->remote_port(hdl); }
  abstract_broker* ptr_;
};

struct id_visitor {
  using result_type = int64_t;
  template <class Handle>
  result_type operator()(const Handle& hdl) { return hdl.id(); }
};

struct hash_visitor {
  using result_type = size_t;
  template <class Handle>
  result_type operator()(const Handle& hdl) const {
    std::hash<Handle> f;
    return f(hdl);
  }
};

} // namespace io
} // namespace caf

#endif // CAF_IO_VISITORS_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_TYPED_BROKER_HPP
#define CAF_IO_TYPED_BROKER_HPP

#include <map>
#include <vector>
#include <type_traits>

#include "caf/none.hpp"
#include "caf/config.hpp"
#include "caf/make_counted.hpp"
#include "caf/extend.hpp"
#include "caf/typed_actor.hpp"
#include "caf/local_actor.hpp"

#include "caf/logger.hpp"
#include "caf/detail/scope_guard.hpp"
#include "caf/actor_registry.hpp"
#include "caf/detail/sync_request_bouncer.hpp"

#include "caf/mixin/sender.hpp"
#include "caf/mixin/requester.hpp"
#include "caf/mixin/behavior_changer.hpp"

#include "caf/io/fwd.hpp"
#include "caf/io/middleman.hpp"
#include "caf/io/abstract_broker.hpp"

namespace caf {

template <class... Sigs>
class behavior_type_of<io::typed_broker<Sigs...>> {
public:
  using type = typed_behavior<Sigs...>;
};

namespace io {

/// Denotes a minimal "client" broker managing one or more connection
/// handles by reacting to `new_data_msg` and `connection_closed_msg`.
/// @relates typed_broker
using connection_handler = typed_actor<reacts_to<new_data_msg>,
                                       reacts_to<connection_closed_msg>>;

/// Denotes a minimal "server" broker managing one or more accept
/// handles by reacting to `new_connection_msg` and `acceptor_closed_msg`.
/// The accept handler usually calls `self->fork(...)` when receiving
/// a `new_connection_msg`.
/// @relates typed_broker
using accept_handler = typed_actor<reacts_to<new_connection_msg>,
                                   reacts_to<acceptor_closed_msg>>;

/// A typed broker mediates between actor systems and other
/// components in the network.
/// @extends local_actor
template <class... Sigs>
class typed_broker : public extend<abstract_broker,
                                   typed_broker<Sigs...>>::template
                            with<mixin::sender, mixin::requester,
                                 mixin::behavior_changer>,
                     public statically_typed_actor_base {
public:
  using signatures = detail::type_list<Sigs...>;

  using actor_hdl = typed_actor<Sigs...>;

  using behavior_type = typed_behavior<Sigs...>;

  using super = typename extend<abstract_broker, typed_broker<Sigs...>>::
    template with<mixin::sender, mixin::requester, mixin::behavior_changer>;

  /// @cond PRIVATE
  std::set<std::string> message_types() const override {
    detail::type_list<typed_actor<Sigs...>> hdl;
    return this->system().message_types(hdl);
  }

  void initialize() override {
    CAF_LOG_TRACE("");
    this->init_broker();
    auto bhvr = make_behavior();
    CAF_LOG_DEBUG_IF(!bhvr, "make_behavior() did not return a behavior:"
                             << CAF_ARG(this->has_behavior()));
    if (bhvr) {
      // make_behavior() did return a behavior instead of using become()
      CAF_LOG_DEBUG("make_behavior() did return a valid behavior");
      this->do_become(std::move(bhvr.unbox()), true);
    }
  }

  template <class F, class... Ts>
  typename infer_handle_from_fun<F>::type
  fork(F fun, connection_handle hdl, Ts&&... xs) {
    CAF_ASSERT(this->context() != nullptr);
    auto sptr = this->take(hdl);
    CAF_ASSERT(sptr->hdl() == hdl);
    using impl = typename infer_handle_from_fun<F>::impl;
    static_assert(std::is_convertible<
                    typename impl::actor_hdl,
                    connection_handler
                  >::value,
                  "Cannot fork: new broker misses required handlers");
    actor_config cfg{this->context()};
    detail::init_fun_factory<impl, F> fac;
    cfg.init_fun = fac(std::move(fun), hdl, std::forward<Ts>(xs)...);
    auto res = this->system().spawn_functor(cfg, fun, hdl, std::forward<Ts>(xs)...);
    auto forked = static_cast<impl*>(actor_cast<abstract_actor*>(res));
    forked->move_scribe(std::move(sptr));
    return res;
  }

  expected<connection_handle> add_tcp_scribe(const std::string& host, uint16_t port) {
    static_assert(std::is_convertible<actor_hdl, connection_handler>::value,
                  "Cannot add scribe: broker misses required handlers");
    return super::add_tcp_scribe(host, port);
  }

  connection_handle add_tcp_scribe(network::native_socket fd) {
    static_assert(std::is_convertible<actor_hdl, connection_handler>::value,
                  "Cannot add scribe: broker misses required handlers");
    return super::add_tcp_scribe(fd);
  }

  expected<std::pair<accept_handle, uint16_t>>
  add_tcp_doorman(uint16_t port = 0,
                  const char* in = nullptr,
                  bool reuse_addr = false) {
    static_assert(std::is_convertible<actor_hdl, accept_handler>::value,
                  "Cannot add doorman: broker misses required handlers");
    return super::add_tcp_doorman(port, in, reuse_addr);
  }

  expected<accept_handle> add_tcp_doorman(network::native_socket fd) {
    static_assert(std::is_convertible<actor_hdl, accept_handler>::value,
                  "Cannot add doorman: broker misses required handlers");
    return super::add_tcp_doorman(fd);
  }

  explicit typed_broker(actor_config& cfg) : super(cfg) {
    // nop
  }

protected:
  virtual behavior_type make_behavior() {
    if (this->initial_behavior_fac_) {
      auto bhvr = this->initial_behavior_fac_(this);
      this->initial_behavior_fac_ = nullptr;
      if (bhvr)
        this->do_become(std::move(bhvr), true);
    }
    return behavior_type::make_empty_behavior();
  }
};

} // namespace io
} // namespace caf

#endif // CAF_IO_TYPED_BROKER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_ALL_HPP
#define CAF_IO_ALL_HPP

#include "caf/io/publish.hpp"
#include "caf/io/broker.hpp"
#include "caf/io/middleman.hpp"
#include "caf/io/unpublish.hpp"
#include "caf/io/basp_broker.hpp"
#include "caf/io/remote_actor.hpp"
#include "caf/io/typed_broker.hpp"
#include "caf/io/receive_policy.hpp"
#include "caf/io/middleman_actor.hpp"
#include "caf/io/system_messages.hpp"

#include "caf/io/network/protocol.hpp"
#include "caf/io/network/interfaces.hpp"
#include "caf/io/network/multiplexer.hpp"
#include "caf/io/network/test_multiplexer.hpp"

#include "caf/io/basp/all.hpp"

#endif // CAF_IO_ALL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_REMOTE_GROUP_HPP
#define CAF_IO_REMOTE_GROUP_HPP

#include <string>
#include <cstdint>

#include "caf/actor_system.hpp"

#include "caf/io/middleman.hpp"

namespace caf {
namespace io {

inline expected<group> remote_group(actor_system& sys,
                                    const std::string& group_uri) {
  return sys.middleman().remote_group(group_uri);
}

inline expected<group> remote_group(actor_system& sys,
                                    const std::string& group_identifier,
                                    const std::string& host, uint16_t port) {
  return sys.middleman().remote_group(group_identifier, host, port);
}

} // namespace io
} // namespace caf

#endif // CAF_IO_REMOTE_GROUP_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_ACCEPT_HANDLE_HPP
#define CAF_IO_ACCEPT_HANDLE_HPP

#include <functional>

#include "caf/error.hpp"

#include "caf/io/handle.hpp"

#include "caf/meta/type_name.hpp"

namespace caf {
namespace io {

struct invalid_accept_handle_t {
  constexpr invalid_accept_handle_t() {
    // nop
  }
};

constexpr invalid_accept_handle_t invalid_accept_handle
  = invalid_accept_handle_t{};

/// Generic handle type for managing incoming connections.
class accept_handle : public handle<accept_handle, invalid_accept_handle_t> {
public:
  friend class handle<accept_handle, invalid_accept_handle_t>;

  using super = handle<accept_handle, invalid_accept_handle_t>;

  constexpr accept_handle() {
    // nop
  }

  constexpr accept_handle(const invalid_accept_handle_t&) {
    // nop
  }

  template <class Inspector>
  friend typename Inspector::result_type inspect(Inspector& f,
                                                 accept_handle& x) {
    return f(meta::type_name("accept_handle"), x.id_);
  }

private:
  inline accept_handle(int64_t handle_id) : super(handle_id) {
    // nop
  }
};

} // namespace ios
} // namespace caf

namespace std{

template<>
struct hash<caf::io::accept_handle> {
  size_t operator()(const caf::io::accept_handle& hdl) const {
    hash<int64_t> f;
    return f(hdl.id());
  }
};

} // namespace std

#endif // CAF_IO_ACCEPT_HANDLE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_BASP_INSTANCE_HPP
#define CAF_IO_BASP_INSTANCE_HPP

#include <limits>

#include "caf/error.hpp"
#include "caf/variant.hpp"
#include "caf/actor_system_config.hpp"
#include "caf/binary_deserializer.hpp"

#include "caf/io/hook.hpp"
#include "caf/io/middleman.hpp"

#include "caf/io/basp/header.hpp"
#include "caf/io/basp/buffer_type.hpp"
#include "caf/io/basp/message_type.hpp"
#include "caf/io/basp/routing_table.hpp"
#include "caf/io/basp/connection_state.hpp"
#include "caf/io/basp/endpoint_context.hpp"

namespace caf {
namespace io {
namespace basp {

/// @addtogroup BASP

/// Describes a protocol instance managing multiple connections.
class instance {
public:
  /// Provides a callback-based interface for certain BASP events.
  class callee {
  protected:
    using buffer_type = std::vector<char>;
    using endpoint_handle = variant<connection_handle, datagram_handle>;
  public:
    explicit callee(actor_system& sys, proxy_registry::backend& backend);

    virtual ~callee();

    /// Called if a server handshake was received and
    /// the connection to `nid` is established.
    virtual void finalize_handshake(const node_id& nid, actor_id aid,
                                    std::set<std::string>& sigs) = 0;

    /// Called whenever a direct connection was closed or a
    /// node became unrechable for other reasons *before*
    /// this node gets erased from the routing table.
    /// @warning The implementing class must not modify the
    ///          routing table from this callback.
    virtual void purge_state(const node_id& nid) = 0;

    /// Called whenever a remote node created a proxy
    /// for one of our local actors.
    virtual void proxy_announced(const node_id& nid, actor_id aid) = 0;

    /// Called for each `dispatch_message` without `named_receiver_flag`.
    virtual void deliver(const node_id& source_node, actor_id source_actor,
                         actor_id dest_actor, message_id mid,
                         std::vector<strong_actor_ptr>& forwarding_stack,
                         message& msg) = 0;

    /// Called for each `dispatch_message` with `named_receiver_flag`.
    virtual void deliver(const node_id& source_node, actor_id source_actor,
                         atom_value dest_actor, message_id mid,
                         std::vector<strong_actor_ptr>& forwarding_stack,
                         message& msg) = 0;

    /// Called whenever BASP learns the ID of a remote node
    /// to which it does not have a direct connection.
    virtual void learned_new_node_directly(const node_id& nid,
                                           bool was_known_indirectly) = 0;

    /// Called whenever BASP learns the ID of a remote node
    /// to which it does not have a direct connection.
    virtual void learned_new_node_indirectly(const node_id& nid) = 0;

    /// Called if a heartbeat was received from `nid`
    virtual void handle_heartbeat(const node_id& nid) = 0;

    /// Returns the actor namespace associated to this BASP protocol instance.
    inline proxy_registry& proxies() {
      return namespace_;
    }

    inline actor_system& system() {
      return namespace_.system();
    }

    /// Returns the next outgoing sequence number for a connection.
    virtual sequence_type next_sequence_number(connection_handle hdl) = 0;

    /// Returns the next outgoing sequence number for an endpoint.
    virtual sequence_type next_sequence_number(datagram_handle hdl) = 0;

    /// Adds a message with a future sequence number to the pending messages
    /// of a given endpoint context.
    virtual void add_pending(execution_unit* ctx, endpoint_context& ep,
                             sequence_type seq, header hdr,
                             std::vector<char> payload) = 0;

    /// Delivers a pending incoming messages for an endpoint `ep` with
    /// application layer ordering. Delivery of the next available packet can
    /// be forced to simply skip undeliverd messages via the `force` flag.
    virtual bool deliver_pending(execution_unit* ctx, endpoint_context& ep,
                                 bool force) = 0;

    /// Drop pending messages with sequence number `seq`.
    virtual void drop_pending(endpoint_context& ep, sequence_type seq) = 0;

    /// Returns a reference to the current sent buffer, dispatching the call
    /// based on the type contained in `hdl`.
    virtual buffer_type& get_buffer(endpoint_handle hdl) = 0;

    /// Returns a reference to the current sent buffer. The callee may cache
    /// buffers to reuse them for multiple datagrams. Subsequent calls will
    /// return the same buffer until `pop_datagram_buffer` is called.
    virtual buffer_type& get_buffer(datagram_handle hdl) = 0;

    /// Returns a reference to the sent buffer.
    virtual buffer_type& get_buffer(connection_handle hdl) = 0;

    /// Returns the buffer accessed through a call to `get_buffer` when
    /// passing a datagram handle and removes it from the callee.
    virtual buffer_type pop_datagram_buffer(datagram_handle hdl) = 0;

    /// Flushes the underlying write buffer of `hdl`, dispatches the call based
    /// on the type contained in `hdl`.
    virtual void flush(endpoint_handle hdl) = 0;

    /// Flushes the underlying write buffer of `hdl`. Implicitly pops the
    /// current buffer and enqueues it for sending.
    virtual void flush(datagram_handle hdl) = 0;

    /// Flushes the underlying write buffer of `hdl`.
    virtual void flush(connection_handle hdl) = 0;

  protected:
    proxy_registry namespace_;
  };

  /// Describes a function object responsible for writing
  /// the payload for a BASP message.
  using payload_writer = callback<serializer&>;

  /// Describes a callback function object for `remove_published_actor`.
  using removed_published_actor = callback<const strong_actor_ptr&, uint16_t>;

  instance(abstract_broker* parent, callee& lstnr);

  /// Handles received data and returns a config for receiving the
  /// next data or `none` if an error occured.
  connection_state handle(execution_unit* ctx,
                          new_data_msg& dm, header& hdr, bool is_payload);

  /// Handles a received datagram.
  bool handle(execution_unit* ctx, new_datagram_msg& dm, endpoint_context& ep);

  /// Sends heartbeat messages to all valid nodes those are directly connected.
  void handle_heartbeat(execution_unit* ctx);

  /// Returns a route to `target` or `none` on error.
  optional<routing_table::route> lookup(const node_id& target);

  /// Flushes the underlying buffer of `path`.
  void flush(const routing_table::route& path);

  /// Sends a BASP message and implicitly flushes the output buffer of `r`.
  /// This function will update `hdr.payload_len` if a payload was written.
  void write(execution_unit* ctx, const routing_table::route& r,
             header& hdr, payload_writer* writer = nullptr);

  /// Adds a new actor to the map of published actors.
  void add_published_actor(uint16_t port,
                           strong_actor_ptr published_actor,
                           std::set<std::string> published_interface);

  /// Removes the actor currently assigned to `port`.
  size_t remove_published_actor(uint16_t port,
                                removed_published_actor* cb = nullptr);

  /// Removes `whom` if it is still assigned to `port` or from all of its
  /// current ports if `port == 0`.
  size_t remove_published_actor(const actor_addr& whom, uint16_t port,
                                removed_published_actor* cb = nullptr);

  /// Compare two sequence numbers
  static bool is_greater(sequence_type lhs, sequence_type rhs,
                         sequence_type max_distance
                          = std::numeric_limits<sequence_type>::max() / 2);


  /// Returns `true` if a path to destination existed, `false` otherwise.
  bool dispatch(execution_unit* ctx, const strong_actor_ptr& sender,
                const std::vector<strong_actor_ptr>& forwarding_stack,
                const strong_actor_ptr& receiver,
                message_id mid, const message& msg);

  /// Returns the actor namespace associated to this BASP protocol instance.
  proxy_registry& proxies() {
    return callee_.proxies();
  }

  /// Returns the routing table of this BASP instance.
  routing_table& tbl() {
    return tbl_;
  }

  /// Stores the address of a published actor along with its publicly
  /// visible messaging interface.
  using published_actor = std::pair<strong_actor_ptr, std::set<std::string>>;

  /// Maps ports to addresses and interfaces of published actors.
  using published_actor_map = std::unordered_map<uint16_t, published_actor>;

  /// Returns the current mapping of ports to addresses
  /// and interfaces of published actors.
  inline const published_actor_map& published_actors() const {
    return published_actors_;
  }

  /// Writes a header followed by its payload to `storage`.
  static void write(execution_unit* ctx, buffer_type& buf, header& hdr,
                    payload_writer* pw = nullptr);

  /// Writes the server handshake containing the information of the
  /// actor published at `port` to `buf`. If `port == none` or
  /// if no actor is published at this port then a standard handshake is
  /// written (e.g. used when establishing direct connections on-the-fly).
  void write_server_handshake(execution_unit* ctx,
                              buffer_type& out_buf, optional<uint16_t> port,
                              uint16_t sequence_number = 0);

  /// Writes the client handshake to `buf`.
  static void write_client_handshake(execution_unit* ctx,
                                     buffer_type& buf,
                                     const node_id& remote_side,
                                     const node_id& this_node,
                                     const std::string& app_identifier,
                                     uint16_t sequence_number = 0);

  /// Writes the client handshake to `buf`.
  void write_client_handshake(execution_unit* ctx,
                              buffer_type& buf, const node_id& remote_side,
                              uint16_t sequence_number = 0);

  /// Writes an `announce_proxy` to `buf`.
  void write_announce_proxy(execution_unit* ctx, buffer_type& buf,
                            const node_id& dest_node, actor_id aid,
                            uint16_t sequence_number = 0);

  /// Writes a `kill_proxy` to `buf`.
  void write_kill_proxy(execution_unit* ctx, buffer_type& buf,
                        const node_id& dest_node, actor_id aid,
                        const error& rsn, uint16_t sequence_number = 0);

  /// Writes a `heartbeat` to `buf`.
  void write_heartbeat(execution_unit* ctx,
                       buffer_type& buf, const node_id& remote_side,
                       uint16_t sequence_number = 0);

  inline const node_id& this_node() const {
    return this_node_;
  }

  /// Invokes the callback(s) associated with given event.
  template <hook::event_type Event, typename... Ts>
  void notify(Ts&&... xs) {
    system().middleman().template notify<Event>(std::forward<Ts>(xs)...);
  }

  inline actor_system& system() {
    return callee_.system();
  }

  template <class Handle>
  bool handle(execution_unit* ctx, const Handle& hdl, header& hdr,
              std::vector<char>* payload, bool tcp_based,
              optional<endpoint_context&> ep, optional<uint16_t> port) {
    // function object for checking payload validity
    auto payload_valid = [&]() -> bool {
      return payload != nullptr && payload->size() == hdr.payload_len;
    };
    // handle message to ourselves
    switch (hdr.operation) {
      case message_type::server_handshake: {
        actor_id aid = invalid_actor_id;
        std::set<std::string> sigs;
        if (!payload_valid()) {
          CAF_LOG_ERROR("fail to receive the app identifier");
          return false;
        } else {
          binary_deserializer bd{ctx, *payload};
          std::string remote_appid;
          auto e = bd(remote_appid);
          if (e)
            return false;
          if (remote_appid != callee_.system().config().middleman_app_identifier) {
            CAF_LOG_ERROR("app identifier mismatch");
            return false;
          }
          e = bd(aid, sigs);
          if (e)
            return false;
        }
        // close self connection after handshake is done
        if (hdr.source_node == this_node_) {
          CAF_LOG_INFO("close connection to self immediately");
          callee_.finalize_handshake(hdr.source_node, aid, sigs);
          return false;
        }
        // close this connection if we already have a direct connection
        if (tbl_.lookup_direct(hdr.source_node)) {
          CAF_LOG_INFO("close connection since we already have a "
                       "direct connection: " << CAF_ARG(hdr.source_node));
          callee_.finalize_handshake(hdr.source_node, aid, sigs);
          return false;
        }
        // add direct route to this node and remove any indirect entry
        CAF_LOG_INFO("new direct connection:" << CAF_ARG(hdr.source_node));
        tbl_.add_direct(hdl, hdr.source_node);
        auto was_indirect = tbl_.erase_indirect(hdr.source_node);
        // write handshake as client in response
        auto path = tbl_.lookup(hdr.source_node);
        if (!path) {
          CAF_LOG_ERROR("no route to host after server handshake");
          return false;
        }
        if (tcp_based) {
          auto ch = get<connection_handle>(path->hdl);
          write_client_handshake(ctx, callee_.get_buffer(ch),
                                 hdr.source_node);
        }
        callee_.learned_new_node_directly(hdr.source_node, was_indirect);
        callee_.finalize_handshake(hdr.source_node, aid, sigs);
        flush(*path);
        break;
      }
      case message_type::client_handshake: {
        if (!payload_valid()) {
          CAF_LOG_ERROR("fail to receive the app identifier");
          return false;
        } else {
          binary_deserializer bd{ctx, *payload};
          std::string remote_appid;
          auto e = bd(remote_appid);
          if (e)
            return false;
          if (remote_appid != callee_.system().config().middleman_app_identifier) {
            CAF_LOG_ERROR("app identifier mismatch");
            return false;
          }
        }
        if (tcp_based) {
          if (tbl_.lookup_direct(hdr.source_node)) {
            CAF_LOG_INFO("received second client handshake:"
                         << CAF_ARG(hdr.source_node));
            break;
          }
          // add direct route to this node and remove any indirect entry
          CAF_LOG_INFO("new direct connection:" << CAF_ARG(hdr.source_node));
          tbl_.add_direct(hdl, hdr.source_node);
          auto was_indirect = tbl_.erase_indirect(hdr.source_node);
          callee_.learned_new_node_directly(hdr.source_node, was_indirect);
        } else {
          auto new_node = (this_node() != hdr.source_node
                          && !tbl_.lookup_direct(hdr.source_node));
          if (new_node) {
            // add direct route to this node and remove any indirect entry
            CAF_LOG_INFO("new direct connection:" << CAF_ARG(hdr.source_node));
            tbl_.add_direct(hdl, hdr.source_node);
          }
          uint16_t seq = (ep && ep->requires_ordering) ? ep->seq_outgoing++ : 0;
          write_server_handshake(ctx,
                                 callee_.get_buffer(hdl),
                                 port, seq);
          callee_.flush(hdl);
          if (new_node) {
            auto was_indirect = tbl_.erase_indirect(hdr.source_node);
            callee_.learned_new_node_directly(hdr.source_node, was_indirect);
          }
        }
        break;
      }
      case message_type::dispatch_message: {
        if (!payload_valid())
          return false;
        // in case the sender of this message was received via a third node,
        // we assume that that node to offers a route to the original source
        auto last_hop = tbl_.lookup_direct(hdl);
        if (hdr.source_node != none
            && hdr.source_node != this_node_
            && last_hop != hdr.source_node
            && !tbl_.lookup_direct(hdr.source_node)
            && tbl_.add_indirect(last_hop, hdr.source_node))
          callee_.learned_new_node_indirectly(hdr.source_node);
        binary_deserializer bd{ctx, *payload};
        auto receiver_name = static_cast<atom_value>(0);
        std::vector<strong_actor_ptr> forwarding_stack;
        message msg;
        if (hdr.has(header::named_receiver_flag)) {
          auto e = bd(receiver_name);
          if (e)
            return false;
        }
        auto e = bd(forwarding_stack, msg);
        if (e)
          return false;
        CAF_LOG_DEBUG(CAF_ARG(forwarding_stack) << CAF_ARG(msg));
        if (hdr.has(header::named_receiver_flag))
          callee_.deliver(hdr.source_node, hdr.source_actor, receiver_name,
                          make_message_id(hdr.operation_data),
                          forwarding_stack, msg);
        else
          callee_.deliver(hdr.source_node, hdr.source_actor, hdr.dest_actor,
                          make_message_id(hdr.operation_data),
                          forwarding_stack, msg);
        break;
      }
      case message_type::announce_proxy:
        callee_.proxy_announced(hdr.source_node, hdr.dest_actor);
        break;
      case message_type::kill_proxy: {
        if (!payload_valid())
          return false;
        binary_deserializer bd{ctx, *payload};
        error fail_state;
        auto e = bd(fail_state);
        if (e)
          return false;
        callee_.proxies().erase(hdr.source_node, hdr.source_actor,
                                std::move(fail_state));
        break;
      }
      case message_type::heartbeat: {
        CAF_LOG_TRACE("received heartbeat: " << CAF_ARG(hdr.source_node));
        callee_.handle_heartbeat(hdr.source_node);
        break;
      }
      default:
        CAF_LOG_ERROR("invalid operation");
        return false;
    }
    return true;
  }

private:
  routing_table tbl_;
  published_actor_map published_actors_;
  node_id this_node_;
  callee& callee_;
};

/// @}

} // namespace basp
} // namespace io
} // namespace caf

#endif // CAF_IO_BASP_INSTANCE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_BASP_ALL_HPP
#define CAF_IO_BASP_ALL_HPP

#include "caf/io/basp/header.hpp"
#include "caf/io/basp/version.hpp"
#include "caf/io/basp/instance.hpp"
#include "caf/io/basp/buffer_type.hpp"
#include "caf/io/basp/message_type.hpp"
#include "caf/io/basp/routing_table.hpp"
#include "caf/io/basp/connection_state.hpp"

/// @defgroup BASP Binary Actor Sytem Protocol
///
/// # Protocol Overview
///
/// The "Binary Actor Sytem Protocol" (BASP) is **not** a network protocol.
/// It is a specification for the "Remote Method Invocation" (RMI) interface
/// used by distributed instances of CAF. The purpose of BASP is unify the
/// structure of RMI calls in order to simplify processing and implementation.
/// Hence, BASP is independent of any underlying network technology,
/// and assumes a reliable communication channel.
///
///
/// The RMI interface of CAF enables network-transparent monitoring and linking
/// as well as global message dispatching to actors running on different nodes.
///
/// ![](basp_overview.png)
///
/// The figure above illustrates the phyiscal as well as the logical view
/// of a distributed CAF application. Note that the actors used for the
/// BASP communication ("BASP Brokers") are not part of the logical system
/// view and are in fact not visible to other actors. A BASP Broker creates
/// proxy actors that represent actors running on different nodes. It is worth
/// mentioning that two instances of CAF running on the same physical machine
/// are considered two different nodes in BASP.
///
/// BASP has two objectives:
///
/// - **Forward messages sent to a proxy to the actor it represents**
///
///   Whenever a proxy instance receives a message, it forwards this message to
///   its parent (a BASP Broker). This message is then serialized and forwarded
///   over the network. If no direct connection between the node sending the
///   message and the node receiving it exists, intermediate BASP Brokers will
///   forward it until it the message reaches its destination.
///
/// - **Synchronize the state of an actor with all of its proxies**.
///
///   Whenever a node learns the address of a remotely running actor, it
///   creates  Ma local proxy instance representing this actor and sends an
///   `announce_proxy_instance` to the node hosting the actor. Whenever an actor
///   terminates, the hosting node sends `kill_proxy_instance` messages to all
///   nodes that have a proxy for this actor. This enables network-transparent
///   actor monitoring. There are two possible ways addresses can be learned:
///
///   + A client connects to a remotely running (published) actor via
///     `remote_actor`. In this case, the `server_handshake` will contain the
///     address of the published actor.
///
///   + Receiving `dispatch_message`. Whenever an actor message arrives,
///     it usually contains the address of the sender. Further, the message
///     itself can contain addresses to other actors that the BASP Broker
///     will get aware of while deserializing the message object
///     from the payload.
///
/// # Node IDs
///
/// The ID of a node consists of a 120 bit hash and the process ID. Note that
/// we use "node" as a synonym for "CAF instance". The hash is generated from
/// "low-level" characteristics of a machine such as the UUID of the root
/// file system and available MAC addresses. The only purpose of the node ID
/// is to generate a network-wide unique identifier. By adding the process ID,
/// CAF disambiguates multiple instances running on the same phyisical machine.
///
/// # Header Format
///
/// ![](basp_header.png)
///
/// - **Operation ID**: 4 bytes.
///
///   This field indicates what BASP function this datagram represents.
///   The value is an `uint32_t` representation of `message_type`.
///
/// - **Payload Length**: 4 bytes.
///
///   The length of the data following this header as `uint32_t`,
///   measured in bytes.
///
/// - **Operation Data**: 8 bytes.
///
///   This field contains.
///
/// - **Source Node ID**: 18 bytes.
///
///   The address of the source node. See [Node IDs](# Node IDs).
///
/// - **Destination Node ID**: 18 bytes.
///
///   The address of the destination node. See [Node IDs](# Node IDs).
///   Upon receiving this datagram, a BASP Broker compares this node ID
///   to its own ID. On a mismatch, it selects the next hop and forwards
///   this datagram unchanged.
///
/// - **Source Actor ID**: 4 bytes.
///
///   This field contains the ID of the sending actor or 0 for anonymously
///   sent messages. The *full address* of an actor is the combination of
///   the node ID and the actor ID. Thus, every actor can be unambigiously
///   identified by combining these two IDs.
///
/// - **Destination Actor ID**: 4 bytes.
///
///   This field contains the ID of the receiving actor or 0 for BASP
///   functions that do not require
///
/// # Example
///
/// The following diagram models a distributed application
/// with three nodes. The pseudo code for the application can be found
/// in the three grey boxes, while the resulting BASP messaging
/// is shown in UML sequence diagram notation. More details about
/// individual BASP message types can be found in the documentation
/// of {@link message_type} below.
///
/// ![](basp_sequence.png)

#endif // CAF_IO_BASP_ALL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_BASP_BUFFER_TYPE_HPP
#define CAF_IO_BASP_BUFFER_TYPE_HPP

#include <vector>

namespace caf {
namespace io {
namespace basp {

/// @addtogroup BASP

/// Storage type for raw bytes.
using buffer_type = std::vector<char>;

/// @}

} // namespace basp
} // namespace io
} // namespace caf

#endif // CAF_IO_BASP_BUFFER_TYPE_HPP

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_BASP_MESSAGE_TYPE_HPP
#define CAF_IO_BASP_MESSAGE_TYPE_HPP

#include <string>
#include <cstdint>

namespace caf {
namespace io {
namespace basp {

/// @addtogroup BASP

/// Describes the first header field of a BASP message and determines the
/// interpretation of the other header fields.
enum class message_type : uint8_t {
  /// Send from server, i.e., the node with a published actor, to client,
  /// i.e., node that initiates a new connection using remote_actor().
  ///
  /// ![](server_handshake.png)
  server_handshake = 0x00,

  /// Send from client to server after it has successfully received the
  /// server_handshake to establish the connection.
  ///
  /// ![](client_handshake.png)
  client_handshake = 0x01,

  /// Transmits a message from `source_node:source_actor` to
  /// `dest_node:dest_actor`.
  ///
  /// ![](dispatch_message.png)
  dispatch_message = 0x02,

  /// Informs the receiving node that the sending node has created a proxy
  /// instance for one of its actors. Causes the receiving node to attach
  /// a functor to the actor that triggers a kill_proxy_instance
  /// message on termination.
  ///
  /// ![](announce_proxy_instance.png)
  announce_proxy = 0x03,

  /// Informs the receiving node that it has a proxy for an actor
  /// that has been terminated.
  ///
  /// ![](kill_proxy_instance.png)
  kill_proxy = 0x04,

  /// Used to generate periodic traffic between two nodes
  /// in order to detect disconnects.
  ///
  /// ![](heartbeat.png)
  heartbeat = 0x05,
};

/// @relates message_type
std::string to_string(message_type);

/// @}

} // namespace basp
} // namespace io
} // namespace caf

#endif // CAF_IO_BASP_MESSAGE_TYPE_HPP

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_BASP_HEADER_HPP
#define CAF_IO_BASP_HEADER_HPP

#include <string>
#include <cstdint>

#include "caf/error.hpp"
#include "caf/node_id.hpp"

#include "caf/meta/omittable.hpp"
#include "caf/meta/type_name.hpp"

#include "caf/io/basp/message_type.hpp"

namespace caf {
namespace io {
namespace basp {

/// @addtogroup BASP

/// Sequence number type for BASP headers.
using sequence_type = uint16_t;

/// The header of a Binary Actor System Protocol (BASP) message.
/// A BASP header consists of a routing part, i.e., source and
/// destination, as well as an operation and operation data. Several
/// message types consist of only a header.
struct header {
  message_type operation;
  uint8_t padding1;
  uint8_t padding2;
  uint8_t flags;
  uint32_t payload_len;
  uint64_t operation_data;
  node_id source_node;
  node_id dest_node;
  actor_id source_actor;
  actor_id dest_actor;
  sequence_type sequence_number;

  inline header(message_type m_operation, uint8_t m_flags,
                uint32_t m_payload_len, uint64_t m_operation_data,
                node_id m_source_node, node_id m_dest_node,
                actor_id m_source_actor, actor_id m_dest_actor)
      : operation(m_operation),
        flags(m_flags),
        payload_len(m_payload_len),
        operation_data(m_operation_data),
        source_node(std::move(m_source_node)),
        dest_node(std::move(m_dest_node)),
        source_actor(m_source_actor),
        dest_actor(m_dest_actor),
        sequence_number(0) {
    // nop
  }

  inline header(message_type m_operation, uint8_t m_flags,
                uint32_t m_payload_len, uint64_t m_operation_data,
                node_id m_source_node, node_id m_dest_node,
                actor_id m_source_actor, actor_id m_dest_actor,
                sequence_type m_sequence_number)
      : operation(m_operation),
        flags(m_flags),
        payload_len(m_payload_len),
        operation_data(m_operation_data),
        source_node(std::move(m_source_node)),
        dest_node(std::move(m_dest_node)),
        source_actor(m_source_actor),
        dest_actor(m_dest_actor),
        sequence_number(m_sequence_number) {
    // nop
  }

  header() = default;

  /// Identifies a receiver by name rather than ID.
  static const uint8_t named_receiver_flag = 0x01;

  /// Queries whether this header has the given flag.
  inline bool has(uint8_t flag) const {
    return (flags & flag) != 0;
  }
};

/// @relates header
template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, header& hdr) {
  uint8_t pad = 0;
  return f(meta::type_name("header"),
           hdr.operation,
           meta::omittable(), pad,
           meta::omittable(), pad,
           hdr.flags, hdr.payload_len, hdr.operation_data,
           hdr.source_node, hdr.dest_node,
           hdr.source_actor, hdr.dest_actor,
           hdr.sequence_number);
}

/// @relates header
bool operator==(const header& lhs, const header& rhs);

/// @relates header
inline bool operator!=(const header& lhs, const header& rhs) {
  return !(lhs == rhs);
}

/// Checks whether given header contains a handshake.
inline bool is_handshake(const header& hdr) {
  return hdr.operation == message_type::server_handshake
      || hdr.operation == message_type::client_handshake;
}

/// Checks wheter given header contains a heartbeat.
inline bool is_heartbeat(const header& hdr) {
  return hdr.operation == message_type::heartbeat;
}

/// Checks whether given BASP header is valid.
/// @relates header
bool valid(const header& hdr);

/// Size of a BASP header in serialized form
constexpr size_t header_size = node_id::serialized_size * 2
                               + sizeof(actor_id) * 2
                               + sizeof(uint32_t) * 2
                               + sizeof(uint64_t)
                               + sizeof(sequence_type);

/// @}

} // namespace basp
} // namespace io
} // namespace caf

#endif // CAF_IO_BASP_HEADER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_BASP_CONNECTION_STATE_HPP
#define CAF_IO_BASP_CONNECTION_STATE_HPP


namespace caf {
namespace io {
namespace basp {

/// @addtogroup BASP

/// Denotes the state of a connection between to BASP nodes.
enum connection_state {
  /// Indicates that a connection is established and this node is
  /// waiting for the next BASP header.
  await_header,
  /// Indicates that this node has received a header with non-zero payload
  /// and is waiting for the data.
  await_payload,
  /// Indicates that this connection no longer exists.
  close_connection
};

/// @relates connection_state
inline std::string to_string(connection_state x) {
  return x == await_header ? "await_header"
                           : (x == await_payload ? "await_payload"
                                                 : "close_connection");
}

/// @}

} // namespace basp
} // namespace io
} // namespace caf

#endif // CAF_IO_BASP_CONNECTION_STATE_HPP

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_BASP_ENDPOINT_CONTEXT_HPP
#define CAF_IO_BASP_ENDPOINT_CONTEXT_HPP

#include <unordered_map>

#include "caf/variant.hpp"
#include "caf/response_promise.hpp"

#include "caf/io/datagram_handle.hpp"
#include "caf/io/connection_handle.hpp"

#include "caf/io/basp/header.hpp"
#include "caf/io/basp/connection_state.hpp"

namespace caf {
namespace io {
namespace basp {

// stores meta information for active endpoints
struct endpoint_context {
  using pending_map = std::map<sequence_type, std::pair<basp::header,
                                                        std::vector<char>>>;
  // denotes what message we expect from the remote node next
  basp::connection_state cstate;
  // our currently processed BASP header
  basp::header hdr;
  // the handle for I/O operations
  variant<connection_handle, datagram_handle> hdl;
  // network-agnostic node identifier
  node_id id;
  // ports
  uint16_t remote_port;
  uint16_t local_port;
  // pending operations to be performed after handshake completed
  optional<response_promise> callback;
  // protocols that do not implement ordering are ordered by CAF
  bool requires_ordering;
  // sequence numbers and a buffer to establish order
  sequence_type seq_incoming;
  sequence_type seq_outgoing;
  // pending messages due to ordering
  pending_map pending;
  // track if a timeout to deliver pending messages is set
  bool did_set_timeout;
};

} // namespace basp
} // namespace io
} // namespace caf

#endif // CAF_IO_BASP_ENDPOINT_CONTEXT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_BASP_ROUTING_TABLE_HPP
#define CAF_IO_BASP_ROUTING_TABLE_HPP

#include <unordered_map>
#include <unordered_set>

#include "caf/node_id.hpp"
#include "caf/callback.hpp"

#include "caf/io/visitors.hpp"
#include "caf/io/abstract_broker.hpp"

#include "caf/io/basp/buffer_type.hpp"

namespace std {

template<>
struct hash<caf::variant<caf::io::connection_handle,caf::io::datagram_handle>> {
  size_t operator()(const caf::variant<caf::io::connection_handle,
                                       caf::io::datagram_handle>& hdl) const {
    return caf::visit(caf::io::hash_visitor{}, hdl);
  }
};

} // namespace std

namespace caf {
namespace io {
namespace basp {

/// @addtogroup BASP

/// Stores routing information for a single broker participating as
/// BASP peer and provides both direct and indirect paths.
class routing_table {
public:
  using endpoint_handle = variant<connection_handle, datagram_handle>;

  explicit routing_table(abstract_broker* parent);

  virtual ~routing_table();

  /// Describes a routing path to a node.
  struct route {
    const node_id& next_hop;
    endpoint_handle hdl;
  };

  /// Describes a function object for erase operations that
  /// is called for each indirectly lost connection.
  using erase_callback = callback<const node_id&>;

  /// Returns a route to `target` or `none` on error.
  optional<route> lookup(const node_id& target);

  /// Returns the ID of the peer connected via `hdl` or
  /// `none` if `hdl` is unknown.
  node_id lookup_direct(const endpoint_handle& hdl) const;

  /// Returns the handle offering a direct connection to `nid` or
  /// `invalid_connection_handle` if no direct connection to `nid` exists.
  optional<endpoint_handle> lookup_direct(const node_id& nid) const;

  /// Returns the next hop that would be chosen for `nid`
  /// or `none` if there's no indirect route to `nid`.
  node_id lookup_indirect(const node_id& nid) const;

  /// Adds a new direct route to the table.
  /// @pre `hdl != invalid_connection_handle && nid != none`
  void add_direct(const endpoint_handle& hdl, const node_id& nid);

  /// Adds a new indirect route to the table.
  bool add_indirect(const node_id& hop, const node_id& dest);

  /// Blacklist the route to `dest` via `hop`.
  void blacklist(const node_id& hop, const node_id& dest);

  /// Removes a direct connection and calls `cb` for any node
  /// that became unreachable as a result of this operation,
  /// including the node that is assigned as direct path for `hdl`.
  void erase_direct(const endpoint_handle& hdl, erase_callback& cb);

  /// Removes any entry for indirect connection to `dest` and returns
  /// `true` if `dest` had an indirect route, otherwise `false`.
  bool erase_indirect(const node_id& dest);

  /// Queries whether `dest` is reachable.
  bool reachable(const node_id& dest);

  /// Removes all direct and indirect routes to `dest` and calls
  /// `cb` for any node that became unreachable as a result of this
  /// operation, including `dest`.
  /// @returns the number of removed routes (direct and indirect)
  size_t erase(const node_id& dest, erase_callback& cb);

  /// Returns the parent broker.
  inline abstract_broker* parent() {
    return parent_;
  }

public:
  template <class Map, class Fallback>
  typename Map::mapped_type
  get_opt(const Map& m, const typename Map::key_type& k, Fallback&& x) const {
    auto i = m.find(k);
    if (i != m.end())
      return i->second;
    return std::forward<Fallback>(x);
  }

  using node_id_set = std::unordered_set<node_id>;

  using indirect_entries = std::unordered_map<node_id,      // dest
                                              node_id_set>; // hop

  abstract_broker* parent_;
  std::unordered_map<endpoint_handle, node_id> direct_by_hdl_;
  std::unordered_map<node_id, endpoint_handle> direct_by_nid_;
  indirect_entries indirect_;
  indirect_entries blacklist_;
};

/// @}

} // namespace basp
} // namespace io
} // namespace caf

#endif // CAF_IO_BASP_ROUTING_TABLE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_BASP_VERSION_HPP
#define CAF_IO_BASP_VERSION_HPP

#include <cstdint>

namespace caf {
namespace io {
namespace basp {

/// @addtogroup BASP

/// The current BASP version. Different BASP versions will not
/// be able to exchange messages.
constexpr uint64_t version = 2;

/// @}

} // namespace basp
} // namespace io
} // namespace caf

#endif // CAF_IO_BASP_VERSION_HPP

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_HOOK_HPP
#define CAF_IO_HOOK_HPP

#include <set>
#include <memory>
#include <vector>

#include "caf/fwd.hpp"

namespace caf {
namespace io {

class hook;

// safes us some typing for the static dispatching
#define CAF_IO_HOOK_DISPATCH(eventname)                                        \
  template <typename... Ts>                                                    \
  void dispatch(event<eventname>, Ts&&... ts) {                                \
    eventname##_cb(std::forward<Ts>(ts)...);                                   \
  }

/// @relates hook
using hook_uptr = std::unique_ptr<hook>;

/// Interface to define hooks into the IO layer.
class hook {
public:
  explicit hook(actor_system& sys);

  virtual ~hook();

  /// Called whenever a message has arrived via the network.
  virtual void message_received_cb(const node_id& source,
                                   const strong_actor_ptr& from,
                                   const strong_actor_ptr& dest,
                                   message_id mid,
                                   const message& msg);

  /// Called whenever a message has been sent to the network.
  /// @param from The address of the sending actor.
  /// @param hop The node in the network we've sent the message to.
  /// @param dest The address of the receiving actor. Note that the node ID
  ///             of `dest` can differ from `hop` in case we don't
  ///             have a direct connection to `dest_node`.
  /// @param mid The ID of the message.
  /// @param payload The message we've sent.
  virtual void message_sent_cb(const strong_actor_ptr& from, const node_id& hop,
                               const strong_actor_ptr& dest, message_id mid,
                               const message& payload);

  /// Called whenever no route for sending a message exists.
  virtual void message_sending_failed_cb(const strong_actor_ptr& from,
                                         const strong_actor_ptr& dest,
                                         message_id mid,
                                         const message& payload);

  /// Called whenever a message is forwarded to a different node.
  virtual void message_forwarded_cb(const basp::header& hdr,
                                    const std::vector<char>* payload);

  /// Called whenever no route for a forwarding request exists.
  virtual void message_forwarding_failed_cb(const basp::header& hdr,
                                            const std::vector<char>* payload);

  /// Called whenever an actor has been published.
  virtual void actor_published_cb(const strong_actor_ptr& addr,
                                  const std::set<std::string>& ifs,
                                  uint16_t port);

  /// Called whenever a new remote actor appeared.
  virtual void new_remote_actor_cb(const strong_actor_ptr& addr);

  /// Called whenever a handshake via a direct TCP connection succeeded.
  virtual void new_connection_established_cb(const node_id& node);

  /// Called whenever a message from or to a yet unknown node was received.
  /// @param via The node that has sent us the message.
  /// @param node The newly added entry to the routing table.
  virtual void new_route_added_cb(const node_id& via, const node_id& node);

  /// Called whenever a direct connection was lost.
  virtual void connection_lost_cb(const node_id& dest);

  /// Called whenever a route became unavailable.
  /// @param hop The node that was either disconnected
  ///            or lost a connection itself.
  /// @param dest The node that is no longer reachable via `hop`.
  virtual void route_lost_cb(const node_id& hop, const node_id& dest);

  /// Called whenever a message was discarded because a remote node
  /// tried to send a message to an actor ID that could not be found
  /// in the registry.
  virtual void invalid_message_received_cb(const node_id& source,
                                           const strong_actor_ptr& sender,
                                           actor_id invalid_dest,
                                           message_id mid, const message& msg);

  /// Called before middleman shuts down.
  virtual void before_shutdown_cb();

  /// All possible events for IO hooks.
  enum event_type {
    message_received,
    message_sent,
    message_forwarded,
    message_sending_failed,
    message_forwarding_failed,
    actor_published,
    new_remote_actor,
    new_connection_established,
    new_route_added,
    connection_lost,
    route_lost,
    invalid_message_received,
    before_shutdown
  };

  /// Handles an event by invoking the associated callback.
  template <event_type Event, typename... Ts>
  void handle(Ts&&... ts) {
    dispatch(event<Event>{}, std::forward<Ts>(ts)...);
  }

  inline actor_system& system() const {
    return system_;
  }

private:
  // ------------ convenience interface based on static dispatching ------------
  template <event_type Id>
  using event = std::integral_constant<event_type, Id>;

  CAF_IO_HOOK_DISPATCH(message_received)
  CAF_IO_HOOK_DISPATCH(message_sent)
  CAF_IO_HOOK_DISPATCH(message_forwarded)
  CAF_IO_HOOK_DISPATCH(message_sending_failed)
  CAF_IO_HOOK_DISPATCH(message_forwarding_failed)
  CAF_IO_HOOK_DISPATCH(actor_published)
  CAF_IO_HOOK_DISPATCH(new_remote_actor)
  CAF_IO_HOOK_DISPATCH(new_connection_established)
  CAF_IO_HOOK_DISPATCH(new_route_added)
  CAF_IO_HOOK_DISPATCH(connection_lost)
  CAF_IO_HOOK_DISPATCH(route_lost)
  CAF_IO_HOOK_DISPATCH(invalid_message_received)
  CAF_IO_HOOK_DISPATCH(before_shutdown)

  actor_system& system_;
};

} // namespace io
} // namespace caf

#endif // CAF_IO_HOOK_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_UNPUBLISH_HPP
#define CAF_IO_UNPUBLISH_HPP

#include <cstdint>

#include "caf/actor_system.hpp"

#include "caf/io/middleman.hpp"

namespace caf {
namespace io {

/// Unpublishes `whom` by closing `port` or all assigned ports if `port == 0`.
/// @param whom Actor that should be unpublished at `port`.
/// @param port TCP port.
template <class Handle>
expected<void> unpublish(const Handle& whom, uint16_t port = 0) {
  if (!whom)
    return sec::invalid_argument;
  return whom.home_system().middleman().unpublish(whom, port);
}

} // namespace io
} // namespace caf

#endif // CAF_IO_UNPUBLISH_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_CONNECTION_HELPER_HPP
#define CAF_IO_CONNECTION_HELPER_HPP

#include <chrono>

#include "caf/stateful_actor.hpp"

#include "caf/io/network/interfaces.hpp"

#include "caf/after.hpp"
#include "caf/event_based_actor.hpp"
#include "caf/actor_system_config.hpp"

#include "caf/io/broker.hpp"
#include "caf/io/middleman.hpp"
#include "caf/io/basp_broker.hpp"
#include "caf/io/system_messages.hpp"
#include "caf/io/datagram_handle.hpp"

#include "caf/io/basp/all.hpp"

#include "caf/io/network/datagram_manager.hpp"
#include "caf/io/network/default_multiplexer.hpp"

namespace caf {
namespace io {

struct connection_helper_state {
  static const char* name;
};

behavior datagram_connection_broker(broker* self,
                                    uint16_t port,
                                    network::address_listing addresses,
                                    actor system_broker);

behavior connection_helper(stateful_actor<connection_helper_state>* self,
                           actor b);
} // namespace io
} // namespace caf

#endif // CAF_IO_CONNECTION_HELPER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_REMOTE_ACTOR_HPP
#define CAF_IO_REMOTE_ACTOR_HPP

#include <set>
#include <string>
#include <cstdint>

#include "caf/actor_system.hpp"

#include "caf/io/middleman.hpp"

namespace caf {
namespace io {

/// Establish a new connection to the actor at `host` on given `port`.
/// @param host Valid hostname or IP address.
/// @param port TCP port.
/// @returns An `actor` to the proxy instance representing
///          a remote actor or an `error`.
template <class ActorHandle = actor>
expected<ActorHandle> remote_actor(actor_system& sys, std::string host,
                                   uint16_t port) {
  return sys.middleman().remote_actor<ActorHandle>(std::move(host), port);
}

} // namespace io
} // namespace caf

#endif // CAF_IO_REMOTE_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_MIDDLEMAN_HPP
#define CAF_IO_MIDDLEMAN_HPP

#include <map>
#include <vector>
#include <memory>
#include <thread>

#include "caf/fwd.hpp"
#include "caf/send.hpp"
#include "caf/node_id.hpp"
#include "caf/expected.hpp"
#include "caf/actor_system.hpp"
#include "caf/proxy_registry.hpp"

#include "caf/io/hook.hpp"
#include "caf/io/broker.hpp"
#include "caf/io/middleman_actor.hpp"
#include "caf/io/network/multiplexer.hpp"

namespace caf {
namespace io {

/// Manages brokers and network backends.
class middleman : public actor_system::module {
public:
  friend class ::caf::actor_system;

  using hook_vector = std::vector<hook_uptr>;

  ~middleman() override;

  /// Tries to open a port for other CAF instances to connect to.
  /// @experimental
  expected<uint16_t> open(uint16_t port, const char* in = nullptr,
                          bool reuse = false);

  /// Closes port `port` regardless of whether an actor is published to it.
  expected<void> close(uint16_t port);

  /// Tries to connect to given node.
  /// @experimental
  expected<node_id> connect(std::string host, uint16_t port);

  /// Tries to publish `whom` at `port` and returns either an
  /// `error` or the bound port.
  /// @param whom Actor that should be published at `port`.
  /// @param port Unused TCP port.
  /// @param in The IP address to listen to or `INADDR_ANY` if `in == nullptr`.
  /// @param reuse Create socket using `SO_REUSEADDR`.
  /// @returns The actual port the OS uses after `bind()`. If `port == 0`
  ///          the OS chooses a random high-level port.
  template <class Handle>
  expected<uint16_t> publish(Handle&& whom, uint16_t port,
                             const char* in = nullptr, bool reuse = false) {
    detail::type_list<typename std::decay<Handle>::type> tk;
    return publish(actor_cast<strong_actor_ptr>(std::forward<Handle>(whom)),
                   system().message_types(tk), port, in, reuse);
  }

  /// Tries to publish `whom` at `port` and returns either an
  /// `error` or the bound port.
  /// @param whom Actor that should be published at `port`.
  /// @param port Unused TCP port.
  /// @param in The IP address to listen to or `INADDR_ANY` if `in == nullptr`.
  /// @param reuse Create socket using `SO_REUSEADDR`.
  /// @returns The actual port the OS uses after `bind()`. If `port == 0`
  ///          the OS chooses a random high-level port.
  template <class Handle>
  expected<uint16_t> publish_udp(Handle&& whom, uint16_t port,
                                 const char* in = nullptr, bool reuse = false) {
    detail::type_list<typename std::decay<Handle>::type> tk;
    return publish_udp(actor_cast<strong_actor_ptr>(std::forward<Handle>(whom)),
                       system().message_types(tk), port, in, reuse);
  }

  /// Makes *all* local groups accessible via network
  /// on address `addr` and `port`.
  /// @returns The actual port the OS uses after `bind()`. If `port == 0`
  ///          the OS chooses a random high-level port.
  expected<uint16_t> publish_local_groups(uint16_t port,
                                          const char* in = nullptr,
                                          bool reuse = false);

  /// Unpublishes `whom` by closing `port` or all assigned ports if `port == 0`.
  /// @param whom Actor that should be unpublished at `port`.
  /// @param port TCP port.
  template <class Handle>
  expected<void> unpublish(const Handle& whom, uint16_t port = 0) {
    return unpublish(whom.address(), port);
  }

  /// Unpublishes `whom` by closing `port` or all assigned ports if `port == 0`.
  /// @param whom Actor that should be unpublished at `port`.
  /// @param port UDP port.
  template <class Handle>
  expected<void> unpublish_udp(const Handle& whom, uint16_t port = 0) {
    return unpublish_udp(whom.address(), port);
  }

  /// Establish a new connection to the actor at `host` on given `port`.
  /// @param host Valid hostname or IP address.
  /// @param port TCP port.
  /// @returns An `actor` to the proxy instance representing
  ///          a remote actor or an `error`.
  template <class ActorHandle = actor>
  expected<ActorHandle> remote_actor(std::string host, uint16_t port) {
    detail::type_list<ActorHandle> tk;
    auto x = remote_actor(system().message_types(tk), std::move(host), port);
    if (!x)
      return x.error();
    CAF_ASSERT(x && *x);
    return actor_cast<ActorHandle>(std::move(*x));
  }

  /// Contacts the actor at `host` on given `port`.
  /// @param host Valid hostname or IP address.
  /// @param port TCP port.
  /// @returns An `actor` to the proxy instance representing
  ///          a remote actor or an `error`.
  template <class ActorHandle = actor>
  expected<ActorHandle> remote_actor_udp(std::string host, uint16_t port) {
    detail::type_list<ActorHandle> tk;
    auto x = remote_actor_udp(system().message_types(tk), std::move(host), port);
    if (!x)
      return x.error();
    CAF_ASSERT(x && *x);
    return actor_cast<ActorHandle>(std::move(*x));
  }

  /// <group-name>@<host>:<port>
  expected<group> remote_group(const std::string& group_uri);

  expected<group> remote_group(const std::string& group_identifier,
                               const std::string& host, uint16_t port);

  /// Returns the enclosing actor system.
  inline actor_system& system() {
    return system_;
  }

  /// Returns a handle to the actor managing the middleman singleton.
  middleman_actor actor_handle();

  /// Returns the broker associated with `name` or creates a
  /// new instance of type `Impl`.
  template <class Impl>
  actor named_broker(atom_value name) {
    auto i = named_brokers_.find(name);
    if (i != named_brokers_.end())
      return i->second;
    actor_config cfg{&backend()};
    auto result = system().spawn_impl<Impl, hidden>(cfg);
    named_brokers_.emplace(name, result);
    return result;
  }

  /// Runs `fun` in the event loop of the middleman.
  /// @note This member function is thread-safe.
  template <class F>
  void run_later(F fun) {
    backend().post(fun);
  }

  /// Returns the IO backend used by this middleman.
  virtual network::multiplexer& backend() = 0;

  /// Invokes the callback(s) associated with given event.
  template <hook::event_type Event, typename... Ts>
  void notify(Ts&&... ts) {
    for (auto& hook : hooks_)
      hook->handle<Event>(std::forward<Ts>(ts)...);
  }

  /// Returns whether this middleman has any hooks installed.
  inline bool has_hook() const {
    return !hooks_.empty();
  }

  /// Returns all installed hooks.
  const hook_vector& hooks() const {
    return hooks_;
  }

  /// Returns the actor associated with `name` at `nid` or
  /// `invalid_actor` if `nid` is not connected or has no actor
  /// associated to this `name`.
  /// @note Blocks the caller until `nid` responded to the lookup
  ///       or an error occurred.
  strong_actor_ptr remote_lookup(atom_value name, const node_id& nid);

  /// @experimental
  template <class Handle>
  expected<Handle>
  remote_spawn(const node_id& nid, std::string name, message args,
               duration timeout = duration(time_unit::minutes, 1)) {
    if (!nid || name.empty())
      return sec::invalid_argument;
    auto res = remote_spawn_impl(nid, name, args,
                                 system().message_types<Handle>(), timeout);
    if (!res)
      return std::move(res.error());
    return actor_cast<Handle>(std::move(*res));
  }

  /// @experimental
  template <class Handle, class Rep, class Period>
  expected<Handle> remote_spawn(const node_id& nid, std::string name,
                                message args,
                                std::chrono::duration<Rep, Period> timeout) {
    return remote_spawn<Handle>(nid, std::move(name), std::move(args),
                                duration{timeout});
  }

  /// Smart pointer for `network::multiplexer`.
  using backend_pointer = std::unique_ptr<network::multiplexer>;

  /// Used to initialize the backend during construction.
  using backend_factory = std::function<backend_pointer ()>;

  void start() override;

  void stop() override;

  void init(actor_system_config&) override;

  id_t id() const override;

  void* subtype_ptr() override;

  /// Spawns a new functor-based broker.
  template <spawn_options Os = no_spawn_options,
            class F = std::function<void(broker*)>, class... Ts>
  typename infer_handle_from_fun<F>::type
  spawn_broker(F fun, Ts&&... xs) {
    actor_config cfg{&backend()};
    return system().spawn_functor<Os>(cfg, fun, std::forward<Ts>(xs)...);
  }

  /// Returns a new functor-based broker connected
  /// to `host:port` or an `error`.
  /// @warning Blocks the caller for the duration of the connection process.
  template <spawn_options Os = no_spawn_options,
            class F = std::function<void(broker*)>, class... Ts>
  expected<typename infer_handle_from_fun<F>::type>
  spawn_client(F fun, const std::string& host, uint16_t port, Ts&&... xs) {
    using impl = typename infer_handle_from_fun<F>::impl;
    return spawn_client_impl<Os, impl>(std::move(fun), host, port,
                                       std::forward<Ts>(xs)...);
  }

  /// Spawns a new broker as server running on given `port`.
  /// @warning Blocks the caller until the server socket is initialized.
  template <spawn_options Os = no_spawn_options,
            class F = std::function<void(broker*)>, class... Ts>
  expected<typename infer_handle_from_fun<F>::type>
  spawn_server(F fun, uint16_t& port, Ts&&... xs) {
    using impl = typename infer_handle_from_fun<F>::impl;
    return spawn_server_impl<Os, impl>(std::move(fun), port,
                                       std::forward<Ts>(xs)...);
  }

  /// Spawns a new broker as server running on given `port`.
  /// @warning Blocks the caller until the server socket is initialized.
  template <spawn_options Os = no_spawn_options,
            class F = std::function<void(broker*)>, class... Ts>
  expected<typename infer_handle_from_fun<F>::type>
  spawn_server(F fun, const uint16_t& port, Ts&&... xs) {
    uint16_t dummy = port;
    using impl = typename infer_handle_from_fun<F>::impl;
    return spawn_server_impl<Os, impl>(std::move(fun), dummy,
                                       std::forward<Ts>(xs)...);
  }

  /// Returns a middleman using the default network backend.
  static actor_system::module* make(actor_system&, detail::type_list<>);

  template <class Backend>
  static actor_system::module* make(actor_system& sys,
                                    detail::type_list<Backend>) {
    class impl : public middleman {
    public:
      impl(actor_system& ref) : middleman(ref), backend_(&ref) {
        // nop
      }

      network::multiplexer& backend() override {
        return backend_;
      }

    private:
      Backend backend_;
    };
    return new impl(sys);
  }

protected:
  middleman(actor_system& sys);

private:
  template <spawn_options Os, class Impl, class F, class... Ts>
  expected<typename infer_handle_from_class<Impl>::type>
  spawn_client_impl(F fun, const std::string& host, uint16_t port, Ts&&... xs) {
    auto eptr = backend().new_tcp_scribe(host, port);
    if (!eptr)
      return eptr.error();
    auto ptr = std::move(*eptr);
    CAF_ASSERT(ptr != nullptr);
    detail::init_fun_factory<Impl, F> fac;
    actor_config cfg{&backend()};
    auto init_fun = fac(std::move(fun), ptr->hdl(), std::forward<Ts>(xs)...);
    cfg.init_fun = [ptr, init_fun](local_actor* self) mutable -> behavior {
      static_cast<abstract_broker*>(self)->add_scribe(std::move(ptr));
      return init_fun(self);
    };
    return system().spawn_class<Impl, Os>(cfg);
  }

  template <spawn_options Os, class Impl, class F, class... Ts>
  expected<typename infer_handle_from_class<Impl>::type>
  spawn_server_impl(F fun, uint16_t& port, Ts&&... xs) {
    auto eptr = backend().new_tcp_doorman(port);
    if (!eptr)
      return eptr.error();
    auto ptr = std::move(*eptr);
    detail::init_fun_factory<Impl, F> fac;
    auto init_fun = fac(std::move(fun), std::forward<Ts>(xs)...);
    port = ptr->port();
    actor_config cfg{&backend()};
    cfg.init_fun = [ptr, init_fun](local_actor* self) mutable -> behavior {
      static_cast<abstract_broker*>(self)->add_doorman(std::move(ptr));
      return init_fun(self);
    };
    return system().spawn_class<Impl, Os>(cfg);
  }

  expected<strong_actor_ptr> remote_spawn_impl(const node_id& nid,
                                               std::string& name, message& args,
                                               std::set<std::string> s,
                                               duration timeout);

  expected<uint16_t> publish(const strong_actor_ptr& whom,
                             std::set<std::string> sigs,
                             uint16_t port, const char* cstr, bool ru);

  expected<uint16_t> publish_udp(const strong_actor_ptr& whom,
                                 std::set<std::string> sigs,
                                 uint16_t port, const char* cstr, bool ru);

  expected<void> unpublish(const actor_addr& whom, uint16_t port);

  expected<void> unpublish_udp(const actor_addr& whom, uint16_t port);

  expected<strong_actor_ptr> remote_actor(std::set<std::string> ifs,
                                          std::string host, uint16_t port);

  expected<strong_actor_ptr> remote_actor_udp(std::set<std::string> ifs,
                                              std::string host, uint16_t port);

  static int exec_slave_mode(actor_system&, const actor_system_config&);

  // environment
  actor_system& system_;
  // prevents backend from shutting down unless explicitly requested
  network::multiplexer::supervisor_ptr backend_supervisor_;
  // runs the backend
  std::thread thread_;
  // keeps track of "singleton-like" brokers
  std::map<atom_value, actor> named_brokers_;
  // user-defined hooks
  hook_vector hooks_;
  // actor offering asyncronous IO by managing this singleton instance
  middleman_actor manager_;
};

} // namespace io
} // namespace caf

#endif // CAF_IO_MIDDLEMAN_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_BROKER_SERVANT_HPP
#define CAF_IO_BROKER_SERVANT_HPP

#include "caf/fwd.hpp"
#include "caf/mailbox_element.hpp"

#include "caf/io/abstract_broker.hpp"
#include "caf/io/system_messages.hpp"

namespace caf {
namespace io {

/// Base class for `scribe` and `doorman`.
/// @ingroup Broker
template <class Base, class Handle, class SysMsgType>
class broker_servant : public Base {
public:
  using handle_type = Handle;

  broker_servant(handle_type x)
      : hdl_(x),
        value_(strong_actor_ptr{}, make_message_id(),
               mailbox_element::forwarding_stack{}, SysMsgType{x, {}}) {
    // nop
  }

  handle_type hdl() const {
    return hdl_;
  }

  void halt() {
    activity_tokens_ = none;
    this->remove_from_loop();
  }

  void trigger() {
    activity_tokens_ = none;
    this->add_to_loop();
  }

  void trigger(size_t num) {
    CAF_ASSERT(num > 0);
    if (activity_tokens_)
      *activity_tokens_ += num;
    else
      activity_tokens_ = num;
    this->add_to_loop();
  }

  inline optional<size_t> activity_tokens() const {
    return activity_tokens_;
  }

protected:
  void detach_from(abstract_broker* ptr) override {
    ptr->erase(hdl_);
  }

  void invoke_mailbox_element_impl(execution_unit* ctx, mailbox_element& x) {
    auto self = this->parent();
    auto pfac = self->proxy_registry_ptr();
    if (pfac)
      ctx->proxy_registry_ptr(pfac);
    auto guard = detail::make_scope_guard([=] {
      if (pfac)
        ctx->proxy_registry_ptr(nullptr);
    });
    self->activate(ctx, x);
  }

  bool invoke_mailbox_element(execution_unit* ctx) {
    // hold on to a strong reference while "messing" with the parent actor
    strong_actor_ptr ptr_guard{this->parent()->ctrl()};
    auto prev = activity_tokens_;
    invoke_mailbox_element_impl(ctx, value_);
    // only consume an activity token if actor did not produce them now
    if (prev && activity_tokens_ && --(*activity_tokens_) == 0) {
      if (this->parent()->getf(abstract_actor::is_terminated_flag))
        return false;
      // tell broker it entered passive mode, this can result in
      // producing, why we check the condition again afterwards
      using passiv_t =
        typename std::conditional<
          std::is_same<handle_type, connection_handle>::value,
          connection_passivated_msg,
          typename std::conditional<
            std::is_same<handle_type, accept_handle>::value,
            acceptor_passivated_msg,
            datagram_servant_passivated_msg
          >::type
        >::type;
        using tmp_t = mailbox_element_vals<passiv_t>;
        tmp_t tmp{strong_actor_ptr{},                  make_message_id(),
                  mailbox_element::forwarding_stack{}, passiv_t{hdl()}};
        invoke_mailbox_element_impl(ctx, tmp);
        return activity_tokens_ != size_t{0};
    }
    return true;
  }

  SysMsgType& msg() {
    return value_.template get_mutable_as<SysMsgType>(0);
  }

  handle_type hdl_;
  mailbox_element_vals<SysMsgType> value_;
  optional<size_t> activity_tokens_;
};

} // namespace io
} // namespace caf

#endif // CAF_IO_BROKER_SERVANT_HPP

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_OPEN_HPP
#define CAF_IO_OPEN_HPP

#include <cstdint>

#include "caf/actor_system.hpp"

#include "caf/io/middleman.hpp"

namespace caf {
namespace io {

/// Tries to open a port for other CAF instances to connect to.
/// @experimental
inline expected<uint16_t> open(actor_system& sys, uint16_t port,
                               const char* in = nullptr, bool reuse = false) {
  return sys.middleman().open(port, in, reuse);
}

} // namespace io
} // namespace caf

#endif // CAF_IO_OPEN_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_MIDDLEMAN_ACTOR_IMPL_HPP
#define CAF_IO_MIDDLEMAN_ACTOR_IMPL_HPP

#include "caf/fwd.hpp"
#include "caf/atom.hpp"
#include "caf/typed_actor.hpp"
#include "caf/typed_event_based_actor.hpp"

#include "caf/io/fwd.hpp"
#include "caf/io/middleman_actor.hpp"

namespace caf {
namespace io {

/// Default implementation of the `middleman_actor` interface.
class middleman_actor_impl : public middleman_actor::base {
public:
  using put_res = result<uint16_t>;

  using mpi_set = std::set<std::string>;

  using get_res = result<node_id, strong_actor_ptr, mpi_set>;

  using get_delegated = delegated<node_id, strong_actor_ptr, mpi_set>;

  using del_res = result<void>;

  using endpoint_data = std::tuple<node_id, strong_actor_ptr, mpi_set>;

  using endpoint = std::pair<std::string, uint16_t>;

  middleman_actor_impl(actor_config& cfg, actor default_broker);

  void on_exit() override;

  const char* name() const override;

  behavior_type make_behavior() override;

protected:
  /// Tries to connect to given `host` and `port`. The default implementation
  /// calls `system().middleman().backend().new_tcp_scribe(host, port)`.
  virtual expected<scribe_ptr> connect(const std::string& host, uint16_t port);

  /// Tries to connect to given `host` and `port`. The default implementation
  /// calls `system().middleman().backend().new_udp`.
  virtual expected<datagram_servant_ptr> contact(const std::string& host,
                                                 uint16_t port);

  /// Tries to open a local port. The default implementation calls
  /// `system().middleman().backend().new_tcp_doorman(port, addr, reuse)`.
  virtual expected<doorman_ptr> open(uint16_t port, const char* addr,
                                     bool reuse);

  /// Tries to open a local port. The default implementation calls
  /// `system().middleman().backend().new_tcp_doorman(port, addr, reuse)`.
  virtual expected<datagram_servant_ptr> open_udp(uint16_t port, 
                                                  const char* addr, bool reuse);

private:
  put_res put(uint16_t port, strong_actor_ptr& whom, mpi_set& sigs,
              const char* in = nullptr, bool reuse_addr = false);

  put_res put_udp(uint16_t port, strong_actor_ptr& whom, mpi_set& sigs,
                  const char* in = nullptr, bool reuse_addr = false);

  optional<endpoint_data&> cached_tcp(const endpoint& ep);
  optional<endpoint_data&> cached_udp(const endpoint& ep);

  optional<std::vector<response_promise>&> pending(const endpoint& ep);

  actor broker_;
  std::map<endpoint, endpoint_data> cached_tcp_;
  std::map<endpoint, endpoint_data> cached_udp_;
  std::map<endpoint, std::vector<response_promise>> pending_;
};

} // namespace io
} // namespace caf

#endif // CAF_IO_MIDDLEMAN_ACTOR_IMPL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_NETWORK_PROTOCOL_HPP
#define CAF_IO_NETWORK_PROTOCOL_HPP

#include <cstddef>
#include <string>

#include "caf/meta/type_name.hpp"

namespace caf {
namespace io {
namespace network {

/// Bundles protocol information for network and transport layer communication.
struct protocol {
  /// Denotes a network protocol, i.e., IPv4 or IPv6.
  enum network {
    ipv4,
    ipv6
  };
  /// Denotes a transport protocol, i.e., TCP or UDP.
  enum transport {
    tcp,
    udp
  };
  transport trans;
  network net;
};

/// @relates protocol::transport
inline std::string to_string(protocol::transport x) {
  return x == protocol::tcp ? "TCP" : "UDP";
}

/// @relates protocol::network
inline std::string to_string(protocol::network x) {
  return x == protocol::ipv4 ? "IPv4" : "IPv6";
}

/// @relates protocol
template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, protocol& x) {
  return f(meta::type_name("protocol"), x.trans, x.net);
}

/// Converts a protocol into a transport/network string representation, e.g.,
/// "TCP/IPv4".
/// @relates protocol
std::string to_string(const protocol& x);

} // namespace network
} // namespace io
} // namespace caf

#endif // CAF_IO_NETWORK_PROTOCOL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_NETWORK_RECEIVE_BUFFER_HPP
#define CAF_IO_NETWORK_RECEIVE_BUFFER_HPP

#include <memory>
#include <cstddef>

#include "caf/allowed_unsafe_message_type.hpp"

namespace caf {
namespace io {
namespace network {

/// A container that does not call constructors and destructors for its values.
class receive_buffer {
public:
  using value_type = char;
  using size_type = size_t;
  using difference_type = std::ptrdiff_t;
  using reference = value_type&;
  using const_reference = const value_type&;
  using pointer = value_type*;
  using const_pointer = std::pointer_traits<pointer>::rebind<const value_type>;
  using iterator = pointer;
  using const_iterator = const_pointer;
  using reverse_iterator = std::reverse_iterator<iterator>;
  using const_reverse_iterator = std::reverse_iterator<const_iterator>;
  using buffer_ptr = std::unique_ptr<value_type[],
                                     std::default_delete<value_type[]>>;

  /// Create an empty container.
  receive_buffer();

  /// Create an empty container with `size` storage. Data in the storage is
  /// not initialized.
  receive_buffer(size_t size);

  /// Move constructor.
  receive_buffer(receive_buffer&& other) noexcept;

  /// Copy constructor.
  receive_buffer(const receive_buffer& other);

  /// Move assignment operator.
  receive_buffer& operator=(receive_buffer&& other) noexcept;

  /// Copy assignment operator.
  receive_buffer& operator=(const receive_buffer& other);

  /// Returns a pointer to the underlying buffer.
  inline pointer data() noexcept {
    return buffer_.get();
  }

  /// Returns a const pointer to the data.
  inline const_pointer data() const noexcept {
    return buffer_.get();
  }

  /// Returns the number of stored elements.
  size_type size() const noexcept {
    return size_;
  }

  /// Returns the number of elements that the container has allocated space for.
  size_type capacity() const noexcept {
    return capacity_;
  }

  /// Returns the maximum possible number of elements the container
  /// could theoretically hold.
  size_type max_size() const noexcept {
    return std::numeric_limits<size_t>::max();
  }

  /// Resize the container to `new_size`. While this may increase its storage,
  /// no storage will be released.
  void resize(size_type new_size);

  /// Set the size of the storage to `new_size`. If `new_size` is smaller than
  /// the current capacity nothing happens. If `new_size` is larger than the
  /// current capacity all iterators are invalidated.
  void reserve(size_type new_size);

  /// Shrink the container to its current size.
  void shrink_to_fit();

  /// Check if the container is empty.
  inline bool empty() const noexcept {
    return size_ == 0;
  }

  /// Clears the content of the container and releases the allocated storage.
  void clear();

  /// Swap contents with `other` receive buffer.
  void swap(receive_buffer& other) noexcept;

  /// Returns an iterator to the beginning.
  inline iterator begin() noexcept {
    return buffer_.get();
  }

  /// Returns an iterator to the end.
  inline iterator end() noexcept {
    return buffer_.get() + size_;
  }

  /// Returns an iterator to the beginning.
  inline const_iterator begin() const noexcept {
    return buffer_.get();
  }

  /// Returns an iterator to the end.
  inline const_iterator end() const noexcept {
    return buffer_.get() + size_;
  }

  /// Returns an iterator to the beginning.
  inline const_iterator cbegin() const noexcept {
    return buffer_.get();
  }

  /// Returns an iterator to the end.
  inline const_iterator cend() const noexcept {
    return buffer_.get() + size_;
  }

  /// Returns an iterator to the reverse beginning.
  inline reverse_iterator rbegin() noexcept {
    return reverse_iterator{buffer_.get() + size_};
  }

  /// Returns an iterator to the reverse end of the data.
  inline reverse_iterator rend() noexcept {
    return reverse_iterator{buffer_.get()};
  }

  /// Returns an iterator to the reverse beginning.
  inline const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator{buffer_.get() + size_};
  }

  /// Returns an iterator to the reverse end of the data.
  inline const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator{buffer_.get()};
  }

  /// Returns an iterator to the reverse beginning.
  inline const_reverse_iterator crbegin() const noexcept {
    return const_reverse_iterator{buffer_.get() + size_};
  }

  /// Returns an iterator to the reverse end of the data.
  inline const_reverse_iterator crend() const noexcept {
    return const_reverse_iterator{buffer_.get()};
  }

  /// Insert `value` before `pos`.
  iterator insert(iterator pos, value_type value);

  /// Append `value`.
  void push_back(value_type value);

private:
  // Increse the buffer capacity, maintaining its data. May invalidate iterators.
  void increase_by(size_t bytes);

  // Reduce the buffer capacity, maintaining its data. May invalidate iterators.
  void shrink_by(size_t bytes);

  buffer_ptr buffer_;
  size_type capacity_;
  size_type size_;
};

} // namepsace network
} // namespace io
} // namespace caf

#endif // CAF_IO_NETWORK_RECEIVE_BUFFER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_NETWORK_DEFAULT_MULTIPLEXER_HPP
#define CAF_IO_NETWORK_DEFAULT_MULTIPLEXER_HPP

#include <thread>

#include <vector>
#include <string>
#include <cstdint>

#include "caf/config.hpp"
#include "caf/extend.hpp"
#include "caf/ref_counted.hpp"

#include "caf/io/fwd.hpp"
#include "caf/io/scribe.hpp"
#include "caf/io/doorman.hpp"
#include "caf/io/accept_handle.hpp"
#include "caf/io/receive_policy.hpp"
#include "caf/io/datagram_handle.hpp"
#include "caf/io/datagram_servant.hpp"
#include "caf/io/connection_handle.hpp"
#include "caf/io/network/operation.hpp"
#include "caf/io/network/ip_endpoint.hpp"
#include "caf/io/network/multiplexer.hpp"
#include "caf/io/network/receive_buffer.hpp"
#include "caf/io/network/stream_manager.hpp"
#include "caf/io/network/acceptor_manager.hpp"
#include "caf/io/network/datagram_manager.hpp"

#include "caf/io/network/native_socket.hpp"

#include "caf/logger.hpp"

#ifdef CAF_WINDOWS
# ifndef WIN32_LEAN_AND_MEAN
#   define WIN32_LEAN_AND_MEAN
# endif // WIN32_LEAN_AND_MEAN
# ifndef NOMINMAX
#   define NOMINMAX
# endif
# ifdef CAF_MINGW
#   undef _WIN32_WINNT
#   undef WINVER
#   define _WIN32_WINNT WindowsVista
#   define WINVER WindowsVista
#   include <w32api.h>
# endif
# include <winsock2.h>
# include <windows.h>
# include <ws2tcpip.h>
# include <ws2ipdef.h>
#else
# include <unistd.h>
# include <cerrno>
# include <sys/socket.h>
# include <netinet/in.h>
# include <netinet/ip.h>
#endif

// poll xs epoll backend
#if !defined(CAF_LINUX) || defined(CAF_POLL_IMPL) // poll() multiplexer
# define CAF_POLL_MULTIPLEXER
# ifndef CAF_WINDOWS
#   include <poll.h>
# endif
# ifndef POLLRDHUP
#   define POLLRDHUP POLLHUP
# endif
# ifndef POLLPRI
#   define POLLPRI POLLIN
# endif
#else
# define CAF_EPOLL_MULTIPLEXER
# include <sys/epoll.h>
#endif

namespace caf {
namespace io {
namespace network {

// annoying platform-dependent bootstrapping
#ifdef CAF_WINDOWS
  using setsockopt_ptr = const char*;
  using getsockopt_ptr = char*;
  using socket_send_ptr = const char*;
  using socket_recv_ptr = char*;
  using socklen_t = int;
  using ssize_t = std::make_signed<size_t>::type;
  inline int last_socket_error() { return WSAGetLastError(); }
  inline bool would_block_or_temporarily_unavailable(int errcode) {
    return errcode == WSAEWOULDBLOCK || errcode == WSATRY_AGAIN;
  }
  constexpr int ec_out_of_memory = WSAENOBUFS;
  constexpr int ec_interrupted_syscall = WSAEINTR;
#else
  using setsockopt_ptr = const void*;
  using getsockopt_ptr = void*;
  using socket_send_ptr = const void*;
  using socket_recv_ptr = void*;
  inline void closesocket(int fd) { close(fd); }
  inline int last_socket_error() { return errno; }
  inline bool would_block_or_temporarily_unavailable(int errcode) {
    return errcode == EAGAIN || errcode == EWOULDBLOCK;
  }
  constexpr int ec_out_of_memory = ENOMEM;
  constexpr int ec_interrupted_syscall = EINTR;
#endif

// platform-dependent SIGPIPE setup
#if defined(CAF_MACOS) || defined(CAF_IOS) || defined(CAF_BSD)
  // Use the socket option but no flags to recv/send on macOS/iOS/BSD.
  constexpr int no_sigpipe_socket_flag = SO_NOSIGPIPE;
  constexpr int no_sigpipe_io_flag = 0;
#elif defined(CAF_WINDOWS)
  // Do nothing on Windows (SIGPIPE does not exist).
  constexpr int no_sigpipe_socket_flag = 0;
  constexpr int no_sigpipe_io_flag = 0;
#else
  // Use flags to recv/send on Linux/Android but no socket option.
  constexpr int no_sigpipe_socket_flag = 0;
  constexpr int no_sigpipe_io_flag = MSG_NOSIGNAL;
#endif

// poll vs epoll backend
#if !defined(CAF_LINUX) || defined(CAF_POLL_IMPL) // poll() multiplexer
# ifdef CAF_WINDOWS
    // From the MSDN: If the POLLPRI flag is set on a socket for the Microsoft
    //                Winsock provider, the WSAPoll function will fail.
    constexpr short input_mask  = POLLIN;
# else
    constexpr short input_mask  = POLLIN | POLLPRI;
# endif
  constexpr short error_mask  = POLLRDHUP | POLLERR | POLLHUP | POLLNVAL;
  constexpr short output_mask = POLLOUT;
  class event_handler;
  using multiplexer_data = pollfd;
  using multiplexer_poll_shadow_data = std::vector<event_handler*>;
#else
# define CAF_EPOLL_MULTIPLEXER
  constexpr int input_mask  = EPOLLIN;
  constexpr int error_mask  = EPOLLRDHUP | EPOLLERR | EPOLLHUP;
  constexpr int output_mask = EPOLLOUT;
  using multiplexer_data = epoll_event;
  using multiplexer_poll_shadow_data = native_socket;
#endif

/// Platform-specific native acceptor socket type.
using native_socket_acceptor = native_socket;

/// Returns the last socket error as human-readable string.
std::string last_socket_error_as_string();

/// Creates two connected sockets. The former is the read handle
/// and the latter is the write handle.
std::pair<native_socket, native_socket> create_pipe();

/// Sets fd to nonblocking if `set_nonblocking == true`
/// or to blocking if `set_nonblocking == false`
/// throws `network_error` on error
expected<void> nonblocking(native_socket fd, bool new_value);

/// Enables or disables Nagle's algorithm on `fd`.
/// @throws network_error
expected<void> tcp_nodelay(native_socket fd, bool new_value);

/// Enables or disables `SIGPIPE` events from `fd`.
expected<void> allow_sigpipe(native_socket fd, bool new_value);

/// Enables or disables `SIO_UDP_CONNRESET`error on `fd`.
expected<void> allow_udp_connreset(native_socket fd, bool new_value);

/// Get the socket buffer size for `fd`.
expected<int> send_buffer_size(native_socket fd);

/// Set the socket buffer size for `fd`.
expected<void> send_buffer_size(native_socket fd, int new_value);

/// Denotes the returned state of read and write operations on sockets.
enum class rw_state {
  /// Reports that bytes could be read or written.
  success,
  /// Reports that the socket is closed or faulty.
  failure,
  /// Reports that an empty buffer is in use and no operation was performed.
  indeterminate
};

/// Convenience functions for checking the result of `recv` or `send`.
bool is_error(ssize_t res, bool is_nonblock);

/// Reads up to `len` bytes from `fd,` writing the received data
/// to `buf`. Returns `true` as long as `fd` is readable and `false`
/// if the socket has been closed or an IO error occured. The number
/// of read bytes is stored in `result` (can be 0).
rw_state read_some(size_t& result, native_socket fd, void* buf, size_t len);

/// Writes up to `len` bytes from `buf` to `fd`.
/// Returns `true` as long as `fd` is readable and `false`
/// if the socket has been closed or an IO error occured. The number
/// of written bytes is stored in `result` (can be 0).
rw_state write_some(size_t& result, native_socket fd, const void* buf,
                    size_t len);

/// Tries to accept a new connection from `fd`. On success,
/// the new connection is stored in `result`. Returns true
/// as long as
bool try_accept(native_socket& result, native_socket fd);

/// Function signature of `read_some`.
using read_some_fun = decltype(read_some)*;

/// Function signature of `wite_some`.
using write_some_fun = decltype(write_some)*;

/// Function signature of `try_accept`.
using try_accept_fun = decltype(try_accept)*;

/// Policy object for wrapping default TCP operations.
struct tcp_policy {
  static read_some_fun read_some;
  static write_some_fun write_some;
  static try_accept_fun try_accept;
};

/// Write a datagram containing `buf_len` bytes to `fd` addressed
/// at the endpoint in `sa` with size `sa_len`. Returns true as long
/// as no IO error occurs. The number of written bytes is stored in
/// `result` and the sender is stored in `ep`.
bool read_datagram(size_t& result, native_socket fd, void* buf, size_t buf_len,
                   ip_endpoint& ep);

/// Reveice a datagram of up to `len` bytes. Larger datagrams are truncated.
/// Up to `sender_len` bytes of the receiver address is written into
/// `sender_addr`. Returns `true` if no IO error occurred. The number of
/// received bytes is stored in `result` (can be 0).
bool write_datagram(size_t& result, native_socket fd, void* buf, size_t buf_len,
                    const ip_endpoint& ep);

/// Function signature of read_datagram
using read_datagram_fun = decltype(read_datagram)*;

/// Function signature of write_datagram
using write_datagram_fun = decltype(write_datagram)*;

/// Policy object for wrapping default UDP operations
struct udp_policy {
  static read_datagram_fun read_datagram;
  static write_datagram_fun write_datagram;
};

/// Returns the locally assigned port of `fd`.
expected<uint16_t> local_port_of_fd(native_socket fd);

/// Returns the locally assigned address of `fd`.
expected<std::string> local_addr_of_fd(native_socket fd);

/// Returns the port used by the remote host of `fd`.
expected<uint16_t> remote_port_of_fd(native_socket fd);

/// Returns the remote host address of `fd`.
expected<std::string> remote_addr_of_fd(native_socket fd);

class default_multiplexer;

/// A socket I/O event handler.
class event_handler {
public:
  event_handler(default_multiplexer& dm, native_socket sockfd);

  virtual ~event_handler();

  /// Returns true once the requested operation is done, i.e.,
  /// to signalize the multiplexer to remove this handler.
  /// The handler remains in the event loop as long as it returns false.
  virtual void handle_event(operation op) = 0;

  /// Callback to signalize that this handler has been removed
  /// from the event loop for operations of type `op`.
  virtual void removed_from_loop(operation op) = 0;

  /// Returns the native socket handle for this handler.
  inline native_socket fd() const {
    return fd_;
  }

  /// Returns the `multiplexer` this acceptor belongs to.
  inline default_multiplexer& backend() {
    return backend_;
  }

  /// Returns the bit field storing the subscribed events.
  inline int eventbf() const {
    return eventbf_;
  }

  /// Sets the bit field storing the subscribed events.
  inline void eventbf(int value) {
    eventbf_ = value;
  }

  /// Checks whether `close_read` has been called.
  inline bool read_channel_closed() const {
    return read_channel_closed_;
  }

  /// Closes the read channel of the underlying socket.
  void close_read_channel();

  /// Removes the file descriptor from the event loop of the parent.
  void passivate();

protected:
  /// Adds the file descriptor to the event loop of the parent.
  void activate();

  void set_fd_flags();

  int eventbf_;
  native_socket fd_;
  bool read_channel_closed_;
  default_multiplexer& backend_;
};

/// An event handler for the internal event pipe.
class pipe_reader : public event_handler {
public:
  pipe_reader(default_multiplexer& dm);
  void removed_from_loop(operation op) override;
  void handle_event(operation op) override;
  void init(native_socket sock_fd);
  resumable* try_read_next();
};

class default_multiplexer : public multiplexer {
public:
  friend class io::middleman; // disambiguate reference
  friend class supervisor;

  struct event {
    native_socket fd;
    int mask;
    event_handler* ptr;
  };

  struct event_less {
    inline bool operator()(native_socket lhs, const event& rhs) const {
      return lhs < rhs.fd;
    }
    inline bool operator()(const event& lhs, native_socket rhs) const {
      return lhs.fd < rhs;
    }
    inline bool operator()(const event& lhs, const event& rhs) const {
      return lhs.fd < rhs.fd;
    }
  };

  scribe_ptr new_scribe(native_socket fd) override;

  expected<scribe_ptr> new_tcp_scribe(const std::string& host,
                                      uint16_t port) override;

  doorman_ptr new_doorman(native_socket fd) override;

  expected<doorman_ptr> new_tcp_doorman(uint16_t port, const char* in,
                                        bool reuse_addr) override;

  datagram_servant_ptr new_datagram_servant(native_socket fd) override;

  datagram_servant_ptr
  new_datagram_servant_for_endpoint(native_socket fd,
                                    const ip_endpoint& ep) override;

  expected<datagram_servant_ptr>
  new_remote_udp_endpoint(const std::string& host, uint16_t port) override;

  expected<datagram_servant_ptr>
  new_local_udp_endpoint(uint16_t port,const char* in = nullptr,
                         bool reuse_addr = false) override;

  void exec_later(resumable* ptr) override;

  explicit default_multiplexer(actor_system* sys);

  ~default_multiplexer() override;

  supervisor_ptr make_supervisor() override;

  /// Tries to run one or more events.
  /// @returns `true` if at least one event occurred, otherwise `false`.
  bool poll_once(bool block);

  bool try_run_once() override;

  void run_once() override;

  void run() override;

  void add(operation op, native_socket fd, event_handler* ptr);

  void del(operation op, native_socket fd, event_handler* ptr);

  /// Calls `ptr->resume`.
  void resume(intrusive_ptr<resumable> ptr);

  /// Get the next id to create a new datagram handle
  int64_t next_endpoint_id();

private:
  /// Calls `epoll`, `kqueue`, or `poll` with or without blocking.
  bool poll_once_impl(bool block);

  // platform-dependent additional initialization code
  void init();

  template <class F>
  void new_event(F fun, operation op, native_socket fd, event_handler* ptr) {
    CAF_ASSERT(fd != invalid_native_socket);
    CAF_ASSERT(ptr != nullptr || fd == pipe_.first);
    // the only valid input where ptr == nullptr is our pipe
    // read handle which is only registered for reading
    auto old_bf = ptr ? ptr->eventbf() : input_mask;
    //auto bf = fun(op, old_bf);
    CAF_LOG_TRACE(CAF_ARG(op) << CAF_ARG(fd) << CAF_ARG(old_bf));
    auto last = events_.end();
    auto i = std::lower_bound(events_.begin(), last, fd, event_less{});
    if (i != last && i->fd == fd) {
      CAF_ASSERT(ptr == i->ptr);
      // squash events together
      CAF_LOG_DEBUG("squash events:" << CAF_ARG(i->mask)
                    << CAF_ARG(fun(op, i->mask)));
      auto bf = i->mask;
      i->mask = fun(op, bf);
      if (i->mask == bf) {
        // didn't do a thing
        CAF_LOG_DEBUG("squashing did not change the event");
      } else if (i->mask == old_bf) {
        // just turned into a nop
        CAF_LOG_DEBUG("squashing events resulted in a NOP");
        events_.erase(i);
      }
    } else {
      // insert new element
      auto bf = fun(op, old_bf);
      if (bf == old_bf) {
        CAF_LOG_DEBUG("event has no effect (discarded): "
                 << CAF_ARG(bf) << ", " << CAF_ARG(old_bf));
      } else {
        CAF_LOG_DEBUG("added handler:" << CAF_ARG(fd) << CAF_ARG(op));
        events_.insert(i, event{fd, bf, ptr});
      }
    }
  }

  void handle(const event& e);

  void handle_socket_event(native_socket fd, int mask, event_handler* ptr);

  void close_pipe();

  void wr_dispatch_request(resumable* ptr);

  /// Socket handle to an OS-level event loop such as `epoll`. Unused in the
  /// `poll` implementation.
  native_socket epollfd_; // unused in poll() implementation

  /// Platform-dependent bookkeeping data, e.g., `pollfd` or `epoll_event`.
  std::vector<multiplexer_data> pollset_;

  /// Insertion and deletion events. This vector is always sorted by `.fd`.
  std::vector<event> events_;

  /// Platform-dependent meta data for `pollset_`. This allows O(1) lookup of
  /// event handlers from `pollfd`.
  multiplexer_poll_shadow_data shadow_;

  /// Pipe for pushing events and callbacks into the multiplexer's thread.
  std::pair<native_socket, native_socket> pipe_;

  /// Special-purpose event handler for the pipe.
  pipe_reader pipe_reader_;

  /// Events posted from the multiplexer's own thread are cached in this vector
  /// in order to prevent the multiplexer from writing into its own pipe. This
  /// avoids a possible deadlock where the multiplexer is blocked in
  /// `wr_dispatch_request` when the pipe's buffer is full.
  std::vector<intrusive_ptr<resumable>> internally_posted_;

  /// Sequential ids for handles of datagram servants
  int64_t servant_ids_;
};

inline connection_handle conn_hdl_from_socket(native_socket fd) {
  return connection_handle::from_int(int64_from_native_socket(fd));
}

inline accept_handle accept_hdl_from_socket(native_socket fd) {
  return accept_handle::from_int(int64_from_native_socket(fd));
}

/// A stream capable of both reading and writing. The stream's input
/// data is forwarded to its {@link stream_manager manager}.
class stream : public event_handler {
public:
  /// A smart pointer to a stream manager.
  using manager_ptr = intrusive_ptr<stream_manager>;

  /// A buffer class providing a compatible
  /// interface to `std::vector`.
  using buffer_type = std::vector<char>;

  stream(default_multiplexer& backend_ref, native_socket sockfd);

  /// Starts reading data from the socket, forwarding incoming data to `mgr`.
  void start(stream_manager* mgr);

  /// Activates the stream.
  void activate(stream_manager* mgr);

  /// Configures how much data will be provided for the next `consume` callback.
  /// @warning Must not be called outside the IO multiplexers event loop
  ///          once the stream has been started.
  void configure_read(receive_policy::config config);

  void ack_writes(bool x);

  /// Copies data to the write buffer.
  /// @warning Not thread safe.
  void write(const void* buf, size_t num_bytes);

  /// Returns the write buffer of this stream.
  /// @warning Must not be modified outside the IO multiplexers event loop
  ///          once the stream has been started.
  inline buffer_type& wr_buf() {
    return wr_offline_buf_;
  }

  /// Returns the read buffer of this stream.
  /// @warning Must not be modified outside the IO multiplexers event loop
  ///          once the stream has been started.
  inline buffer_type& rd_buf() {
    return rd_buf_;
  }

  /// Sends the content of the write buffer, calling the `io_failure`
  /// member function of `mgr` in case of an error.
  /// @warning Must not be called outside the IO multiplexers event loop
  ///          once the stream has been started.
  void flush(const manager_ptr& mgr);

  /// Closes the read channel of the underlying socket and removes
  /// this handler from its parent.
  void stop_reading();

  void removed_from_loop(operation op) override;

  /// Forces this stream to subscribe to write events if no data is in the
  /// write buffer.
  void force_empty_write(const manager_ptr& mgr) {
    if (!writing_) {
      backend().add(operation::write, fd(), this);
      writer_ = mgr;
      writing_ = true;
    }
  }

protected:
  template <class Policy>
  void handle_event_impl(io::network::operation op, Policy& policy) {
    CAF_LOG_TRACE(CAF_ARG(op));
    auto mcr = max_consecutive_reads();
    switch (op) {
      case io::network::operation::read: {
        // Loop until an error occurs or we have nothing more to read
        // or until we have handled `mcr` reads.
        size_t rb;
        for (size_t i = 0; i < mcr; ++i) {
          switch (policy.read_some(rb, fd(), rd_buf_.data() + collected_,
                                   rd_buf_.size() - collected_)) {
            case rw_state::failure:
              reader_->io_failure(&backend(), operation::read);
              passivate();
              return;
            case rw_state::indeterminate:
              return;
            case rw_state::success:
              if (rb == 0)
                return;
              collected_ += rb;
              if (collected_ >= read_threshold_) {
                auto res = reader_->consume(&backend(), rd_buf_.data(),
                                            collected_);
                prepare_next_read();
                if (!res) {
                  passivate();
                  return;
                }
              }
          }
        }
        break;
      }
      case io::network::operation::write: {
        size_t wb; // written bytes
        switch (policy.write_some(wb, fd(), wr_buf_.data() + written_,
                               wr_buf_.size() - written_)) {
          case rw_state::failure:
            writer_->io_failure(&backend(), operation::write);
            backend().del(operation::write, fd(), this);
            break;
          case rw_state::indeterminate:
            prepare_next_write();
            break;
          case rw_state::success:
            written_ += wb;
            CAF_ASSERT(written_ <= wr_buf_.size());
            auto remaining = wr_buf_.size() - written_;
            if (ack_writes_)
              writer_->data_transferred(&backend(), wb,
                                        remaining + wr_offline_buf_.size());
            // prepare next send (or stop sending)
            if (remaining == 0)
              prepare_next_write();
        }
        break;
      }
      case operation::propagate_error:
        if (reader_)
          reader_->io_failure(&backend(), operation::read);
        if (writer_)
          writer_->io_failure(&backend(), operation::write);
        // backend will delete this handler anyway,
        // no need to call backend().del() here
    }
  }

private:
  size_t max_consecutive_reads();

  void prepare_next_read();

  void prepare_next_write();

  // state for reading
  manager_ptr reader_;
  size_t read_threshold_;
  size_t collected_;
  size_t max_;
  receive_policy_flag rd_flag_;
  buffer_type rd_buf_;

  // state for writing
  manager_ptr writer_;
  bool ack_writes_;
  bool writing_;
  size_t written_;
  buffer_type wr_buf_;
  buffer_type wr_offline_buf_;
};

/// A concrete stream with a technology-dependent policy for sending and
/// receiving data from a socket.
template <class ProtocolPolicy>
class stream_impl : public stream {
public:
  template <class... Ts>
  stream_impl(default_multiplexer& mpx, native_socket sockfd, Ts&&... xs)
    : stream(mpx, sockfd),
      policy_(std::forward<Ts>(xs)...) {
    // nop
  }

  void handle_event(io::network::operation op) override {
    this->handle_event_impl(op, policy_);
  }

private:
  ProtocolPolicy policy_;
};

/// An acceptor is responsible for accepting incoming connections.
class acceptor : public event_handler {
public:
  /// A manager providing the `accept` member function.
  using manager_type = acceptor_manager;

  /// A smart pointer to an acceptor manager.
  using manager_ptr = intrusive_ptr<manager_type>;

  acceptor(default_multiplexer& backend_ref, native_socket sockfd);

  /// Returns the accepted socket. This member function should
  /// be called only from the `new_connection` callback.
  inline native_socket& accepted_socket() {
    return sock_;
  }

  /// Starts this acceptor, forwarding all incoming connections to
  /// `manager`. The intrusive pointer will be released after the
  /// acceptor has been closed or an IO error occured.
  void start(acceptor_manager* mgr);

  /// Activates the acceptor.
  void activate(acceptor_manager* mgr);

  /// Closes the network connection and removes this handler from its parent.
  void stop_reading();

  void removed_from_loop(operation op) override;

protected:
  template <class Policy>
  void handle_event_impl(io::network::operation op, Policy& policy) {
    CAF_LOG_TRACE(CAF_ARG(fd()) << CAF_ARG(op));
    if (mgr_ && op == operation::read) {
      native_socket sockfd = invalid_native_socket;
      if (policy.try_accept(sockfd, fd())) {
        if (sockfd != invalid_native_socket) {
          sock_ = sockfd;
          mgr_->new_connection();
        }
      }
    }
  }

private:
  manager_ptr mgr_;
  native_socket sock_;
};

/// A concrete acceptor with a technology-dependent policy.
template <class ProtocolPolicy>
class acceptor_impl : public acceptor {
public:
  template <class... Ts>
  acceptor_impl(default_multiplexer& mpx, native_socket sockfd, Ts&&... xs)
    : acceptor(mpx, sockfd),
      policy_(std::forward<Ts>(xs)...) {
    // nop
  }

  void handle_event(io::network::operation op) override {
    this->handle_event_impl(op, policy_);
  }

private:
  ProtocolPolicy policy_;
};

class datagram_handler : public event_handler {
public:
  /// A smart pointer to a datagram manager.
  using manager_ptr = intrusive_ptr<datagram_manager>;

  /// A buffer class providing a compatible interface to `std::vector`.
  using write_buffer_type = std::vector<char>;
  using read_buffer_type = network::receive_buffer;

  /// A job for sending a datagram consisting of the sender and a buffer.
  using job_type = std::pair<datagram_handle, write_buffer_type>;

  datagram_handler(default_multiplexer& backend_ref, native_socket sockfd);

  /// Starts reading data from the socket, forwarding incoming data to `mgr`.
  void start(datagram_manager* mgr);

  /// Activates the datagram handler.
  void activate(datagram_manager* mgr);

  void ack_writes(bool x);

  /// Copies data to the write buffer.
  /// @warning Not thread safe.
  void write(datagram_handle hdl, const void* buf, size_t num_bytes);

  /// Returns the write buffer of this enpoint.
  /// @warning Must not be modified outside the IO multiplexers event loop
  ///          once the stream has been started.
  inline write_buffer_type& wr_buf(datagram_handle hdl) {
    wr_offline_buf_.emplace_back();
    wr_offline_buf_.back().first = hdl;
    return wr_offline_buf_.back().second;
  }

  /// Enqueues a buffer to be sent as a datagram.
  /// @warning Must not be modified outside the IO multiplexers event loop
  ///          once the stream has been started.
  inline void enqueue_datagram(datagram_handle hdl, std::vector<char> buf) {
    wr_offline_buf_.emplace_back(hdl, move(buf));
  }

  /// Returns the read buffer of this stream.
  /// @warning Must not be modified outside the IO multiplexers event loop
  ///          once the stream has been started.
  inline read_buffer_type& rd_buf() {
    return rd_buf_;
  }

  /// Sends the content of the write buffer, calling the `io_failure`
  /// member function of `mgr` in case of an error.
  /// @warning Must not be called outside the IO multiplexers event loop
  ///          once the stream has been started.
  void flush(const manager_ptr& mgr);

  /// Closes the read channel of the underlying socket and removes
  /// this handler from its parent.
  void stop_reading();

  void removed_from_loop(operation op) override;

  void add_endpoint(datagram_handle hdl, const ip_endpoint& ep,
                    const manager_ptr mgr);

  std::unordered_map<datagram_handle, ip_endpoint>& endpoints();
  const std::unordered_map<datagram_handle, ip_endpoint>& endpoints() const;

  void remove_endpoint(datagram_handle hdl);

  inline ip_endpoint& sending_endpoint() {
    return sender_;
  }

protected:
  template <class Policy>
  void handle_event_impl(io::network::operation op, Policy& policy) {
    CAF_LOG_TRACE(CAF_ARG(op));
    auto mcr = max_consecutive_reads();
    switch (op) {
      case io::network::operation::read: {
        // Loop until an error occurs or we have nothing more to read
        // or until we have handled `mcr` reads.
        for (size_t i = 0; i < mcr; ++i) {
          if (!policy.read_datagram(num_bytes_, fd(), rd_buf_.data(),
                                    rd_buf_.size(), sender_)) {
            reader_->io_failure(&backend(), operation::read);
            passivate();
            return;
          }
          if (num_bytes_ > 0) {
            rd_buf_.resize(num_bytes_);
            auto itr = hdl_by_ep_.find(sender_);
            bool consumed = false;
            if (itr == hdl_by_ep_.end())
              consumed = reader_->new_endpoint(rd_buf_);
            else
              consumed = reader_->consume(&backend(), itr->second, rd_buf_);
            prepare_next_read();
            if (!consumed) {
              passivate();
              return;
            }
          }
        }
        break;
      }
      case io::network::operation::write: {
        size_t wb; // written bytes
        auto itr = ep_by_hdl_.find(wr_buf_.first);
        // maybe this could be an assert?
        if (itr == ep_by_hdl_.end())
          CAF_RAISE_ERROR("got write event for undefined endpoint");
        auto& id = itr->first;
        auto& ep = itr->second;
        std::vector<char> buf;
        std::swap(buf, wr_buf_.second);
        auto size_as_int = static_cast<int>(buf.size());
        if (size_as_int > send_buffer_size_) {
          send_buffer_size_ = size_as_int;
          send_buffer_size(fd(), size_as_int);
        }
        if (!policy.write_datagram(wb, fd(), buf.data(),
                                   buf.size(), ep)) {
          writer_->io_failure(&backend(), operation::write);
          backend().del(operation::write, fd(), this);
        } else if (wb > 0) {
          CAF_ASSERT(wb == buf.size());
          if (ack_writes_)
            writer_->datagram_sent(&backend(), id, wb, std::move(buf));
          prepare_next_write();
        } else {
          if (writer_)
            writer_->io_failure(&backend(), operation::write);
        }
        break;
      }
      case operation::propagate_error:
        if (reader_)
          reader_->io_failure(&backend(), operation::read);
        if (writer_)
          writer_->io_failure(&backend(), operation::write);
        // backend will delete this handler anyway,
        // no need to call backend().del() here
    }
  }

private:
  size_t max_consecutive_reads();

  void prepare_next_read();

  void prepare_next_write();

  // known endpoints and broker servants
  std::unordered_map<ip_endpoint, datagram_handle> hdl_by_ep_;
  std::unordered_map<datagram_handle, ip_endpoint> ep_by_hdl_;

  // state for reading
  const size_t max_datagram_size_;
  size_t num_bytes_;
  read_buffer_type rd_buf_;
  manager_ptr reader_;
  ip_endpoint sender_;

  // state for writing
  int send_buffer_size_;
  bool ack_writes_;
  bool writing_;
  std::deque<job_type> wr_offline_buf_;
  job_type wr_buf_;
  manager_ptr writer_;
};

/// A concrete datagram_handler with a technology-dependent policy.
template <class ProtocolPolicy>
class datagram_handler_impl : public datagram_handler {
public:
  template <class... Ts>
  datagram_handler_impl(default_multiplexer& mpx, native_socket sockfd,
                        Ts&&... xs)
    : datagram_handler(mpx, sockfd),
      policy_(std::forward<Ts>(xs)...) {
    // nop
  }

  void handle_event(io::network::operation op) override {
    this->handle_event_impl(op, policy_);
  }

private:
  ProtocolPolicy policy_;
};

expected<native_socket>
new_tcp_connection(const std::string& host, uint16_t port,
                   optional<protocol::network> preferred = none);

expected<native_socket>
new_tcp_acceptor_impl(uint16_t port, const char* addr, bool reuse_addr);

/// Default doorman implementation.
class doorman_impl : public doorman {
public:
  doorman_impl(default_multiplexer& mx, native_socket sockfd);

  bool new_connection() override;

  void stop_reading() override;

  void launch() override;

  std::string addr() const override;

  uint16_t port() const override;

  void add_to_loop() override;

  void remove_from_loop() override;

protected:
  acceptor_impl<tcp_policy> acceptor_;
};

/// Default scribe implementation.
class scribe_impl : public scribe {
public:
  scribe_impl(default_multiplexer& mx, native_socket sockfd);

  void configure_read(receive_policy::config config) override;

  void ack_writes(bool enable) override;

  std::vector<char>& wr_buf() override;

  std::vector<char>& rd_buf() override;

  void stop_reading() override;

  void flush() override;

  std::string addr() const override;

  uint16_t port() const override;

  void launch();

  void add_to_loop() override;

  void remove_from_loop() override;

protected:
  bool launched_;
  stream_impl<tcp_policy> stream_;
};

/// Default datagram servant implementation
class datagram_servant_impl : public datagram_servant {
  using id_type = int64_t;

public:
  datagram_servant_impl(default_multiplexer& mx, native_socket sockfd,
                        int64_t id);

  bool new_endpoint(network::receive_buffer& buf) override;

  void ack_writes(bool enable) override;

  std::vector<char>& wr_buf(datagram_handle hdl) override;

  void enqueue_datagram(datagram_handle hdl, std::vector<char> buf) override;

  network::receive_buffer& rd_buf() override;

  void stop_reading() override;

  void flush() override;

  std::string addr() const override;

  uint16_t port(datagram_handle hdl) const override;

  uint16_t local_port() const override;

  std::vector<datagram_handle> hdls() const override;

  void add_endpoint(const ip_endpoint& ep, datagram_handle hdl) override;

  void remove_endpoint(datagram_handle hdl) override;

  void launch() override;

  void add_to_loop() override;

  void remove_from_loop() override;

  void detach_handles() override;

private:
  bool launched_;
  datagram_handler_impl<udp_policy> handler_;
};

expected<std::pair<native_socket, ip_endpoint>>
new_remote_udp_endpoint_impl(const std::string& host, uint16_t port,
                             optional<protocol::network> preferred = none);

expected<std::pair<native_socket, protocol::network>>
new_local_udp_endpoint_impl(uint16_t port, const char* addr,
                            bool reuse_addr = false,
                            optional<protocol::network> preferred = none);

} // namespace network
} // namespace io
} // namespace caf

#endif // CAF_IO_NETWORK_DEFAULT_MULTIPLEXER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_NETWORK_INTERFACES_HPP
#define CAF_IO_NETWORK_INTERFACES_HPP

#include <map>
#include <vector>
#include <string>
#include <utility>
#include <functional>
#include <initializer_list>

#include "caf/optional.hpp"

#include "caf/io/network/protocol.hpp"
#include "caf/io/network/ip_endpoint.hpp"

namespace caf {
namespace io {
namespace network {

// {protocol => address}
using address_listing = std::map<protocol::network, std::vector<std::string>>;

// {interface_name => {protocol => address}}
using interfaces_map = std::map<std::string, address_listing>;

/// Utility class bundling access to network interface names and addresses.
class interfaces {
public:
  /// Consumes `{interface_name, protocol_type, is_localhost, address}` entries.
  using consumer = std::function<void (const char*, protocol::network,
                                       bool, const char*)>;

  /// Traverses all network interfaces for given protocols using `f`.
  static void traverse(std::initializer_list<protocol::network> ps, consumer f);

  /// Traverses all network interfaces using `f`.
  static void traverse(consumer f);

  /// Returns a map listing each interface by its name.
  static interfaces_map list_all(bool include_localhost = true);

  /// Returns all addresses for all devices for all protocols.
  static address_listing list_addresses(bool include_localhost = true);

  /// Returns all addresses for all devices for given protocols.
  static std::vector<std::string>
  list_addresses(std::initializer_list<protocol::network> procs,
                 bool include_localhost = true);

  /// Returns all addresses for all devices for given protocol.
  static std::vector<std::string> list_addresses(protocol::network proc,
                                                 bool include_localhost = true);

  /// Returns a native IPv4 or IPv6 translation of `host`.
  static optional<std::pair<std::string, protocol::network>>
  native_address(const std::string& host,
                 optional<protocol::network> preferred = none);

  /// Returns the host and protocol available for a local server socket
  static std::vector<std::pair<std::string, protocol::network>>
  server_address(uint16_t port, const char* host,
                 optional<protocol::network> preferred = none);

  /// Writes datagram endpoint info for `host`:`port` into ep
  static bool
  get_endpoint(const std::string& host, uint16_t port, ip_endpoint& ep,
               optional<protocol::network> preferred = none);
};

} // namespace network
} // namespace io
} // namespace caf

#endif // CAF_IO_NETWORK_INTERFACES_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 * Raphael Hiesgen <raphael.hiesgen (at) haw-hamburg.de>                      *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_NETWORK_ASIO_MULTIPLEXER_HPP
#define CAF_IO_NETWORK_ASIO_MULTIPLEXER_HPP

#include "caf/config.hpp"

CAF_PUSH_WARNINGS
#include "boost/asio.hpp"
CAF_POP_WARNINGS

#include "caf/logger.hpp"

#include "caf/io/receive_policy.hpp"

#include "caf/io/network/multiplexer.hpp"
#include "caf/io/network/native_socket.hpp"
#include "caf/io/network/stream_manager.hpp"
#include "caf/io/network/acceptor_manager.hpp"

namespace caf {
namespace io {
namespace network {

/// Low-level error code.
using error_code = boost::system::error_code;

/// Low-level backend for IO multiplexing.
using io_service = boost::asio::io_service;

/// Low-level socket type used as default.
using asio_tcp_socket = boost::asio::ip::tcp::socket;

/// Low-level socket type used as default.
using asio_tcp_socket_acceptor = boost::asio::ip::tcp::acceptor;

class multiplexer_backend : public io_service {
  // nop
};

/// A wrapper for the boost::asio multiplexer
class asio_multiplexer : public multiplexer {
public:
  friend class io::middleman;
  friend class supervisor;

  scribe_ptr new_scribe(asio_tcp_socket&& sock);

  scribe_ptr new_scribe(native_socket fd) override;

  expected<scribe_ptr> new_tcp_scribe(const std::string& host,
                                      uint16_t port) override;

  doorman_ptr new_doorman(asio_tcp_socket_acceptor&& sock);

  doorman_ptr new_doorman(native_socket fd) override;

  expected<doorman_ptr> new_tcp_doorman(uint16_t port, const char* in,
                                        bool reuse_addr) override;

  datagram_servant_ptr new_datagram_servant(native_socket fd) override;

  datagram_servant_ptr
  new_datagram_servant_for_endpoint(native_socket fd,
                                    const ip_endpoint& ep) override;

  expected<datagram_servant_ptr>
  new_remote_udp_endpoint(const std::string& host, uint16_t port) override;

  expected<datagram_servant_ptr>
  new_local_udp_endpoint(uint16_t port, const char* in = nullptr,
                         bool reuse_addr = false) override;

  void exec_later(resumable* ptr) override;

  asio_multiplexer(actor_system* sys);

  ~asio_multiplexer();

  supervisor_ptr make_supervisor() override;

  bool try_run_once() override;

  void run_once() override;

  void run() override;

  multiplexer_backend* pimpl() override;

  inline boost::asio::io_service& service() {
    return service_;
  }

private:
  multiplexer_backend service_;
};

template <class T>
connection_handle conn_hdl_from_socket(T& sock) {
  return connection_handle::from_int(
    int64_from_native_socket(sock.native_handle()));
}

template <class T>
accept_handle accept_hdl_from_socket(T& sock) {
  return accept_handle::from_int(
    int64_from_native_socket(sock.native_handle()));
}

/// @relates manager
using manager_ptr = intrusive_ptr<manager>;

/// A stream capable of both reading and writing. The stream's input
/// data is forwarded to its {@link stream_manager manager}.
template <class Socket>
class asio_stream {
public:
  /// A smart pointer to a stream manager.
  using manager_ptr = intrusive_ptr<stream_manager>;

  /// A buffer class providing a compatible interface to `std::vector`.
  using buffer_type = std::vector<char>;

  asio_stream(asio_multiplexer& ref)
      : reading_(false),
        writing_(false),
        ack_writes_(false),
        fd_(ref.service()),
        backend_(ref),
        rd_buf_ready_(false),
        async_read_pending_(false) {
    configure_read(receive_policy::at_most(1024));
  }

  /// Returns the IO socket.
  Socket& socket_handle() {
    return fd_;
  }

  /// Returns the IO socket.
  const Socket& socket_handle() const {
    return fd_;
  }

  /// Initializes this stream, setting the socket handle to `fd`.
  void init(Socket fd) {
    fd_ = std::move(fd);
  }

  /// Starts reading data from the socket, forwarding incoming data to `mgr`.
  void start(stream_manager* mgr) {
    CAF_ASSERT(mgr != nullptr);
    activate(mgr);
  }

  /// Configures how much data will be provided for the next `consume` callback.
  /// @warning Must not be called outside the IO multiplexers event loop
  ///          once the stream has been started.
  void configure_read(receive_policy::config config) {
    rd_flag_ = config.first;
    rd_size_ = config.second;
  }

  void ack_writes(bool enable) {
    CAF_LOG_TRACE(CAF_ARG(enable));
    ack_writes_ = enable;
  }

  /// Copies data to the write buffer.
  /// @note Not thread safe.
  void write(const void* buf, size_t num_bytes) {
    CAF_LOG_TRACE(CAF_ARG(num_bytes));
    auto first = reinterpret_cast<const char*>(buf);
    auto last = first + num_bytes;
    wr_offline_buf_.insert(wr_offline_buf_.end(), first, last);
  }

  /// Returns the write buffer of this stream.
  /// @warning Must not be modified outside the IO multiplexers event loop
  ///          once the stream has been started.
  buffer_type& wr_buf() {
    return wr_offline_buf_;
  }

  buffer_type& rd_buf() {
    return rd_buf_;
  }

  /// Sends the content of the write buffer, calling the `io_failure`
  /// member function of `mgr` in case of an error.
  /// @warning Must not be called outside the IO multiplexers event loop
  ///          once the stream has been started.
  void flush(const manager_ptr& mgr) {
    CAF_ASSERT(mgr != nullptr);
    if (!wr_offline_buf_.empty() && !writing_) {
      writing_ = true;
      write_loop(mgr);
    }
  }

  /// Closes the network connection, thus stopping this stream.
  void stop() {
    CAF_LOG_TRACE("");
    fd_.close();
  }

  void stop_reading() {
    CAF_LOG_TRACE("");
    error_code ec; // ignored
    fd_.shutdown(boost::asio::ip::tcp::socket::shutdown_receive, ec);
  }

  asio_multiplexer& backend() {
    return backend_;
  }

  /// Activates the stream.
  void activate(stream_manager* mgr) {
    reading_ = true;
    read_loop(mgr);
  }

  /// Stops activity of the stream.
  void passivate() {
    reading_ = false;
  }

private:
  bool read_one(stream_manager* ptr, size_t num_bytes) {
    if (!reading_) {
      // broker was passivated while async read was on its way
      rd_buf_ready_ = true;
      // make sure buf size matches read_bytes in case of async_read
      if (rd_buf_.size() != num_bytes)
        rd_buf_.resize(num_bytes);
      return false;
    }
    if (ptr->consume(&backend(), rd_buf_.data(), num_bytes))
      return reading_;
    return false;
  }

  void read_loop(manager_ptr mgr) {
    if (async_read_pending_)
      return;
    if (rd_buf_ready_) {
      rd_buf_ready_ = false;
      if (read_one(mgr.get(), rd_buf_.size()))
        read_loop(std::move(mgr));
      return;
    }
    auto cb = [=](const error_code& ec, size_t read_bytes) mutable {
      async_read_pending_ = false;
      CAF_LOG_TRACE("");
      if (!ec) {
        // bail out early in case broker passivated stream in the meantime
        if (read_one(mgr.get(), read_bytes))
          read_loop(std::move(mgr));
      } else {
        mgr->io_failure(&backend(), operation::read);
      }
    };
    switch (rd_flag_) {
      case receive_policy_flag::exactly:
        if (rd_buf_.size() < rd_size_)
          rd_buf_.resize(rd_size_);
        async_read_pending_ = true;
        boost::asio::async_read(fd_, boost::asio::buffer(rd_buf_, rd_size_),
                                cb);
        break;
      case receive_policy_flag::at_most:
        if (rd_buf_.size() < rd_size_)
          rd_buf_.resize(rd_size_);
        async_read_pending_ = true;
        fd_.async_read_some(boost::asio::buffer(rd_buf_, rd_size_), cb);
        break;
      case receive_policy_flag::at_least: {
        // read up to 10% more, but at least allow 100 bytes more
        auto min_size = rd_size_ + std::max<size_t>(100, rd_size_ / 10);
        if (rd_buf_.size() < min_size) {
          rd_buf_.resize(min_size);
        }
        collect_data(mgr, 0);
        break;
      }
    }
  }

  void write_loop(const manager_ptr& mgr) {
    if (wr_offline_buf_.empty()) {
      writing_ = false;
      return;
    }
    wr_buf_.clear();
    wr_buf_.swap(wr_offline_buf_);
    boost::asio::async_write(
      fd_, boost::asio::buffer(wr_buf_),
      [=](const error_code& ec, size_t nb) {
        CAF_LOG_TRACE("");
        if (ec) {
          CAF_LOG_DEBUG(CAF_ARG(ec.message()));
          mgr->io_failure(&backend(), operation::read);
          writing_ = false;
          return;
        }
        CAF_LOG_DEBUG(CAF_ARG(nb));
        if (ack_writes_)
          mgr->data_transferred(&backend(), nb, wr_offline_buf_.size());
        write_loop(mgr);
      });
  }

  void collect_data(manager_ptr mgr, size_t collected_bytes) {
    async_read_pending_ = true;
    fd_.async_read_some(boost::asio::buffer(rd_buf_.data() + collected_bytes,
                                            rd_buf_.size() - collected_bytes),
                        [=](const error_code& ec, size_t nb) mutable {
      async_read_pending_ = false;
      CAF_LOG_TRACE(CAF_ARG(nb));
      if (!ec) {
        auto sum = collected_bytes + nb;
        if (sum >= rd_size_) {
          if (read_one(mgr.get(), sum))
            read_loop(std::move(mgr));
        } else {
          collect_data(std::move(mgr), sum);
        }
      } else {
        mgr->io_failure(&backend(), operation::write);
      }
    });
  }

  /// Set if read loop was started by user and unset if passivate is called.
  bool reading_;

  /// Set on flush, also indicates that an async_write is pending.
  bool writing_;

  /// Stores whether user requested ACK messages for async writes.
  bool ack_writes_;

  /// TCP socket for this connection.
  Socket fd_;

  /// Configures how chunk sizes are calculated.
  receive_policy_flag rd_flag_;

  /// Minimum, maximum, or exact size of a chunk, depending on `rd_flag_`.
  size_t rd_size_;

  /// Input buffer.
  buffer_type rd_buf_;

  /// Output buffer for ASIO.
  buffer_type wr_buf_;

  /// Swapped with `wr_buf_` before next write. Users write into this buffer
  /// as long as `wr_buf_` is processed by ASIO.
  buffer_type wr_offline_buf_;

  /// Reference to our I/O backend.
  asio_multiplexer& backend_;

  /// Signalizes that a scribe was passivated while an async read was pending.
  bool rd_buf_ready_;

  /// Makes sure no more than one async_read is pending at any given time
  bool async_read_pending_;
};

/// An acceptor is responsible for accepting incoming connections.
template <class SocketAcceptor>
class asio_acceptor {
  using protocol_type = typename SocketAcceptor::protocol_type;
  using socket_type = boost::asio::basic_stream_socket<protocol_type>;

public:
  /// A manager providing the `accept` member function.
  using manager_type = acceptor_manager;

  /// A smart pointer to an acceptor manager.
  using manager_ptr = intrusive_ptr<manager_type>;

  asio_acceptor(asio_multiplexer& am, io_service& io)
      : accepting_(false),
        backend_(am),
        accept_fd_(io),
        fd_valid_(false),
        fd_(io),
        async_accept_pending_(false) {
    // nop
  }

  /// Returns the `multiplexer` this acceptor belongs to.
  asio_multiplexer& backend() { return backend_; }

  /// Returns the IO socket.
  SocketAcceptor& socket_handle() {
    return accept_fd_;
  }

  /// Returns the IO socket.
  const SocketAcceptor& socket_handle() const {
    return accept_fd_;
  }

  /// Returns the accepted socket. This member function should
  ///        be called only from the `new_connection` callback.
  inline socket_type& accepted_socket() {
    return fd_;
  }

  /// Initializes this acceptor, setting the socket handle to `fd`.
  void init(SocketAcceptor fd) {
    accept_fd_ = std::move(fd);
  }

  /// Starts this acceptor, forwarding all incoming connections to
  /// `manager`. The intrusive pointer will be released after the
  /// acceptor has been closed or an IO error occured.
  void start(manager_type* mgr) {
    activate(mgr);
  }

  /// Starts the accept loop.
  void activate(manager_type* mgr) {
    accepting_ = true;
    accept_loop(mgr);
  }

  /// Starts the accept loop.
  void passivate() {
    accepting_ = false;
  }

  /// Closes the network connection, thus stopping this acceptor.
  void stop() {
    accept_fd_.close();
  }

private:
  bool accept_one(manager_type* mgr) {
    auto res = mgr->new_connection(); // moves fd_
    // reset fd_ for next accept operation
    fd_ = socket_type{accept_fd_.get_io_service()};
    return res && accepting_;
  }

  void accept_loop(manager_ptr mgr) {
    if (async_accept_pending_)
      return;
    // accept "cached" connection first
    if (fd_valid_) {
      fd_valid_ = false;
      if (accept_one(mgr.get()))
        accept_loop(std::move(mgr));
      return;
    }
    async_accept_pending_ = true;
    accept_fd_.async_accept(fd_, [=](const error_code& ec) mutable {
      CAF_LOG_TRACE("");
      async_accept_pending_ = false;
      if (!ec) {
        // if broker has passivated this in the meantime, cache fd_ for later
        if (!accepting_) {
          fd_valid_ = true;
          return;
        }
        if (accept_one(mgr.get()))
          accept_loop(std::move(mgr));
      } else {
        mgr->io_failure(&backend(), operation::read);
      }
    });
  }

  bool accepting_;
  asio_multiplexer& backend_;
  SocketAcceptor accept_fd_;
  bool fd_valid_;
  socket_type fd_;
  /// Makes sure no more than one async_accept is pending at any given time
  bool async_accept_pending_;
};

} // namesapce network
} // namespace io
} // namespace caf

#endif // CAF_IO_NETWORK_ASIO_MULTIPLEXER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_NETWORK_OPERATION_HPP
#define CAF_IO_NETWORK_OPERATION_HPP

#include <string>

namespace caf {
namespace io {
namespace network {

/// Identifies network IO operations, i.e., read or write.
enum class operation {
  read,
  write,
  propagate_error
};

inline std::string to_string(operation op) {
  return op == operation::read ? "read"
                               : (op == operation::write ? "write"
                                                         : "propagate_error");
}

} // namespace network
} // namespace io
} // namespace caf

#endif // CAF_IO_NETWORK_OPERATION_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_NETWORK_DATAGRAM_MANAGER_HPP
#define CAF_IO_NETWORK_DATAGRAM_MANAGER_HPP

#include "caf/io/datagram_handle.hpp"
#include "caf/io/network/manager.hpp"
#include "caf/io/network/receive_buffer.hpp"

namespace caf {
namespace io {
namespace network {

/// A datagram manager provides callbacks for outgoing
/// datagrams as well as for error handling.
class datagram_manager : public manager {
public:
  ~datagram_manager() override;

  /// Called by the underlying I/O device whenever it received data.
  /// @returns `true` if the manager accepts further reads, otherwise `false`.
  virtual bool consume(execution_unit*, datagram_handle hdl,
                       receive_buffer& buf) = 0;

  /// Called by the underlying I/O device whenever it sent data.
  virtual void datagram_sent(execution_unit*, datagram_handle hdl, size_t,
                             std::vector<char> buffer) = 0;

  /// Called by the underlying I/O device to indicate that a new remote
  /// endpoint has been detected, passing in the received datagram.
  /// @returns `true` if the manager accepts further enpoints,
  ///          otherwise `false`.
  virtual bool new_endpoint(receive_buffer& buf) = 0;

  /// Get the port of the underlying I/O device.
  virtual uint16_t port(datagram_handle) const = 0;
};

} // namespace network
} // namespace io
} // namespace caf

#endif // CAF_IO_NETWORK_DATAGRAM_MANAGER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_NETWORK_MULTIPLEXER_HPP
#define CAF_IO_NETWORK_MULTIPLEXER_HPP

#include <string>
#include <thread>
#include <functional>

#include "caf/extend.hpp"
#include "caf/expected.hpp"
#include "caf/resumable.hpp"
#include "caf/make_counted.hpp"
#include "caf/execution_unit.hpp"

#include "caf/io/fwd.hpp"
#include "caf/io/accept_handle.hpp"
#include "caf/io/connection_handle.hpp"

#include "caf/io/network/protocol.hpp"
#include "caf/io/network/ip_endpoint.hpp"
#include "caf/io/network/native_socket.hpp"

namespace caf {
namespace io {
namespace network {

class multiplexer_backend;

/// Low-level backend for IO multiplexing.
class multiplexer : public execution_unit {
public:
  explicit multiplexer(actor_system* sys);

  /// Creates a new `scribe` from a native socket handle.
  /// @threadsafe
  virtual scribe_ptr new_scribe(native_socket fd) = 0;

  /// Tries to connect to `host` on given `port` and returns a `scribe` instance
  /// on success.
  /// @threadsafe
  virtual expected<scribe_ptr> new_tcp_scribe(const std::string& host,
                                              uint16_t port) = 0;

  /// Creates a new doorman from a native socket handle.
  /// @threadsafe
  virtual doorman_ptr new_doorman(native_socket fd) = 0;

  /// Tries to create an unbound TCP doorman bound to `port`, optionally
  /// accepting only connections from IP address `in`.
  /// @warning Do not call from outside the multiplexer's event loop.
  virtual expected<doorman_ptr> new_tcp_doorman(uint16_t port,
                                                const char* in = nullptr,
                                                bool reuse_addr = false) = 0;

  /// Creates a new `datagram_servant` from a native socket handle.
  /// @threadsafe
  virtual datagram_servant_ptr new_datagram_servant(native_socket fd) = 0;

  virtual datagram_servant_ptr
  new_datagram_servant_for_endpoint(native_socket fd, const ip_endpoint& ep) = 0;

  /// Create a new `datagram_servant` to contact a remote endpoint `host` and
  /// `port`.
  /// @warning Do not call from outside the multiplexer's event loop.
  virtual expected<datagram_servant_ptr>
  new_remote_udp_endpoint(const std::string& host, uint16_t port) = 0;

  /// Create a new `datagram_servant` that receives datagrams on the local
  /// `port`, optionally only accepting connections from IP address `in`.
  /// @warning Do not call from outside the multiplexer's event loop.
  virtual expected<datagram_servant_ptr>
  new_local_udp_endpoint(uint16_t port, const char* in = nullptr,
                         bool reuse_addr = false) = 0;

  /// Simple wrapper for runnables
  class runnable : public resumable, public ref_counted {
  public:
    subtype_t subtype() const override;
    void intrusive_ptr_add_ref_impl() override;
    void intrusive_ptr_release_impl() override;
  };

  /// Makes sure the multipler does not exit its event loop until
  /// the destructor of `supervisor` has been called.
  class supervisor {
  public:
    virtual ~supervisor();
  };

  using supervisor_ptr = std::unique_ptr<supervisor>;

  /// Creates a supervisor to keep the event loop running.
  virtual supervisor_ptr make_supervisor() = 0;

  /// Creates an instance using the networking backend compiled with CAF.
  static std::unique_ptr<multiplexer> make(actor_system& sys);

  /// Exectutes all pending events without blocking.
  /// @returns `true` if at least one event was called, `false` otherwise.
  virtual bool try_run_once() = 0;

  /// Runs at least one event and blocks if needed.
  virtual void run_once() = 0;

  /// Runs events until all connection are closed.
  virtual void run() = 0;

  /// Invokes @p fun in the multiplexer's event loop, calling `fun()`
  /// immediately when called from inside the event loop.
  /// @threadsafe
  template <class F>
  void dispatch(F fun) {
    if (std::this_thread::get_id() == thread_id()) {
      fun();
      return;
    }
    post(std::move(fun));
  }

  /// Invokes @p fun in the multiplexer's event loop, forcing
  /// execution to be delayed when called from inside the event loop.
  /// @threadsafe
  template <class F>
  void post(F fun) {
    struct impl : runnable {
      F f;
      impl(F&& mf) : f(std::move(mf)) { }
      resume_result resume(execution_unit*, size_t) override {
        f();
        return done;
      }
    };
    exec_later(new impl(std::move(fun)));
  }

  /// Retrieves a pointer to the implementation or `nullptr` if CAF was
  /// compiled using the default backend.
  virtual multiplexer_backend* pimpl();

  inline const std::thread::id& thread_id() const {
    return tid_;
  }

  inline void thread_id(std::thread::id tid) {
    tid_ = std::move(tid);
  }

protected:
  /// Identifies the thread this multiplexer
  /// is running in. Must be set by the subclass.
  std::thread::id tid_;
};

using multiplexer_ptr = std::unique_ptr<multiplexer>;

} // namespace network
} // namespace io
} // namespace caf

#endif // CAF_IO_NETWORK_MULTIPLEXER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_IP_ENDPOINT_HPP
#define CAF_IO_IP_ENDPOINT_HPP

#include <deque>
#include <vector>
#include <string>
#include <functional>

#include "caf/error.hpp"
#include "caf/meta/type_name.hpp"
#include "caf/meta/save_callback.hpp"
#include "caf/meta/load_callback.hpp"

struct sockaddr;
struct sockaddr_storage;
struct sockaddr_in;
struct sockaddr_in6;

namespace caf {
namespace io {
namespace network {

// hash for char*, see:
// - https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
// - http://www.isthe.com/chongo/tech/comp/fnv/index.html
// Always hash 128 bit address, for v4 we use the embedded addr.
class ep_hash {
public:
  ep_hash();
  size_t operator()(const sockaddr& sa) const noexcept;
  size_t hash(const sockaddr_in* sa) const noexcept;
  size_t hash(const sockaddr_in6* sa) const noexcept;
};

/// A hashable wrapper for a sockaddr storage.
struct ip_endpoint {
public:

  /// Default constructor for sockaddr storage which reserves memory for the
  /// internal data structure on creation.
  ip_endpoint();

  /// Move constructor.
  ip_endpoint(ip_endpoint&&) = default;

  /// Copy constructor.
  ip_endpoint(const ip_endpoint&);

  /// Destructor
  ~ip_endpoint() = default;

  /// Copy assignment operator.
  ip_endpoint& operator=(const ip_endpoint&);

  /// Move assignment operator.
  ip_endpoint& operator=(ip_endpoint&&) = default;

  /// Returns a pointer to the internal address storage.
  sockaddr* address();

  /// Returns a constant pointer to the internal address storage.
  const sockaddr* caddress() const;

  /// Returns the length of the stored address.
  size_t* length();

  /// Returns the length of the stored address.
  const size_t* clength() const;

  /// Null internal storage and length.
  void clear();

private:
  struct impl;
  struct impl_deleter { void operator()(impl*) const; };
  std::unique_ptr<impl,impl_deleter> ptr_;
};

bool operator==(const ip_endpoint& lhs, const ip_endpoint& rhs);

std::string to_string(const ip_endpoint& ep);

std::string host(const ip_endpoint& ep);

uint16_t port(const ip_endpoint& ep);

uint32_t family(const ip_endpoint& ep);

error load_endpoint(ip_endpoint& ep, uint32_t& f, std::string& h,
                    uint16_t& p, size_t& l);

error save_endpoint(ip_endpoint& ep, uint32_t& f, std::string& h,
                    uint16_t& p, size_t& l);

template <class Inspector>
typename Inspector::result_type inspect(Inspector& fun, ip_endpoint& ep) {
  uint32_t f;
  std::string h;
  uint16_t p;
  size_t l;
  if (*ep.length() > 0) {
    f = family(ep);
    h = host(ep);
    p = port(ep);
    l = *ep.length();
  }
  auto load = [&] { return load_endpoint(ep, f, h, p, l); };
  auto save = [&] { return save_endpoint(ep, f, h, p, l); };
  return fun(meta::type_name("ip_endpoint"), f, h, p, l,
             meta::load_callback(load), meta::save_callback(save));
}

} // namespace network
} // namespace io
} // namespace caf

namespace std {

template <>
struct hash<caf::io::network::ip_endpoint> {
  using argument_type = caf::io::network::ip_endpoint;
  using result_type = size_t;
  result_type operator()(const argument_type& ep) const {
    auto ptr = ep.caddress();
    return caf::io::network::ep_hash{}(*ptr);
  }
};

} // namespace std


#endif // CAF_IO_IP_ENDPOINT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_NETWORK_MANAGER_HPP
#define CAF_IO_NETWORK_MANAGER_HPP

#include "caf/message.hpp"
#include "caf/ref_counted.hpp"
#include "caf/intrusive_ptr.hpp"

#include "caf/io/fwd.hpp"
#include "caf/io/network/operation.hpp"

namespace caf {
namespace io {
namespace network {

/// A manager configures an I/O device and provides callbacks
/// for various I/O operations.
class manager : public ref_counted {
public:
  manager();

  ~manager() override;

  /// Sets the parent for this manager.
  /// @pre `parent() == nullptr`
  void set_parent(abstract_broker* ptr);

  /// Returns the parent broker of this manager.
  abstract_broker* parent();

  /// Returns `true` if this manager has a parent, `false` otherwise.
  inline bool detached() const {
    return !parent_;
  }

  /// Detach this manager from its parent and invoke `detach_message()``
  /// if `invoke_detach_message == true`.
  void detach(execution_unit* ctx, bool invoke_disconnect_message);

  /// Causes the manager to stop read operations on its I/O device.
  /// Unwritten bytes are still send before the socket will be closed.
  virtual void stop_reading() = 0;

  /// Removes the I/O device to the event loop of the middleman.
  virtual void remove_from_loop() = 0;

  /// Adds the I/O device to the event loop of the middleman.
  virtual void add_to_loop() = 0;

  /// Called by the underlying I/O device to report failures.
  virtual void io_failure(execution_unit* ctx, operation op) = 0;

  /// Get the address of the underlying I/O device.
  virtual std::string addr() const = 0;

protected:
  /// Creates a message signalizing a disconnect to the parent.
  virtual message detach_message() = 0;

  /// Detaches this manager from `ptr`.
  virtual void detach_from(abstract_broker* ptr) = 0;

  strong_actor_ptr parent_;
};

} // namespace network
} // namespace io
} // namespace caf

#endif // CAF_IO_NETWORK_MANAGER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 * Raphael Hiesgen <raphael.hiesgen (at) haw-hamburg.de>                      *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/broker.hpp"
#include "caf/io/middleman.hpp"

#include "caf/scheduler/abstract_coordinator.hpp"

#include "caf/io/network/asio_multiplexer.hpp"

namespace caf {
namespace io {
namespace network {

namespace {

/// A wrapper for the supervisor backend provided by boost::asio.
struct asio_supervisor : public multiplexer::supervisor {
  explicit asio_supervisor(io_service& iob) : work(iob) {
    // nop
  }

private:
  boost::asio::io_service::work work;
};

} // namespace anonymous

expected<asio_tcp_socket>
new_tcp_connection(io_service& ios, const std::string& host, uint16_t port) {
  asio_tcp_socket fd{ios};
  using boost::asio::ip::tcp;
  tcp::resolver r(fd.get_io_service());
  tcp::resolver::query q(host, std::to_string(port));
  boost::system::error_code ec;
  auto i = r.resolve(q, ec);
  if (ec)
    return make_error(sec::cannot_connect_to_node);
  boost::asio::connect(fd, i, ec);
  if (ec)
    return make_error(sec::cannot_connect_to_node);
  return asio_tcp_socket{std::move(fd)};
}

error ip_bind(asio_tcp_socket_acceptor& fd, uint16_t port,
              const char* addr, bool reuse_addr) {
  CAF_LOG_TRACE(CAF_ARG(port) << CAF_ARG(reuse_addr));
  using boost::asio::ip::tcp;
  auto bind_and_listen = [&](tcp::endpoint& ep) -> error {
    CAF_LOG_DEBUG("created IP endpoint:" << CAF_ARG(ep.address().to_string())
                  << CAF_ARG(ep.port()));
    boost::system::error_code ec;
    fd.open(ep.protocol());
    if (reuse_addr) {
      fd.set_option(tcp::acceptor::reuse_address(reuse_addr), ec);
      if (ec)
        return sec::cannot_open_port;
    }
    fd.bind(ep, ec);
    if (ec)
      return sec::cannot_open_port;
    fd.listen(asio_tcp_socket_acceptor::max_connections, ec);
    if (ec)
      return sec::cannot_open_port;
    return none;
  };
  if (addr) {
    CAF_LOG_DEBUG(CAF_ARG(addr));
    tcp::endpoint ep(boost::asio::ip::address::from_string(addr), port);
    CAF_LOG_DEBUG("got 'em");
    return bind_and_listen(ep);
  } else {
    CAF_LOG_DEBUG("addr = nullptr");
    tcp::endpoint ep(tcp::v6(), port);
    return bind_and_listen(ep);
  }
}

scribe_ptr asio_multiplexer::new_scribe(asio_tcp_socket&& sock) {
  CAF_LOG_TRACE("");
  class impl : public scribe {
  public:
    impl(asio_multiplexer& am, asio_tcp_socket&& s)
        : scribe(network::conn_hdl_from_socket(s)),
          launched_(false),
          stream_(am) {
      stream_.init(std::move(s));
    }
    void configure_read(receive_policy::config config) override {
      CAF_LOG_TRACE("");
      stream_.configure_read(config);
      if (!launched_) {
        launch();
      }
    }
    void ack_writes(bool enable) override {
      CAF_LOG_TRACE(CAF_ARG(enable));
      stream_.ack_writes(enable);
    }
    std::vector<char>& wr_buf() override {
      return stream_.wr_buf();
    }
    std::vector<char>& rd_buf() override {
      return stream_.rd_buf();
    }
    void stop_reading() override {
      CAF_LOG_TRACE("");
      stream_.stop_reading();
      detach(&stream_.backend(), false);
    }
    void flush() override {
      CAF_LOG_TRACE("");
      stream_.flush(this);
    }
    std::string addr() const override {
      return stream_.socket_handle().remote_endpoint().address().to_string();
    }
    uint16_t port() const override {
      return stream_.socket_handle().remote_endpoint().port();
    }
    void launch() {
      CAF_LOG_TRACE("");
      CAF_ASSERT(!launched_);
      launched_ = true;
      stream_.start(this);
    }
    void add_to_loop() override {
      stream_.activate(this);
    }
    void remove_from_loop() override {
      stream_.passivate();
    }
  private:
    bool launched_;
    asio_stream<asio_tcp_socket> stream_;
  };
  return make_counted<impl>(*this, std::move(sock));
}

scribe_ptr asio_multiplexer::new_scribe(native_socket fd) {
  CAF_LOG_TRACE(CAF_ARG(fd));
  boost::system::error_code ec;
  asio_tcp_socket sock{service()};
  sock.assign(boost::asio::ip::tcp::v6(), fd, ec);
  if (ec)
    sock.assign(boost::asio::ip::tcp::v4(), fd, ec);
  if (ec)
    CAF_RAISE_ERROR(ec.message());
  return new_scribe(std::move(sock));
}

expected<scribe_ptr> asio_multiplexer::new_tcp_scribe(const std::string& host,
                                                      uint16_t port) {
  auto sck = new_tcp_connection(service(), host, port);
  if (!sck)
    return std::move(sck.error());
  return new_scribe(std::move(*sck));
}

doorman_ptr asio_multiplexer::new_doorman(asio_tcp_socket_acceptor&& sock) {
  CAF_LOG_TRACE(CAF_ARG(sock.native_handle()));
  CAF_ASSERT(sock.native_handle() != network::invalid_native_socket);
  class impl : public doorman {
  public:
    impl(asio_tcp_socket_acceptor&& s, network::asio_multiplexer& am)
        : doorman(network::accept_hdl_from_socket(s)),
          acceptor_(am, s.get_io_service()) {
      acceptor_.init(std::move(s));
    }
    bool new_connection() override {
      CAF_LOG_TRACE("");
      if (detached())
        // we are already disconnected from the broker while the multiplexer
        // did not yet remove the socket, this can happen if an I/O event causes
        // the broker to call close_all() while the pollset contained
        // further activities for the broker
        return false;
      auto& am = acceptor_.backend();
      auto sptr = am.new_scribe(std::move(acceptor_.accepted_socket()));
      auto shdl = sptr->hdl();
      parent()->add_scribe(std::move(sptr));
      return doorman::new_connection(&am, shdl);
    }
    void stop_reading() override {
      CAF_LOG_TRACE("");
      acceptor_.stop();
      detach(&acceptor_.backend(), false);
    }
    void launch() override {
      CAF_LOG_TRACE("");
      acceptor_.start(this);
    }
    std::string addr() const override {
      return
        acceptor_.socket_handle().local_endpoint().address().to_string();
    }
    uint16_t port() const override {
      return acceptor_.socket_handle().local_endpoint().port();
    }
    void add_to_loop() override {
      acceptor_.activate(this);
    }
    void remove_from_loop() override {
      acceptor_.passivate();
    }
  private:
    network::asio_acceptor<asio_tcp_socket_acceptor> acceptor_;
  };
  return make_counted<impl>(std::move(sock), *this);
}

doorman_ptr asio_multiplexer::new_doorman(native_socket fd) {
  CAF_LOG_TRACE(CAF_ARG(fd));
  asio_tcp_socket_acceptor sock{service()};
  boost::system::error_code ec;
  sock.assign(boost::asio::ip::tcp::v6(), fd, ec);
  if (ec)
    sock.assign(boost::asio::ip::tcp::v4(), fd, ec);
  if (ec)
    CAF_RAISE_ERROR(ec.message());
  return new_doorman(std::move(sock));
}

expected<doorman_ptr>
asio_multiplexer::new_tcp_doorman(uint16_t port, const char* in, bool rflag) {
  CAF_LOG_TRACE(CAF_ARG(port) << ", addr = " << (in ? in : "nullptr"));
  asio_tcp_socket_acceptor fd{service()};
  auto err = ip_bind(fd, port, in, rflag);
  if (err)
    return err;
  return new_doorman(std::move(fd));
}

datagram_servant_ptr asio_multiplexer::new_datagram_servant(native_socket) {
  CAF_RAISE_ERROR("UDP is not implemented for asio");
  return nullptr;
}

datagram_servant_ptr
asio_multiplexer::new_datagram_servant_for_endpoint(native_socket,
                                                    const ip_endpoint&) {
  CAF_RAISE_ERROR("UDP is not implemented for asio");
  return nullptr;
}

expected<datagram_servant_ptr>
asio_multiplexer::new_remote_udp_endpoint(const std::string&, uint16_t) {
  CAF_RAISE_ERROR("UDP is not implemented for asio");
  return sec::bad_function_call;
}

expected<datagram_servant_ptr>
asio_multiplexer::new_local_udp_endpoint(uint16_t, const char*, bool) {
  CAF_RAISE_ERROR("UDP is not implemented for asio");
  return sec::bad_function_call;
}

void asio_multiplexer::exec_later(resumable* rptr) {
  auto mt = system().config().scheduler_max_throughput;
  switch (rptr->subtype()) {
    case resumable::io_actor:
    case resumable::function_object: {
      intrusive_ptr<resumable> ptr{rptr, false};
      service().post([=]() mutable {
        switch (ptr->resume(this, mt)) {
          case resumable::resume_later:
            exec_later(ptr.release());
            break;
          case resumable::done:
          case resumable::awaiting_message:
            break;
          default:
            ; // ignored
        }
      });
      break;
    }
    default:
     system().scheduler().enqueue(rptr);
  }
}

asio_multiplexer::asio_multiplexer(actor_system* sys) : multiplexer(sys) {
  // nop
}

asio_multiplexer::~asio_multiplexer() {
  //nop
}

multiplexer::supervisor_ptr asio_multiplexer::make_supervisor() {
  return std::unique_ptr<asio_supervisor>(new asio_supervisor(service()));
}

bool asio_multiplexer::try_run_once() {
  boost::system::error_code ec;
  auto num = service().poll(ec);
  if (ec)
    CAF_RAISE_ERROR(ec.message());
  return num > 0;
}

void asio_multiplexer::run_once() {
  boost::system::error_code ec;
  service().run_one(ec);
  if (ec)
    CAF_RAISE_ERROR(ec.message());
}

void asio_multiplexer::run() {
  CAF_LOG_TRACE("asio-based multiplexer");
  boost::system::error_code ec;
  service().run(ec);
  if (ec)
    CAF_RAISE_ERROR(ec.message());
}

multiplexer_backend* asio_multiplexer::pimpl() {
  return &service_;
}

} // namesapce network
} // namespace io
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_NETWORK_STREAM_MANAGER_HPP
#define CAF_IO_NETWORK_STREAM_MANAGER_HPP

#include <cstddef>

#include "caf/io/network/manager.hpp"

namespace caf {
namespace io {
namespace network {

/// A stream manager configures an IO stream and provides callbacks
/// for incoming data as well as for error handling.
class stream_manager : public manager {
public:
  ~stream_manager() override;

  /// Called by the underlying I/O device whenever it received data.
  /// @returns `true` if the manager accepts further reads, otherwise `false`.
  virtual bool consume(execution_unit* ctx, const void* buf, size_t bsize) = 0;

  /// Called by the underlying I/O device whenever it sent data.
  virtual void data_transferred(execution_unit* ctx, size_t num_bytes,
                                size_t remaining_bytes) = 0;

  /// Get the port of the underlying I/O device.
  virtual uint16_t port() const = 0;
};

} // namespace network
} // namespace io
} // namespace caf

#endif // CAF_IO_NETWORK_STREAM_MANAGER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_NETWORK_TEST_MULTIPLEXER_HPP
#define CAF_IO_NETWORK_TEST_MULTIPLEXER_HPP

#include <thread>

#include "caf/io/receive_policy.hpp"
#include "caf/io/abstract_broker.hpp"

#include "caf/io/network/multiplexer.hpp"
#include "caf/io/network/receive_buffer.hpp"

namespace caf {
namespace io {
namespace network {

class test_multiplexer : public multiplexer {
private:
  struct datagram_data;

public:
  explicit test_multiplexer(actor_system* sys);

  ~test_multiplexer() override;

  scribe_ptr new_scribe(native_socket) override;

  expected<scribe_ptr> new_tcp_scribe(const std::string& host,
                                      uint16_t port_hint) override;

  doorman_ptr new_doorman(native_socket) override;

  expected<doorman_ptr> new_tcp_doorman(uint16_t prt, const char* in,
                                        bool reuse_addr) override;

  datagram_servant_ptr new_datagram_servant(native_socket fd) override;

  datagram_servant_ptr
  new_datagram_servant_for_endpoint(native_socket fd,
                                    const ip_endpoint& ep) override;

  expected<datagram_servant_ptr>
  new_remote_udp_endpoint(const std::string& host, uint16_t port) override;

  expected<datagram_servant_ptr>
  new_local_udp_endpoint(uint16_t port, const char* in = nullptr,
                         bool reuse_addr = false) override;

  /// Checks whether `x` is assigned to any known doorman or is user-provided
  /// for future assignment.
  bool is_known_port(uint16_t x) const;

  /// Checks whether `x` is assigned to any known doorman or is user-provided
  /// for future assignment.
  bool is_known_handle(accept_handle x) const;

  bool is_known_handle(datagram_handle x) const;

  supervisor_ptr make_supervisor() override;

  bool try_run_once() override;

  void run_once() override;

  void run() override;

  scribe_ptr new_scribe(connection_handle);

  doorman_ptr new_doorman(accept_handle, uint16_t port);

public:
  datagram_servant_ptr new_datagram_servant(datagram_handle, uint16_t port);

  datagram_servant_ptr new_datagram_servant(datagram_handle,
                                            const std::string& host,
                                            uint16_t port);

  void provide_scribe(std::string host, uint16_t desired_port,
                      connection_handle hdl);

  void provide_acceptor(uint16_t desired_port, accept_handle hdl);

  void provide_datagram_servant(uint16_t desired_port, datagram_handle hdl);

  void provide_datagram_servant(std::string host, uint16_t desired_port,
                                datagram_handle hdl);

  /// Generate an id for a new servant.
  int64_t next_endpoint_id();

  /// A buffer storing bytes used for TCP related components.
  using buffer_type = std::vector<char>;

  /// Buffers storing bytes for UDP related components.
  using read_buffer_type = network::receive_buffer;
  using write_buffer_type = buffer_type;
  using read_job_type = std::pair<datagram_handle, read_buffer_type>;
  using write_job_type = std::pair<datagram_handle, write_buffer_type>;
  using write_job_queue_type = std::deque<write_job_type>;

  using shared_buffer_type = std::shared_ptr<buffer_type>;
  using shared_job_queue_type = std::shared_ptr<write_job_queue_type>;

  /// Models pending data on the network, i.e., the network
  /// input buffer usually managed by the operating system.
  buffer_type& virtual_network_buffer(connection_handle hdl);

  /// Models pending data on the network, i.e., the network
  /// input buffer usually managed by the operating system.
  write_job_queue_type& virtual_network_buffer(datagram_handle hdl);

  /// Returns the output buffer of the scribe identified by `hdl`.
  buffer_type& output_buffer(connection_handle hdl);

  /// Returns the input buffer of the scribe identified by `hdl`.
  buffer_type& input_buffer(connection_handle hdl);

  /// Returns the output buffer of the dgram servant identified by `hdl`.
  write_job_type& output_buffer(datagram_handle hdl);

  /// Returns the queue with all outgoing datagrams for the dgram servant
  /// identified by `hdl`.
  write_job_queue_type& output_queue(datagram_handle hdl);

  /// Returns the input buffer of the dgram servant identified by `hdl`.
  read_job_type& input_buffer(datagram_handle hdl);

  /// Returns the configured read policy of the scribe identified by `hdl`.
  receive_policy::config& read_config(connection_handle hdl);

  /// Returns whether the scribe identified by `hdl` receives write ACKs.
  bool& ack_writes(connection_handle hdl);

  /// Returns whether the dgram servant identified by `hdl` receives write ACKs.
  bool& ack_writes(datagram_handle hdl);

  /// Returns `true` if this handle has been closed
  /// for reading, `false` otherwise.
  bool& stopped_reading(connection_handle hdl);

  /// Returns `true` if this handle has been closed
  /// for reading, `false` otherwise.
  bool& stopped_reading(datagram_handle hdl);

  /// Returns `true` if this handle is inactive, otherwise `false`.
  bool& passive_mode(connection_handle hdl);

  /// Returns `true` if this handle is inactive, otherwise `false`.
  bool& passive_mode(datagram_handle hdl);

  scribe_ptr& impl_ptr(connection_handle hdl);

  uint16_t& port(accept_handle hdl);

  uint16_t& port(datagram_handle hdl);

  uint16_t& local_port(datagram_handle hdl);

  size_t& datagram_size(datagram_handle hdl);

  datagram_servant_ptr& impl_ptr(datagram_handle hdl);

  /// Returns a map with all servants related to the servant `hdl`.
  std::set<datagram_handle>& servants(datagram_handle hdl);

  /// Returns `true` if this handle has been closed
  /// for reading, `false` otherwise.
  bool& stopped_reading(accept_handle hdl);

  /// Returns `true` if this handle is inactive, otherwise `false`.
  bool& passive_mode(accept_handle hdl);

  doorman_ptr& impl_ptr(accept_handle hdl);

  /// Stores `hdl` as a pending connection for `src`.
  void add_pending_connect(accept_handle src, connection_handle hdl);

  /// Add `hdl` as a pending connect to `src` and provide a scribe on `peer`
  /// that connects the buffers of `hdl` and `peer_hdl`. Calls
  /// `add_pending_connect(...)` and `peer.provide_scribe(...)`.
  void prepare_connection(accept_handle src, connection_handle hdl,
                          test_multiplexer& peer, std::string host,
                          uint16_t port, connection_handle peer_hdl);

  /// Stores `hdl` as a pending endpoint for `src`.
  void add_pending_endpoint(datagram_handle src, datagram_handle hdl);

  using pending_connects_map = std::unordered_multimap<accept_handle,
                                                       connection_handle>;

  pending_connects_map& pending_connects();

  using pending_endpoints_map = std::unordered_map<int64_t, datagram_handle>;

  pending_endpoints_map& pending_endpoints();

  using pending_scribes_map = std::map<std::pair<std::string, uint16_t>,
                                       connection_handle>;

  using pending_doorman_map = std::unordered_map<uint16_t, accept_handle>;

  using pending_local_datagram_endpoints_map = std::map<uint16_t,
                                                        datagram_handle>;

  using pending_remote_datagram_endpoints_map
    = std::map<std::pair<std::string, uint16_t>, datagram_handle>;

  bool has_pending_scribe(std::string x, uint16_t y);

  bool has_pending_remote_endpoint(std::string x, uint16_t y);

  /// Accepts a pending connect on `hdl`.
  void accept_connection(accept_handle hdl);

  /// Tries to accept a pending connection.
  bool try_accept_connection();

  /// Tries to read data on any available scribe.
  bool try_read_data();

  /// Tries to read data from the external input buffer of `hdl`.
  bool try_read_data(connection_handle hdl);

  /// Poll data on all scribes.
  bool read_data();

  /// Reads data from the external input buffer until
  /// the configured read policy no longer allows receiving.
  bool read_data(connection_handle hdl);

  /// Reads the next datagram from the external input buffer.
  bool read_data(datagram_handle hdl);

  /// Appends `buf` to the virtual network buffer of `hdl`
  /// and calls `read_data(hdl)` afterwards.
  void virtual_send(connection_handle hdl, const buffer_type& buf);

  /// Appends `buf` to the virtual network buffer of `hdl`
  /// and calls `read_data(hdl)` afterwards.
  void virtual_send(datagram_handle src, datagram_handle ep,
                    const buffer_type&);

  /// Waits until a `runnable` is available and executes it.
  void exec_runnable();

  /// Returns `true` if a `runnable` was available, `false` otherwise.
  bool try_exec_runnable();

  /// Executes all pending `runnable` objects.
  void flush_runnables();

  /// Executes the next `num` enqueued runnables immediately.
  inline void inline_next_runnables(size_t num) {
    inline_runnables_ += num;
  }

  /// Executes the next enqueued runnable immediately.
  inline void inline_next_runnable() {
    inline_next_runnables(1);
  }

  /// Resets the counter for the next inlined runnables.
  inline void reset_inlining() {
    inline_runnables_ = 0;
  }

  /// Installs a callback that is triggered on the next inlined runnable.
  inline void after_next_inlined_runnable(std::function<void()> f) {
    inline_runnable_callback_ = std::move(f);
  }

protected:
  void exec_later(resumable* ptr) override;

private:
  using resumable_ptr = intrusive_ptr<resumable>;

  void exec(resumable_ptr& ptr);

  using guard_type = std::unique_lock<std::mutex>;

  std::shared_ptr<datagram_data> data_for_hdl(datagram_handle hdl);

  struct scribe_data {
    shared_buffer_type vn_buf_ptr;
    shared_buffer_type wr_buf_ptr;
    buffer_type& vn_buf;
    buffer_type rd_buf;
    buffer_type& wr_buf;
    receive_policy::config recv_conf;
    bool stopped_reading;
    bool passive_mode;
    intrusive_ptr<scribe> ptr;
    bool ack_writes;

    // Allows creating an entangled scribes where the input of this scribe is
    // the output of another scribe and vice versa.
    scribe_data(shared_buffer_type input = std::make_shared<buffer_type>(),
                shared_buffer_type output = std::make_shared<buffer_type>());
  };

  struct doorman_data {
    doorman_ptr ptr;
    uint16_t port;
    bool stopped_reading;
    bool passive_mode;
    doorman_data();
  };

  struct datagram_data {
    shared_job_queue_type vn_buf_ptr;
    shared_job_queue_type wr_buf_ptr;
    write_job_queue_type& vn_buf;
    write_job_queue_type& wr_buf;
    read_job_type rd_buf;
    datagram_servant_ptr ptr;
    bool stopped_reading;
    bool passive_mode;
    bool ack_writes;
    uint16_t port;
    uint16_t local_port;
    std::set<datagram_handle> servants;
    size_t datagram_size;

    // Allows creating an entangled scribes where the input of this scribe is
    // the output of another scribe and vice versa.
    datagram_data(
      shared_job_queue_type input = std::make_shared<write_job_queue_type>(),
      shared_job_queue_type output = std::make_shared<write_job_queue_type>()
    );
  };

  using scribe_data_map = std::unordered_map<connection_handle, scribe_data>;

  using doorman_data_map = std::unordered_map<accept_handle, doorman_data>;

  using datagram_data_map = std::unordered_map<datagram_handle,
                                               std::shared_ptr<datagram_data>>;

  // guards resumables_ and scribes_
  std::mutex mx_;
  std::condition_variable cv_;
  std::list<resumable_ptr> resumables_;
  pending_scribes_map scribes_;
  pending_doorman_map doormen_;
  scribe_data_map scribe_data_;
  doorman_data_map doorman_data_;
  pending_local_datagram_endpoints_map local_endpoints_;
  pending_remote_datagram_endpoints_map remote_endpoints_;
  pending_connects_map pending_connects_;
  pending_endpoints_map pending_endpoints_;
  datagram_data_map datagram_data_;

  // extra state for making sure the test multiplexer is not used in a
  // multithreaded setup
  std::thread::id tid_;

  // Configures shortcuts for runnables.
  size_t inline_runnables_;

  // Configures a one-shot handler for the next inlined runnable.
  std::function<void()> inline_runnable_callback_;

  int64_t servant_ids_;
};

} // namespace network
} // namespace io
} // namespace caf

#endif // CAF_IO_NETWORK_TEST_MULTIPLEXER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_NETWORK_ACCEPTOR_MANAGER_HPP
#define CAF_IO_NETWORK_ACCEPTOR_MANAGER_HPP

#include "caf/io/network/manager.hpp"

namespace caf {
namespace io {
namespace network {

/// An acceptor manager configures an acceptor and provides
/// callbacks for incoming connections as well as for error handling.
class acceptor_manager : public manager {
public:
  ~acceptor_manager() override;

  /// Called by the underlying I/O device to indicate that
  /// a new connection is awaiting acceptance.
  /// @returns `true` if the manager accepts further connections,
  ///          otherwise `false`.
  virtual bool new_connection() = 0;

  /// Get the port of the underlying I/O device.
  virtual uint16_t port() const = 0;
};

} // namespace network
} // namespace io
} // namespace caf

#endif // CAF_IO_NETWORK_ACCEPTOR_MANAGER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_NETWORK_NATIVE_SOCKET_HPP
#define CAF_IO_NETWORK_NATIVE_SOCKET_HPP

#include <cstddef>

#include "caf/config.hpp"

namespace caf {
namespace io {
namespace network {

#ifdef CAF_WINDOWS
  using native_socket = size_t;
  constexpr native_socket invalid_native_socket = static_cast<native_socket>(-1);
  inline int64_t int64_from_native_socket(native_socket sock) {
    return sock == invalid_native_socket ? -1 : static_cast<uint64_t>(sock);
  }
#else
  using native_socket = int;
  constexpr native_socket invalid_native_socket = -1;
  inline int64_t int64_from_native_socket(native_socket sock) {
    return static_cast<int64_t>(sock);
  }
#endif

} // namespace network
} // namespace io
} // namespace caf

#endif // CAF_IO_NETWORK_NATIVE_SOCKET_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_ABSTRACT_BROKER_HPP
#define CAF_IO_ABSTRACT_BROKER_HPP

#include <vector>
#include <unordered_map>

#include "caf/scheduled_actor.hpp"
#include "caf/prohibit_top_level_spawn_marker.hpp"
#include "caf/detail/intrusive_partitioned_list.hpp"

#include "caf/io/fwd.hpp"
#include "caf/io/accept_handle.hpp"
#include "caf/io/receive_policy.hpp"
#include "caf/io/datagram_handle.hpp"
#include "caf/io/system_messages.hpp"
#include "caf/io/connection_handle.hpp"

#include "caf/io/network/ip_endpoint.hpp"
#include "caf/io/network/native_socket.hpp"
#include "caf/io/network/stream_manager.hpp"
#include "caf/io/network/acceptor_manager.hpp"
#include "caf/io/network/datagram_manager.hpp"

namespace caf {
namespace io {

class middleman;

/// @defgroup Broker Actor-based Network Abstraction
///
/// Brokers provide an actor-based abstraction for low-level network IO.
/// The central component in the network abstraction of CAF is the
/// `middleman`. It connects any number of brokers to a `multiplexer`,
/// which implements a low-level IO event loop.
///
/// ![Relation between middleman, multiplexer, and broker](broker.png)
///
/// Brokers do *not* operate on sockets or other platform-dependent
/// communication primitives. Instead, brokers use a `connection_handle`
/// to identify a reliable, end-to-end byte stream (e.g. a TCP connection)
/// and `accept_handle` to identify a communication endpoint others can
/// connect to via its port.
///
/// Each `connection_handle` is associated with a `scribe` that provides
/// access to an output buffer as well as a `flush` operation to request
/// sending its content via the network. Instead of actively receiving data,
/// brokers configure a scribe to asynchronously receive data, e.g.,
/// `self->configure_read(hdl, receive_policy::exactly(1024))` would
/// configure the scribe associated with `hdl` to receive *exactly* 1024 bytes
/// and generate a `new_data_msg` message for the broker once the
/// data is available. The buffer in this message will be re-used by the
/// scribe to minimize memory usage and heap allocations.
///
/// Each `accept_handle` is associated with a `doorman` that will create
/// a `new_connection_msg` whenever a new connection was established.
///
/// All `scribe` and `doorman` instances are managed by the `multiplexer`

/// A broker mediates between actor systems and other components in the network.
/// @ingroup Broker
class abstract_broker : public scheduled_actor,
                        public prohibit_top_level_spawn_marker {
public:
  ~abstract_broker() override;

  // even brokers need friends
  friend class scribe;
  friend class doorman;
  friend class datagram_servant;

  // -- overridden modifiers of abstract_actor ---------------------------------

  void enqueue(mailbox_element_ptr, execution_unit*) override;

  void enqueue(strong_actor_ptr, message_id, message, execution_unit*) override;

  // -- overridden modifiers of local_actor ------------------------------------

  void launch(execution_unit* eu, bool lazy, bool hide) override;

  // -- overridden modifiers of abstract_broker --------------------------------

  bool cleanup(error&& reason, execution_unit* host) override;

  // -- overridden modifiers of resumable --------------------------------------

  resume_result resume(execution_unit*, size_t) override;

  // -- modifiers --------------------------------------------------------------

  /// Suspends activities on `hdl` unconditionally.
  template <class Handle>
  void halt(Handle hdl) {
    auto ref = by_id(hdl);
    if (ref)
      ref->halt();
  }

  /// Allows activities on `hdl` unconditionally (default).
  template <class Handle>
  void trigger(Handle hdl) {
    auto ref = by_id(hdl);
    if (ref)
      ref->trigger();
  }

  /// Allows `num_events` activities on `hdl`.
  template <class Handle>
  void trigger(Handle hdl, size_t num_events) {
    auto ref = by_id(hdl);
    if (!ref)
      return;
    if (num_events > 0) {
      ref->trigger(num_events);
    } else {
      // if we have any number of activity tokens, ignore this call
      // otherwise (currently in unconditional receive state) halt
      auto x = ref->activity_tokens();
      if (!x)
        ref->halt();
    }
  }

  /// Modifies the receive policy for a given connection.
  /// @param hdl Identifies the affected connection.
  /// @param cfg Contains the new receive policy.
  void configure_read(connection_handle hdl, receive_policy::config cfg);

  /// Enables or disables write notifications for a given connection.
  void ack_writes(connection_handle hdl, bool enable);

  /// Returns the write buffer for a given connection.
  std::vector<char>& wr_buf(connection_handle hdl);

  /// Writes `data` into the buffer for a given connection.
  void write(connection_handle hdl, size_t bs, const void* buf);

  /// Sends the content of the buffer for a given connection.
  void flush(connection_handle hdl);

  /// Enables or disables write notifications for a given datagram socket.
  void ack_writes(datagram_handle hdl, bool enable);

  /// Returns the write buffer for a given sink.
  std::vector<char>& wr_buf(datagram_handle hdl);

  /// Enqueue a buffer to be sent as a datagram via a given endpoint.
  void enqueue_datagram(datagram_handle, std::vector<char>);

  /// Writes `data` into the buffer of a given sink.
  void write(datagram_handle hdl, size_t data_size, const void* data);

  /// Sends the content of the buffer to a UDP endpoint.
  void flush(datagram_handle hdl);

  /// Returns the middleman instance this broker belongs to.
  inline middleman& parent() {
    return system().middleman();
  }

  /// Adds the unitialized `scribe` instance `ptr` to this broker.
  void add_scribe(scribe_ptr ptr);

  /// Creates and assigns a new `scribe` from given native socked `fd`.
  connection_handle add_scribe(network::native_socket fd);

  /// Tries to connect to `host` on given `port` and creates
  /// a new scribe describing the connection afterwards.
  /// @returns The handle of the new `scribe` on success.
  expected<connection_handle> add_tcp_scribe(const std::string& host,
                                             uint16_t port);

  /// Moves the initialized `scribe` instance `ptr` from another broker to this
  /// broker.
  void move_scribe(scribe_ptr ptr);

  /// Adds a `doorman` instance to this broker.
  void add_doorman(doorman_ptr ptr);

  /// Creates and assigns a new `doorman` from given native socked `fd`.
  accept_handle add_doorman(network::native_socket fd);

  /// Adds a `doorman` instance to this broker.
  void move_doorman(doorman_ptr ptr);

  /// Tries to open a local port and creates a `doorman` managing
  /// it on success. If `port == 0`, then the broker will ask
  /// the operating system to pick a random port.
  /// @returns The handle of the new `doorman` and the assigned port.
  expected<std::pair<accept_handle, uint16_t>>
  add_tcp_doorman(uint16_t port = 0, const char* in = nullptr,
                  bool reuse_addr = false);

  /// Adds a `datagram_servant` to this broker.
  void add_datagram_servant(datagram_servant_ptr ptr);

  /// Adds the `datagram_servant` under an additional `hdl`.
  void add_hdl_for_datagram_servant(datagram_servant_ptr ptr,
                                    datagram_handle hdl);

  /// Creates and assigns a new `datagram_servant` from a given socket `fd`.
  datagram_handle add_datagram_servant(network::native_socket fd);

  /// Creates and assigns a new `datagram_servant` from a given socket `fd`
  /// for the remote endpoint `ep`.
  datagram_handle
  add_datagram_servant_for_endpoint(network::native_socket fd,
                                    const network::ip_endpoint& ep);

  /// Creates a new `datagram_servant` for the remote endpoint `host` and `port`.
  /// @returns The handle to the new `datagram_servant`.
  expected<datagram_handle>
  add_udp_datagram_servant(const std::string& host, uint16_t port);

  /// Tries to open a local port and creates a `datagram_servant` managing it on
  /// success. If `port == 0`, then the broker will ask the operating system to
  /// pick a random port.
  /// @returns The handle of the new `datagram_servant` and the assigned port.
  expected<std::pair<datagram_handle, uint16_t>>
  add_udp_datagram_servant(uint16_t port = 0, const char* in = nullptr,
                           bool reuse_addr = false);

  /// Moves an initialized `datagram_servant` instance `ptr` from another broker
  /// to this one.
  void move_datagram_servant(datagram_servant_ptr ptr);

  /// Returns the remote address associated with `hdl`
  /// or empty string if `hdl` is invalid.
  std::string remote_addr(connection_handle hdl);

  /// Returns the remote port associated with `hdl`
  /// or `0` if `hdl` is invalid.
  uint16_t remote_port(connection_handle hdl);

  /// Returns the local address associated with `hdl`
  /// or empty string if `hdl` is invalid.
  std::string local_addr(accept_handle hdl);

  /// Returns the local port associated with `hdl` or `0` if `hdl` is invalid.
  uint16_t local_port(accept_handle hdl);

  /// Returns the handle associated with given local `port` or `none`.
  accept_handle hdl_by_port(uint16_t port);

  /// Returns the dgram handle associated with given local `port` or `none`.
  datagram_handle datagram_hdl_by_port(uint16_t port);

  /// Returns the remote address associated with `hdl`
  /// or an empty string if `hdl` is invalid.
  std::string remote_addr(datagram_handle hdl);

  /// Returns the remote port associated with `hdl`
  /// or `0` if `hdl` is invalid.
  uint16_t remote_port(datagram_handle hdl);

  /// Returns the remote port associated with `hdl`
  /// or `0` if `hdl` is invalid.
  uint16_t local_port(datagram_handle hdl);

  /// Remove the endpoint `hdl` from the broker.
  bool remove_endpoint(datagram_handle hdl);

  /// Closes all connections and acceptors.
  void close_all();

  /// Closes the connection or acceptor identified by `handle`.
  /// Unwritten data will still be send.
  template <class Handle>
  bool close(Handle hdl) {
    auto x = by_id(hdl);
    if (!x)
      return false;
    x->stop_reading();
    return true;
  }

  /// Checks whether `hdl` is assigned to broker.
  template <class Handle>
  bool valid(Handle hdl) {
    return get_map(hdl).count(hdl) > 0;
  }

  /// @cond PRIVATE
  template <class Handle>
  void erase(Handle hdl) {
    auto& elements = get_map(hdl);
    auto i = elements.find(hdl);
    if (i != elements.end())
      elements.erase(i);
  }

  // meta programming utility (not implemented)
  static intrusive_ptr<doorman> ptr_of(accept_handle);

  // meta programming utility (not implemented)
  static intrusive_ptr<scribe> ptr_of(connection_handle);

  // meta programming utility (not implemented)
  static intrusive_ptr<datagram_servant> ptr_of(datagram_handle);

  /// Returns an intrusive pointer to a `scribe` or `doorman`
  /// identified by `hdl` and remove it from this broker.
  template <class Handle>
  auto take(Handle hdl) -> decltype(ptr_of(hdl)) {
    using std::swap;
    auto& elements = get_map(hdl);
    decltype(ptr_of(hdl)) result;
    auto i = elements.find(hdl);
    if (i == elements.end())
      return nullptr;
    swap(result, i->second);
    elements.erase(i);
    return result;
  }
  /// @endcond

  // -- overridden observers of abstract_actor ---------------------------------

  const char* name() const override;

  // -- overridden observers of resumable --------------------------------------

  subtype_t subtype() const override;

  // -- observers --------------------------------------------------------------

  /// Returns the number of open connections.
  inline size_t num_connections() const {
    return scribes_.size();
  }

  /// Returns all handles of all `scribe` instances attached to this broker.
  std::vector<connection_handle> connections() const;

  /// Returns the `multiplexer` running this broker.
  network::multiplexer& backend();

protected:
  void init_broker();

  explicit abstract_broker(actor_config& cfg);

  using doorman_map = std::unordered_map<accept_handle, intrusive_ptr<doorman>>;

  using scribe_map = std::unordered_map<connection_handle,
                                        intrusive_ptr<scribe>>;

  using datagram_servant_map
    = std::unordered_map<datagram_handle, intrusive_ptr<datagram_servant>>;
  /// @cond PRIVATE

  // meta programming utility
  inline doorman_map& get_map(accept_handle) {
    return doormen_;
  }

  // meta programming utility
  inline scribe_map& get_map(connection_handle) {
    return scribes_;
  }

  inline datagram_servant_map& get_map(datagram_handle) {
    return datagram_servants_;
  }
  /// @endcond

  /// Returns a `scribe` or `doorman` identified by `hdl`.
  template <class Handle>
  auto by_id(Handle hdl) -> optional<decltype(*ptr_of(hdl))> {
    auto& elements = get_map(hdl);
    auto i = elements.find(hdl);
    if (i == elements.end())
      return none;
    return *(i->second);
  }

private:
  inline void launch_servant(scribe_ptr&) {
    // nop
  }

  void launch_servant(doorman_ptr& ptr);

  void launch_servant(datagram_servant_ptr& ptr);

  template <class T>
  typename T::handle_type add_servant(intrusive_ptr<T>&& ptr) {
    CAF_ASSERT(ptr != nullptr);
    CAF_ASSERT(ptr->parent() == nullptr);
    ptr->set_parent(this);
    auto hdl = ptr->hdl();
    launch_servant(ptr);
    get_map(hdl).emplace(hdl, std::move(ptr));
    return hdl;
  }

  template <class T>
  void move_servant(intrusive_ptr<T>&& ptr) {
    CAF_ASSERT(ptr != nullptr);
    CAF_ASSERT(ptr->parent() != nullptr && ptr->parent() != this);
    ptr->set_parent(this);
    CAF_ASSERT(ptr->parent() == this);
    auto hdl = ptr->hdl();
    get_map(hdl).emplace(hdl, std::move(ptr));
  }

  scribe_map scribes_;
  doorman_map doormen_;
  datagram_servant_map datagram_servants_;
  detail::intrusive_partitioned_list<mailbox_element, detail::disposer> cache_;
  std::vector<char> dummy_wr_buf_;
};

} // namespace io
} // namespace caf

#endif // CAF_IO_ABSTRACT_BROKER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_FWD_HPP
#define CAF_IO_FWD_HPP

namespace caf {

// -- templates from the parent namespace necessary for defining aliases -------

template <class> class intrusive_ptr;

namespace io {

// -- variadic templates -------------------------------------------------------

template <class... Sigs>
class typed_broker;

// -- classes ------------------------------------------------------------------

class scribe;
class broker;
class doorman;
class middleman;
class basp_broker;
class receive_policy;
class abstract_broker;
class datagram_servant;

// -- aliases ------------------------------------------------------------------

using scribe_ptr = intrusive_ptr<scribe>;
using doorman_ptr = intrusive_ptr<doorman>;
using datagram_servant_ptr = intrusive_ptr<datagram_servant>;

// -- nested namespaces --------------------------------------------------------

namespace network {

class multiplexer;

} // namespace network

} // namespace io
} // namespace caf

#endif // CAF_IO_FWD_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_MIDDLEMAN_ACTOR_HPP
#define CAF_IO_MIDDLEMAN_ACTOR_HPP

#include "caf/fwd.hpp"
#include "caf/atom.hpp"
#include "caf/typed_actor.hpp"

namespace caf {
namespace io {

/// A message passing interface for asynchronous networking operations.
///
/// The interface implements the following pseudo code.
/// ~~~
/// interface middleman_actor {
///
///   // Establishes a new `port <-> actor` mapping and  returns the actual
///   // port in use on success. Passing 0 as port instructs the OS to choose
///   // the next high-level port available for binding.
///   // port: Unused TCP port or 0 for any.
///   // whom: Actor that should be published at given port.
///   // ifs: Interface of given actor.
///   // addr: IP address to listen to or empty for any.
///   // reuse:_addr: Enables or disables SO_REUSEPORT option.
///   (publish_atom, uint16_t port, strong_actor_ptr whom,
///    set<string> ifs, string addr, bool reuse_addr)
///   -> (uint16_t)
///
///   // Opens a new port other CAF instances can connect to. The
///   // difference between `PUBLISH` and `OPEN` is that no actor is mapped to
///   // this port, meaning that connecting nodes only get a valid `node_id`
///   // handle when connecting.
///   // port: Unused TCP port or 0 for any.
///   // addr: IP address to listen to or empty for any.
///   // reuse:_addr: Enables or disables SO_REUSEPORT option.
///   (open_atom, uint16_t port, string addr, bool reuse_addr)
///   -> (uint16_t)
///
///   // Queries a remote node and returns an ID to this node as well as
///   // an `strong_actor_ptr` to a remote actor if an actor was published at this
///   // port. The actor address must be cast to either `actor` or
///   // `typed_actor` using `actor_cast` after validating `ifs`.
///   // hostname: IP address or DNS hostname.
///   // port: TCP port.
///   (connect_atom, string hostname, uint16_t port)
///   -> (node_id nid, strong_actor_ptr remote_actor, set<string> ifs)
///
///   // Closes `port` if it is mapped to `whom`.
///   // whom: A published actor.
///   // port: Used TCP port.
///   (unpublish_atom, strong_actor_ptr whom, uint16_t port)
///   -> void
///
///   // Closes `port` if it is mapped to `whom`.
///   // whom: A published actor.
///   // port: Used UDP port.
///   (unpublish_udp_atom, strong_actor_ptr whom, uint16_t port)
///   -> void
///
///   // Unconditionally closes `port`, removing any actor
///   // published at this port.
///   // port: Used TCP port.
///   (close_atom, uint16_t port)
///   -> void
///
///   // Spawns an actor on a remote node, initializing it using the arguments
///   // stored in `msg` and returns the address of the spawned actor and its
///   // interface description on success; an error string otherwise.
///   // nid: ID of the remote node that should spawn the actor.
///   // name: Announced type name of the actor.
///   // args: Initialization arguments for the actor.
///   (spawn_atom, node_id nid, string name, message args)
///   -> (strong_actor_ptr, set<string>)
///
/// }
/// ~~~
using middleman_actor =
  typed_actor<
    replies_to<publish_atom, uint16_t, strong_actor_ptr,
               std::set<std::string>, std::string, bool>
    ::with<uint16_t>,


    replies_to<publish_udp_atom, uint16_t, strong_actor_ptr,
               std::set<std::string>, std::string, bool>
    ::with<uint16_t>,

    replies_to<open_atom, uint16_t, std::string, bool>
    ::with<uint16_t>,

    replies_to<connect_atom, std::string, uint16_t>
    ::with<node_id, strong_actor_ptr, std::set<std::string>>,

    replies_to<contact_atom, std::string, uint16_t>
    ::with<node_id, strong_actor_ptr, std::set<std::string>>,

    reacts_to<unpublish_atom, actor_addr, uint16_t>,

    reacts_to<unpublish_udp_atom, actor_addr, uint16_t>,

    reacts_to<close_atom, uint16_t>,

    replies_to<spawn_atom, node_id, std::string, message, std::set<std::string>>
    ::with<strong_actor_ptr>,

    replies_to<get_atom, node_id>::with<node_id, std::string, uint16_t>>;

/// @relates middleman_actor
middleman_actor make_middleman_actor(actor_system& sys, actor db);

} // namespace io
} // namespace caf

#endif // CAF_IO_MIDDLEMAN_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_DATAGRAM_SERVANT_HPP
#define CAF_IO_DATAGRAM_SERVANT_HPP

#include <vector>

#include "caf/message.hpp"

#include "caf/io/datagram_handle.hpp"
#include "caf/io/broker_servant.hpp"
#include "caf/io/system_messages.hpp"
#include "caf/io/network/ip_endpoint.hpp"
#include "caf/io/network/datagram_manager.hpp"
#include "caf/io/network/receive_buffer.hpp"

namespace caf {
namespace io {

using datagram_servant_base = broker_servant<network::datagram_manager,
                                             datagram_handle, new_datagram_msg>;

/// Manages writing to a datagram sink.
/// @ingroup Broker
class datagram_servant : public datagram_servant_base {
public:
  datagram_servant(datagram_handle hdl);

  ~datagram_servant() override;

  /// Enables or disables write notifications.
  virtual void ack_writes(bool enable) = 0;

  /// Returns a new output buffer.
  virtual std::vector<char>& wr_buf(datagram_handle) = 0;

  /// Enqueue a buffer to be sent as a datagram.
  virtual void enqueue_datagram(datagram_handle, std::vector<char>) = 0;

  /// Returns the current input buffer.
  virtual network::receive_buffer& rd_buf() = 0;

  /// Flushes the output buffer, i.e., sends the
  /// content of the buffer via the network.
  virtual void flush() = 0;

  /// Returns the local port of associated socket.
  virtual uint16_t local_port() const = 0;

  /// Returns all the handles associated with this servant
  virtual std::vector<datagram_handle> hdls() const = 0;

  /// Adds a new remote endpoint identified by the `ip_endpoint` to
  /// the related manager.
  virtual void add_endpoint(const network::ip_endpoint& ep,
                            datagram_handle hdl) = 0;

  virtual void remove_endpoint(datagram_handle hdl) = 0;

  void io_failure(execution_unit* ctx, network::operation op) override;

  bool consume(execution_unit*, datagram_handle hdl,
               network::receive_buffer& buf) override;

  void datagram_sent(execution_unit*, datagram_handle hdl, size_t,
                     std::vector<char> buffer) override;

  virtual void detach_handles() = 0;

  using datagram_servant_base::new_endpoint;

  virtual void launch() = 0;

protected:
  message detach_message() override;
};

using datagram_servant_ptr = intrusive_ptr<datagram_servant>;

} // namespace io
} // namespace caf

// Allows the `middleman_actor` to create an `datagram_servant` and then send it
// to the BASP broker.
CAF_ALLOW_UNSAFE_MESSAGE_TYPE(caf::io::datagram_servant_ptr)

#endif // CAF_IO_DATAGRAM_SERVANT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_RECEIVE_POLICY_HPP
#define CAF_IO_RECEIVE_POLICY_HPP

#include <string>
#include <cstddef>
#include <utility>

#include "caf/config.hpp"

namespace caf {
namespace io {

enum class receive_policy_flag {
  at_least,
  at_most,
  exactly
};

inline std::string to_string(receive_policy_flag x) {
  return x == receive_policy_flag::at_least
         ? "at_least"
         : (x == receive_policy_flag::at_most ? "at_most" : "exactly");
}

class receive_policy {
public:
  receive_policy() = delete;

  using config = std::pair<receive_policy_flag, size_t>;

  static inline config at_least(size_t num_bytes) {
    CAF_ASSERT(num_bytes > 0);
    return {receive_policy_flag::at_least, num_bytes};
  }

  static inline config at_most(size_t num_bytes) {
    CAF_ASSERT(num_bytes > 0);
    return {receive_policy_flag::at_most, num_bytes};
  }

  static inline config exactly(size_t num_bytes) {
    CAF_ASSERT(num_bytes > 0);
    return {receive_policy_flag::exactly, num_bytes};
  }
};

} // namespace io
} // namespace caf

#endif // CAF_IO_RECEIVE_POLICY_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_PUBLISH_HPP
#define CAF_IO_PUBLISH_HPP

#include <set>
#include <string>
#include <cstdint>

#include "caf/actor_system.hpp"

#include "caf/io/middleman.hpp"

namespace caf {
namespace io {

/// Tries to publish `whom` at `port` and returns either an `error` or the
/// bound port.
/// @param whom Actor that should be published at `port`.
/// @param port Unused TCP port.
/// @param in The IP address to listen to or `INADDR_ANY` if `in == nullptr`.
/// @param reuse Create socket using `SO_REUSEADDR`.
/// @returns The actual port the OS uses after `bind()`. If `port == 0`
///          the OS chooses a random high-level port.
template <class Handle>
expected<uint16_t> publish(const Handle& whom, uint16_t port,
                           const char* in = nullptr, bool reuse = false) {
  if (!whom)
    return sec::cannot_publish_invalid_actor;
  auto& sys = whom.home_system();
  return sys.middleman().publish(whom, port, in, reuse);
}

} // namespace io
} // namespace caf

#endif // CAF_IO_PUBLISH_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_SCRIBE_HPP
#define CAF_IO_SCRIBE_HPP

#include <vector>

#include "caf/message.hpp"

#include "caf/io/broker_servant.hpp"
#include "caf/io/receive_policy.hpp"
#include "caf/io/system_messages.hpp"
#include "caf/io/network/stream_manager.hpp"

namespace caf {
namespace io {

using scribe_base = broker_servant<network::stream_manager, connection_handle,
                                   new_data_msg>;

/// Manages a stream.
/// @ingroup Broker
class scribe : public scribe_base {
public:
  scribe(connection_handle conn_hdl);

  ~scribe() override;

  /// Implicitly starts the read loop on first call.
  virtual void configure_read(receive_policy::config config) = 0;

  /// Enables or disables write notifications.
  virtual void ack_writes(bool enable) = 0;

  /// Returns the current output buffer.
  virtual std::vector<char>& wr_buf() = 0;

  /// Returns the current input buffer.
  virtual std::vector<char>& rd_buf() = 0;

  /// Flushes the output buffer, i.e., sends the
  /// content of the buffer via the network.
  virtual void flush() = 0;

  void io_failure(execution_unit* ctx, network::operation op) override;

  bool consume(execution_unit*, const void*, size_t) override;

  void data_transferred(execution_unit*, size_t, size_t) override;

protected:
  message detach_message() override;
};

using scribe_ptr = intrusive_ptr<scribe>;

} // namespace io
} // namespace caf

// Allows the `middleman_actor` to create a `scribe` and then send it to the
// BASP broker.
CAF_ALLOW_UNSAFE_MESSAGE_TYPE(caf::io::scribe_ptr)

#endif // CAF_IO_SCRIBE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_BROKER_HPP
#define CAF_IO_BROKER_HPP

#include <map>
#include <vector>

#include "caf/fwd.hpp"
#include "caf/extend.hpp"
#include "caf/local_actor.hpp"
#include "caf/stateful_actor.hpp"

#include "caf/io/scribe.hpp"
#include "caf/io/doorman.hpp"
#include "caf/io/abstract_broker.hpp"
#include "caf/io/datagram_servant.hpp"

#include "caf/mixin/sender.hpp"
#include "caf/mixin/requester.hpp"
#include "caf/mixin/behavior_changer.hpp"

namespace caf {

template <>
class behavior_type_of<io::broker> {
public:
  using type = behavior;
};

namespace io {

/// Describes a dynamically typed broker.
/// @extends abstract_broker
/// @ingroup Broker
class broker : public extend<abstract_broker, broker>::
                      with<mixin::sender, mixin::requester,
                           mixin::behavior_changer>,
               public dynamically_typed_actor_base {
public:
  using super = extend<abstract_broker, broker>::
                with<mixin::sender, mixin::requester, mixin::behavior_changer>;

  using signatures = none_t;

  template <class F, class... Ts>
  typename infer_handle_from_fun<F>::type
  fork(F fun, connection_handle hdl, Ts&&... xs) {
    CAF_ASSERT(context() != nullptr);
    auto sptr = this->take(hdl);
    CAF_ASSERT(sptr->hdl() == hdl);
    using impl = typename infer_handle_from_fun<F>::impl;
    actor_config cfg{context()};
    detail::init_fun_factory<impl, F> fac;
    cfg.init_fun = fac(std::move(fun), hdl, std::forward<Ts>(xs)...);
    auto res = this->system().spawn_class<impl, no_spawn_options>(cfg);
    auto forked = static_cast<impl*>(actor_cast<abstract_actor*>(res));
    forked->move_scribe(std::move(sptr));
    return res;
  }

  void initialize() override;

  explicit broker(actor_config& cfg);

protected:
  virtual behavior make_behavior();
};

/// Convenience template alias for declaring state-based brokers.
template <class State>
using stateful_broker = stateful_actor<State, broker>;

} // namespace io
} // namespace caf

#endif // CAF_IO_BROKER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_CONNECT_HPP
#define CAF_IO_CONNECT_HPP

#include <string>
#include <cstdint>

#include "caf/node_id.hpp"
#include "caf/actor_system.hpp"

#include "caf/io/middleman.hpp"

namespace caf {
namespace io {

/// Tries to connect to given node.
/// @experimental
inline expected<node_id> connect(actor_system& sys, std::string host,
                                 uint16_t port) {
  return sys.middleman().connect(std::move(host), port);
}


} // namespace io
} // namespace caf

#endif // CAF_IO_CONNECT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_DATAGRAM_HANDLE_HPP
#define CAF_IO_DATAGRAM_HANDLE_HPP

#include <functional>

#include "caf/error.hpp"

#include "caf/io/handle.hpp"

#include "caf/meta/type_name.hpp"

namespace caf {
namespace io {

struct invalid_datagram_handle_t {
  constexpr invalid_datagram_handle_t() {
    // nop
  }
};

constexpr invalid_datagram_handle_t invalid_datagram_handle
  = invalid_datagram_handle_t{};

/// Generic handle type for identifying datagram endpoints
class datagram_handle : public handle<datagram_handle,
                                      invalid_datagram_handle_t> {
public:
  friend class handle<datagram_handle, invalid_datagram_handle_t>;

  using super = handle<datagram_handle, invalid_datagram_handle_t>;

  constexpr datagram_handle() {
    // nop
  }

  constexpr datagram_handle(const invalid_datagram_handle_t&) {
    // nop
  }

  template <class Inspector>
  friend typename Inspector::result_type inspect(Inspector& f,
                                                 datagram_handle& x) {
    return f(meta::type_name("datagram_handle"), x.id_);
  }

private:
  inline datagram_handle(int64_t handle_id) : super{handle_id} {
    // nop
  }
};

} // namespace io
} // namespace caf

namespace std {

template<>
struct hash<caf::io::datagram_handle> {
  size_t operator()(const caf::io::datagram_handle& hdl) const {
    return std::hash<int64_t>{}(hdl.id());
  }
};

} // namespace std

#endif // CAF_IO_DATAGRAM_HANDLE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_SYSTEM_MESSAGES_HPP
#define CAF_IO_SYSTEM_MESSAGES_HPP

#include <tuple>
#include <vector>
#include <sstream>
#include <iomanip>

#include "caf/meta/type_name.hpp"
#include "caf/meta/hex_formatted.hpp"

#include "caf/io/handle.hpp"
#include "caf/io/accept_handle.hpp"
#include "caf/io/datagram_handle.hpp"
#include "caf/io/connection_handle.hpp"
#include "caf/io/network/receive_buffer.hpp"

namespace caf {
namespace io {

/// Signalizes a newly accepted connection from a {@link broker}.
struct new_connection_msg {
  /// The handle that accepted the new connection.
  accept_handle source;
  /// The handle for the new connection.
  connection_handle handle;
};

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, new_connection_msg& x) {
  return f(meta::type_name("new_connection_msg"), x.source, x.handle);
}

/// Signalizes newly arrived data for a {@link broker}.
struct new_data_msg {
  /// Handle to the related connection.
  connection_handle handle;
  /// Buffer containing the received data.
  std::vector<char> buf;
};

/// @relates new_data_msg
template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, new_data_msg& x) {
  return f(meta::type_name("new_data_msg"), x.handle,
           meta::hex_formatted(), x.buf);
}

/// Signalizes that a certain amount of bytes has been written.
struct data_transferred_msg {
  /// Handle to the related connection.
  connection_handle handle;
  /// Number of transferred bytes.
  uint64_t written;
  /// Number of remaining bytes in all send buffers.
  uint64_t remaining;
};

/// @relates data_transferred_msg
template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, data_transferred_msg& x) {
  return f(meta::type_name("data_transferred_msg"),
           x.handle, x.written, x.remaining);
}

/// Signalizes that a {@link broker} connection has been closed.
struct connection_closed_msg {
  /// Handle to the closed connection.
  connection_handle handle;
};

/// @relates connection_closed_msg
template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, connection_closed_msg& x) {
  return f(meta::type_name("connection_closed_msg"), x.handle);
}

/// Signalizes that a {@link broker} acceptor has been closed.
struct acceptor_closed_msg {
  /// Handle to the closed connection.
  accept_handle handle;
};

/// @relates connection_closed_msg
template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, acceptor_closed_msg& x) {
  return f(meta::type_name("acceptor_closed_msg"), x.handle);
}

/// Signalizes that a connection has entered passive mode.
struct connection_passivated_msg {
  connection_handle handle;
};

/// @relates connection_passivated_msg
template <class Inspector>
typename Inspector::result_type
inspect(Inspector& f, connection_passivated_msg& x) {
  return f(meta::type_name("connection_passivated_msg"), x.handle);
}

/// Signalizes that an acceptor has entered passive mode.
struct acceptor_passivated_msg {
  accept_handle handle;
};

/// @relates acceptor_passivated_msg
template <class Inspector>
typename Inspector::result_type
inspect(Inspector& f, acceptor_passivated_msg& x) {
  return f(meta::type_name("acceptor_passivated_msg"), x.handle);
}

/// Signalizes that a datagram with a certain size has been sent.
struct new_datagram_msg {
  // Handle to the endpoint used.
  datagram_handle handle;
  // Buffer containing received data.
  network::receive_buffer buf;
};

/// @relates new_datagram_msg
template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, new_datagram_msg& x) {
  return f(meta::type_name("new_datagram_msg"), x.handle, x.buf);
}

/// Signalizes that a datagram with a certain size has been sent.
struct datagram_sent_msg {
  // Handle to the endpoint used.
  datagram_handle handle;
  // Number of bytes written.
  uint64_t written;
  // Buffer of the sent datagram, for reuse.
  std::vector<char> buf;
};

/// @relates datagram_sent_msg
template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, datagram_sent_msg& x) {
  return f(meta::type_name("datagram_sent_msg"), x.handle, x.written, x.buf);
}

/// Signalizes that a datagram sink has entered passive mode.
struct datagram_servant_passivated_msg {
  datagram_handle handle;
};

/// @relates datagram_servant_passivated_msg
template <class Inspector>
typename Inspector::result_type
inspect(Inspector& f, datagram_servant_passivated_msg& x) {
  return f(meta::type_name("datagram_servant_passivated_msg"), x.handle);
}

/// Signalizes that a datagram endpoint has entered passive mode.
struct datagram_servant_closed_msg {
  std::vector<datagram_handle> handles;
};

/// @relates datagram_servant_closed_msg
template <class Inspector>
typename Inspector::result_type
inspect(Inspector& f, datagram_servant_closed_msg& x) {
  return f(meta::type_name("datagram_servant_closed_msg"), x.handles);
}

} // namespace io
} // namespace caf

#endif // CAF_IO_SYSTEM_MESSAGES_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_BASP_BROKER_HPP
#define CAF_IO_BASP_BROKER_HPP

#include <map>
#include <set>
#include <stack>
#include <string>
#include <future>
#include <vector>
#include <unordered_map>
#include <unordered_set>

#include "caf/stateful_actor.hpp"
#include "caf/proxy_registry.hpp"
#include "caf/binary_serializer.hpp"
#include "caf/binary_deserializer.hpp"
#include "caf/forwarding_actor_proxy.hpp"

#include "caf/io/basp/all.hpp"
#include "caf/io/broker.hpp"
#include "caf/io/visitors.hpp"
#include "caf/io/typed_broker.hpp"

#include "caf/io/basp/endpoint_context.hpp"

namespace caf {
namespace io {

struct basp_broker_state : proxy_registry::backend, basp::instance::callee {
  basp_broker_state(broker* selfptr);

  ~basp_broker_state() override;

  // inherited from proxy_registry::backend
  strong_actor_ptr make_proxy(node_id nid, actor_id aid) override;

  // inherited from proxy_registry::backend
  execution_unit* registry_context() override;

  // inherited from basp::instance::callee
  void finalize_handshake(const node_id& nid, actor_id aid,
                          std::set<std::string>& sigs) override;

  // inherited from basp::instance::callee
  void purge_state(const node_id& nid) override;

  // inherited from basp::instance::callee
  void proxy_announced(const node_id& nid, actor_id aid) override;

  // inherited from basp::instance::callee
  void deliver(const node_id& src_nid, actor_id src_aid,
               actor_id dest_aid, message_id mid,
               std::vector<strong_actor_ptr>& stages, message& msg) override;

  // inherited from basp::instance::callee
  void deliver(const node_id& src_nid, actor_id src_aid,
               atom_value dest_name, message_id mid,
               std::vector<strong_actor_ptr>& stages, message& msg) override;

  // called from both overriden functions
  void deliver(const node_id& src_nid, actor_id src_aid,
               strong_actor_ptr dest, message_id mid,
               std::vector<strong_actor_ptr>& stages, message& msg);

  // performs bookkeeping such as managing `spawn_servers`
  void learned_new_node(const node_id& nid);

  // inherited from basp::instance::callee
  void learned_new_node_directly(const node_id& nid,
                                 bool was_indirectly_before) override;

  // inherited from basp::instance::callee
  void learned_new_node_indirectly(const node_id& nid) override;

  // inherited from basp::instance::callee
  uint16_t next_sequence_number(connection_handle hdl) override;

  // inherited from basp::instance::callee
  uint16_t next_sequence_number(datagram_handle hdl) override;

  // inherited from basp::instance::callee
  void add_pending(execution_unit* ctx, basp::endpoint_context& ep,
                   uint16_t seq, basp::header hdr,
                   std::vector<char> payload) override;

  // inherited from basp::instance::callee
  bool deliver_pending(execution_unit* ctx, basp::endpoint_context& ep,
                       bool force) override;

  // inherited from basp::instance::callee
  void drop_pending(basp::endpoint_context& ep, uint16_t seq) override;

  // inherited from basp::instance::callee
  buffer_type& get_buffer(endpoint_handle hdl) override;

  // inherited from basp::instance::callee
  buffer_type& get_buffer(datagram_handle hdl) override;

  // inherited from basp::instance::callee
  buffer_type& get_buffer(connection_handle hdl) override;

  // inherited from basp::instance::callee
  buffer_type pop_datagram_buffer(datagram_handle hdl) override;

  // inherited from basp::instance::callee
  void flush(endpoint_handle hdl) override;

  // inherited from basp::instance::callee
  void flush(datagram_handle hdl) override;

  // inherited from basp::instance::callee
  void flush(connection_handle hdl) override;

  void handle_heartbeat(const node_id&) override {
    // nop
  }

  /// Sets `this_context` by either creating or accessing state for `hdl`.
  void set_context(connection_handle hdl);
  void set_context(datagram_handle hdl);

  /// Cleans up any state for `hdl`.
  void cleanup(connection_handle hdl);
  void cleanup(datagram_handle hdl);

  // pointer to ourselves
  broker* self;

  // protocol instance of BASP
  basp::instance instance;

  using ctx_tcp_map = std::unordered_map<connection_handle,
                                         basp::endpoint_context>;
  using ctx_udp_map = std::unordered_map<datagram_handle,
                                         basp::endpoint_context>;

  // keeps context information for all open connections
  ctx_tcp_map ctx_tcp;
  ctx_udp_map ctx_udp;

  // points to the current context for callbacks such as `make_proxy`
  basp::endpoint_context* this_context = nullptr;

  // stores handles to spawn servers for other nodes; these servers
  // are spawned whenever the broker learns a new node ID and try to
  // get a 'SpawnServ' instance on the remote side
  std::unordered_map<node_id, actor> spawn_servers;

  // can be enabled by the user to let CAF automatically try
  // to establish new connections at runtime to optimize
  // routing paths by forming a mesh between all nodes
  bool enable_automatic_connections = false;
  bool enable_tcp = true;
  bool enable_udp = false;

  // reusable send buffers for UDP communication
  const size_t max_buffers;
  std::stack<buffer_type> cached_buffers;

  // maximum queue size for pending messages of endpoints with ordering
  const size_t max_pending_messages;

  // timeout for delivery of pending messages of endpoints with ordering
  const std::chrono::milliseconds pending_to = std::chrono::milliseconds(100);

  // returns the node identifier of the underlying BASP instance
  const node_id& this_node() const {
    return instance.this_node();
  }

  using monitored_actor_map =
    std::unordered_map<actor_addr, std::unordered_set<node_id>>;

  // keeps a list of nodes that monitor a particular local actor
  monitored_actor_map monitored_actors;

  // sends a kill_proxy message to a remote node
  void send_kill_proxy_instance(const node_id& nid, actor_id aid, error err);

  // sends kill_proxy_instance message to all nodes monitoring the terminated
  // actor
  void handle_down_msg(down_msg&);

  static const char* name;
};

/// A broker implementation for the Binary Actor System Protocol (BASP).
class basp_broker : public stateful_actor<basp_broker_state, broker> {
public:
  using super = stateful_actor<basp_broker_state, broker>;

  explicit basp_broker(actor_config& cfg);

  behavior make_behavior() override;
  proxy_registry* proxy_registry_ptr() override;
  resume_result resume(execution_unit*, size_t) override;
};

} // namespace io
} // namespace caf

#endif // CAF_IO_BASP_BROKER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_HANDLE_HPP
#define CAF_IO_HANDLE_HPP

#include <string>
#include <cstdint>

#include "caf/detail/comparable.hpp"

namespace caf {

/// Base class for IO handles such as `accept_handle` or `connection_handle`.
template <class Subtype, class InvalidType, int64_t InvalidId = -1>
class handle : detail::comparable<Subtype>,
               detail::comparable<Subtype, InvalidType> {
public:
  constexpr handle() : id_(InvalidId) {
    // nop
  }

  handle(const Subtype& other) {
    id_ = other.id();
  }

  handle(const handle& other) = default;

  handle& operator=(const handle& other) {
    id_ = other.id();
    return *this;
  }

  handle& operator=(const InvalidType&) {
    id_ = InvalidId;
    return *this;
  }

  /// Returns the unique identifier of this handle.
  int64_t id() const {
    return id_;
  }

  /// Sets the unique identifier of this handle.
  void set_id(int64_t value) {
    id_ = value;
  }

  int64_t compare(const Subtype& other) const {
    return id_ - other.id();
  }

  int64_t compare(const InvalidType&) const {
    return invalid() ? 0 : 1;
  }

  bool invalid() const {
    return id_ == InvalidId;
  }

  void set_invalid() {
    set_id(InvalidId);
  }

  static Subtype from_int(int64_t id) {
    return {id};
  }

  friend std::string to_string(const Subtype& x) {
    return std::to_string(x.id());
  }

protected:
  handle(int64_t handle_id) : id_{handle_id} {
    // nop
  }

  int64_t id_;
};

} // namespace caf

#endif // CAF_IO_HANDLE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IO_CONNECTION_HANDLE_HPP
#define CAF_IO_CONNECTION_HANDLE_HPP

#include <functional>

#include "caf/error.hpp"

#include "caf/io/handle.hpp"

#include "caf/meta/type_name.hpp"

namespace caf {
namespace io {

struct invalid_connection_handle_t {
  constexpr invalid_connection_handle_t() {
    // nop
  }
};

constexpr invalid_connection_handle_t invalid_connection_handle
  = invalid_connection_handle_t{};

/// Generic handle type for identifying connections.
class connection_handle : public handle<connection_handle,
                                        invalid_connection_handle_t> {
public:
  friend class handle<connection_handle, invalid_connection_handle_t>;

  using super = handle<connection_handle, invalid_connection_handle_t>;

  constexpr connection_handle() {
    // nop
  }

  constexpr connection_handle(const invalid_connection_handle_t&) {
    // nop
  }

  template <class Inspector>
  friend typename Inspector::result_type inspect(Inspector& f,
                                                 connection_handle& x) {
    return f(meta::type_name("connection_handle"), x.id_);
  }

 private:
  inline connection_handle(int64_t handle_id) : super(handle_id) {
    // nop
  }
};

} // namespace io
} // namespace caf

namespace std {

template<>
struct hash<caf::io::connection_handle> {
  size_t operator()(const caf::io::connection_handle& hdl) const {
    hash<int64_t> f;
    return f(hdl.id());
  }
};

} // namespace std

#endif // CAF_IO_CONNECTION_HANDLE_HPP
#include <iostream>
using namespace std;

int main() {
#   ifdef __clang__
    cout << __clang_major__
         << "."
         << __clang_minor__;
#   elif defined(__GNUC__)
    cout << __GNUC__
         << "."
         << __GNUC_MINOR__;
#   else
    cout << "0.0";
#   endif
    return 0;
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/message_view.hpp"

namespace caf {

message_view::~message_view() {
  // nop
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/sec.hpp"

#include "caf/detail/enum_to_string.hpp"

namespace caf {

namespace {

const char* sec_strings[] = {
  "none",
  "unexpected_message",
  "unexpected_response",
  "request_receiver_down",
  "request_timeout",
  "no_such_group_module",
  "no_actor_published_at_port",
  "unexpected_actor_messaging_interface",
  "state_not_serializable",
  "unsupported_sys_key",
  "unsupported_sys_message",
  "disconnect_during_handshake",
  "cannot_forward_to_invalid_actor",
  "no_route_to_receiving_node",
  "failed_to_assign_scribe_from_handle",
  "failed_to_assign_doorman_from_handle",
  "cannot_close_invalid_port",
  "cannot_connect_to_node",
  "cannot_open_port",
  "network_syscall_failed",
  "invalid_argument",
  "invalid_protocol_family",
  "cannot_publish_invalid_actor",
  "cannot_spawn_actor_from_arguments",
  "end_of_stream",
  "no_context",
  "unknown_type",
  "no_proxy_registry",
  "runtime_error",
  "remote_linking_failed",
  "cannot_add_upstream",
  "upstream_already_exists",
  "invalid_upstream",
  "cannot_add_downstream",
  "downstream_already_exists",
  "invalid_downstream",
  "no_downstream_stages_defined",
  "stream_init_failed",
  "invalid_stream_state",
  "bad_function_call",
  "feature_disabled",
};

} // namespace <anonymous>

std::string to_string(sec x) {
  return detail::enum_to_string(x, sec_strings);
}

error make_error(sec x) {
  return {static_cast<uint8_t>(x), atom("system")};
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

/******************************************************************************\
 * Based on http://homes.esat.kuleuven.be/~cosicart/ps/AB-9601/rmd160.c;      *
 * original header:                                                           *
 *                                                                            *
 *    AUTHOR:   Antoon Bosselaers, ESAT-COSIC                                 *
 *    DATE:   1 March 1996                                                    *
 *    VERSION:  1.0                                                           *
 *                                                                            *
 *    Copyright (c) Katholieke Universiteit Leuven                            *
 *    1996, All Rights Reserved                                               *
 *                                                                            *
 *  Conditions for use of the RIPEMD-160 Software                             *
 *                                                                            *
 *  The RIPEMD-160 software is freely available for use under the terms and   *
 *  conditions described hereunder, which shall be deemed to be accepted by   *
 *  any user of the software and applicable on any use of the software:       *
 *                                                                            *
 *  1. K.U.Leuven Department of Electrical Engineering-ESAT/COSIC shall for   *
 *   all purposes be considered the owner of the RIPEMD-160 software and of   *
 *   all copyright, trade secret, patent or other intellectual property       *
 *   rights therein.                                                          *
 *  2. The RIPEMD-160 software is provided on an "as is" basis without        *
 *   warranty of any sort, express or implied. K.U.Leuven makes no            *
 *   representation that the use of the software will not infringe any        *
 *   patent or proprietary right of third parties. User will indemnify        *
 *   K.U.Leuven and hold K.U.Leuven harmless from any claims or liabilities   *
 *   which may arise as a result of its use of the software. In no            *
 *   circumstances K.U.Leuven R&D will be held liable for any deficiency,     *
 *   fault or other mishappening with regard to the use or performance of     *
 *   the software.                                                            *
 *  3. User agrees to give due credit to K.U.Leuven in scientific             *
 *   publications or communications in relation with the use of the           *
 *   RIPEMD-160 software as follows: RIPEMD-160 software written by           *
 *   Antoon Bosselaers,                                                       *
 *   available at http://www.esat.kuleuven.be/~cosicart/ps/AB-9601/.          *
 *                                                                            *
\******************************************************************************/

#include <cstring>
#include "caf/detail/ripemd_160.hpp"

namespace {

// typedef 8 and 32 bit types, resp.
// adapt these, if necessary, for your operating system and compiler
using byte = unsigned char;
using dword = uint32_t;

static_assert(sizeof(dword) == sizeof(unsigned), "platform not supported");

// macro definitions

// collect four bytes into one word:
#define BYTES_TO_DWORD(strptr)                                                 \
  ((static_cast<dword>(*((strptr) + 3)) << 24)                                 \
   | (static_cast<dword>(*((strptr) + 2)) << 16)                               \
   | (static_cast<dword>(*((strptr) + 1)) << 8)                                \
   | (static_cast<dword>(*(strptr))))

// ROL(x, n) cyclically rotates x over n bits to the left
// x must be of an unsigned 32 bits type and 0 <= n < 32.
#define ROL(x, n) (((x) << (n)) | ((x) >> (32 - (n))))

// the five basic functions F(), G() and H()
#define F(x, y, z) ((x) ^ (y) ^ (z))
#define G(x, y, z) (((x) & (y)) | (~(x) & (z)))
#define H(x, y, z) (((x) | ~(y)) ^ (z))
#define I(x, y, z) (((x) & (z)) | ((y) & ~(z)))
#define J(x, y, z) ((x) ^ ((y) | ~(z)))

// the ten basic operations FF() through III()
#define FF(a, b, c, d, e, x, s)                                                \
  {                                                                            \
    (a) += F((b), (c), (d)) + (x);                                             \
    (a) = ROL((a), (s)) + (e);                                                 \
    (c) = ROL((c), 10);                                                        \
  }

#define GG(a, b, c, d, e, x, s)                                                \
  {                                                                            \
    (a) += G((b), (c), (d)) + (x) + 0x5a827999U;                               \
    (a) = ROL((a), (s)) + (e);                                                 \
    (c) = ROL((c), 10);                                                        \
  }

#define HH(a, b, c, d, e, x, s)                                                \
  {                                                                            \
    (a) += H((b), (c), (d)) + (x) + 0x6ed9eba1U;                               \
    (a) = ROL((a), (s)) + (e);                                                 \
    (c) = ROL((c), 10);                                                        \
  }

#define II(a, b, c, d, e, x, s)                                                \
  {                                                                            \
    (a) += I((b), (c), (d)) + (x) + 0x8f1bbcdcU;                               \
    (a) = ROL((a), (s)) + (e);                                                 \
    (c) = ROL((c), 10);                                                        \
  }

#define JJ(a, b, c, d, e, x, s)                                                \
  {                                                                            \
    (a) += J((b), (c), (d)) + (x) + 0xa953fd4eU;                               \
    (a) = ROL((a), (s)) + (e);                                                 \
    (c) = ROL((c), 10);                                                        \
  }

#define FFF(a, b, c, d, e, x, s)                                               \
  {                                                                            \
    (a) += F((b), (c), (d)) + (x);                                             \
    (a) = ROL((a), (s)) + (e);                                                 \
    (c) = ROL((c), 10);                                                        \
  }

#define GGG(a, b, c, d, e, x, s)                                               \
  {                                                                            \
    (a) += G((b), (c), (d)) + (x) + 0x7a6d76e9U;                               \
    (a) = ROL((a), (s)) + (e);                                                 \
    (c) = ROL((c), 10);                                                        \
  }

#define HHH(a, b, c, d, e, x, s)                                               \
  {                                                                            \
    (a) += H((b), (c), (d)) + (x) + 0x6d703ef3U;                               \
    (a) = ROL((a), (s)) + (e);                                                 \
    (c) = ROL((c), 10);                                                        \
  }

#define III(a, b, c, d, e, x, s)                                               \
  {                                                                            \
    (a) += I((b), (c), (d)) + (x) + 0x5c4dd124U;                               \
    (a) = ROL((a), (s)) + (e);                                                 \
    (c) = ROL((c), 10);                                                        \
  }

#define JJJ(a, b, c, d, e, x, s)                                               \
  {                                                                            \
    (a) += J((b), (c), (d)) + (x) + 0x50a28be6U;                               \
    (a) = ROL((a), (s)) + (e);                                                 \
    (c) = ROL((c), 10);                                                        \
  }

void MDinit(dword* MDbuf) {
  MDbuf[0] = 0x67452301UL;
  MDbuf[1] = 0xefcdab89UL;
  MDbuf[2] = 0x98badcfeUL;
  MDbuf[3] = 0x10325476UL;
  MDbuf[4] = 0xc3d2e1f0UL;
}

void compress(dword* MDbuf, dword* X) {
  // round 1-5 variables
  dword aa = MDbuf[0];
  dword bb = MDbuf[1];
  dword cc = MDbuf[2];
  dword dd = MDbuf[3];
  dword ee = MDbuf[4];
  // parallel round 1-5 variables
  dword aaa = MDbuf[0];
  dword bbb = MDbuf[1];
  dword ccc = MDbuf[2];
  dword ddd = MDbuf[3];
  dword eee = MDbuf[4];
  // round 1
  FF(aa, bb, cc, dd, ee, X[0], 11);
  FF(ee, aa, bb, cc, dd, X[1], 14);
  FF(dd, ee, aa, bb, cc, X[2], 15);
  FF(cc, dd, ee, aa, bb, X[3], 12);
  FF(bb, cc, dd, ee, aa, X[4], 5);
  FF(aa, bb, cc, dd, ee, X[5], 8);
  FF(ee, aa, bb, cc, dd, X[6], 7);
  FF(dd, ee, aa, bb, cc, X[7], 9);
  FF(cc, dd, ee, aa, bb, X[8], 11);
  FF(bb, cc, dd, ee, aa, X[9], 13);
  FF(aa, bb, cc, dd, ee, X[10], 14);
  FF(ee, aa, bb, cc, dd, X[11], 15);
  FF(dd, ee, aa, bb, cc, X[12], 6);
  FF(cc, dd, ee, aa, bb, X[13], 7);
  FF(bb, cc, dd, ee, aa, X[14], 9);
  FF(aa, bb, cc, dd, ee, X[15], 8);
  // round 2
  GG(ee, aa, bb, cc, dd, X[7], 7);
  GG(dd, ee, aa, bb, cc, X[4], 6);
  GG(cc, dd, ee, aa, bb, X[13], 8);
  GG(bb, cc, dd, ee, aa, X[1], 13);
  GG(aa, bb, cc, dd, ee, X[10], 11);
  GG(ee, aa, bb, cc, dd, X[6], 9);
  GG(dd, ee, aa, bb, cc, X[15], 7);
  GG(cc, dd, ee, aa, bb, X[3], 15);
  GG(bb, cc, dd, ee, aa, X[12], 7);
  GG(aa, bb, cc, dd, ee, X[0], 12);
  GG(ee, aa, bb, cc, dd, X[9], 15);
  GG(dd, ee, aa, bb, cc, X[5], 9);
  GG(cc, dd, ee, aa, bb, X[2], 11);
  GG(bb, cc, dd, ee, aa, X[14], 7);
  GG(aa, bb, cc, dd, ee, X[11], 13);
  GG(ee, aa, bb, cc, dd, X[8], 12);
  // round 3
  HH(dd, ee, aa, bb, cc, X[3], 11);
  HH(cc, dd, ee, aa, bb, X[10], 13);
  HH(bb, cc, dd, ee, aa, X[14], 6);
  HH(aa, bb, cc, dd, ee, X[4], 7);
  HH(ee, aa, bb, cc, dd, X[9], 14);
  HH(dd, ee, aa, bb, cc, X[15], 9);
  HH(cc, dd, ee, aa, bb, X[8], 13);
  HH(bb, cc, dd, ee, aa, X[1], 15);
  HH(aa, bb, cc, dd, ee, X[2], 14);
  HH(ee, aa, bb, cc, dd, X[7], 8);
  HH(dd, ee, aa, bb, cc, X[0], 13);
  HH(cc, dd, ee, aa, bb, X[6], 6);
  HH(bb, cc, dd, ee, aa, X[13], 5);
  HH(aa, bb, cc, dd, ee, X[11], 12);
  HH(ee, aa, bb, cc, dd, X[5], 7);
  HH(dd, ee, aa, bb, cc, X[12], 5);
  // round 4
  II(cc, dd, ee, aa, bb, X[1], 11);
  II(bb, cc, dd, ee, aa, X[9], 12);
  II(aa, bb, cc, dd, ee, X[11], 14);
  II(ee, aa, bb, cc, dd, X[10], 15);
  II(dd, ee, aa, bb, cc, X[0], 14);
  II(cc, dd, ee, aa, bb, X[8], 15);
  II(bb, cc, dd, ee, aa, X[12], 9);
  II(aa, bb, cc, dd, ee, X[4], 8);
  II(ee, aa, bb, cc, dd, X[13], 9);
  II(dd, ee, aa, bb, cc, X[3], 14);
  II(cc, dd, ee, aa, bb, X[7], 5);
  II(bb, cc, dd, ee, aa, X[15], 6);
  II(aa, bb, cc, dd, ee, X[14], 8);
  II(ee, aa, bb, cc, dd, X[5], 6);
  II(dd, ee, aa, bb, cc, X[6], 5);
  II(cc, dd, ee, aa, bb, X[2], 12);
  // round 5
  JJ(bb, cc, dd, ee, aa, X[4], 9);
  JJ(aa, bb, cc, dd, ee, X[0], 15);
  JJ(ee, aa, bb, cc, dd, X[5], 5);
  JJ(dd, ee, aa, bb, cc, X[9], 11);
  JJ(cc, dd, ee, aa, bb, X[7], 6);
  JJ(bb, cc, dd, ee, aa, X[12], 8);
  JJ(aa, bb, cc, dd, ee, X[2], 13);
  JJ(ee, aa, bb, cc, dd, X[10], 12);
  JJ(dd, ee, aa, bb, cc, X[14], 5);
  JJ(cc, dd, ee, aa, bb, X[1], 12);
  JJ(bb, cc, dd, ee, aa, X[3], 13);
  JJ(aa, bb, cc, dd, ee, X[8], 14);
  JJ(ee, aa, bb, cc, dd, X[11], 11);
  JJ(dd, ee, aa, bb, cc, X[6], 8);
  JJ(cc, dd, ee, aa, bb, X[15], 5);
  JJ(bb, cc, dd, ee, aa, X[13], 6);
  // parallel round 1
  JJJ(aaa, bbb, ccc, ddd, eee, X[5], 8);
  JJJ(eee, aaa, bbb, ccc, ddd, X[14], 9);
  JJJ(ddd, eee, aaa, bbb, ccc, X[7], 9);
  JJJ(ccc, ddd, eee, aaa, bbb, X[0], 11);
  JJJ(bbb, ccc, ddd, eee, aaa, X[9], 13);
  JJJ(aaa, bbb, ccc, ddd, eee, X[2], 15);
  JJJ(eee, aaa, bbb, ccc, ddd, X[11], 15);
  JJJ(ddd, eee, aaa, bbb, ccc, X[4], 5);
  JJJ(ccc, ddd, eee, aaa, bbb, X[13], 7);
  JJJ(bbb, ccc, ddd, eee, aaa, X[6], 7);
  JJJ(aaa, bbb, ccc, ddd, eee, X[15], 8);
  JJJ(eee, aaa, bbb, ccc, ddd, X[8], 11);
  JJJ(ddd, eee, aaa, bbb, ccc, X[1], 14);
  JJJ(ccc, ddd, eee, aaa, bbb, X[10], 14);
  JJJ(bbb, ccc, ddd, eee, aaa, X[3], 12);
  JJJ(aaa, bbb, ccc, ddd, eee, X[12], 6);
  // parallel round 2
  III(eee, aaa, bbb, ccc, ddd, X[6], 9);
  III(ddd, eee, aaa, bbb, ccc, X[11], 13);
  III(ccc, ddd, eee, aaa, bbb, X[3], 15);
  III(bbb, ccc, ddd, eee, aaa, X[7], 7);
  III(aaa, bbb, ccc, ddd, eee, X[0], 12);
  III(eee, aaa, bbb, ccc, ddd, X[13], 8);
  III(ddd, eee, aaa, bbb, ccc, X[5], 9);
  III(ccc, ddd, eee, aaa, bbb, X[10], 11);
  III(bbb, ccc, ddd, eee, aaa, X[14], 7);
  III(aaa, bbb, ccc, ddd, eee, X[15], 7);
  III(eee, aaa, bbb, ccc, ddd, X[8], 12);
  III(ddd, eee, aaa, bbb, ccc, X[12], 7);
  III(ccc, ddd, eee, aaa, bbb, X[4], 6);
  III(bbb, ccc, ddd, eee, aaa, X[9], 15);
  III(aaa, bbb, ccc, ddd, eee, X[1], 13);
  III(eee, aaa, bbb, ccc, ddd, X[2], 11);
  // parallel round 3
  HHH(ddd, eee, aaa, bbb, ccc, X[15], 9);
  HHH(ccc, ddd, eee, aaa, bbb, X[5], 7);
  HHH(bbb, ccc, ddd, eee, aaa, X[1], 15);
  HHH(aaa, bbb, ccc, ddd, eee, X[3], 11);
  HHH(eee, aaa, bbb, ccc, ddd, X[7], 8);
  HHH(ddd, eee, aaa, bbb, ccc, X[14], 6);
  HHH(ccc, ddd, eee, aaa, bbb, X[6], 6);
  HHH(bbb, ccc, ddd, eee, aaa, X[9], 14);
  HHH(aaa, bbb, ccc, ddd, eee, X[11], 12);
  HHH(eee, aaa, bbb, ccc, ddd, X[8], 13);
  HHH(ddd, eee, aaa, bbb, ccc, X[12], 5);
  HHH(ccc, ddd, eee, aaa, bbb, X[2], 14);
  HHH(bbb, ccc, ddd, eee, aaa, X[10], 13);
  HHH(aaa, bbb, ccc, ddd, eee, X[0], 13);
  HHH(eee, aaa, bbb, ccc, ddd, X[4], 7);
  HHH(ddd, eee, aaa, bbb, ccc, X[13], 5);
  // parallel round 4
  GGG(ccc, ddd, eee, aaa, bbb, X[8], 15);
  GGG(bbb, ccc, ddd, eee, aaa, X[6], 5);
  GGG(aaa, bbb, ccc, ddd, eee, X[4], 8);
  GGG(eee, aaa, bbb, ccc, ddd, X[1], 11);
  GGG(ddd, eee, aaa, bbb, ccc, X[3], 14);
  GGG(ccc, ddd, eee, aaa, bbb, X[11], 14);
  GGG(bbb, ccc, ddd, eee, aaa, X[15], 6);
  GGG(aaa, bbb, ccc, ddd, eee, X[0], 14);
  GGG(eee, aaa, bbb, ccc, ddd, X[5], 6);
  GGG(ddd, eee, aaa, bbb, ccc, X[12], 9);
  GGG(ccc, ddd, eee, aaa, bbb, X[2], 12);
  GGG(bbb, ccc, ddd, eee, aaa, X[13], 9);
  GGG(aaa, bbb, ccc, ddd, eee, X[9], 12);
  GGG(eee, aaa, bbb, ccc, ddd, X[7], 5);
  GGG(ddd, eee, aaa, bbb, ccc, X[10], 15);
  GGG(ccc, ddd, eee, aaa, bbb, X[14], 8);
  // parallel round 5
  FFF(bbb, ccc, ddd, eee, aaa, X[12], 8);
  FFF(aaa, bbb, ccc, ddd, eee, X[15], 5);
  FFF(eee, aaa, bbb, ccc, ddd, X[10], 12);
  FFF(ddd, eee, aaa, bbb, ccc, X[4], 9);
  FFF(ccc, ddd, eee, aaa, bbb, X[1], 12);
  FFF(bbb, ccc, ddd, eee, aaa, X[5], 5);
  FFF(aaa, bbb, ccc, ddd, eee, X[8], 14);
  FFF(eee, aaa, bbb, ccc, ddd, X[7], 6);
  FFF(ddd, eee, aaa, bbb, ccc, X[6], 8);
  FFF(ccc, ddd, eee, aaa, bbb, X[2], 13);
  FFF(bbb, ccc, ddd, eee, aaa, X[13], 6);
  FFF(aaa, bbb, ccc, ddd, eee, X[14], 5);
  FFF(eee, aaa, bbb, ccc, ddd, X[0], 15);
  FFF(ddd, eee, aaa, bbb, ccc, X[3], 13);
  FFF(ccc, ddd, eee, aaa, bbb, X[9], 11);
  FFF(bbb, ccc, ddd, eee, aaa, X[11], 11);
  // combine results
  ddd += cc + MDbuf[1]; // final result for MDbuf[0]
  MDbuf[1] = MDbuf[2] + dd + eee;
  MDbuf[2] = MDbuf[3] + ee + aaa;
  MDbuf[3] = MDbuf[4] + aa + bbb;
  MDbuf[4] = MDbuf[0] + bb + ccc;
  MDbuf[0] = ddd;
}

void MDfinish(dword* MDbuf, const byte* strptr, dword lswlen, dword mswlen) {
  dword X[16]; // message words
  memset(X, 0, 16 * sizeof(dword));
  // put bytes from strptr into X
  for (unsigned int i = 0; i < (lswlen & 63); ++i) {
    // byte i goes into word X[i div 4] at pos.  8*(i mod 4)
    X[i >> 2] ^= static_cast<dword>(*strptr++) << (8 * (i & 3));
  }
  // append the bit n_ == 1
  X[(lswlen >> 2) & 15] ^= static_cast<dword>(1) << (8 * (lswlen & 3) + 7);
  if ((lswlen & 63) > 55) {
    // length goes to next block
    compress(MDbuf, X);
    memset(X, 0, 16 * sizeof(dword));
  }
  // append length in bits
  X[14] = lswlen << 3;
  X[15] = (lswlen >> 29) | (mswlen << 3);
  compress(MDbuf, X);
}

} // namespace <anonmyous>

namespace caf {
namespace detail {

void ripemd_160(std::array<uint8_t, 20>& storage, const std::string& data) {
  dword MDbuf[5]; // contains (A, B, C, D(, E))
  dword X[16];    // current 16-word chunk
  dword length;   // length in bytes of message
  auto message = reinterpret_cast<const unsigned char*>(data.c_str());
  // initialize
  MDinit(MDbuf);
  length = static_cast<dword>(data.size());
  // process message in 16-word chunks
  for (dword nbytes = length; nbytes > 63; nbytes -= 64) {
    for (auto& i : X) {
      i = BYTES_TO_DWORD(message);
      message += 4;
    }
    compress(MDbuf, X);
  }
  // length mod 64 bytes left
  // finish:
  MDfinish(MDbuf, message, length, 0);
  for (size_t i = 0; i < storage.size(); i += 4) {
    // extracts the 8 least significant bits by casting to byte
    storage[i] = static_cast<uint8_t>(MDbuf[i >> 2]);
    storage[i + 1] = static_cast<uint8_t>(MDbuf[i >> 2] >> 8);
    storage[i + 2] = static_cast<uint8_t>(MDbuf[i >> 2] >> 16);
    storage[i + 3] = static_cast<uint8_t>(MDbuf[i >> 2] >> 24);
  }
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/serializer.hpp"

#include "caf/actor_system.hpp"

namespace caf {

serializer::serializer(actor_system& sys) : super(sys.dummy_execution_unit()) {
  // nop
}

serializer::serializer(execution_unit* ctx) : super(ctx) {
  // nop
}

serializer::~serializer() {
  // nop
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/scoped_actor.hpp"

#include "caf/to_string.hpp"
#include "caf/spawn_options.hpp"
#include "caf/actor_registry.hpp"
#include "caf/scoped_execution_unit.hpp"

namespace caf {

namespace {

class impl : public blocking_actor {
public:
  impl(actor_config& cfg) : blocking_actor(cfg) {
    setf(is_detached_flag);
  }

  void act() override {
    CAF_LOG_ERROR("act() of scoped_actor impl called");
  }

  const char* name() const override {
    return "scoped_actor";
  }
};

} // namespace <anonymous>

scoped_actor::scoped_actor(actor_system& sys, bool hide) : context_(&sys) {
  CAF_SET_LOGGER_SYS(&sys);
  actor_config cfg{&context_};
  self_ = make_actor<impl, strong_actor_ptr>(sys.next_actor_id(), sys.node(),
                                             &sys, cfg);
  if (!hide)
    ptr()->register_at_system();
  prev_ = CAF_SET_AID(self_->id());
  ptr()->initialize();
}

scoped_actor::~scoped_actor() {
  if (!self_)
    return;
  auto x = ptr();
  if (!x->getf(abstract_actor::is_terminated_flag))
    x->cleanup(exit_reason::normal, &context_);
  CAF_SET_AID(prev_);
}

blocking_actor* scoped_actor::ptr() const {
  return static_cast<blocking_actor*>(actor_cast<abstract_actor*>(self_));
}

std::string to_string(const scoped_actor& x) {
  return to_string(x.address());
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/detail/message_data.hpp"

#include <cstring>

namespace caf {
namespace detail {

message_data::~message_data() {
  // nop
}

bool message_data::shared() const noexcept {
  return !unique();
}

message_data* message_data::cow_ptr::get_unshared() {
  auto p = ptr_.get();
  if (!p->unique()) {
    auto cptr = p->copy();
    ptr_.swap(cptr.ptr_);
    return ptr_.get();
  }
  return p;
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/error.hpp"

#include "caf/config.hpp"
#include "caf/message.hpp"
#include "caf/serializer.hpp"
#include "caf/deserializer.hpp"
#include "caf/deep_to_string.hpp"

namespace caf {

// -- nested classes -----------------------------------------------------------

struct error::data {
  uint8_t code;
  atom_value category;
  message context;
};

// -- constructors, destructors, and assignment operators ----------------------

error::error() noexcept : data_(nullptr) {
  // nop
}

error::error(none_t) noexcept : data_(nullptr) {
  // nop
}

error::error(error&& x) noexcept : data_(x.data_) {
  if (data_ != nullptr)
    x.data_ = nullptr;
}

error& error::operator=(error&& x) noexcept {
  if (this != &x)
    std::swap(data_, x.data_);
  return *this;
}

error::error(const error& x) : data_(x ? new data(*x.data_) : nullptr) {
  // nop
}

error& error::operator=(const error& x) {
  if (this == &x)
    return *this;
  if (x) {
    if (data_ == nullptr)
      data_ = new data(*x.data_);
    else
      *data_ = *x.data_;
  } else {
    clear();
  }
  return *this;
}

error::error(uint8_t x, atom_value y)
    : data_(x != 0 ? new data{x, y, none} : nullptr) {
  // nop
}

error::error(uint8_t x, atom_value y, message z)
    : data_(x != 0 ? new data{x, y, std::move(z)} : nullptr) {
  // nop
}

error::~error() {
  delete data_;
}

// -- observers ----------------------------------------------------------------

uint8_t error::code() const noexcept {
  CAF_ASSERT(data_ != nullptr);
  return data_->code;
}

atom_value error::category() const noexcept {
  CAF_ASSERT(data_ != nullptr);
  return data_->category;
}

const message& error::context() const noexcept {
  CAF_ASSERT(data_ != nullptr);
  return data_->context;
}

int error::compare(const error& x) const noexcept {
  uint8_t x_code;
  atom_value x_category;
  if (x) {
    x_code = x.data_->code;
    x_category = x.data_->category;
  } else {
    x_code = 0;
    x_category = atom("");
  }
  return compare(x_code, x_category);
}

int error::compare(uint8_t x, atom_value y) const noexcept {
  uint8_t mx;
  atom_value my;
  if (data_ != nullptr) {
    mx = data_->code;
    my = data_->category;
  } else {
    mx = 0;
    my = atom("");
  }
  // all errors with default value are considered no error -> equal
  if (mx == x && x == 0)
    return 0;
  if (my < y)
    return -1;
  if (my > y)
    return 1;
  return static_cast<int>(mx) - x;
}

// -- modifiers --------------------------------------------------------------

message& error::context() noexcept {
  CAF_ASSERT(data_ != nullptr);
  return data_->context;
}

void error::clear() noexcept {
  if (data_ != nullptr) {
    delete data_;
    data_ = nullptr;
  }
}

// -- inspection support -----------------------------------------------------

error error::apply(const inspect_fun& f) {
  data tmp{0, atom(""), message{}};
  data& ref = data_ != nullptr ? *data_ : tmp;
  auto result = f(meta::type_name("error"), ref.code, ref.category,
                  meta::omittable_if_empty(), ref.context);
  if (ref.code == 0)
    clear();
  else if (&tmp == &ref)
    data_ = new data(std::move(tmp));
  return result;
}

std::string to_string(const error& x) {
  if (!x)
    return "none";
  return deep_to_string(meta::type_name("error"), x.code(), x.category(),
                        meta::omittable_if_empty(), x.context());
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/monitorable_actor.hpp"

#include "caf/sec.hpp"
#include "caf/logger.hpp"
#include "caf/actor_cast.hpp"
#include "caf/actor_system.hpp"
#include "caf/message_handler.hpp"
#include "caf/system_messages.hpp"
#include "caf/default_attachable.hpp"

#include "caf/detail/sync_request_bouncer.hpp"

#include "caf/scheduler/abstract_coordinator.hpp"

namespace caf {

const char* monitorable_actor::name() const {
  return "monitorable_actor";
}

void monitorable_actor::attach(attachable_ptr ptr) {
  CAF_LOG_TRACE("");
  CAF_ASSERT(ptr != nullptr);
  error fail_state;
  auto attached = exclusive_critical_section([&] {
    if (getf(is_terminated_flag)) {
      fail_state = fail_state_;
      return false;
    }
    attach_impl(ptr);
    return true;
  });
  CAF_LOG_DEBUG("cannot attach functor to terminated actor: call immediately");
  if (!attached)
    ptr->actor_exited(fail_state, nullptr);
}

size_t monitorable_actor::detach(const attachable::token& what) {
  CAF_LOG_TRACE("");
  std::unique_lock<std::mutex> guard{mtx_};
  return detach_impl(what);
}

void monitorable_actor::unlink_from(const actor_addr& x) {
  auto ptr = actor_cast<strong_actor_ptr>(x);
  if (ptr != nullptr) {
    if (ptr->get() != this)
      remove_link(ptr->get());
  } else {
    default_attachable::observe_token tk{x, default_attachable::link};
    exclusive_critical_section([&] {
      detach_impl(tk, true);
    });
  }
}

bool monitorable_actor::cleanup(error&& reason, execution_unit* host) {
  CAF_LOG_TRACE(CAF_ARG(reason));
  attachable_ptr head;
  bool set_fail_state = exclusive_critical_section([&]() -> bool {
    if (!getf(is_cleaned_up_flag)) {
      // local actors pass fail_state_ as first argument
      if (&fail_state_ != &reason)
        fail_state_ = std::move(reason);
      attachables_head_.swap(head);
      flags(flags() | is_terminated_flag | is_cleaned_up_flag);
      on_cleanup();
      return true;
    }
    return false;
  });
  if (!set_fail_state)
    return false;
  CAF_LOG_INFO("cleanup" << CAF_ARG(id())
               << CAF_ARG(node()) << CAF_ARG(reason));
  // send exit messages
  for (attachable* i = head.get(); i != nullptr; i = i->next.get())
    i->actor_exited(reason, host);
  // tell printer to purge its state for us if we ever used aout()
  if (getf(abstract_actor::has_used_aout_flag)) {
    auto pr = home_system().scheduler().printer();
    pr->enqueue(make_mailbox_element(nullptr, make_message_id(), {},
                                      delete_atom::value, id()),
                nullptr);
  }
  return true;
}

void monitorable_actor::on_cleanup() {
  // nop
}

void monitorable_actor::bounce(mailbox_element_ptr& what) {
  error err;
  shared_critical_section([&] {
    err = fail_state_;
  });
  bounce(what, err);
}

void monitorable_actor::bounce(mailbox_element_ptr& what, const error& err) {
  // make sure that a request always gets a response;
  // the exit reason reflects the first actor on the
  // forwarding chain that is out of service
  detail::sync_request_bouncer rb{err};
  rb(*what);
}

monitorable_actor::monitorable_actor(actor_config& cfg) : abstract_actor(cfg) {
  // nop
}

void monitorable_actor::add_link(abstract_actor* x) {
  // Add backlink on `x` first and add the local attachable only on success.
  CAF_LOG_TRACE(CAF_ARG(x));
  CAF_ASSERT(x != nullptr);
  error fail_state;
  bool send_exit_immediately = false;
  auto tmp = default_attachable::make_link(address(), x->address());
  joined_exclusive_critical_section(this, x, [&] {
    if (getf(is_terminated_flag)) {
      fail_state = fail_state_;
      send_exit_immediately = true;
    } else if (x->add_backlink(this)) {
      attach_impl(tmp);
    }
  });
  if (send_exit_immediately)
    x->enqueue(nullptr, invalid_message_id,
                 make_message(exit_msg{address(), fail_state}), nullptr);
}

void monitorable_actor::remove_link(abstract_actor* x) {
  CAF_LOG_TRACE(CAF_ARG(x));
  default_attachable::observe_token tk{x->address(), default_attachable::link};
  joined_exclusive_critical_section(this, x, [&] {
    x->remove_backlink(this);
    detach_impl(tk, true);
  });
}

bool monitorable_actor::add_backlink(abstract_actor* x) {
  // Called in an exclusive critical section.
  CAF_LOG_TRACE(CAF_ARG(x));
  CAF_ASSERT(x);
  error fail_state;
  bool send_exit_immediately = false;
  default_attachable::observe_token tk{x->address(),
                                       default_attachable::link};
  auto tmp = default_attachable::make_link(address(), x->address());
  auto success = false;
  if (getf(is_terminated_flag)) {
    fail_state = fail_state_;
    send_exit_immediately = true;
  } else if (detach_impl(tk, true, true) == 0) {
    attach_impl(tmp);
    success = true;
  }
  if (send_exit_immediately)
    x->enqueue(nullptr, invalid_message_id,
               make_message(exit_msg{address(), fail_state}), nullptr);
  return success;
}

bool monitorable_actor::remove_backlink(abstract_actor* x) {
  // Called in an exclusive critical section.
  CAF_LOG_TRACE(CAF_ARG(x));
  default_attachable::observe_token tk{x->address(), default_attachable::link};
  return detach_impl(tk, true) > 0;
}

size_t monitorable_actor::detach_impl(const attachable::token& what,
                                      bool stop_on_hit, bool dry_run) {
  CAF_LOG_TRACE(CAF_ARG(stop_on_hit) << CAF_ARG(dry_run));
  size_t count = 0;
  auto i = &attachables_head_;
  while (*i != nullptr) {
    if ((*i)->matches(what)) {
      ++count;
      if (!dry_run) {
        CAF_LOG_DEBUG("removed element");
        attachable_ptr next;
        next.swap((*i)->next);
        (*i).swap(next);
      } else {
        i = &((*i)->next);
      }
      if (stop_on_hit)
        return count;
    } else {
      i = &((*i)->next);
    }
  }
  return count;
}

bool monitorable_actor::handle_system_message(mailbox_element& x,
                                              execution_unit* ctx,
                                              bool trap_exit) {
  auto& msg = x.content();
  if (!trap_exit && msg.size() == 1 && msg.match_element<exit_msg>(0)) {
    // exits for non-normal exit reasons
    auto& em = msg.get_mutable_as<exit_msg>(0);
    if (em.reason)
      cleanup(std::move(em.reason), ctx);
    return true;
  }
  if (msg.size() > 1 && msg.match_element<sys_atom>(0)) {
    if (!x.sender)
      return true;
    error err;
    mailbox_element_ptr res;
    msg.apply(
      [&](sys_atom, get_atom, std::string& what) {
        CAF_LOG_TRACE(CAF_ARG(what));
        if (what != "info") {
          err = sec::unsupported_sys_key;
          return;
        }
        res = make_mailbox_element(ctrl(), x.mid.response_id(), {},
                                    ok_atom::value, std::move(what),
                                    strong_actor_ptr{ctrl()}, name());
      }
    );
    if (!res && !err)
      err = sec::unsupported_sys_message;
    if (err && x.mid.is_request())
      res = make_mailbox_element(ctrl(), x.mid.response_id(),
                                  {}, std::move(err));
    if (res) {
      auto s = actor_cast<strong_actor_ptr>(x.sender);
      if (s)
        s->enqueue(std::move(res), ctx);
    }
    return true;
  }
  return false;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/stream.hpp"

namespace caf {

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <cstdio>
#include <cstring>
#include <sstream>
#include <iterator>

#include "caf/config.hpp"
#include "caf/node_id.hpp"
#include "caf/serializer.hpp"
#include "caf/deserializer.hpp"
#include "caf/make_counted.hpp"
#include "caf/string_algorithms.hpp"
#include "caf/primitive_variant.hpp"

#include "caf/logger.hpp"
#include "caf/detail/ripemd_160.hpp"
#include "caf/detail/get_root_uuid.hpp"
#include "caf/detail/get_process_id.hpp"
#include "caf/detail/get_mac_addresses.hpp"

namespace caf {

namespace {

uint32_t invalid_process_id = 0;

node_id::host_id_type invalid_host_id;

} // namespace <anonymous>

node_id::~node_id() {
  // nop
}

node_id::node_id(const none_t&) {
  // nop
}

node_id& node_id::operator=(const none_t&) {
  data_.reset();
  return *this;
}

node_id::node_id(intrusive_ptr<data> dataptr) : data_(std::move(dataptr)) {
  // nop
}

node_id::node_id(uint32_t procid, const std::string& hash)
    : data_(make_counted<data>(procid, hash)) {
  // nop
}

node_id::node_id(uint32_t procid, const host_id_type& hid)
    : data_(make_counted<data>(procid, hid)) {
  // nop
}

int node_id::compare(const none_t&) const {
  return data_ ? 1 : 0; // invalid instances are always smaller
}

int node_id::compare(const node_id& other) const {
  if (this == &other || data_ == other.data_)
    return 0; // shortcut for comparing to self or identical instances
  if (!data_ != !other.data_)
    return data_ ? 1 : -1; // invalid instances are always smaller
  // use mismatch instead of strncmp because the
  // latter bails out on the first 0-byte
  auto last = host_id().end();
  auto ipair = std::mismatch(host_id().begin(), last, other.host_id().begin());
  if (ipair.first == last)
    return static_cast<int>(process_id())-static_cast<int>(other.process_id());
  if (*ipair.first < *ipair.second)
    return -1;
  return 1;
}

node_id::data::data() : pid_(0) {
  memset(host_.data(), 0, host_.size());
}

node_id::data::data(uint32_t procid, host_id_type hid)
    : pid_(procid),
      host_(hid) {
  // nop
}

node_id::data::data(uint32_t procid, const std::string& hash) : pid_(procid) {
  if (hash.size() != (host_id_size * 2)) {
    host_ = invalid_host_id;
    return;
  }
  auto hex_value = [](char c) -> uint8_t {
    if (isalpha(c) != 0) {
      if (c >= 'a' && c <= 'f')
        return static_cast<uint8_t>((c - 'a') + 10);
      if (c >= 'A' && c <= 'F')
        return static_cast<uint8_t>((c - 'A') + 10);
    }
    return isdigit(c) != 0 ? static_cast<uint8_t>(c - '0') : 0;
  };
  auto j = hash.c_str();
  for (size_t i = 0; i < host_id_size; ++i) {
    // read two characters, each representing 4 bytes
    host_[i] = static_cast<uint8_t>(hex_value(j[0]) << 4) | hex_value(j[1]);
    j += 2;
  }
}

node_id::data::~data() {
  // nop
}

bool node_id::data::valid() const {
  auto is_zero = [](uint8_t x) { return x == 0; };
  return pid_ != 0 && !std::all_of(host_.begin(), host_.end(), is_zero);
}

namespace {

std::atomic<uint8_t> system_id;

} // <anonymous>

// initializes singleton
intrusive_ptr<node_id::data> node_id::data::create_singleton() {
  CAF_LOG_TRACE("");
  auto ifs = detail::get_mac_addresses();
  std::vector<std::string> macs;
  macs.reserve(ifs.size());
  for (auto& i : ifs) {
    macs.emplace_back(std::move(i.second));
  }
  auto hd_serial_and_mac_addr = join(macs, "") + detail::get_root_uuid();
  node_id::host_id_type nid;
  detail::ripemd_160(nid, hd_serial_and_mac_addr);
  // TODO: redesign network layer, make node_id an opaque type, etc.
  // this hack enables multiple actor systems in a single process
  // by overriding the last byte in the node ID with the actor system "ID"
  nid.back() = system_id.fetch_add(1);
  // note: pointer has a ref count of 1 -> implicitly held by detail::singletons
  intrusive_ptr<data> result;
  result.reset(new node_id::data(detail::get_process_id(), nid), false);
  return result;
}

uint32_t node_id::process_id() const {
  return data_ ? data_->pid_ : invalid_process_id;
}

const node_id::host_id_type& node_id::host_id() const {
  return data_ ? data_->host_ : invalid_host_id;
}

node_id::operator bool() const {
  return static_cast<bool>(data_);
}

void node_id::swap(node_id& x) {
  data_.swap(x.data_);
}

std::string to_string(const node_id& x) {
  std::string result;
  append_to_string(result, x);
  return result;
}

void append_to_string(std::string& x, const node_id& y) {
  if (!y) {
    x += "invalid-node";
    return;
  }
  detail::stringification_inspector si{x};
  si.consume_hex(reinterpret_cast<const uint8_t*>(y.host_id().data()),
                 y.host_id().size());
  x += '#';
  x += std::to_string(y.process_id());
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/detail/parse_ini.hpp"

#include <string>
#include <vector>
#include <iostream>
#include <algorithm>

namespace caf {
namespace detail {

void parse_ini_t::operator()(std::istream& input, const config_consumer& consumer_fun,
                             opt_err errors) const {
  // wraps a temporary into an (lvalue) config_value and calls `consumer_fun`
  auto consumer = [&](size_t ln, std::string name, config_value x) {
    consumer_fun(ln, std::move(name), x, errors);
  };
  std::string group;
  std::string line;
  size_t ln = 0; // line number
  auto print = [&](const char* category, const char* str) {
    if (errors)
      *errors << category << " INI file line "
              << ln << ": " << str << std::endl;
  };
  auto print_error = [&](const char* str) {
    print("[ERROR]", str);
  };
  auto print_warning = [&](const char* str) {
    print("[WARNING]", str);
  };
  while (std::getline(input, line)) {
    ++ln;
    // get begin-of-line (bol) and end-of-line (eol), ignoring whitespaces
    auto eol = find_if_not(line.rbegin(), line.rend(), ::isspace).base();
    auto bol = find_if_not(line.begin(), eol, ::isspace);
    // ignore empty lines and lines starting with ';' (comment)
    if (bol == eol || *bol == ';')
      continue;
    // do we read a group name?
    if (*bol == '[') {
      if (*(eol - 1) != ']')
        print_error("missing ] at end of line");
      else
        group.assign(bol + 1, eol - 1);
      // skip further processing of this line
      continue;
    }
    // do we have a group name yet? (prohibit ungrouped values)
    if (group.empty()) {
      print_error("value outside of a group");
      continue;
    }
    // position of the equal sign
    auto eqs = find(bol, eol, '=');
    if (eqs == eol) {
      print_error("no '=' found");
      continue;
    }
    if (bol == eqs) {
      print_error("line starting with '='");
      continue;
    }
    if ((eqs + 1) == eol) {
      print_error("line ends with '='");
      continue;
    }
    // our keys have the format "<group>.<config-name>"
    auto key = group;
    key += '.';
    // ignore any whitespace between config-name and equal sign
    key.insert(key.end(), bol, find_if(bol, eqs, ::isspace));
    // begin-of-value, ignoring whitespaces after '='
    auto bov = find_if_not(eqs + 1, eol, ::isspace);
    // auto-detect what we are dealing with
    constexpr const char* true_str = "true";
    constexpr const char* false_str = "false";
    auto icase_eq = [](char x, char y) {
      return tolower(x) == tolower(y);
    };
    if (std::equal(bov, eol, true_str, icase_eq)) {
      consumer(ln, std::move(key), true);
    } else if (std::equal(bov, eol, false_str, icase_eq)) {
      consumer(ln, std::move(key), false);
    } else if (*bov == '\'') {
      // end-of-atom iterator
      auto eoa = eol - 1;
      if (bov == eoa) {
        print_error("stray '");
        continue;
      }
      if (*eoa != '\'') {
        print_error("atom not terminated by '");
        continue;
      }
      ++bov; // skip leading '
      if (std::distance(bov, eoa) > 10) {
        print_error("atoms are not allowed to have more than 10 characters");
        continue;
      }
      // found an atom value, copy it into a null-terminated buffer
      char buf[11];
      std::copy(bov, eoa, buf);
      buf[std::distance(bov, eoa)] = '\0';
      atom_value result = atom(buf);
      consumer(ln, std::move(key), result);
    } else if (*bov == '"') {
      // end-of-string iterator
      auto eos = eol - 1;
      if (bov == eos) {
        print_error(R"(stray '"')");
        continue;
      }
      if (*eos != '"') {
        print_error(R"(string not terminated by '"')");
        continue;
      }
      // found a string, remove first and last char from string,
      // start escaping string sequence
      auto last_char_backslash = false;
      std::string result;
      result.reserve(static_cast<size_t>(std::distance(bov, eos)));
      // skip leading " and iterate up to the trailing "
      ++bov;
      for (; bov != eos; ++bov) {
        if (last_char_backslash) {
          switch (*bov) {
            case 'n':
              result += '\n';
              break;
            case 't':
              result += '\t';
              break;
            default:
              result += *bov;
          }
          last_char_backslash = false;
        } else if (*bov == '\\') {
          last_char_backslash = true;
        } else {
          result += *bov;
        }
      }
      if (last_char_backslash)
        print_warning("trailing quotation mark escaped");
      consumer(ln, std::move(key), std::move(result));
    } else {
      bool is_neg = *bov == '-';
      if (is_neg && ++bov == eol) {
        print_error("'-' is not a number");
        continue;
      }
      auto set_ival = [&](int base, int prefix_len, const char* err) {
        auto advanced_bov = bov + prefix_len;
        const char* str_begin = &*(advanced_bov);
        const char* str_end = str_begin + std::distance(advanced_bov, eol);
        char* e;
        int64_t res = std::strtoll(str_begin, &e, base);
        // check if we reached the end
        if (e != str_end)
          print_error(err);
        else
          consumer(ln, std::move(key), is_neg ? -res : res);
      };
      auto set_dval = [&] {
        const char* str_begin = &*(bov);
        const char* str_end = str_begin + std::distance(bov, eol);
        char* e;
        double res = std::strtod(str_begin, &e);
        if (e != str_end)
          print_error("invalid value");
        else
          consumer(ln, std::move(key), is_neg ? -res : res);
      };
      if (*bov == '0' && std::distance(bov, eol) > 1)
        switch (*(bov + 1)) {
          case 'x':
          case 'X':
            set_ival(16, 2, "invalid hex value");
            break;
          case 'b':
          case 'B':
            set_ival(2, 2, "invalid binary value");
            break;
          default:
            if (all_of(bov, eol, ::isdigit))
              set_ival(8, 1, "invalid oct value");
            else
              set_dval();
        }
      else if (all_of(bov, eol, ::isdigit))
        set_ival(10, 0, "invalid decimal value");
      else
        set_dval();
    }
  }
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <string>
#include <condition_variable>

#include "caf/sec.hpp"
#include "caf/atom.hpp"
#include "caf/logger.hpp"
#include "caf/scheduler.hpp"
#include "caf/resumable.hpp"
#include "caf/actor_cast.hpp"
#include "caf/exit_reason.hpp"
#include "caf/local_actor.hpp"
#include "caf/actor_system.hpp"
#include "caf/actor_ostream.hpp"
#include "caf/binary_serializer.hpp"
#include "caf/default_attachable.hpp"
#include "caf/binary_deserializer.hpp"

#include "caf/detail/private_thread.hpp"
#include "caf/detail/sync_request_bouncer.hpp"

namespace caf {

// local actors are created with a reference count of one that is adjusted
// later on in spawn(); this prevents subtle bugs that lead to segfaults,
// e.g., when calling address() in the ctor of a derived class
local_actor::local_actor(actor_config& cfg)
    : monitorable_actor(cfg),
      context_(cfg.host),
      initial_behavior_fac_(std::move(cfg.init_fun)) {
  // nop
}

local_actor::~local_actor() {
  // nop
}

void local_actor::on_destroy() {
  CAF_PUSH_AID_FROM_PTR(this);
  if (!getf(is_cleaned_up_flag)) {
    on_exit();
    cleanup(exit_reason::unreachable, nullptr);
    monitorable_actor::on_destroy();
  }
}

void local_actor::request_response_timeout(const duration& d, message_id mid) {
  CAF_LOG_TRACE(CAF_ARG(d) << CAF_ARG(mid));
  if (!d.valid())
    return;
  auto t = clock().now();
  t += d;
  clock().set_request_timeout(t, this, mid.response_id());
}

void local_actor::monitor(abstract_actor* ptr) {
  if (ptr != nullptr)
    ptr->attach(default_attachable::make_monitor(ptr->address(), address()));
}

void local_actor::demonitor(const actor_addr& whom) {
  CAF_LOG_TRACE(CAF_ARG(whom));
  auto ptr = actor_cast<strong_actor_ptr>(whom);
  if (ptr) {
    default_attachable::observe_token tk{address(), default_attachable::monitor};
    ptr->get()->detach(tk);
  }
}

void local_actor::on_exit() {
  // nop
}


message_id local_actor::new_request_id(message_priority mp) {
  auto result = ++last_request_id_;
  return mp == message_priority::normal ? result : result.with_high_priority();
}

mailbox_element_ptr local_actor::next_message() {
  if (!getf(is_priority_aware_flag))
    return mailbox_element_ptr{mailbox().try_pop()};
  // we partition the mailbox into four segments in this case:
  // <-------- ! was_skipped --------> | <--------  was_skipped  -------->
  // <-- high prio --><-- low prio --> | <-- high prio --><-- low prio -->
  auto& cache = mailbox().cache();
  auto i = cache.begin();
  auto e = cache.separator();
  // read elements from mailbox if we don't have a high
  // priority message or if cache is empty
  if (i == e || !i->is_high_priority()) {
    // insert points for high priority
    auto hp_pos = i;
    // read whole mailbox at once
    auto tmp = mailbox().try_pop();
    while (tmp != nullptr) {
      cache.insert(tmp->is_high_priority() ? hp_pos : e, tmp);
      // adjust high priority insert point on first low prio element insert
      if (hp_pos == e && !tmp->is_high_priority())
        --hp_pos;
      tmp = mailbox().try_pop();
    }
  }
  mailbox_element_ptr result;
  i = cache.begin();
  if (i != e)
    result.reset(cache.take(i));
  return result;
}

bool local_actor::has_next_message() {
  if (!getf(is_priority_aware_flag))
    return mailbox_.can_fetch_more();
  auto& mbox = mailbox();
  auto& cache = mbox.cache();
  return cache.begin() != cache.separator() || mbox.can_fetch_more();
}

void local_actor::push_to_cache(mailbox_element_ptr ptr) {
  CAF_ASSERT(ptr != nullptr);
  CAF_LOG_TRACE(CAF_ARG(*ptr));
  if (!getf(is_priority_aware_flag) || !ptr->is_high_priority()) {
    mailbox().cache().insert(mailbox().cache().end(), ptr.release());
    return;
  }
  auto high_prio = [](const mailbox_element& val) {
    return val.is_high_priority();
  };
  auto& cache = mailbox().cache();
  auto e = cache.end();
  cache.insert(std::partition_point(cache.continuation(),
                                    e, high_prio),
               ptr.release());
}

void local_actor::send_exit(const actor_addr& whom, error reason) {
  send_exit(actor_cast<strong_actor_ptr>(whom), std::move(reason));
}

void local_actor::send_exit(const strong_actor_ptr& dest, error reason) {
  if (!dest)
    return;
  dest->get()->eq_impl(make_message_id(), nullptr, context(),
                       exit_msg{address(), std::move(reason)});
}

const char* local_actor::name() const {
  return "actor";
}

error local_actor::save_state(serializer&, const unsigned int) {
  CAF_RAISE_ERROR("local_actor::serialize called");
}

error local_actor::load_state(deserializer&, const unsigned int) {
  CAF_RAISE_ERROR("local_actor::deserialize called");
}

void local_actor::initialize() {
  // nop
}

bool local_actor::cleanup(error&& fail_state, execution_unit* host) {
  CAF_LOG_TRACE(CAF_ARG(fail_state));
  if (!mailbox_.closed()) {
    detail::sync_request_bouncer f{fail_state};
    mailbox_.close(f);
  }
  // tell registry we're done
  unregister_from_system();
  monitorable_actor::cleanup(std::move(fail_state), host);
  clock().cancel_timeouts(this);
  CAF_LOG_TERMINATE_EVENT(this, fail_state);
  return true;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"
#include "caf/message_handler.hpp"

namespace caf {

message_handler::message_handler(impl_ptr ptr) : impl_(std::move(ptr)) {
  // nop
}

void message_handler::assign(message_handler what) {
  impl_.swap(what.impl_);
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/uniform_type_info_map.hpp"

#include <ios> // std::ios_base::failure
#include <array>
#include <tuple>
#include <limits>
#include <string>
#include <vector>
#include <cstring> // memcmp
#include <algorithm>
#include <type_traits>

#include "caf/locks.hpp"
#include "caf/string_algorithms.hpp"

#include "caf/group.hpp"
#include "caf/logger.hpp"
#include "caf/type_nr.hpp"
#include "caf/message.hpp"
#include "caf/duration.hpp"
#include "caf/timestamp.hpp"
#include "caf/actor_cast.hpp"
#include "caf/stream_msg.hpp"
#include "caf/actor_system.hpp"
#include "caf/actor_factory.hpp"
#include "caf/abstract_group.hpp"
#include "caf/proxy_registry.hpp"
#include "caf/message_builder.hpp"
#include "caf/actor_system_config.hpp"

#include "caf/detail/safe_equal.hpp"
#include "caf/detail/scope_guard.hpp"
#include "caf/detail/shared_spinlock.hpp"

namespace caf {

const char* numbered_type_names[] = {
  "@actor",
  "@actorvec",
  "@addr",
  "@addrvec",
  "@atom",
  "@charbuf",
  "@down",
  "@duration",
  "@timestamp",
  "@error",
  "@exit",
  "@group",
  "@group_down",
  "@i16",
  "@i32",
  "@i64",
  "@i8",
  "@ldouble",
  "@message",
  "@message_id",
  "@node",
  "@str",
  "@stream_msg",
  "@strmap",
  "@strong_actor_ptr",
  "@strset",
  "@strvec",
  "@timeout",
  "@u16",
  "@u16str",
  "@u32",
  "@u32str",
  "@u64",
  "@u8",
  "@unit",
  "@weak_actor_ptr",
  "bool",
  "double",
  "float"
};

namespace {

using builtins = std::array<uniform_type_info_map::value_factory_kvp,
                            type_nrs - 1>;

void fill_builtins(builtins&, detail::type_list<>, size_t) {
  // end of recursion
}

template <class List>
void fill_builtins(builtins& arr, List, size_t pos) {
  using type = typename detail::tl_head<List>::type;
  typename detail::tl_tail<List>::type next;
  arr[pos].first = numbered_type_names[pos];
  arr[pos].second = &make_type_erased_value<type>;
  fill_builtins(arr, next, pos + 1);
}

} // namespace <anonymous>

type_erased_value_ptr uniform_type_info_map::make_value(uint16_t nr) const {
  return builtin_[nr - 1].second();
}

type_erased_value_ptr
uniform_type_info_map::make_value(const std::string& x) const {
  auto pred = [&](const value_factory_kvp& kvp) {
    return kvp.first == x;
  };
  auto e = builtin_.end();
  auto i = std::find_if(builtin_.begin(), e, pred);
  if (i != e)
    return i->second();
  auto& custom_names = system().config().value_factories_by_name;
  auto j = custom_names.find(x);
  if (j != custom_names.end())
    return j->second();
  return nullptr;
}

type_erased_value_ptr
uniform_type_info_map::make_value(const std::type_info& x) const {
  auto& custom_by_rtti = system().config().value_factories_by_rtti;
  auto i = custom_by_rtti.find(std::type_index(x));
  if (i != custom_by_rtti.end())
    return i->second();
  return nullptr;
}

const std::string*
uniform_type_info_map::portable_name(uint16_t nr,
                                     const std::type_info* ti) const {
  if (nr != 0)
    return &builtin_names_[nr - 1];
  if (ti == nullptr)
    return nullptr;
  auto& custom_names = system().config().type_names_by_rtti;
  auto i = custom_names.find(std::type_index(*ti));
  if (i != custom_names.end())
    return &(i->second);
  return nullptr;
}

uniform_type_info_map::uniform_type_info_map(actor_system& sys) : system_(sys) {
  sorted_builtin_types list;
  fill_builtins(builtin_, list, 0);
  for (size_t i = 0; i < builtin_names_.size(); ++i)
    builtin_names_[i] = numbered_type_names[i];
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <utility>
#include <algorithm>

#include "caf/node_id.hpp"
#include "caf/actor_addr.hpp"
#include "caf/serializer.hpp"
#include "caf/actor_system.hpp"
#include "caf/deserializer.hpp"
#include "caf/proxy_registry.hpp"

#include "caf/logger.hpp"
#include "caf/actor_registry.hpp"

namespace caf {

proxy_registry::backend::~backend() {
  // nop
}

proxy_registry::proxy_registry(actor_system& sys, backend& be)
    : system_(sys),
      backend_(be) {
  // nop
}

proxy_registry::~proxy_registry() {
  clear();
}

size_t proxy_registry::count_proxies(const node_id& node) {
  auto i = proxies_.find(node);
  return (i != proxies_.end()) ? i->second.size() : 0;
}

strong_actor_ptr proxy_registry::get(const node_id& node, actor_id aid) {
  auto& submap = proxies_[node];
  auto i = submap.find(aid);
  if (i != submap.end())
    return i->second;
  return nullptr;
}

strong_actor_ptr proxy_registry::get_or_put(const node_id& nid, actor_id aid) {
  CAF_LOG_TRACE(CAF_ARG(nid) << CAF_ARG(aid));
  auto& result = proxies_[nid][aid];
  if (!result)
    result = backend_.make_proxy(nid, aid);
  return result;
}

std::vector<strong_actor_ptr> proxy_registry::get_all(const node_id& node) {
  std::vector<strong_actor_ptr> result;
  auto i = proxies_.find(node);
  if (i != proxies_.end())
    for (auto& kvp : i->second)
      result.push_back(kvp.second);
  return result;
}

bool proxy_registry::empty() const {
  return proxies_.empty();
}

void proxy_registry::erase(const node_id& nid) {
  CAF_LOG_TRACE(CAF_ARG(nid));
  auto i = proxies_.find(nid);
  if (i == proxies_.end())
    return;
  for (auto& kvp : i->second)
    kill_proxy(kvp.second, exit_reason::remote_link_unreachable);
  proxies_.erase(i);
}

void proxy_registry::erase(const node_id& nid, actor_id aid, error rsn) {
  CAF_LOG_TRACE(CAF_ARG(nid) << CAF_ARG(aid));
  auto i = proxies_.find(nid);
  if (i != proxies_.end()) {
    auto& submap = i->second;
    auto j = submap.find(aid);
    if (j == submap.end())
      return;
    kill_proxy(j->second, std::move(rsn));
    submap.erase(j);
    if (submap.empty())
      proxies_.erase(i);
  }
}

void proxy_registry::clear() {
  for (auto& kvp : proxies_)
    for (auto& sub_kvp : kvp.second)
      kill_proxy(sub_kvp.second, exit_reason::remote_link_unreachable);
  proxies_.clear();
}

void proxy_registry::kill_proxy(strong_actor_ptr& ptr, error rsn) {
  if (!ptr)
    return;
  auto pptr = static_cast<actor_proxy*>(actor_cast<abstract_actor*>(ptr));
  pptr->kill_proxy(backend_.registry_context(), std::move(rsn));
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/actor_system.hpp"

#include <unordered_set>

#include "caf/send.hpp"
#include "caf/to_string.hpp"
#include "caf/event_based_actor.hpp"
#include "caf/actor_system_config.hpp"
#include "caf/raw_event_based_actor.hpp"

#include "caf/policy/work_sharing.hpp"
#include "caf/policy/work_stealing.hpp"

#include "caf/scheduler/coordinator.hpp"
#include "caf/scheduler/test_coordinator.hpp"
#include "caf/scheduler/abstract_coordinator.hpp"
#include "caf/scheduler/profiled_coordinator.hpp"

namespace caf {

namespace {

struct kvstate {
  using key_type = std::string;
  using mapped_type = message;
  using subscriber_set = std::unordered_set<strong_actor_ptr>;
  using topic_set = std::unordered_set<std::string>;
  std::unordered_map<key_type, std::pair<mapped_type, subscriber_set>> data;
  std::unordered_map<strong_actor_ptr, topic_set> subscribers;
  static const char* name;
  template <class Processor>
  friend void serialize(Processor& proc, kvstate& x, unsigned int) {
    proc & x.data;
    proc & x.subscribers;
  }
};

const char* kvstate::name = "config_server";

behavior config_serv_impl(stateful_actor<kvstate>* self) {
  CAF_LOG_TRACE("");
  std::string wildcard = "*";
  auto unsubscribe_all = [=](actor subscriber) {
    auto& subscribers = self->state.subscribers;
    auto ptr = actor_cast<strong_actor_ptr>(subscriber);
    auto i = subscribers.find(ptr);
    if (i == subscribers.end())
      return;
    for (auto& key : i->second)
      self->state.data[key].second.erase(ptr);
    subscribers.erase(i);
  };
  self->set_down_handler([=](down_msg& dm) {
    CAF_LOG_TRACE(CAF_ARG(dm));
    auto ptr = actor_cast<strong_actor_ptr>(dm.source);
    if (ptr)
      unsubscribe_all(actor_cast<actor>(std::move(ptr)));
  });
  return {
    // set a key/value pair
    [=](put_atom, const std::string& key, message& msg) {
      CAF_LOG_TRACE(CAF_ARG(key) << CAF_ARG(msg));
      if (key == "*")
        return;
      auto& vp = self->state.data[key];
      vp.first = std::move(msg);
      for (auto& subscriber_ptr : vp.second) {
        // we never put a nullptr in our map
        auto subscriber = actor_cast<actor>(subscriber_ptr);
        if (subscriber != self->current_sender())
          self->send(subscriber, update_atom::value, key, vp.second);
      }
      // also iterate all subscribers for '*'
      for (auto& subscriber : self->state.data[wildcard].second)
        if (subscriber != self->current_sender())
          self->send(actor_cast<actor>(subscriber), update_atom::value,
                     key, vp.second);
    },
    // get a key/value pair
    [=](get_atom, std::string& key) -> message {
      CAF_LOG_TRACE(CAF_ARG(key));
      if (key == wildcard) {
        std::vector<std::pair<std::string, message>> msgs;
        for (auto& kvp : self->state.data)
          if (kvp.first != "*")
            msgs.emplace_back(kvp.first, kvp.second.first);
        return make_message(std::move(msgs));
      }
      auto i = self->state.data.find(key);
      return make_message(std::move(key),
                          i != self->state.data.end() ? i->second.first
                                                      : make_message());
    },
    // subscribe to a key
    [=](subscribe_atom, const std::string& key) {
      auto subscriber = actor_cast<strong_actor_ptr>(self->current_sender());
      CAF_LOG_TRACE(CAF_ARG(key) << CAF_ARG(subscriber));
      if (!subscriber)
        return;
      self->state.data[key].second.insert(subscriber);
      auto& subscribers = self->state.subscribers;
      auto i = subscribers.find(subscriber);
      if (i != subscribers.end()) {
        i->second.insert(key);
      } else {
        self->monitor(subscriber);
        subscribers.emplace(subscriber, kvstate::topic_set{key});
      }
    },
    // unsubscribe from a key
    [=](unsubscribe_atom, const std::string& key) {
      auto subscriber = actor_cast<strong_actor_ptr>(self->current_sender());
      if (!subscriber)
        return;
      CAF_LOG_TRACE(CAF_ARG(key) << CAF_ARG(subscriber));
      if (key == wildcard) {
        unsubscribe_all(actor_cast<actor>(std::move(subscriber)));
        return;
      }
      self->state.subscribers[subscriber].erase(key);
      self->state.data[key].second.erase(subscriber);
    },
    // get a 'named' actor from local registry
    [=](get_atom, atom_value name) {
      return self->home_system().registry().get(name);
    }
  };
}

// -- spawn server -------------------------------------------------------------

// A spawn server allows users to spawn actors dynamically with a name and a
// message containing the data for initialization. By accessing the spawn server
// on another node, users can spwan actors remotely.

struct spawn_serv_state {
  static const char* name;
};

const char* spawn_serv_state::name = "spawn_server";

behavior spawn_serv_impl(stateful_actor<spawn_serv_state>* self) {
  CAF_LOG_TRACE("");
  return {
    [=](spawn_atom, const std::string& name,
        message& args, actor_system::mpi& xs)
    -> expected<strong_actor_ptr> {
      CAF_LOG_TRACE(CAF_ARG(name) << CAF_ARG(args));
      return self->system().spawn<strong_actor_ptr>(name, std::move(args),
                                                    self->context(), true, &xs);
    }
  };
}

// -- stream server ------------------------------------------------------------

// The stream server acts as a man-in-the-middle for all streams that cross the
// network. It manages any number of unrelated streams by placing itself and the
// stream server on the next remote node into the pipeline.

// Outgoing messages are buffered in FIFO order to ensure fairness. However, the
// stream server uses five different FIFO queues: on for each priority level.
// A high priority grants more network bandwidth.

// Note that stream servers do not actively take part in the streams they
// process. Batch messages and ACKs are treated equally. Open, close, and error
// messages are evaluated to add and remove state as needed.

class dropping_execution_unit : public execution_unit {
public:
  dropping_execution_unit(actor_system* sys) : execution_unit(sys) {
    // nop
  }

  void exec_later(resumable*) override {
    // should not happen in the first place
    CAF_LOG_ERROR("actor registry actor called exec_later during shutdown");
  }
};

} // namespace <anonymous>

actor_system::module::~module() {
  // nop
}

actor_system::actor_system(actor_system_config& cfg)
    : ids_(0),
      types_(*this),
      logger_(new caf::logger(*this), false),
      registry_(*this),
      groups_(*this),
      dummy_execution_unit_(this),
      await_actors_before_shutdown_(true),
      detached(0),
      cfg_(cfg),
      logger_dtor_done_(false) {
  CAF_SET_LOGGER_SYS(this);
  for (auto& hook : cfg.thread_hooks_)
    hook->init(*this);
  for (auto& f : cfg.module_factories) {
    auto mod_ptr = f(*this);
    modules_[mod_ptr->id()].reset(mod_ptr);
  }
  auto& sched = modules_[module::scheduler];
  using namespace scheduler;
  using policy::work_sharing;
  using policy::work_stealing;
  using share = coordinator<work_sharing>;
  using steal = coordinator<work_stealing>;
  using profiled_share = profiled_coordinator<policy::profiled<work_sharing>>;
  using profiled_steal = profiled_coordinator<policy::profiled<work_stealing>>;
  // set scheduler only if not explicitly loaded by user
  if (!sched) {
    enum sched_conf {
      stealing          = 0x0001,
      sharing           = 0x0002,
      testing           = 0x0003,
      profiled          = 0x0100,
      profiled_stealing = 0x0101,
      profiled_sharing  = 0x0102
    };
    sched_conf sc = stealing;
    if (cfg.scheduler_policy == atom("sharing"))
      sc = sharing;
    else if (cfg.scheduler_policy == atom("testing"))
      sc = testing;
    else if (cfg.scheduler_policy != atom("stealing"))
      std::cerr << "[WARNING] " << deep_to_string(cfg.scheduler_policy)
                << " is an unrecognized scheduler pollicy, "
                   "falling back to 'stealing' (i.e. work-stealing)"
                << std::endl;
    if (cfg.scheduler_enable_profiling)
      sc = static_cast<sched_conf>(sc | profiled);
    switch (sc) {
      default: // any invalid configuration falls back to work stealing
        sched.reset(new steal(*this));
        break;
      case sharing:
        sched.reset(new share(*this));
        break;
      case profiled_stealing:
        sched.reset(new profiled_steal(*this));
        break;
      case profiled_sharing:
        sched.reset(new profiled_share(*this));
        break;
      case testing:
        sched.reset(new test_coordinator(*this));
    }
  }
  // initialize state for each module and give each module the opportunity
  // to influence the system configuration, e.g., by adding more types
  logger_->init(cfg);
  CAF_SET_LOGGER_SYS(this);
  for (auto& mod : modules_)
    if (mod)
      mod->init(cfg);
  groups_.init(cfg);
  // spawn config and spawn servers (lazily to not access the scheduler yet)
  static constexpr auto Flags = hidden + lazy_init;
  spawn_serv(actor_cast<strong_actor_ptr>(spawn<Flags>(spawn_serv_impl)));
  config_serv(actor_cast<strong_actor_ptr>(spawn<Flags>(config_serv_impl)));
  // fire up remaining modules
  registry_.start();
  registry_.put(atom("SpawnServ"), spawn_serv());
  registry_.put(atom("ConfigServ"), config_serv());
  for (auto& mod : modules_)
    if (mod)
      mod->start();
  groups_.start();
  logger_->start();
}

actor_system::~actor_system() {
  CAF_LOG_DEBUG("shutdown actor system");
  if (await_actors_before_shutdown_)
    await_all_actors_done();
  // shutdown internal actors
  for (auto& x : internal_actors_) {
    anon_send_exit(x, exit_reason::user_shutdown);
    x = nullptr;
  }
  registry_.erase(atom("SpawnServ"));
  registry_.erase(atom("ConfigServ"));
  registry_.erase(atom("StreamServ"));
  // group module is the first one, relies on MM
  groups_.stop();
  // stop modules in reverse order
  for (auto i = modules_.rbegin(); i != modules_.rend(); ++i)
    if (*i)
      (*i)->stop();
  await_detached_threads();
  registry_.stop();
  // reset logger and wait until dtor was called
  CAF_SET_LOGGER_SYS(nullptr);
  logger_.reset();
  std::unique_lock<std::mutex> guard{logger_dtor_mtx_};
  while (!logger_dtor_done_)
    logger_dtor_cv_.wait(guard);
}

/// Returns the host-local identifier for this system.
const node_id& actor_system::node() const {
  return node_;
}

/// Returns the scheduler instance.
scheduler::abstract_coordinator& actor_system::scheduler() {
  using ptr = scheduler::abstract_coordinator*;
  return *static_cast<ptr>(modules_[module::scheduler].get());
}

caf::logger& actor_system::logger() {
  return *logger_;
}

actor_registry& actor_system::registry() {
  return registry_;
}

const uniform_type_info_map& actor_system::types() const {
  return types_;
}

std::string actor_system::render(const error& x) const {
  if (!x)
    return to_string(x);
  auto& xs = config().error_renderers;
  auto i = xs.find(x.category());
  if (i != xs.end())
    return i->second(x.code(), x.category(), x.context());
  return to_string(x);
}

group_manager& actor_system::groups() {
  return groups_;
}

bool actor_system::has_middleman() const {
  return modules_[module::middleman] != nullptr;
}

io::middleman& actor_system::middleman() {
  auto& clptr = modules_[module::middleman];
  if (!clptr)
    CAF_RAISE_ERROR("cannot access middleman: module not loaded");
  return *reinterpret_cast<io::middleman*>(clptr->subtype_ptr());
}

bool actor_system::has_opencl_manager() const {
  return modules_[module::opencl_manager] != nullptr;
}

opencl::manager& actor_system::opencl_manager() const {
  auto& clptr = modules_[module::opencl_manager];
  if (!clptr)
    CAF_RAISE_ERROR("cannot access opencl manager: module not loaded");
  return *reinterpret_cast<opencl::manager*>(clptr->subtype_ptr());
}

bool actor_system::has_openssl_manager() const {
  return modules_[module::openssl_manager] != nullptr;
}

openssl::manager& actor_system::openssl_manager() const {
  auto& clptr = modules_[module::openssl_manager];
  if (!clptr)
    CAF_RAISE_ERROR("cannot access openssl manager: module not loaded");
  return *reinterpret_cast<openssl::manager*>(clptr->subtype_ptr());
}

scoped_execution_unit* actor_system::dummy_execution_unit() {
  return &dummy_execution_unit_;
}

actor_id actor_system::next_actor_id() {
  return ++ids_;
}

actor_id actor_system::latest_actor_id() const {
  return ids_.load();
}

void actor_system::await_all_actors_done() const {
  registry_.await_running_count_equal(0);
}

actor_clock& actor_system::clock() noexcept {
  return scheduler().clock();
}


void actor_system::inc_detached_threads() {
  ++detached;
}

void actor_system::dec_detached_threads() {
  std::unique_lock<std::mutex> guard{detached_mtx};
  if (--detached == 0)
    detached_cv.notify_all();
}

void actor_system::await_detached_threads() {
  std::unique_lock<std::mutex> guard{detached_mtx};
  while (detached != 0)
    detached_cv.wait(guard);
}

void actor_system::thread_started() {
  for (auto& hook : cfg_.thread_hooks_)
    hook->thread_started();
}

void actor_system::thread_terminates() {
  for (auto& hook : cfg_.thread_hooks_)
    hook->thread_terminates();
}

expected<strong_actor_ptr>
actor_system::dyn_spawn_impl(const std::string& name, message& args,
                             execution_unit* ctx, bool check_interface,
                             optional<const mpi&> expected_ifs) {
  CAF_LOG_TRACE(CAF_ARG(name) << CAF_ARG(args) << CAF_ARG(check_interface)
                << CAF_ARG(expected_ifs));
  if (name.empty())
    return sec::invalid_argument;
  auto& fs = cfg_.actor_factories;
  auto i = fs.find(name);
  if (i == fs.end())
    return sec::unknown_type;
  actor_config cfg{ctx != nullptr ? ctx : &dummy_execution_unit_};
  auto res = i->second(cfg, args);
  if (!res.first)
    return sec::cannot_spawn_actor_from_arguments;
  if (check_interface && !assignable(res.second, *expected_ifs))
    return sec::unexpected_actor_messaging_interface;
  return std::move(res.first);
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <sstream>

#include "caf/duration.hpp"

#include "caf/detail/enum_to_string.hpp"

namespace caf {

namespace {

const char* time_unit_strings[] = {
  "invalid",
  "minutes",
  "seconds",
  "milliseconds",
  "microseconds",
  "nanoseconds"
};

const char* time_unit_short_strings[] = {
  "?",
  "min",
  "s",
  "ms",
  "us",
  "ns"
};

} // namespace <anonymous>

std::string to_string(time_unit x) {
  return detail::enum_to_string(x, time_unit_strings);
}

std::string to_string(const duration& x) {
  if (x.unit == time_unit::invalid)
    return "infinite";
  auto result = std::to_string(x.count);
  result += detail::enum_to_string(x.unit, time_unit_short_strings);
  return result;
}

bool operator==(const duration& lhs, const duration& rhs) {
  return lhs.unit == rhs.unit && lhs.count == rhs.count;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/invalid_stream_gatherer.hpp"

#include "caf/logger.hpp"

namespace caf {

invalid_stream_gatherer::~invalid_stream_gatherer() {
  // nop
}

stream_gatherer::path_ptr
invalid_stream_gatherer::add_path(const stream_id&, strong_actor_ptr,
                                  strong_actor_ptr, stream_priority, long, bool,
                                  response_promise) {
  CAF_LOG_ERROR("invalid_stream_gatherer::add_path called");
  return nullptr;
}

bool invalid_stream_gatherer::remove_path(const stream_id&, const actor_addr&,
                                          error, bool) {
  CAF_LOG_ERROR("invalid_stream_gatherer::remove_path called");
  return false;
}

void invalid_stream_gatherer::close(message) {
  // nop
}

void invalid_stream_gatherer::abort(error) {
  // nop
}

long invalid_stream_gatherer::num_paths() const {
  return 0;
}

bool invalid_stream_gatherer::closed() const {
  return true;
}

bool invalid_stream_gatherer::continuous() const {
  return false;
}

void invalid_stream_gatherer::continuous(bool) {
  // nop
}

stream_gatherer::path_type* invalid_stream_gatherer::path_at(size_t) {
  return nullptr;
}

stream_gatherer::path_type* invalid_stream_gatherer::find(const stream_id&,
                                                          const actor_addr&) {
  return nullptr;
}

long invalid_stream_gatherer::high_watermark() const {
  return 0;
}

long invalid_stream_gatherer::min_credit_assignment() const {
  return 0;
}

long invalid_stream_gatherer::max_credit() const {
  return 0;
}

void invalid_stream_gatherer::high_watermark(long) {
  // nop
}

void invalid_stream_gatherer::min_credit_assignment(long) {
  // nop
}

void invalid_stream_gatherer::max_credit(long) {
  // nop
}

void invalid_stream_gatherer::assign_credit(long) {
  // nop
}

long invalid_stream_gatherer::initial_credit(long, path_type*) {
  return 0;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/detail/private_thread.hpp"

#include "caf/config.hpp"
#include "caf/logger.hpp"
#include "caf/scheduled_actor.hpp"

namespace caf {
namespace detail {

private_thread::private_thread(scheduled_actor* self)
    : self_destroyed_(false),
      self_(self),
      state_(active),
      system_(self->system()) {
  intrusive_ptr_add_ref(self->ctrl());
  system_.inc_detached_threads();
}

void private_thread::run() {
  auto job = self_.load();
  CAF_ASSERT(job != nullptr);
  CAF_SET_LOGGER_SYS(&job->system());
  CAF_PUSH_AID(job->id());
  CAF_LOG_TRACE("");
  scoped_execution_unit ctx{&job->system()};
  auto max_throughput = std::numeric_limits<size_t>::max();
  bool resume_later;
  for (;;) {
    state_ = await_resume_or_shutdown;
    do {
      resume_later = false;
      switch (job->resume(&ctx, max_throughput)) {
        case resumable::resume_later:
          resume_later = true;
          break;
        case resumable::done:
          intrusive_ptr_release(job->ctrl());
          return;
        case resumable::awaiting_message:
          intrusive_ptr_release(job->ctrl());
          break;
        case resumable::shutdown_execution_unit:
          return;
      }
    } while (resume_later);
    // wait until actor becomes ready again or was destroyed
    if (!await_resume())
      return;
  }
}

bool private_thread::await_resume() {
  std::unique_lock<std::mutex> guard(mtx_);
  while (state_ == await_resume_or_shutdown)
    cv_.wait(guard);
  return state_ == active;
}

void private_thread::resume() {
  std::unique_lock<std::mutex> guard(mtx_);
  state_ = active;
  cv_.notify_one();
}

void private_thread::shutdown() {
  std::unique_lock<std::mutex> guard(mtx_);
  state_ = shutdown_requested;
  cv_.notify_one();
}

void private_thread::exec(private_thread* this_ptr) {
  this_ptr->system_.thread_started();
  this_ptr->run();
  // make sure to not destroy the private thread object before the
  // detached actor is destroyed and this object is unreachable
  this_ptr->await_self_destroyed();
  // signalize destruction of detached thread to registry
  this_ptr->system_.thread_terminates();
  this_ptr->system_.dec_detached_threads();
  // done
  delete this_ptr;
}

void private_thread::notify_self_destroyed() {
  std::unique_lock<std::mutex> guard(mtx_);
  self_destroyed_ = true;
  cv_.notify_one();
}

void private_thread::await_self_destroyed() {
  std::unique_lock<std::mutex> guard(mtx_);
  while (!self_destroyed_)
    cv_.wait(guard);
}

void private_thread::start() {
  std::thread{exec, this}.detach();
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/decorator/splitter.hpp"

#include "caf/actor_system.hpp"
#include "caf/stateful_actor.hpp"
#include "caf/response_promise.hpp"
#include "caf/event_based_actor.hpp"
#include "caf/default_attachable.hpp"

#include "caf/detail/disposer.hpp"
#include "caf/detail/sync_request_bouncer.hpp"

namespace caf {
namespace decorator {

namespace {

struct splitter_state {
  response_promise rp;
  message result;
  size_t pending;
};

behavior fan_out_fan_in(stateful_actor<splitter_state>* self,
                        const std::vector<strong_actor_ptr>& workers) {
  auto f = [=](local_actor*, message_view& x) -> result<message> {
    auto msg = x.move_content_to_message();
    self->state.rp = self->make_response_promise();
    self->state.pending = workers.size();
    // request().await() has LIFO ordering
    for (auto i = workers.rbegin(); i != workers.rend(); ++i)
      // TODO: maybe infer some useful timeout or use config parameter?
      self->request(actor_cast<actor>(*i), infinite, msg).await(
        [=]() {
          // nop
        },
        [=](error& err) mutable {
          if (err == sec::unexpected_response) {
            self->state.result += std::move(err.context());
            if (--self->state.pending == 0)
              self->state.rp.deliver(std::move(self->state.result));
          } else {
            self->state.rp.deliver(err);
            self->quit();
          }
        }
      );
    return delegated<message>{};
  };
  self->set_default_handler(f);
  return [] {
    // nop
  };
}

} // namespace <anonymous>

splitter::splitter(std::vector<strong_actor_ptr> workers,
                   message_types_set msg_types)
    : monitorable_actor(actor_config{}.add_flag(is_actor_dot_decorator_flag)),
      num_workers(workers.size()),
      workers_(std::move(workers)),
      msg_types_(std::move(msg_types)) {
  // composed actor has dependency on constituent actors by default;
  // if either constituent actor is already dead upon establishing
  // the dependency, the actor is spawned dead
  auto addr = address();
  for (auto& worker : workers_)
    worker->get()->attach(
      default_attachable::make_monitor(actor_cast<actor_addr>(worker), addr));
}

void splitter::enqueue(mailbox_element_ptr what, execution_unit* context) {
  auto down_msg_handler = [&](down_msg& dm) {
    // quit if any worker fails
    cleanup(std::move(dm.reason), context);
  };
  if (handle_system_message(*what, context, false, down_msg_handler))
    return;
  std::vector<strong_actor_ptr> workers;
  workers.reserve(num_workers);
  error fail_state;
  shared_critical_section([&] {
    workers = workers_;
    fail_state = fail_state_;
  });
  if (workers.empty()) {
    bounce(what, fail_state);
    return;
  }
  auto helper = context->system().spawn(fan_out_fan_in, std::move(workers));
  helper->enqueue(std::move(what), context);
}

splitter::message_types_set splitter::message_types() const {
  return msg_types_;
}

} // namespace decorator
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/atom.hpp"

#include <cstring>

namespace caf {

atom_value atom_from_string(const std::string& x) {
  if (x.size() > 10)
    return atom("");
  char buf[11];
  memcpy(buf, x.c_str(), x.size());
  buf[x.size()] = '\0';
  return atom(buf);
}

std::string to_string(const atom_value& what) {
  auto x = static_cast<uint64_t>(what);
  std::string result;
  result.reserve(11);
  // don't read characters before we found the leading 0xF
  // first four bits set?
  bool read_chars = ((x & 0xF000000000000000) >> 60) == 0xF;
  uint64_t mask = 0x0FC0000000000000;
  for (int bitshift = 54; bitshift >= 0; bitshift -= 6, mask >>= 6) {
    if (read_chars)
      result += detail::decoding_table[(x & mask) >> bitshift];
    else if (((x & mask) >> bitshift) == 0xF)
      read_chars = true;
  }
  return result;
}

} // namespace caf
#include "caf/config.hpp"
#include "caf/detail/get_mac_addresses.hpp"

#if defined(CAF_MACOS) || defined(CAF_BSD) || defined(CAF_IOS)

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/sysctl.h>
#include <net/if.h>
#include <net/if_dl.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <cerrno>
#include <cstdio>
#include <cstdlib>
#include <memory>
#include <sstream>

#include <iostream>

namespace caf {
namespace detail {

std::vector<iface_info> get_mac_addresses() {
  int mib[6];
  std::vector<iface_info> result;
  mib[0] = CTL_NET;
  mib[1] = AF_ROUTE;
  mib[2] = 0;
  mib[3] = AF_LINK;
  mib[4] = NET_RT_IFLIST;
  auto indices = if_nameindex();
  std::vector<char> buf;
  for (auto i = indices; !(i->if_index == 0 && i->if_name == nullptr); ++i) {
    mib[5] = static_cast<int>(i->if_index);
    size_t len;
    if (sysctl(mib, 6, nullptr, &len, nullptr, 0) < 0) {
      perror("sysctl 1 error");
      exit(3);
    }
    if (buf.size() < len)
      buf.resize(len);
    CAF_ASSERT(len > 0);
    if (sysctl(mib, 6, buf.data(), &len, nullptr, 0) < 0) {
      perror("sysctl 2 error");
      exit(5);
    }
    auto ifm = reinterpret_cast<if_msghdr*>(buf.data());
    auto sdl = reinterpret_cast<sockaddr_dl*>(ifm + 1);
    auto ptr = reinterpret_cast<unsigned char*>(LLADDR(sdl));
    auto uctoi = [](unsigned char c) -> unsigned {
      return static_cast<unsigned char>(c);
    };
    std::ostringstream oss;
    oss << std::hex;
    oss.fill('0');
    oss.width(2);
    oss << uctoi(*ptr++);
    for (auto j = 0; j < 5; ++j) {
      oss << ":";
      oss.width(2);
      oss << uctoi(*ptr++);
    }
    auto addr = oss.str();
    if (addr != "00:00:00:00:00:00") {
      result.emplace_back(i->if_name, std::move(addr));
    }
  }
  if_freenameindex(indices);
  return result;
}

} // namespace detail
} // namespace caf

#elif defined(CAF_LINUX) || defined(CAF_ANDROID) || defined(CAF_CYGWIN)

#include <vector>
#include <string>
#include <cctype>
#include <fstream>
#include <sstream>
#include <iostream>
#include <iterator>
#include <algorithm>
#include <stdio.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <net/if.h>
#include <cstring>
#include <unistd.h>
#include <iostream>

namespace caf {
namespace detail {

std::vector<iface_info> get_mac_addresses() {
  // get a socket handle
  int sck = socket(AF_INET, SOCK_DGRAM, 0);
  if (sck < 0) {
    perror("socket");
    return {};
  }
  // query available interfaces
  char buf[1024] = {0};
  ifconf ifc;
  ifc.ifc_len = sizeof(buf);
  ifc.ifc_buf = buf;
  if (ioctl(sck, SIOCGIFCONF, &ifc) < 0) {
    perror("ioctl(SIOCGIFCONF)");
    return {};
  }
  std::vector<iface_info> result;
  auto ctoi = [](char c) -> unsigned {
    return static_cast<unsigned char>(c);
  };
  // iterate through interfaces
  auto ifr = ifc.ifc_req;
  auto num_ifaces = static_cast<size_t>(ifc.ifc_len) / sizeof(ifreq);
  for (size_t i = 0; i < num_ifaces; ++i) {
    auto item = &ifr[i];
    // get mac address
    if (ioctl(sck, SIOCGIFHWADDR, item) < 0) {
      perror("ioctl(SIOCGIFHWADDR)");
      return {};
    }
    std::ostringstream oss;
    oss << std::hex;
    oss.width(2);
    oss << ctoi(item->ifr_hwaddr.sa_data[0]);
    for (size_t j = 1; j < 6; ++j) {
      oss << ":";
      oss.width(2);
      oss << ctoi(item->ifr_hwaddr.sa_data[j]);
    }
    auto addr = oss.str();
    if (addr != "00:00:00:00:00:00") {
      result.push_back({item->ifr_name, std::move(addr)});
    }
  }
  return result;
}

} // namespace detail
} // namespace caf

#else

// windows

#include <ws2tcpip.h>
#include <winsock2.h>
#include <iphlpapi.h>

#include <memory>
#include <vector>
#include <string>
#include <cctype>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <sstream>
#include <iostream>
#include <iterator>
#include <algorithm>

namespace {

constexpr size_t working_buffer_size = 15 * 1024; // 15kb by default
constexpr size_t max_iterations = 3;

struct c_free {
  template <class T>
  void operator()(T* ptr) const {
    free(ptr);
  }
};

} // namespace <anonymous>

namespace caf {
namespace detail {

std::vector<iface_info> get_mac_addresses() {
  // result vector
  std::vector<iface_info> result;
  // flags to pass to GetAdaptersAddresses
  ULONG flags = GAA_FLAG_INCLUDE_PREFIX;
  // default to unspecified address family (both)
  ULONG family = AF_UNSPEC;
  // buffer
  std::unique_ptr<IP_ADAPTER_ADDRESSES, c_free> addresses;
  // init buf size to default, adjusted by GetAdaptersAddresses if needed
  ULONG addresses_len = working_buffer_size;
  // stores result of latest system call
  DWORD res = 0;
  // break condition
  size_t iterations = 0;
  do {
    addresses.reset((IP_ADAPTER_ADDRESSES*)malloc(addresses_len));
    if (!addresses) {
      perror("Memory allocation failed for IP_ADAPTER_ADDRESSES struct");
      exit(1);
    }
    res = GetAdaptersAddresses(family, flags, nullptr, addresses.get(),
                               &addresses_len);
  } while ((res == ERROR_BUFFER_OVERFLOW) && (++iterations < max_iterations));
  if (res == NO_ERROR) {
    // read hardware addresses from the output we've received
    for (auto addr = addresses.get(); addr != nullptr; addr = addr->Next) {
      if (addr->PhysicalAddressLength > 0) {
        std::ostringstream oss;
        oss << std::hex;
        oss.width(2);
        oss << static_cast<int>(addr->PhysicalAddress[0]);
        for (DWORD i = 1; i < addr->PhysicalAddressLength; ++i) {
          oss << ":";
          oss.width(2);
          oss << static_cast<int>(addr->PhysicalAddress[i]);
        }
        auto hw_addr = oss.str();
        if (hw_addr != "00:00:00:00:00:00") {
          result.push_back({addr->AdapterName, std::move(hw_addr)});
        }
      }
    }
  } else {
    if (res == ERROR_NO_DATA) {
      perror("No addresses were found for the requested parameters");
    } else {
      perror("Call to GetAdaptersAddresses failed with error");
    }
  }
  return result;
}

} // namespace detail
} // namespace caf

#endif
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/type_erased_tuple.hpp"

#include "caf/error.hpp"
#include "caf/config.hpp"

#include "caf/detail/try_match.hpp"

namespace caf {

type_erased_tuple::~type_erased_tuple() {
  // nop
}

error type_erased_tuple::load(deserializer& source) {
  for (size_t i = 0; i < size(); ++i) {
    auto e = load(i, source);
    if (e)
      return e;
  }
  return none;
}

bool type_erased_tuple::shared() const noexcept {
  return false;
}

bool type_erased_tuple::empty() const {
  return size() == 0;
}

std::string type_erased_tuple::stringify() const {
  if (size() == 0)
    return "()";
  std::string result = "(";
  result += stringify(0);
  for (size_t i = 1; i < size(); ++i) {
    result += ", ";
    result += stringify(i);
  }
  result += ')';
  return result;
}

error type_erased_tuple::save(serializer& sink) const {
  for (size_t i = 0; i < size(); ++i) {
    auto e = save(i, sink);
    if (e)
      return e;
  }
  return none;
}

bool type_erased_tuple::matches(size_t pos, uint16_t nr,
                                const std::type_info* ptr) const noexcept {
  CAF_ASSERT(pos < size());
  auto tp = type(pos);
  if (tp.first != nr)
    return false;
  if (nr == 0)
    return ptr != nullptr ? *tp.second == *ptr : false;
  return true;
}

empty_type_erased_tuple::~empty_type_erased_tuple() {
  // nop
}

void* empty_type_erased_tuple::get_mutable(size_t) {
  CAF_RAISE_ERROR("empty_type_erased_tuple::get_mutable");
}

error empty_type_erased_tuple::load(size_t, deserializer&) {
  CAF_RAISE_ERROR("empty_type_erased_tuple::get_mutable");
}

size_t empty_type_erased_tuple::size() const noexcept {
  return 0;
}

uint32_t empty_type_erased_tuple::type_token() const noexcept {
  return make_type_token();
}

auto empty_type_erased_tuple::type(size_t) const noexcept -> rtti_pair {
  CAF_CRITICAL("empty_type_erased_tuple::type");
}

const void* empty_type_erased_tuple::get(size_t) const noexcept {
  CAF_CRITICAL("empty_type_erased_tuple::get");
}

std::string empty_type_erased_tuple::stringify(size_t) const {
  CAF_RAISE_ERROR("empty_type_erased_tuple::stringify");
}

type_erased_value_ptr empty_type_erased_tuple::copy(size_t) const {
  CAF_RAISE_ERROR("empty_type_erased_tuple::copy");
}

error empty_type_erased_tuple::save(size_t, serializer&) const {
  CAF_RAISE_ERROR("empty_type_erased_tuple::copy");
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/terminal_stream_scatterer.hpp"

#include "caf/logger.hpp"

namespace caf {

terminal_stream_scatterer::~terminal_stream_scatterer() {
  // nop
}

stream_scatterer::path_ptr
terminal_stream_scatterer::add_path(const stream_id&, strong_actor_ptr,
                                    strong_actor_ptr,
                                    mailbox_element::forwarding_stack,
                                    message_id, message, stream_priority,
                                    bool) {
  CAF_LOG_ERROR("terminal_stream_scatterer::add_path called");
  return nullptr;
}

stream_scatterer::path_ptr
terminal_stream_scatterer::confirm_path(const stream_id&, const actor_addr&,
                                        strong_actor_ptr, long, bool) {
  CAF_LOG_ERROR("terminal_stream_scatterer::confirm_path called");
  return nullptr;
}

bool terminal_stream_scatterer::remove_path(const stream_id&, const actor_addr&,
                                            error, bool) {
  CAF_LOG_ERROR("terminal_stream_scatterer::remove_path called");
  return false;
}

bool terminal_stream_scatterer::paths_clean() const {
  return true;
}

void terminal_stream_scatterer::close() {
  // nop
}

void terminal_stream_scatterer::abort(error) {
  // nop
}

long terminal_stream_scatterer::num_paths() const {
  return 0;
}

bool terminal_stream_scatterer::closed() const {
  return true;
}

bool terminal_stream_scatterer::continuous() const {
  return false;
}

void terminal_stream_scatterer::continuous(bool) {
  // nop
}

stream_scatterer::path_type* terminal_stream_scatterer::path_at(size_t) {
  return nullptr;
}

void terminal_stream_scatterer::emit_batches() {
  // nop
}

stream_scatterer::path_type*
terminal_stream_scatterer::find(const stream_id&, const actor_addr&) {
  return nullptr;
}

long terminal_stream_scatterer::credit() const {
  // TODO: do something more advanced, yes?
  return 50;
}

long terminal_stream_scatterer::buffered() const {
  return 0;
}

long terminal_stream_scatterer::min_batch_size() const {
  return 0;
}

long terminal_stream_scatterer::max_batch_size() const {
  return 0;
}

long terminal_stream_scatterer::min_buffer_size() const {
  return 0;
}

duration terminal_stream_scatterer::max_batch_delay() const {
  return infinite;
}

void terminal_stream_scatterer::min_batch_size(long) {
  // nop
}

void terminal_stream_scatterer::max_batch_size(long) {
  // nop
}

void terminal_stream_scatterer::min_buffer_size(long) {
  // nop
}

void terminal_stream_scatterer::max_batch_delay(duration) {
  // nop
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/detail/merged_tuple.hpp"

#include "caf/index_mapping.hpp"
#include "caf/system_messages.hpp"

#include "caf/detail/disposer.hpp"

namespace caf {
namespace detail {

merged_tuple::cow_ptr merged_tuple::make(message x, message y) {
  data_type data{x.vals(), y.vals()};
  mapping_type mapping;
  auto s = x.size();
  for (size_t i = 0; i < s; ++i) {
    if (x.match_element<index_mapping>(i))
      mapping.emplace_back(1, x.get_as<index_mapping>(i).value - 1);
    else
      mapping.emplace_back(0, i);
  }
  return cow_ptr{make_counted<merged_tuple>(std::move(data),
                                            std::move(mapping))};
}

merged_tuple::merged_tuple(data_type xs, mapping_type ys)
    : data_(std::move(xs)),
      type_token_(0xFFFFFFFF),
      mapping_(std::move(ys)) {
  CAF_ASSERT(!data_.empty());
  CAF_ASSERT(!mapping_.empty());
  // calculate type token
  for (auto& p : mapping_) {
    type_token_ <<= 6;
    type_token_ |= data_[p.first]->type_nr(p.second);
  }
}

merged_tuple::cow_ptr merged_tuple::copy() const {
  return cow_ptr{make_counted<merged_tuple>(data_, mapping_)};
}

void* merged_tuple::get_mutable(size_t pos) {
  CAF_ASSERT(pos < mapping_.size());
  auto& p = mapping_[pos];
  return data_[p.first]->get_mutable(p.second);
}

error merged_tuple::load(size_t pos, deserializer& source) {
  CAF_ASSERT(pos < mapping_.size());
  auto& p = mapping_[pos];
  return data_[p.first]->load(p.second, source);
}

size_t merged_tuple::size() const noexcept {
  return mapping_.size();
}

uint32_t merged_tuple::type_token() const noexcept {
  return type_token_;
}

merged_tuple::rtti_pair merged_tuple::type(size_t pos) const noexcept {
  CAF_ASSERT(pos < mapping_.size());
  auto& p = mapping_[pos];
  return data_[p.first]->type(p.second);
}

const void* merged_tuple::get(size_t pos) const noexcept {
  CAF_ASSERT(pos < mapping_.size());
  auto& p = mapping_[pos];
  return data_[p.first]->get(p.second);
}

std::string merged_tuple::stringify(size_t pos) const {
  CAF_ASSERT(pos < mapping_.size());
  auto& p = mapping_[pos];
  return data_[p.first]->stringify(p.second);
}

type_erased_value_ptr merged_tuple::copy(size_t pos) const {
  CAF_ASSERT(pos < mapping_.size());
  auto& p = mapping_[pos];
  return data_[p.first]->copy(p.second);
}

error merged_tuple::save(size_t pos, serializer& sink) const {
  CAF_ASSERT(pos < mapping_.size());
  auto& p = mapping_[pos];
  return data_[p.first]->save(p.second, sink);
}

const merged_tuple::mapping_type& merged_tuple::mapping() const {
  return mapping_;
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/detail/test_actor_clock.hpp"

namespace caf {
namespace detail {

test_actor_clock::time_point test_actor_clock::now() const noexcept {
  return current_time;
}

bool test_actor_clock::dispatch_once() {
  if (schedule_.empty())
    return false;
  visitor f{this};
  auto i = schedule_.begin();
  visit(f, i->second);
  schedule_.erase(i);
  return true;
}

size_t test_actor_clock::dispatch() {
  if (schedule_.empty())
    return 0u;
  visitor f{this};
  auto result = schedule_.size();
  for (auto& kvp : schedule_)
    visit(f, kvp.second);
  schedule_.clear();
  return result;
}

void test_actor_clock::advance_time(duration_type x) {
  visitor f{this};
  current_time += x;
  auto i = schedule_.begin();
  while (i != schedule_.end() && i->first <= current_time) {
    visit(f, i->second);
    i = schedule_.erase(i);
  }
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/logger.hpp"

#include <ctime>
#include <thread>
#include <cstring>
#include <iomanip>
#include <fstream>
#include <algorithm>
#include <condition_variable>

#include "caf/config.hpp"

#include "caf/term.hpp"
#include "caf/locks.hpp"
#include "caf/timestamp.hpp"
#include "caf/actor_proxy.hpp"
#include "caf/actor_system.hpp"
#include "caf/string_algorithms.hpp"
#include "caf/actor_system_config.hpp"

#include "caf/detail/get_process_id.hpp"
#include "caf/detail/pretty_type_name.hpp"
#include "caf/detail/single_reader_queue.hpp"

namespace caf {

namespace {

constexpr const char* log_level_name[] = {
  "ERROR",
  "WARN",
  "INFO",
  "DEBUG",
  "TRACE"
};

#ifdef CAF_LOG_LEVEL

static_assert(CAF_LOG_LEVEL >= 0 && CAF_LOG_LEVEL <= 4,
              "assertion: 0 <= CAF_LOG_LEVEL <= 4");

#if defined(CAF_NO_THREAD_LOCAL)

pthread_key_t s_key;
pthread_once_t s_key_once = PTHREAD_ONCE_INIT;

void logger_ptr_destructor(void* ptr) {
  if (ptr != nullptr) {
    intrusive_ptr_release(reinterpret_cast<logger*>(ptr));
  }
}

void make_logger_ptr() {
  pthread_key_create(&s_key, logger_ptr_destructor);
}

void set_current_logger(logger* x) {
  pthread_once(&s_key_once, make_logger_ptr);
  logger_ptr_destructor(pthread_getspecific(s_key));
  if (x != nullptr)
    intrusive_ptr_add_ref(x);
  pthread_setspecific(s_key, x);
}

logger* get_current_logger() {
  pthread_once(&s_key_once, make_logger_ptr);
  return reinterpret_cast<logger*>(pthread_getspecific(s_key));
}

#else // !CAF_NO_THREAD_LOCAL

thread_local intrusive_ptr<logger> current_logger;

inline void set_current_logger(logger* x) {
  current_logger.reset(x);
}

inline logger* get_current_logger() {
  return current_logger.get();
}

#endif // CAF_NO_THREAD_LOCAL

#else // CAF_LOG_LEVEL

inline void set_current_logger(logger*) {
  // nop
}

inline logger* get_current_logger() {
  return nullptr;
}
#endif // CAF_LOG_LEVEL

} // namespace <anonymous>

logger::line_builder::line_builder() : behind_arg_(false) {
  // nop
}

logger::line_builder& logger::line_builder::operator<<(const std::string& str) {
  if (!str_.empty())
    str_ += " ";
  str_ += str;
  behind_arg_ = false;
  return *this;
}

logger::line_builder& logger::line_builder::operator<<(const char* str) {
  if (!str_.empty())
    str_ += " ";
  str_ += str;
  behind_arg_ = false;
  return *this;
}

std::string logger::line_builder::get() const {
  return std::move(str_);
}

// returns the actor ID for the current thread
actor_id logger::thread_local_aid() {
  shared_lock<detail::shared_spinlock> guard{aids_lock_};
  auto i = aids_.find(std::this_thread::get_id());
  if (i != aids_.end())
    return i->second;
  return 0;
}

actor_id logger::thread_local_aid(actor_id aid) {
  auto tid = std::this_thread::get_id();
  upgrade_lock<detail::shared_spinlock> guard{aids_lock_};
  auto i = aids_.find(tid);
  if (i != aids_.end()) {
    // we modify it despite the shared lock because the elements themselves
    // are considered thread-local
    auto res = i->second;
    i->second = aid;
    return res;
  }
  // upgrade to unique lock and insert new element
  upgrade_to_unique_lock<detail::shared_spinlock> uguard{guard};
  aids_.emplace(tid, aid);
  return 0; // was empty before
}

void logger::log(event* x) {
  CAF_ASSERT(x->level >= 0 && x->level <= 4);
  if (!inline_output_) {
    queue_.synchronized_enqueue(queue_mtx_, queue_cv_,x);
  } else {
    std::unique_ptr<event> ptr{x};
    handle_event(*ptr);
  }
}

void logger::set_current_actor_system(actor_system* x) {
  if (x != nullptr)
    set_current_logger(&x->logger());
  else
    set_current_logger(nullptr);
}

logger* logger::current_logger() {
  return get_current_logger();
}

bool logger::accepts(int level, const char* cname_begin,
                     const char* cname_end) {
  CAF_ASSERT(cname_begin != nullptr && cname_end != nullptr);
  CAF_ASSERT(level >= 0 && level <= 4);
  if (level > level_)
    return false;
  auto& filter = system_.config().logger_component_filter;
  if (!filter.empty()) {
    auto it = std::search(filter.begin(), filter.end(), cname_begin, cname_end);
    return it != filter.end();
  }
  return true;
}

logger::~logger() {
  stop();
  // tell system our dtor is done
  std::unique_lock<std::mutex> guard{system_.logger_dtor_mtx_};
  system_.logger_dtor_done_ = true;
  system_.logger_dtor_cv_.notify_one();
}

logger::logger(actor_system& sys) : system_(sys), inline_output_(false) {
  // nop
}

void logger::init(actor_system_config& cfg) {
  CAF_IGNORE_UNUSED(cfg);
#if defined(CAF_LOG_LEVEL)
  inline_output_ = cfg.logger_inline_output;
  // Parse the configured log level.
  switch (static_cast<uint64_t>(cfg.logger_verbosity)) {
    case atom_uint("quiet"):
    case atom_uint("QUIET"):
      level_ = CAF_LOG_LEVEL_QUIET;
      break;
    case atom_uint("error"):
    case atom_uint("ERROR"):
      level_ = CAF_LOG_LEVEL_ERROR;
      break;
    case atom_uint("warning"):
    case atom_uint("WARNING"):
      level_ = CAF_LOG_LEVEL_WARNING;
      break;
    case atom_uint("info"):
    case atom_uint("INFO"):
      level_ = CAF_LOG_LEVEL_INFO;
      break;
    case atom_uint("debug"):
    case atom_uint("DEBUG"):
      level_ = CAF_LOG_LEVEL_DEBUG;
      break;
    case atom_uint("trace"):
    case atom_uint("TRACE"):
      level_ = CAF_LOG_LEVEL_TRACE;
      break;
    default: {
      level_ = CAF_LOG_LEVEL;
    }
  }
  // Parse the format string.
  file_format_ = parse_format(cfg.logger_file_format.c_str());
  console_format_ = parse_format(cfg.logger_console_format.c_str());
#endif
}

void logger::render_fun_prefix(std::ostream& out, const char* pretty_fun) {
  auto first = pretty_fun;
  // set end to beginning of arguments
  const char* last = strchr(pretty_fun, '(');
  if (last == nullptr)
    return;
  auto strsize = static_cast<size_t>(last - first);
  auto jump_to_next_whitespace = [&] {
    // leave `first` unchanged if no whitespaces is present,
    // e.g., in constructor signatures
    auto tmp = std::find(first, last, ' ');
    if (tmp != last)
      first = tmp + 1;
  };
  // skip "virtual" prefix if present
  if (strncmp(pretty_fun, "virtual ", std::min<size_t>(strsize, 8)) == 0)
    jump_to_next_whitespace();
  // skip return type
  jump_to_next_whitespace();
  if (first == last)
    return;
  const char sep[] = "::"; // separator for namespaces and classes
  auto sep_first = std::begin(sep);
  auto sep_last = sep_first + 2; // using end() includes \0
  auto colons = first;
  decltype(colons) nextcs;
  while ((nextcs = std::search(colons + 1, last, sep_first, sep_last)) != last)
    colons = nextcs;
  std::string result;
  result.assign(first, colons);
  detail::prettify_type_name(result);
  out << result;
}

void logger::render_fun_name(std::ostream& out, const char* pretty_fun) {
  // Find the end of the function name by looking for the opening parenthesis
  // trailing it.
  CAF_ASSERT(pretty_fun != nullptr);
  const char* e = strchr(pretty_fun, '(');
  if (e == nullptr)
    return;
  /// Now look for the beginning of the function name.
  using rev_iter = std::reverse_iterator<const char*>;
  auto b = std::find_if(rev_iter(e), rev_iter(pretty_fun),
                        [](char x) { return x == ':' || x == ' '; });
  out.write(b.base(), e - b.base());
}

void logger::render_time_diff(std::ostream& out, timestamp t0, timestamp tn) {
  out << std::chrono::duration_cast<std::chrono::milliseconds>(tn - t0).count();
}

void logger::render_date(std::ostream& out, timestamp x) {
  auto y = std::chrono::time_point_cast<timestamp::clock::duration>(x);
  auto z = timestamp::clock::to_time_t(y);
  // strftime workaround: std::put_time not available on GCC 4.8
  // out << std::put_time(std::localtime(&z), "%F %T");
  char buf[50];
  if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", std::localtime(&z)))
    out << buf;
}

void logger::render(std::ostream& out, const line_format& lf,
                    const event& x) const {
  for (auto& f : lf)
    switch (f.kind) {
      case category_field: out << x.category_name; break;
      case class_name_field: render_fun_prefix(out, x.pretty_fun); break;
      case date_field: render_date(out, x.tstamp); break;
      case file_field: out << x.file_name; break;
      case line_field: out << x.line_number; break;
      case message_field: out << x.message; break;
      case method_field: render_fun_name(out, x.pretty_fun); break;
      case newline_field: out << std::endl; break;
      case priority_field: out << log_level_name[x.level]; break;
      case runtime_field: render_time_diff(out, t0_, x.tstamp); break;
      case thread_field: out << x.tid; break;
      case actor_field: out << "actor" << x.aid; break;
      case percent_sign_field: out << '%'; break;
      case plain_text_field: out.write(f.first, f.last - f.first); break;
      default: ; // nop
    }
}

logger::line_format logger::parse_format(const char* format_str) {
  std::vector<field> res;
  auto i = format_str;
  auto plain_text_first = i;
  bool read_percent_sign = false;
  for (; *i != '\0'; ++i) {
    if (read_percent_sign) {
      field_type ft;
      switch (*i) {
        case 'c': ft = category_field; break;
        case 'C': ft = class_name_field; break;
        case 'd': ft = date_field; break;
        case 'F': ft =  file_field; break;
        case 'L': ft = line_field; break;
        case 'm': ft = message_field; break;
        case 'M': ft = method_field; break;
        case 'n': ft = newline_field; break;
        case 'p': ft = priority_field; break;
        case 'r': ft = runtime_field; break;
        case 't': ft = thread_field; break;
        case 'a': ft = actor_field; break;
        case '%': ft = percent_sign_field; break;
        default:
          ft = invalid_field;
          std::cerr << "invalid field specifier in format string: "
                    << *i << std::endl;
      }
      if (ft != invalid_field)
        res.emplace_back(field{ft, nullptr, nullptr});
      plain_text_first = i + 1;
      read_percent_sign = false;
    } else {
      if (*i == '%') {
        if (plain_text_first != i)
          res.emplace_back(field{plain_text_field, plain_text_first, i});
        read_percent_sign = true;
      }
    }
  }
  if (plain_text_first != i)
    res.emplace_back(field{plain_text_field, plain_text_first, i});
  return res;
}

void logger::run() {
#if defined(CAF_LOG_LEVEL)
  log_first_line();
  // receive log entries from other threads and actors
  std::unique_ptr<event> ptr;
  for (;;) {
    // make sure we have data to read
    queue_.synchronized_await(queue_mtx_, queue_cv_);
    // read & process event
    ptr.reset(queue_.try_pop());
    CAF_ASSERT(ptr != nullptr);
    // empty message means: shut down
    if (ptr->message.empty())
      break;
    handle_event(*ptr);
  }
  log_last_line();
#endif
}

void logger::handle_event(event& x) {
  if (file_)
    render(file_, file_format_, x);
  if (system_.config().logger_console == atom("UNCOLORED")) {
    render(std::clog, console_format_, x);
  } else if  (system_.config().logger_console == atom("COLORED")) {
    switch (x.level) {
      default:
        break;
      case CAF_LOG_LEVEL_ERROR:
        std::clog << term::red;
        break;
      case CAF_LOG_LEVEL_WARNING:
        std::clog << term::yellow;
        break;
      case CAF_LOG_LEVEL_INFO:
        std::clog << term::green;
        break;
      case CAF_LOG_LEVEL_DEBUG:
        std::clog << term::cyan;
        break;
      case CAF_LOG_LEVEL_TRACE:
        std::clog << term::blue;
        break;
    }
    render(std::clog, console_format_, x);
    std::clog << term::reset_endl;
  }
}

void logger::log_first_line() {
  std::string msg = "level = ";
  msg += to_string(system_.config().logger_verbosity);
  msg += ", node = ";
  msg += to_string(system_.node());
  event tmp{nullptr,
            nullptr,
            CAF_LOG_LEVEL_INFO,
            CAF_LOG_COMPONENT,
            CAF_PRETTY_FUN,
            __FILE__,
            __LINE__,
            std::move(msg),
            std::this_thread::get_id(),
            0,
            make_timestamp()};
  handle_event(tmp);
}

void logger::log_last_line() {
  event tmp{nullptr,
            nullptr,
            CAF_LOG_LEVEL_INFO,
            CAF_LOG_COMPONENT,
            CAF_PRETTY_FUN,
            __FILE__,
            __LINE__,
            "EOF",
            std::this_thread::get_id(),
            0,
            make_timestamp()};
  handle_event(tmp);
}

void logger::start() {
#if defined(CAF_LOG_LEVEL)
  parent_thread_ = std::this_thread::get_id();
  auto verbosity = system_.config().logger_verbosity;
  if (verbosity == atom("quiet") || verbosity == atom("QUIET"))
    return;
  t0_ = make_timestamp();
  if (system_.config().logger_file_name.empty()) {
    // No need to continue if console and log file are disabled.
    if (!(system_.config().logger_console == atom("UNCOLORED")
          || system_.config().logger_console == atom("COLORED")))
      return;
  } else {
    auto f = system_.config().logger_file_name;
    // Replace placeholders.
    const char pid[] = "[PID]";
    auto i = std::search(f.begin(), f.end(), std::begin(pid),
                         std::end(pid) - 1);
    if (i != f.end()) {
      auto id = std::to_string(detail::get_process_id());
      f.replace(i, i + sizeof(pid) - 1, id);
    }
    const char ts[] = "[TIMESTAMP]";
    i = std::search(f.begin(), f.end(), std::begin(ts), std::end(ts) - 1);
    if (i != f.end()) {
      auto t0_str = timestamp_to_string(t0_);
      f.replace(i, i + sizeof(ts) - 1, t0_str);
    }
    const char node[] = "[NODE]";
    i = std::search(f.begin(), f.end(), std::begin(node), std::end(node) - 1);
    if (i != f.end()) {
      auto nid = to_string(system_.node());
      f.replace(i, i + sizeof(node) - 1, nid);
    }
    file_.open(f, std::ios::out | std::ios::app);
    if (!file_) {
      std::cerr << "unable to open log file " << f << std::endl;
      return;
    }
  }
  if (inline_output_)
    log_first_line();
  else
    thread_ = std::thread{[this] {
      this->system_.thread_started();
      this->run();
      this->system_.thread_terminates();
    }};
#endif
}

void logger::stop() {
#if defined(CAF_LOG_LEVEL)
  if (inline_output_) {
    log_last_line();
    return;
  }
  if (!thread_.joinable())
    return;
  // an empty string means: shut down
  queue_.synchronized_enqueue(queue_mtx_, queue_cv_, new event);
  thread_.join();
#endif
}

std::string to_string(logger::field_type x) {
  static constexpr const char* names[] = {
    "invalid", "category", "class_name", "date",         "file",
    "line",    "message",  "method",     "newline",      "priority",
    "runtime", "thread",   "actor",      "percent_sign", "plain_text"};
  return names[static_cast<size_t>(x)];
}

std::string to_string(const logger::field& x) {
  std::string result = "field{";
  result += to_string(x.kind);
  if (x.first != nullptr) {
    result += ", \"";
    result.insert(result.end(), x.first, x.last);
    result += '\"';
  }
  result += "}";
  return result;
}

bool operator==(const logger::field& x, const logger::field& y) {
  if (x.kind == y.kind) {
    if (x.kind == logger::plain_text_field)
      return std::distance(x.first, x.last) == std::distance(y.first, y.last)
             && std::equal(x.first, x.last, y.first);
    return true;
  }
  return false;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/actor_control_block.hpp"

#include "caf/to_string.hpp"




#include "caf/message.hpp"
#include "caf/actor_system.hpp"
#include "caf/proxy_registry.hpp"
#include "caf/abstract_actor.hpp"
#include "caf/mailbox_element.hpp"

#include "caf/detail/disposer.hpp"

namespace caf {

actor_addr actor_control_block::address() {
  return {this, true};
}

void actor_control_block::enqueue(strong_actor_ptr sender, message_id mid,
                                  message content, execution_unit* host) {
  get()->enqueue(std::move(sender), mid, std::move(content), host);
}

void actor_control_block::enqueue(mailbox_element_ptr what,
                                  execution_unit* host) {
  get()->enqueue(std::move(what), host);
}

bool intrusive_ptr_upgrade_weak(actor_control_block* x) {
  auto count = x->strong_refs.load();
  while (count != 0)
    if (x->strong_refs.compare_exchange_weak(count, count + 1,
                                             std::memory_order_relaxed))
      return true;
  return false;
}

void intrusive_ptr_release_weak(actor_control_block* x) {
  // destroy object if last weak pointer expires
  if (x->weak_refs == 1
      || x->weak_refs.fetch_sub(1, std::memory_order_acq_rel) == 1)
    x->block_dtor(x);
}

void intrusive_ptr_release(actor_control_block* x) {
  // release implicit weak pointer if the last strong ref expires
  // and destroy the data block
  if (x->strong_refs.fetch_sub(1, std::memory_order_acq_rel) == 1) {
    x->data_dtor(x->get());
    intrusive_ptr_release_weak(x);
  }
}

bool operator==(const strong_actor_ptr& x, const abstract_actor* y) {
  return x.get() == actor_control_block::from(y);
}

bool operator==(const abstract_actor* x, const strong_actor_ptr& y) {
  return actor_control_block::from(x) == y.get();
}

error load_actor(strong_actor_ptr& storage, execution_unit* ctx,
                 actor_id aid, const node_id& nid) {
  if (ctx == nullptr)
    return sec::no_context;
  auto& sys = ctx->system();
  if (sys.node() == nid) {
    storage = sys.registry().get(aid);
    CAF_LOG_DEBUG("fetch actor handle from local actor registry: "
                  << (storage ? "found" : "not found"));
    return none;
  }
  auto prp = ctx->proxy_registry_ptr();
  if (prp == nullptr)
    return sec::no_proxy_registry;
  // deal with (proxies for) remote actors
  storage = prp->get_or_put(nid, aid);
  return none;
}

error save_actor(strong_actor_ptr& storage, execution_unit* ctx,
                 actor_id aid, const node_id& nid) {
  if (ctx == nullptr)
    return sec::no_context;
  auto& sys = ctx->system();
  // register locally running actors to be able to deserialize them later
  if (nid == sys.node())
    sys.registry().put(aid, storage);
  return none;
}

namespace {

void append_to_string_impl(std::string& x, const actor_control_block* y) {
  if (y != nullptr) {
    x += std::to_string(y->aid);
    x += '@';
    append_to_string(x, y->nid);
  } else {
    x += "0@invalid-node";
  }
}

std::string to_string_impl(const actor_control_block* x) {
  std::string result;
  append_to_string_impl(result, x);
  return result;
}

} // namespace <anonymous>

std::string to_string(const strong_actor_ptr& x) {
  return to_string_impl(x.get());
}

void append_to_string(std::string& x, const strong_actor_ptr& y) {
  return append_to_string_impl(x, y.get());
}

std::string to_string(const weak_actor_ptr& x) {
  return to_string_impl(x.get());
}

void append_to_string(std::string& x, const weak_actor_ptr& y) {
  return append_to_string_impl(x, y.get());
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <iterator>

#include "caf/none.hpp"
#include "caf/local_actor.hpp"
#include "caf/detail/behavior_stack.hpp"

namespace caf {
namespace detail {

void behavior_stack::pop_back() {
  CAF_ASSERT(!elements_.empty());
  erased_elements_.push_back(std::move(elements_.back()));
  elements_.pop_back();
}

void behavior_stack::clear() {
  if (!elements_.empty()) {
    if (erased_elements_.empty()) {
      elements_.swap(erased_elements_);
    } else {
      std::move(elements_.begin(), elements_.end(),
                std::back_inserter(erased_elements_));
      elements_.clear();
    }
  }
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/scheduler/abstract_coordinator.hpp"

#include <ios>
#include <thread>
#include <atomic>
#include <chrono>
#include <fstream>
#include <iostream>
#include <unordered_map>
#include <condition_variable>

#include "caf/send.hpp"
#include "caf/after.hpp"
#include "caf/others.hpp"
#include "caf/duration.hpp"
#include "caf/actor_system.hpp"
#include "caf/scoped_actor.hpp"
#include "caf/actor_ostream.hpp"
#include "caf/system_messages.hpp"
#include "caf/scheduled_actor.hpp"
#include "caf/actor_system_config.hpp"

#include "caf/scheduler/coordinator.hpp"

#include "caf/policy/work_stealing.hpp"

#include "caf/logger.hpp"

namespace caf {
namespace scheduler {

/******************************************************************************
 *                     utility and implementation details                     *
 ******************************************************************************/

namespace {

using string_sink = std::function<void (std::string&&)>;

// the first value is the use count, the last ostream_handle that
// decrements it to 0 removes the ostream pointer from the map
using counted_sink = std::pair<size_t, string_sink>;

using sink_cache = std::map<std::string, counted_sink>;

class sink_handle {
public:
  using iterator = sink_cache::iterator;

  sink_handle() : cache_(nullptr) {
    // nop
  }

  sink_handle(sink_cache* fc, iterator iter) : cache_(fc), iter_(iter) {
    if (cache_ != nullptr)
      ++iter_->second.first;
  }

  sink_handle(const sink_handle& other) : cache_(nullptr) {
    *this = other;
  }

  sink_handle& operator=(const sink_handle& other) {
    if (cache_ != other.cache_ || iter_ != other.iter_) {
      clear();
      cache_ = other.cache_;
      if (cache_ != nullptr) {
        iter_ = other.iter_;
        ++iter_->second.first;
      }
    }
    return *this;
  }

  ~sink_handle() {
    clear();
  }

  explicit operator bool() const {
    return cache_ != nullptr;
  }

  string_sink& operator*() {
    CAF_ASSERT(iter_->second.second != nullptr);
    return iter_->second.second;
  }

private:
  void clear() {
    if (cache_ != nullptr && --iter_->second.first == 0) {
      cache_->erase(iter_);
      cache_ = nullptr;
    }
  }

  sink_cache* cache_;
  sink_cache::iterator iter_;
};

string_sink make_sink(actor_system& sys, const std::string& fn, int flags) {
  if (fn.empty())
    return nullptr;
  if (fn.front() == ':') {
    // "virtual file" name given, translate this to group communication
    auto grp = sys.groups().get_local(fn);
    return [grp, fn](std::string&& out) { anon_send(grp, fn, std::move(out)); };
  }
  auto append = (flags & actor_ostream::append) != 0;
  auto fs = std::make_shared<std::ofstream>();
  fs->open(fn, append ? std::ios_base::out | std::ios_base::app
                      : std::ios_base::out);
  if (fs->is_open())
    return [fs](std::string&& out) { *fs << out; };
std::cerr << "cannot open file: " << fn << std::endl;
  return nullptr;
}

sink_handle get_sink_handle(actor_system& sys, sink_cache& fc,
                            const std::string& fn, int flags) {
  auto i = fc.find(fn);
  if (i != fc.end())
    return {&fc, i};
  auto fs = make_sink(sys, fn, flags);
  if (fs) {
    i = fc.emplace(fn, sink_cache::mapped_type{0, std::move(fs)}).first;
    return {&fc, i};
  }
  return {};
}

class printer_actor : public blocking_actor {
public:
  printer_actor(actor_config& cfg) : blocking_actor(cfg) {
    // nop
  }

  void act() override {
    struct actor_data {
      std::string current_line;
      sink_handle redirect;
      actor_data() {
        // nop
      }
    };
    using data_map = std::unordered_map<actor_id, actor_data>;
    sink_cache fcache;
    sink_handle global_redirect;
    data_map data;
    auto get_data = [&](actor_id addr, bool insert_missing) -> actor_data* {
      if (addr == invalid_actor_id)
        return nullptr;
      auto i = data.find(addr);
      if (i == data.end() && insert_missing)
        i = data.emplace(addr, actor_data{}).first;
      if (i != data.end())
        return &(i->second);
      return nullptr;
    };
    auto flush = [&](actor_data* what, bool forced) {
      if (what == nullptr)
        return;
      auto& line = what->current_line;
      if (line.empty() || (line.back() != '\n' && !forced))
        return;
      if (what->redirect)
        (*what->redirect)(std::move(line));
      else if (global_redirect)
        (*global_redirect)(std::move(line));
      else
        std::cout << line << std::flush;
      line.clear();
    };
    bool done = false;
    do_receive(
      [&](add_atom, actor_id aid, std::string& str) {
        if (str.empty() || aid == invalid_actor_id)
          return;
        auto d = get_data(aid, true);
        if (d != nullptr) {
          d->current_line += str;
          flush(d, false);
        }
      },
      [&](flush_atom, actor_id aid) {
        flush(get_data(aid, false), true);
      },
      [&](delete_atom, actor_id aid) {
        auto data_ptr = get_data(aid, false);
        if (data_ptr != nullptr) {
          flush(data_ptr, true);
          data.erase(aid);
        }
      },
      [&](redirect_atom, const std::string& fn, int flag) {
        global_redirect = get_sink_handle(system(), fcache, fn, flag);
      },
      [&](redirect_atom, actor_id aid, const std::string& fn, int flag) {
        auto d = get_data(aid, true);
        if (d != nullptr)
          d->redirect = get_sink_handle(system(), fcache, fn, flag);
      },
      [&](exit_msg& em) {
        fail_state(std::move(em.reason));
        done = true;
      }
    ).until([&] { return done; });
  }

  const char* name() const override {
    return "printer_actor";
  }
};

} // namespace <anonymous>

/******************************************************************************
 *                       implementation of coordinator                        *
 ******************************************************************************/

bool abstract_coordinator::detaches_utility_actors() const {
  return true;
}

void abstract_coordinator::start() {
  CAF_LOG_TRACE("");
  // launch utility actors
  static constexpr auto fs = hidden + detached;
  utility_actors_[printer_id] = system_.spawn<printer_actor, fs>();
}

void abstract_coordinator::init(actor_system_config& cfg) {
  max_throughput_ = cfg.scheduler_max_throughput;
  num_workers_ = cfg.scheduler_max_threads;
}

actor_system::module::id_t abstract_coordinator::id() const {
  return module::scheduler;
}

void* abstract_coordinator::subtype_ptr() {
  return this;
}

void abstract_coordinator::stop_actors() {
  CAF_LOG_TRACE("");
  scoped_actor self{system_, true};
  for (auto& x : utility_actors_)
    anon_send_exit(x, exit_reason::user_shutdown);
  self->wait_for(utility_actors_);
}

abstract_coordinator::abstract_coordinator(actor_system& sys)
    : next_worker_(0),
      max_throughput_(0),
      num_workers_(0),
      system_(sys) {
  // nop
}

void abstract_coordinator::cleanup_and_release(resumable* ptr) {
  class dummy_unit : public execution_unit {
  public:
    dummy_unit(local_actor* job) : execution_unit(&job->home_system()) {
      // nop
    }
    void exec_later(resumable* job) override {
      resumables.push_back(job);
    }
    std::vector<resumable*> resumables;
  };
  switch (ptr->subtype()) {
    case resumable::scheduled_actor:
    case resumable::io_actor: {
      auto dptr = static_cast<scheduled_actor*>(ptr);
      dummy_unit dummy{dptr};
      dptr->cleanup(make_error(exit_reason::user_shutdown), &dummy);
      while (!dummy.resumables.empty()) {
        auto sub = dummy.resumables.back();
        dummy.resumables.pop_back();
        switch (sub->subtype()) {
          case resumable::scheduled_actor:
          case resumable::io_actor: {
            auto dsub = static_cast<scheduled_actor*>(sub);
            dsub->cleanup(make_error(exit_reason::user_shutdown), &dummy);
            break;
          }
          default:
            break;
        }
      }
      break;
    }
    default:
      break;
  }
  intrusive_ptr_release(ptr);
}

} // namespace scheduler
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/abstract_channel.hpp"

#include "caf/actor_system.hpp"
#include "caf/mailbox_element.hpp"

namespace caf {

abstract_channel::abstract_channel(int fs) : flags_(fs) {
  // nop
}

abstract_channel::~abstract_channel() {
  // nop
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/group.hpp"

#include "caf/message.hpp"
#include "caf/actor_cast.hpp"
#include "caf/actor_system.hpp"
#include "caf/group_manager.hpp"

namespace caf {

group::group(abstract_group* ptr) : ptr_(ptr) {
  // nop
}

group::group(abstract_group* ptr, bool add_ref) : ptr_(ptr, add_ref) {
  // nop
}

group::group(const invalid_group_t&) : ptr_(nullptr) {
  // nop
}

group::group(abstract_group_ptr gptr) : ptr_(std::move(gptr)) {
  // nop
}

group& group::operator=(const invalid_group_t&) {
  ptr_.reset();
  return *this;
}

intptr_t group::compare(const abstract_group* lhs, const abstract_group* rhs) {
  return reinterpret_cast<intptr_t>(lhs) - reinterpret_cast<intptr_t>(rhs);
}

intptr_t group::compare(const group& other) const noexcept {
  return compare(ptr_.get(), other.ptr_.get());
}

error inspect(serializer& f, group& x) {
  std::string mod_name;
  auto ptr = x.get();
  if (ptr == nullptr)
    return f(mod_name);
  mod_name = ptr->module().name();
  auto e = f(mod_name);
  return e ? e : ptr->save(f);
}

error inspect(deserializer& f, group& x) {
  std::string module_name;
  f(module_name);
  if (module_name.empty()) {
    x = invalid_group;
    return none;
  }
  if (f.context() == nullptr)
    return sec::no_context;
  auto& sys = f.context()->system();
  auto mod = sys.groups().get_module(module_name);
  if (!mod)
    return sec::no_such_group_module;
  return mod->load(f, x);
}

std::string to_string(const group& x) {
  if (x == invalid_group)
    return "<invalid-group>";
  std::string result = x.get()->module().name();
  result += ":";
  result += x.get()->identifier();
  return result;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <utility>

#include "caf/forwarding_actor_proxy.hpp"

#include "caf/send.hpp"
#include "caf/locks.hpp"
#include "caf/logger.hpp"
#include "caf/stream_msg.hpp"
#include "caf/mailbox_element.hpp"

namespace caf {

forwarding_actor_proxy::forwarding_actor_proxy(actor_config& cfg, actor dest)
    : actor_proxy(cfg),
      broker_(std::move(dest)) {
  // nop
}

forwarding_actor_proxy::~forwarding_actor_proxy() {
  anon_send(broker_, make_message(delete_atom::value, node(), id()));
}

void forwarding_actor_proxy::forward_msg(strong_actor_ptr sender,
                                         message_id mid, message msg,
                                         const forwarding_stack* fwd) {
  CAF_LOG_TRACE(CAF_ARG(id()) << CAF_ARG(sender)
                << CAF_ARG(mid) << CAF_ARG(msg));
  if (msg.match_elements<exit_msg>())
    unlink_from(msg.get_as<exit_msg>(0).source);
  forwarding_stack tmp;
  shared_lock<detail::shared_spinlock> guard(mtx_);
  if (broker_)
    broker_->enqueue(nullptr, invalid_message_id,
                     make_message(forward_atom::value, std::move(sender),
                                  fwd != nullptr ? *fwd : tmp,
                                  strong_actor_ptr{ctrl()}, mid,
                                  std::move(msg)),
                     nullptr);
}

void forwarding_actor_proxy::enqueue(mailbox_element_ptr what,
                                     execution_unit*) {
  CAF_PUSH_AID(0);
  CAF_ASSERT(what);
  forward_msg(std::move(what->sender), what->mid,
              what->move_content_to_message(), &what->stages);
}

bool forwarding_actor_proxy::add_backlink(abstract_actor* x) {
  if (monitorable_actor::add_backlink(x)) {
    forward_msg(ctrl(), invalid_message_id,
                make_message(link_atom::value, x->ctrl()));
    return true;
  }
  return false;
}

bool forwarding_actor_proxy::remove_backlink(abstract_actor* x) {
  if (monitorable_actor::remove_backlink(x)) {
    forward_msg(ctrl(), invalid_message_id,
                make_message(unlink_atom::value, x->ctrl()));
    return true;
  }
  return false;
}

void forwarding_actor_proxy::kill_proxy(execution_unit* ctx, error rsn) {
  CAF_ASSERT(ctx != nullptr);
  actor tmp;
  { // lifetime scope of guard
    std::unique_lock<detail::shared_spinlock> guard(mtx_);
    broker_.swap(tmp); // manually break cycle
  }
  cleanup(std::move(rsn), ctx);
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/attachable.hpp"

namespace caf {

attachable::~attachable() {
  // Avoid recursive cleanup of next pointers because this can cause a stack
  // overflow for long linked lists.
  using std::swap;
  while (next != nullptr) {
    attachable_ptr tmp;
    swap(next->next, tmp);
    swap(next, tmp);
  }
}

attachable::token::token(size_t typenr, const void* vptr)
    : subtype(typenr), ptr(vptr) {
  // nop
}

void attachable::actor_exited(const error&, execution_unit*) {
  // nop
}

bool attachable::matches(const token&) {
  return false;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/scoped_execution_unit.hpp"

#include "caf/actor_system.hpp"
#include "caf/scheduler/abstract_coordinator.hpp"

namespace caf {

scoped_execution_unit::scoped_execution_unit(actor_system* sys)
  : execution_unit(sys){
  // nop
}

void scoped_execution_unit::exec_later(resumable* ptr) {
  system().scheduler().enqueue(ptr);
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/stream_aborter.hpp"

#include "caf/actor.hpp"
#include "caf/logger.hpp"
#include "caf/message.hpp"
#include "caf/actor_cast.hpp"
#include "caf/stream_msg.hpp"
#include "caf/system_messages.hpp"

namespace caf {

stream_aborter::~stream_aborter() {
  // nop
}

void stream_aborter::actor_exited(const error& rsn, execution_unit* host) {
  CAF_ASSERT(observed_ != observer_);
  auto observer = actor_cast<strong_actor_ptr>(observer_);
  if (observer != nullptr)
  {
    if (mode_ == source_aborter)
      observer->enqueue(
        nullptr, make_message_id(),
        make_message(caf::make<stream_msg::forced_close>(sid_, observed_, rsn)),
        host);
    else
      observer->enqueue(
        nullptr, make_message_id(),
        make_message(caf::make<stream_msg::forced_drop>(sid_, observed_, rsn)),
        host);
  }
}

bool stream_aborter::matches(const attachable::token& what) {
  if (what.subtype != attachable::token::stream_aborter)
    return false;
  auto& ot = *reinterpret_cast<const token*>(what.ptr);
  return ot.observer == observer_ && ot.sid == sid_;
}

stream_aborter::stream_aborter(actor_addr&& observed, actor_addr&& observer,
                               const stream_id& sid, mode m)
    : observed_(std::move(observed)),
      observer_(std::move(observer)),
      sid_(sid),
      mode_(m) {
  // nop
}

void stream_aborter::add(strong_actor_ptr observed, actor_addr observer,
                         const stream_id& sid, mode m) {
  CAF_LOG_TRACE(CAF_ARG(observed) << CAF_ARG(observer) << CAF_ARG(sid));
  observed->get()->attach(make(observed->address(), std::move(observer),
                               sid, m));
}

void stream_aborter::del(strong_actor_ptr observed, const actor_addr& observer,
                         const stream_id& sid, mode m) {
  CAF_LOG_TRACE(CAF_ARG(observed) << CAF_ARG(observer) << CAF_ARG(sid));
  token tk{observer, sid, m};
  observed->get()->detach(tk);
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#include <map>
#include <mutex>
#include <atomic>
#include <stdexcept>

#include "caf/atom.hpp"
#include "caf/config.hpp"
#include "caf/logger.hpp"
#include "caf/message.hpp"
#include "caf/actor_addr.hpp"
#include "caf/actor_cast.hpp"
#include "caf/actor_system.hpp"
#include "caf/abstract_actor.hpp"
#include "caf/actor_registry.hpp"
#include "caf/execution_unit.hpp"
#include "caf/mailbox_element.hpp"
#include "caf/system_messages.hpp"
#include "caf/default_attachable.hpp"
#include "caf/actor_control_block.hpp"

#include "caf/detail/disposer.hpp"
#include "caf/detail/enum_to_string.hpp"
#include "caf/detail/shared_spinlock.hpp"

namespace caf {

// exit_state_ is guaranteed to be set to 0, i.e., exit_reason::not_exited,
// by std::atomic<> constructor

actor_control_block* abstract_actor::ctrl() const {
  return actor_control_block::from(this);
}

abstract_actor::~abstract_actor() {
  // nop
}

void abstract_actor::on_destroy() {
  // nop
}

void abstract_actor::enqueue(strong_actor_ptr sender, message_id mid,
                             message msg, execution_unit* host) {
  enqueue(make_mailbox_element(sender, mid, {}, std::move(msg)), host);
}

abstract_actor::abstract_actor(actor_config& cfg)
    : abstract_channel(cfg.flags) {
  // nop
}

actor_addr abstract_actor::address() const {
  return actor_addr{actor_control_block::from(this)};
}

std::set<std::string> abstract_actor::message_types() const {
  // defaults to untyped
  return std::set<std::string>{};
}

actor_id abstract_actor::id() const noexcept {
  return actor_control_block::from(this)->id();
}

node_id abstract_actor::node() const noexcept {
  return actor_control_block::from(this)->node();
}

actor_system& abstract_actor::home_system() const noexcept {
  return *(actor_control_block::from(this)->home_system);
}

void abstract_actor::register_at_system() {
  if (getf(is_registered_flag))
    return;
  setf(is_registered_flag);
  home_system().registry().inc_running();
}

void abstract_actor::unregister_from_system() {
  if (!getf(is_registered_flag))
    return;
  unsetf(is_registered_flag);
  home_system().registry().dec_running();
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/policy/work_stealing.hpp"

namespace caf {
namespace policy {

work_stealing::~work_stealing() {
  // nop
}

} // namespace policy
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/detail/invoke_result_visitor.hpp"

namespace caf {
namespace detail {

invoke_result_visitor::~invoke_result_visitor() {
  // nop
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/stream_priority.hpp"

namespace caf {

std::string to_string(stream_priority x) {
  switch (x) {
    default:
      return "invalid";
    case stream_priority::very_high:
      return "very_high";
    case stream_priority::high:
      return "high";
    case stream_priority::normal:
      return "normal";
    case stream_priority::low:
      return "low";
    case stream_priority::very_low:
      return "very_low";
  }
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <utility>

#include "caf/locks.hpp"

#include "caf/atom.hpp"
#include "caf/message.hpp"
#include "caf/actor_proxy.hpp"
#include "caf/exit_reason.hpp"

namespace caf {

actor_proxy::actor_proxy(actor_config& cfg) : monitorable_actor(cfg) {
  // nop
}

actor_proxy::~actor_proxy() {
  // nop
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/execution_unit.hpp"

namespace caf {

execution_unit::execution_unit(actor_system* sys)
    : system_(sys),
      proxies_(nullptr) {
  // nop
}

execution_unit::~execution_unit() {
  // nop
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/detail/pull5_gatherer.hpp"

namespace caf {
namespace detail {

pull5_gatherer::pull5_gatherer(local_actor* selfptr) : super(selfptr) {
  // nop
}

void pull5_gatherer::assign_credit(long available) {
  CAF_LOG_TRACE(CAF_ARG(available));
  for (auto& kvp : assignment_vec_) {
    auto x = std::min(available, 5l - kvp.first->assigned_credit);
    available -= x;
    kvp.second = x;
  }
  emit_credits();
}

long pull5_gatherer::initial_credit(long, inbound_path*) {
  return 5;
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <set>
#include <mutex>
#include <sstream>
#include <stdexcept>
#include <condition_variable>

#include "caf/locks.hpp"

#include "caf/all.hpp"
#include "caf/group.hpp"
#include "caf/message.hpp"
#include "caf/serializer.hpp"
#include "caf/deserializer.hpp"
#include "caf/event_based_actor.hpp"

#include "caf/group_manager.hpp"

namespace caf {

namespace {

using exclusive_guard = unique_lock<detail::shared_spinlock>;
using shared_guard = shared_lock<detail::shared_spinlock>;
using upgrade_guard = upgrade_lock<detail::shared_spinlock>;
using upgrade_to_unique_guard = upgrade_to_unique_lock<detail::shared_spinlock>;

class local_broker;
class local_group_module;

void await_all_locals_down(actor_system& sys, std::initializer_list<actor> xs) {
  CAF_LOG_TRACE("");
  scoped_actor self{sys, true};
  std::vector<actor> ys;
  for (auto& x : xs)
    if (x.node() == sys.node()) {
      self->send_exit(x, exit_reason::kill);
      ys.push_back(x);
    }
  // Don't block when using the test coordinator.
  if (sys.config().scheduler_policy != atom("testing"))
    self->wait_for(ys);
}

class local_group : public abstract_group {
public:
  void send_all_subscribers(const strong_actor_ptr& sender, const message& msg,
                            execution_unit* host) {
    CAF_LOG_TRACE(CAF_ARG(sender) << CAF_ARG(msg));
    shared_guard guard(mtx_);
    for (auto& s : subscribers_)
      s->enqueue(sender, invalid_message_id, msg, host);
  }

  void enqueue(strong_actor_ptr sender, message_id, message msg,
               execution_unit* host) override {
    CAF_LOG_TRACE(CAF_ARG(sender) << CAF_ARG(msg));
    send_all_subscribers(sender, msg, host);
    broker_->enqueue(sender, invalid_message_id, msg, host);
  }

  std::pair<bool, size_t> add_subscriber(strong_actor_ptr who) {
    CAF_LOG_TRACE(CAF_ARG(who));
    if (!who)
      return {false, subscribers_.size()};
    exclusive_guard guard(mtx_);
    auto res = subscribers_.emplace(std::move(who)).second;
    return {res, subscribers_.size()};
  }

  std::pair<bool, size_t> erase_subscriber(const actor_control_block* who) {
    CAF_LOG_TRACE(""); // serializing who would cause a deadlock
    exclusive_guard guard(mtx_);
    auto e = subscribers_.end();
#if __cplusplus > 201103L
    auto i = subscribers_.find(who);
#else
    auto cmp = [&](const strong_actor_ptr& lhs) {
      return lhs.get() == who;
    };
    auto i = std::find_if(subscribers_.begin(), e, cmp);
#endif
    if(i == e)
      return {false, subscribers_.size()};
    subscribers_.erase(i);
    return {true, subscribers_.size()};
  }

  bool subscribe(strong_actor_ptr who) override {
    CAF_LOG_TRACE(CAF_ARG(who));
    return add_subscriber(std::move(who)).first;
  }

  void unsubscribe(const actor_control_block* who) override {
    CAF_LOG_TRACE(CAF_ARG(who));
    erase_subscriber(who);
  }

  error save(serializer& sink) const override;

  void stop() override {
    CAF_LOG_TRACE("");
    await_all_locals_down(system(), {broker_});
  }

  const actor& broker() const {
    return broker_;
  }

  local_group(local_group_module& mod, std::string id, node_id nid,
              optional<actor> lb);

  ~local_group() override;

protected:
  detail::shared_spinlock mtx_;
#if __cplusplus > 201103L
  std::set<strong_actor_ptr, std::less<>> subscribers_;
#else
  std::set<strong_actor_ptr> subscribers_;
#endif
  actor broker_;
};

using local_group_ptr = intrusive_ptr<local_group>;

class local_broker : public event_based_actor {
public:
  explicit local_broker(actor_config& cfg, local_group_ptr g)
      : event_based_actor(cfg),
        group_(std::move(g)) {
    // nop
  }

  void on_exit() override {
    acquaintances_.clear();
    group_.reset();
  }

  const char* name() const override {
    return "local_broker";
  }

  behavior make_behavior() override {
    CAF_LOG_TRACE("");
    // instead of dropping "unexpected" messages,
    // we simply forward them to our acquaintances
    auto fwd = [=](scheduled_actor*, message_view& x) -> result<message> {
      send_to_acquaintances(x.move_content_to_message());
      return message{};
    };
    set_default_handler(fwd);
    set_down_handler([=](down_msg& dm) {
      CAF_LOG_TRACE(CAF_ARG(dm));
      auto first = acquaintances_.begin();
      auto last = acquaintances_.end();
      auto i = std::find_if(first, last, [&](const actor& a) {
        return a == dm.source;
      });
      if (i != last)
        acquaintances_.erase(i);
    });
    // return behavior
    return {
      [=](join_atom, const actor& other) {
        CAF_LOG_TRACE(CAF_ARG(other));
        if (acquaintances_.insert(other).second) {
          monitor(other);
        }
      },
      [=](leave_atom, const actor& other) {
        CAF_LOG_TRACE(CAF_ARG(other));
        acquaintances_.erase(other);
        if (acquaintances_.erase(other) > 0)
          demonitor(other);
      },
      [=](forward_atom, const message& what) {
        CAF_LOG_TRACE(CAF_ARG(what));
        // local forwarding
        group_->send_all_subscribers(current_element_->sender, what, context());
        // forward to all acquaintances
        send_to_acquaintances(what);
      }
    };
  }

private:
  void send_to_acquaintances(const message& what) {
    // send to all remote subscribers
    auto src = current_element_->sender;
    CAF_LOG_DEBUG(CAF_ARG(acquaintances_.size())
                  << CAF_ARG(src) << CAF_ARG(what));
    for (auto& acquaintance : acquaintances_)
      acquaintance->enqueue(src, invalid_message_id, what, context());
  }

  local_group_ptr group_;
  std::set<actor> acquaintances_;
};

// Send a join message to the original group if a proxy
// has local subscriptions and a "LEAVE" message to the original group
// if there's no subscription left.

class local_group_proxy;

using local_group_proxy_ptr = intrusive_ptr<local_group_proxy>;

class proxy_broker : public event_based_actor {
public:
  proxy_broker(actor_config& cfg, local_group_proxy_ptr grp)
      : event_based_actor(cfg),
        group_(std::move(grp)) {
    CAF_LOG_TRACE("");
  }

  behavior make_behavior() override;

  void on_exit() override {
    group_.reset();
  }

private:
  local_group_proxy_ptr group_;
};

class local_group_proxy : public local_group {
public:
  local_group_proxy(actor_system& sys, actor remote_broker,
                    local_group_module& mod, std::string id, node_id nid)
      : local_group(mod, std::move(id), std::move(nid), std::move(remote_broker)),
        proxy_broker_{sys.spawn<proxy_broker, hidden>(this)},
        monitor_{sys.spawn<hidden>(broker_monitor_actor, this)} {
    // nop
  }

  bool subscribe(strong_actor_ptr who) override {
    CAF_LOG_TRACE(CAF_ARG(who));
    auto res = add_subscriber(std::move(who));
    if (res.first) {
      // join remote source
      if (res.second == 1)
        anon_send(broker_, join_atom::value, proxy_broker_);
      return true;
    }
    CAF_LOG_WARNING("actor already joined group");
    return false;
  }

  void unsubscribe(const actor_control_block* who) override {
    CAF_LOG_TRACE(CAF_ARG(who));
    auto res = erase_subscriber(who);
    if (res.first && res.second == 0) {
      // leave the remote source,
      // because there's no more subscriber on this node
      anon_send(broker_, leave_atom::value, proxy_broker_);
    }
  }

  void enqueue(strong_actor_ptr sender, message_id mid,
               message msg, execution_unit* eu) override {
    CAF_LOG_TRACE(CAF_ARG(sender) << CAF_ARG(mid) << CAF_ARG(msg));
    // forward message to the broker
    broker_->enqueue(std::move(sender), mid,
                     make_message(forward_atom::value, std::move(msg)), eu);
  }

  void stop() override {
    CAF_LOG_TRACE("");
    await_all_locals_down(system_, {monitor_, proxy_broker_, broker_});
  }

private:
  static behavior broker_monitor_actor(event_based_actor* self,
                                       local_group_proxy* grp) {
    CAF_LOG_TRACE("");
    self->monitor(grp->broker_);
    self->set_down_handler([=](down_msg& down) {
      CAF_LOG_TRACE(CAF_ARG(down));
      auto msg = make_message(group_down_msg{group(grp)});
      grp->send_all_subscribers(self->ctrl(), std::move(msg),
                                self->context());
      self->quit(down.reason);
    });
    return {
      [] {
        // nop
      }
    };
  }

  actor proxy_broker_;
  actor monitor_;
};

behavior proxy_broker::make_behavior() {
  CAF_LOG_TRACE("");
  // instead of dropping "unexpected" messages,
  // we simply forward them to our acquaintances
  auto fwd = [=](local_actor*, message_view& x) -> result<message> {
    group_->send_all_subscribers(current_element_->sender,
                                 x.move_content_to_message(), context());
    return message{};
  };
  set_default_handler(fwd);
  // return dummy behavior
  return {
    [] {
      // nop
    }
  };
}

class local_group_module : public group_module {
public:
  local_group_module(actor_system& sys) : group_module(sys, "local") {
    CAF_LOG_TRACE("");
  }

  expected<group> get(const std::string& identifier) override {
    CAF_LOG_TRACE(CAF_ARG(identifier));
    upgrade_guard guard(instances_mtx_);
    auto i = instances_.find(identifier);
    if (i != instances_.end())
      return group{i->second};
    auto tmp = make_counted<local_group>(*this, identifier,
                                         system().node(), none);
    upgrade_to_unique_guard uguard(guard);
    auto p = instances_.emplace(identifier, tmp);
    auto result = p.first->second;
    uguard.unlock();
    // someone might preempt us
    if (result != tmp)
      tmp->stop();
    return group{result};
  }

  error load(deserializer& source, group& storage) override {
    CAF_LOG_TRACE("");
    // deserialize identifier and broker
    std::string identifier;
    strong_actor_ptr broker_ptr;
    auto e = source(identifier, broker_ptr);
    if (e)
      return e;
    CAF_LOG_DEBUG(CAF_ARG(identifier) << CAF_ARG(broker_ptr));
    if (!broker_ptr) {
      storage = invalid_group;
      return none;
    }
    auto broker = actor_cast<actor>(broker_ptr);
    if (broker->node() == system().node()) {
      storage = *this->get(identifier);
      return none;
    }
    upgrade_guard guard(proxies_mtx_);
    auto i = proxies_.find(broker);
    if (i != proxies_.end()) {
      storage = group{i->second};
      return none;
    }
    local_group_ptr tmp = make_counted<local_group_proxy>(system(), broker,
                                                          *this, identifier,
                                                          broker->node());
    upgrade_to_unique_guard uguard(guard);
    auto p = proxies_.emplace(broker, tmp);
    // someone might preempt us
    storage = group{p.first->second};
    return none;
  }

  error save(const local_group* ptr, serializer& sink) const {
    CAF_ASSERT(ptr != nullptr);
    CAF_LOG_TRACE("");
    auto bro = actor_cast<strong_actor_ptr>(ptr->broker());
    auto& id = const_cast<std::string&>(ptr->identifier());
    return sink(id, bro);
  }

  void stop() override {
    CAF_LOG_TRACE("");
    std::map<std::string, local_group_ptr> imap;
    std::map<actor, local_group_ptr> pmap;
    { // critical section
      exclusive_guard guard1{instances_mtx_};
      exclusive_guard guard2{proxies_mtx_};
      imap.swap(instances_);
      pmap.swap(proxies_);
    }
    for (auto& kvp : imap)
      kvp.second->stop();
    for (auto& kvp : pmap)
      kvp.second->stop();
  }

private:
  detail::shared_spinlock instances_mtx_;
  std::map<std::string, local_group_ptr> instances_;
  detail::shared_spinlock proxies_mtx_;
  std::map<actor, local_group_ptr> proxies_;
};

local_group::local_group(local_group_module& mod, std::string id, node_id nid,
                         optional<actor> lb)
    : abstract_group(mod, std::move(id), std::move(nid)),
      broker_(lb ? *lb : mod.system().spawn<local_broker, hidden>(this)) {
  CAF_LOG_TRACE(CAF_ARG(id) << CAF_ARG(nid));
}

local_group::~local_group() {
  // nop
}

error local_group::save(serializer& sink) const {
  CAF_LOG_TRACE("");
  // this cast is safe, because the only available constructor accepts
  // local_group_module* as module pointer
  return static_cast<local_group_module&>(parent_).save(this, sink);
}

std::atomic<size_t> s_ad_hoc_id;

} // namespace <anonymous>

void group_manager::init(actor_system_config& cfg) {
  CAF_LOG_TRACE("");
  using ptr_type = std::unique_ptr<group_module>;
  mmap_.emplace("local", ptr_type{new local_group_module(system_)});
  for (auto& fac : cfg.group_module_factories) {
    ptr_type ptr{fac()};
    std::string name = ptr->name();
    mmap_.emplace(std::move(name), std::move(ptr));
  }
}

void group_manager::start() {
  CAF_LOG_TRACE("");
}

void group_manager::stop() {
  CAF_LOG_TRACE("");
  for (auto& kvp : mmap_)
    kvp.second->stop();
}

group_manager::~group_manager() {
  // nop
}

group_manager::group_manager(actor_system& sys) : system_(sys) {
  // nop
}

group group_manager::anonymous() const {
  CAF_LOG_TRACE("");
  std::string id = "__#";
  id += std::to_string(++s_ad_hoc_id);
  // local module is guaranteed to not return an error
  return *get_module("local")->get(id);
}

expected<group> group_manager::get(std::string group_uri) const {
  CAF_LOG_TRACE(CAF_ARG(group_uri));
  // URI parsing is pretty much a brute-force approach, no actual validation yet
  auto p = group_uri.find(':');
  if (p == std::string::npos)
    return sec::invalid_argument;
  auto group_id = group_uri.substr(p + 1);
  // erase all but the scheme part from the URI and use that as module name
  group_uri.erase(p);
  return get(group_uri, group_id);
}

expected<group> group_manager::get(const std::string& module_name,
                                   const std::string& group_identifier) const {
  CAF_LOG_TRACE(CAF_ARG(module_name) << CAF_ARG(group_identifier));
  auto mod = get_module(module_name);
  if (mod)
    return mod->get(group_identifier);
  std::string error_msg = R"(no module named ")";
  error_msg += module_name;
  error_msg += R"(" found)";
  return make_error(sec::no_such_group_module, std::move(error_msg));
}

optional<group_module&> group_manager::get_module(const std::string& x) const {
  auto i = mmap_.find(x);
  if (i != mmap_.end())
    return *(i->second);
  return none;
}

group group_manager::get_local(const std::string& group_identifier) const {
  // guaranteed to never return an error
  return *get("local", group_identifier);
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/term.hpp"

#include <iostream>

#include "caf/config.hpp"

#ifdef CAF_WINDOWS
#include <io.h>
#include <windows.h>
#else
#include <cstdio>
#include <unistd.h>
#endif

namespace caf {

namespace {

#ifdef CAF_WINDOWS

// windows terminals do no support bold fonts

constexpr int win_black = 0;
constexpr int win_red = FOREGROUND_INTENSITY | FOREGROUND_RED;
constexpr int win_green = FOREGROUND_INTENSITY | FOREGROUND_GREEN;
constexpr int win_blue = FOREGROUND_INTENSITY | FOREGROUND_BLUE;
constexpr int win_yellow = win_red | win_green;
constexpr int win_magenta = win_red | win_blue;
constexpr int win_cyan = win_green | win_blue;
constexpr int win_white = win_red | win_cyan;

int tty_codes[] = {
  -1,          // reset
  -2,          // reset_endl
  win_black,   // black
  win_red,     // red
  win_green,   // green
  win_yellow,  // yellow
  win_blue,    // blue
  win_magenta, // magenta
  win_cyan,    // cyan
  win_white,   // white
  win_black,   // bold black
  win_red,     // bold red
  win_green,   // bold green
  win_yellow,  // bold yellow
  win_blue,    // bold blue
  win_magenta, // bold magenta
  win_cyan,    // bold cyan
  win_white    // bold white
};

void set_term_color(std::ostream& out, int c) {
  static WORD default_color = 0xFFFF;
  auto hdl = GetStdHandle(&out == &std::cout ? STD_OUTPUT_HANDLE
                                             : STD_ERROR_HANDLE);
  if (default_color == 0xFFFF) {
    CONSOLE_SCREEN_BUFFER_INFO info;
    if (!GetConsoleScreenBufferInfo(hdl, &info))
      return;
    default_color = info.wAttributes;
  }
  // always pick background from the default color
  auto x = c < 0 ? default_color
                 : static_cast<WORD>((0xF0 & default_color) | (0x0F & c));
  SetConsoleTextAttribute(hdl, x);
  if (c == -2)
    out << '\n';
}

#define STDOUT_FILENO 1
#define STDERR_FILENO 2

#define ISATTY_FUN ::_isatty

#else // POSIX-compatible terminals

const char* tty_codes[] = {
  "\033[0m",         // reset
  "\033[0m\n",       // reset_endl
  "\033[30m",        // black
  "\033[31m",        // red
  "\033[32m",        // green
  "\033[33m",        // yellow
  "\033[34m",        // blue
  "\033[35m",        // magenta
  "\033[36m",        // cyan
  "\033[37m",        // white
  "\033[1m\033[30m", // bold_black
  "\033[1m\033[31m", // bold_red
  "\033[1m\033[32m", // bold_green
  "\033[1m\033[33m", // bold_yellow
  "\033[1m\033[34m", // bold_blue
  "\033[1m\033[35m", // bold_magenta
  "\033[1m\033[36m", // bold_cyan
  "\033[1m\033[37m"  // bold_white
};

void set_term_color(std::ostream& out, const char* x) {
  out << x;
}

#define ISATTY_FUN ::isatty

#endif

bool is_tty(const std::ostream& out) {
  if (&out == &std::cout)
    return ISATTY_FUN(STDOUT_FILENO) != 0;
  if (&out == &std::cerr || &out == &std::clog)
    return ISATTY_FUN(STDERR_FILENO) != 0;
  return false;
}

} // namespace <anonymous>

std::ostream& operator<<(std::ostream& out, term x) {
  if (is_tty(out))
    set_term_color(out, tty_codes[static_cast<size_t>(x)]);
  return out;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/detail/try_match.hpp"

#include "caf/type_erased_tuple.hpp"

namespace caf {
namespace detail {

using pattern_iterator = const meta_element*;

bool match_element(const meta_element& me, const type_erased_tuple& xs,
                   size_t pos) {
  CAF_ASSERT(me.typenr != 0 || me.type != nullptr);
  return xs.matches(pos, me.typenr, me.type);
}

bool match_atom_constant(const meta_element& me, const type_erased_tuple& xs,
                         size_t pos) {
  CAF_ASSERT(me.typenr == type_nr<atom_value>::value);
  if (!xs.matches(pos, type_nr<atom_value>::value, nullptr))
    return false;
  auto ptr = xs.get(pos);
  return me.v == *reinterpret_cast<const atom_value*>(ptr);
}

bool try_match(const type_erased_tuple& xs,
               pattern_iterator iter, size_t ps) {
  if (xs.size() != ps)
    return false;
  for (size_t i = 0; i < ps; ++i, ++iter)
    // inspect current element
    if (!iter->fun(*iter, xs, i))
      // type mismatch
      return false;
  return true;
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/detail/dynamic_message_data.hpp"

#include "caf/error.hpp"
#include "caf/make_counted.hpp"

namespace caf {
namespace detail {

dynamic_message_data::dynamic_message_data() : type_token_(0xFFFFFFFF) {
  // nop
}

dynamic_message_data::dynamic_message_data(elements&& data)
    : elements_(std::move(data)),
      type_token_(0xFFFFFFFF) {
  for (auto& e : elements_)
    add_to_type_token(e->type().first);
}

dynamic_message_data::dynamic_message_data(const dynamic_message_data& other)
    : detail::message_data(other),
      type_token_(0xFFFFFFFF) {
  for (auto& e : other.elements_) {
    add_to_type_token(e->type().first);
    elements_.emplace_back(e->copy());
  }
}

dynamic_message_data::~dynamic_message_data() {
  // nop
}

message_data::cow_ptr dynamic_message_data::copy() const {
  return make_counted<dynamic_message_data>(*this);
}

void* dynamic_message_data::get_mutable(size_t pos) {
  CAF_ASSERT(pos < size());
  return elements_[pos]->get_mutable();
}

error dynamic_message_data::load(size_t pos, deserializer& source) {
  CAF_ASSERT(pos < size());
  return elements_[pos]->load(source);
}

size_t dynamic_message_data::size() const noexcept {
  return elements_.size();
}

uint32_t dynamic_message_data::type_token() const noexcept {
  return type_token_;
}

auto dynamic_message_data::type(size_t pos) const noexcept -> rtti_pair {
  CAF_ASSERT(pos < size());
  return elements_[pos]->type();
}

const void* dynamic_message_data::get(size_t pos) const noexcept {
  CAF_ASSERT(pos < size());
  return elements_[pos]->get();
}

std::string dynamic_message_data::stringify(size_t pos) const {
  CAF_ASSERT(pos < size());
  return elements_[pos]->stringify();
}

type_erased_value_ptr dynamic_message_data::copy(size_t pos) const {
  CAF_ASSERT(pos < size());
  return elements_[pos]->copy();
}

error dynamic_message_data::save(size_t pos, serializer& sink) const {
  CAF_ASSERT(pos < size());
  return elements_[pos]->save(sink);
}

void dynamic_message_data::clear() {
  elements_.clear();
  type_token_ = 0xFFFFFFFF;
}

void dynamic_message_data::append(type_erased_value_ptr x) {
  add_to_type_token(x->type().first);
  elements_.emplace_back(std::move(x));
}

void dynamic_message_data::add_to_type_token(uint16_t typenr) {
  type_token_ = (type_token_ << 6) | typenr;
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/policy/work_sharing.hpp"

namespace caf {
namespace policy {

work_sharing::~work_sharing() {
  // nop
}

} // namespace policy
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/group_module.hpp"

namespace caf {

group_module::group_module(actor_system& sys, std::string mname)
    : system_(sys),
      name_(std::move(mname)) {
  // nop
}

group_module::~group_module() {
  // nop
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/actor_pool.hpp"

#include <atomic>
#include <random>

#include "caf/send.hpp"
#include "caf/default_attachable.hpp"

#include "caf/detail/sync_request_bouncer.hpp"

namespace caf {

actor_pool::policy actor_pool::round_robin() {
  struct impl {
    impl() : pos_(0) {
      // nop
    }
    impl(const impl&) : pos_(0) {
      // nop
    }
    void operator()(actor_system&, uplock& guard, const actor_vec& vec,
                    mailbox_element_ptr& ptr, execution_unit* host) {
      CAF_ASSERT(!vec.empty());
      actor selected = vec[pos_++ % vec.size()];
      guard.unlock();
      selected->enqueue(std::move(ptr), host);
    }
    std::atomic<size_t> pos_;
  };
  return impl{};
}

namespace {

void broadcast_dispatch(actor_system&, actor_pool::uplock&,
                        const actor_pool::actor_vec& vec,
                        mailbox_element_ptr& ptr, execution_unit* host) {
  CAF_ASSERT(!vec.empty());
  auto msg = ptr->move_content_to_message();
  for (auto& worker : vec)
    worker->enqueue(ptr->sender, ptr->mid, msg, host);
}

} // namespace <anonymous>

actor_pool::policy actor_pool::broadcast() {
  return broadcast_dispatch;
}

actor_pool::policy actor_pool::random() {
  struct impl {
    impl() : rd_() {
      // nop
    }
    impl(const impl&) : rd_() {
      // nop
    }
    void operator()(actor_system&, uplock& guard, const actor_vec& vec,
                    mailbox_element_ptr& ptr, execution_unit* host) {
      upgrade_to_unique_lock<detail::shared_spinlock> unique_guard{guard};
      auto selected =
          vec[dis_(rd_, decltype(dis_)::param_type(0, vec.size() - 1))];
      unique_guard.unlock();
      selected->enqueue(std::move(ptr), host);
    }
    std::random_device rd_;
    std::uniform_int_distribution<size_t> dis_;
  };
  return impl{};
}

actor_pool::~actor_pool() {
  // nop
}

actor actor_pool::make(execution_unit* eu, policy pol) {
  CAF_ASSERT(eu);
  auto& sys = eu->system();
  actor_config cfg{eu};
  auto res = make_actor<actor_pool, actor>(sys.next_actor_id(), sys.node(),
                                           &sys, cfg);
  auto ptr = static_cast<actor_pool*>(actor_cast<abstract_actor*>(res));
  ptr->policy_ = std::move(pol);
  return res;
}

actor actor_pool::make(execution_unit* eu, size_t num_workers,
                       const factory& fac, policy pol) {
  auto res = make(eu, std::move(pol));
  auto ptr = static_cast<actor_pool*>(actor_cast<abstract_actor*>(res));
  auto res_addr = ptr->address();
  for (size_t i = 0; i < num_workers; ++i) {
    auto worker = fac();
    worker->attach(default_attachable::make_monitor(worker.address(), res_addr));
    ptr->workers_.push_back(std::move(worker));
  }
  return res;
}

void actor_pool::enqueue(mailbox_element_ptr what, execution_unit* eu) {
  upgrade_lock<detail::shared_spinlock> guard{workers_mtx_};
  if (filter(guard, what->sender, what->mid, *what, eu))
    return;
  policy_(home_system(), guard, workers_, what, eu);
}

actor_pool::actor_pool(actor_config& cfg) : monitorable_actor(cfg) {
  register_at_system();
}

void actor_pool::on_cleanup() {
  // nop
}

bool actor_pool::filter(upgrade_lock<detail::shared_spinlock>& guard,
                        const strong_actor_ptr& sender, message_id mid,
                        message_view& mv, execution_unit* eu) {
  auto& content = mv.content();
  CAF_LOG_TRACE(CAF_ARG(mid) << CAF_ARG(content));
  if (content.match_elements<exit_msg>()) {
    // acquire second mutex as well
    std::vector<actor> workers;
    auto em = content.get_as<exit_msg>(0).reason;
    if (cleanup(std::move(em), eu)) {
      auto tmp = mv.move_content_to_message();
      // send exit messages *always* to all workers and clear vector afterwards
      // but first swap workers_ out of the critical section
      upgrade_to_unique_lock<detail::shared_spinlock> unique_guard{guard};
      workers_.swap(workers);
      unique_guard.unlock();
      for (auto& w : workers)
        anon_send(w, tmp);
      unregister_from_system();
    }
    return true;
  }
  if (content.match_elements<down_msg>()) {
    // remove failed worker from pool
    auto& dm = content.get_as<down_msg>(0);
    upgrade_to_unique_lock<detail::shared_spinlock> unique_guard{guard};
    auto last = workers_.end();
    auto i = std::find(workers_.begin(), workers_.end(), dm.source);
    CAF_LOG_DEBUG_IF(i == last, "received down message for an unknown worker");
    if (i != last)
      workers_.erase(i);
    if (workers_.empty()) {
      planned_reason_ = exit_reason::out_of_workers;
      unique_guard.unlock();
      quit(eu);
    }
    return true;
  }
  if (content.match_elements<sys_atom, put_atom, actor>()) {
    auto& worker = content.get_as<actor>(2);
    worker->attach(default_attachable::make_monitor(worker.address(),
                                                    address()));
    upgrade_to_unique_lock<detail::shared_spinlock> unique_guard{guard};
    workers_.push_back(worker);
    return true;
  }
  if (content.match_elements<sys_atom, delete_atom, actor>()) {
    upgrade_to_unique_lock<detail::shared_spinlock> unique_guard{guard};
    auto& what = content.get_as<actor>(2);
    auto last = workers_.end();
    auto i = std::find(workers_.begin(), last, what);
    if (i != last) {
      default_attachable::observe_token tk{address(),
                                           default_attachable::monitor};
      what->detach(tk);
      workers_.erase(i);
    }
    return true;
  }
  if (content.match_elements<sys_atom, delete_atom>()) {
    upgrade_to_unique_lock<detail::shared_spinlock> unique_guard{guard};
    for (auto& worker : workers_) {
      default_attachable::observe_token tk{address(),
                                           default_attachable::monitor};
      worker->detach(tk);
    }
    workers_.clear();
    return true;
  }
  if (content.match_elements<sys_atom, get_atom>()) {
    auto cpy = workers_;
    guard.unlock();
    sender->enqueue(nullptr, mid.response_id(),
                    make_message(std::move(cpy)), eu);
    return true;
  }
  if (workers_.empty()) {
    guard.unlock();
    if (sender && mid.valid()) {
      // tell client we have ignored this sync message by sending
      // and empty message back
      sender->enqueue(nullptr, mid.response_id(), message{}, eu);
    }
    return true;
  }
  return false;
}

void actor_pool::quit(execution_unit* host) {
  // we can safely run our cleanup code here without holding
  // workers_mtx_ because abstract_actor has its own lock
  if (cleanup(planned_reason_, host))
    unregister_from_system();
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/sec.hpp"
#include "caf/atom.hpp"
#include "caf/actor.hpp"
#include "caf/config.hpp"
#include "caf/actor_cast.hpp"
#include "caf/message_id.hpp"
#include "caf/exit_reason.hpp"
#include "caf/mailbox_element.hpp"
#include "caf/system_messages.hpp"

#include "caf/detail/sync_request_bouncer.hpp"

namespace caf {
namespace detail {

sync_request_bouncer::sync_request_bouncer(error r) : rsn(std::move(r)) {
  // nop
}

void sync_request_bouncer::operator()(const strong_actor_ptr& sender,
                                      const message_id& mid) const {
  if (sender && mid.is_request())
    sender->enqueue(nullptr, mid.response_id(),
                    make_message(make_error(sec::request_receiver_down)),
                    // TODO: this breaks out of the execution unit
                    nullptr);
}

void sync_request_bouncer::operator()(const mailbox_element& e) const {
  (*this)(e.sender, e.mid);
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/message_id.hpp"
#include "caf/event_based_actor.hpp"

#include "caf/detail/pretty_type_name.hpp"

namespace caf {

event_based_actor::event_based_actor(actor_config& cfg) : extended_base(cfg) {
  // nop
}

event_based_actor::~event_based_actor() {
  // nop
}

void event_based_actor::initialize() {
  CAF_LOG_TRACE("subtype =" << detail::pretty_type_name(typeid(*this)).c_str());
  setf(is_initialized_flag);
  auto bhvr = make_behavior();
  CAF_LOG_DEBUG_IF(!bhvr, "make_behavior() did not return a behavior:"
                           << CAF_ARG(has_behavior()));
  if (bhvr) {
    // make_behavior() did return a behavior instead of using become()
    CAF_LOG_DEBUG("make_behavior() did return a valid behavior");
    become(std::move(bhvr));
  }
  extended_base::initialize();
}

behavior event_based_actor::make_behavior() {
  CAF_LOG_TRACE("");
  behavior res;
  if (initial_behavior_fac_) {
    res = initial_behavior_fac_(this);
    initial_behavior_fac_ = nullptr;
  }
  return res;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/detail/stringification_inspector.hpp"

namespace caf {
namespace detail {

void stringification_inspector::sep() {
  if (!result_.empty())
    switch (result_.back()) {
      case '(':
      case '[':
      case ' ': // only at back if we've printed ", " before
        break;
      default:
        result_ += ", ";
    }
}

void stringification_inspector::consume(atom_value& x) {
  result_ += '\'';
  result_ += to_string(x);
  result_ += '\'';
}

void stringification_inspector::consume(const char* cstr) {
  if (cstr == nullptr || *cstr == '\0') {
    result_ += R"("")";
    return;
  }
  if (*cstr == '"') {
    // assume an already escaped string
    result_ += cstr;
    return;
  }
  result_ += '"';
  char c;
  for(;;) {
    switch (c = *cstr++) {
      default:
        result_ += c;
        break;
      case '\\':
        result_ += R"(\\)";
        break;
      case '"':
        result_ += R"(\")";
        break;
      case '\0':
        goto end_of_string;
    }
  }
  end_of_string:
  result_ += '"';
}

void stringification_inspector::consume_hex(const uint8_t* xs, size_t n) {
  if (n == 0) {
    result_ += "00";
    return;
  }
  auto tbl = "0123456789ABCDEF";
  char buf[3] = {0, 0, 0};
  for (size_t i = 0; i < n; ++i) {
    auto c = xs[i];
    buf[0] = tbl[c >> 4];
    buf[1] = tbl[c & 0x0F];
    result_ += buf;
  }
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/abstract_group.hpp"

#include "caf/group.hpp"
#include "caf/message.hpp"
#include "caf/actor_cast.hpp"
#include "caf/group_module.hpp"
#include "caf/group_manager.hpp"
#include "caf/detail/shared_spinlock.hpp"

namespace caf {

abstract_group::abstract_group(group_module& mod, std::string id, node_id nid)
    : abstract_channel(abstract_channel::is_abstract_group_flag),
      system_(mod.system()),
      parent_(mod),
      identifier_(std::move(id)),
      origin_(std::move(nid)) {
  // nop
}

abstract_group::~abstract_group() {
  // nop
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/detail/blocking_behavior.hpp"

namespace caf {
namespace detail {

blocking_behavior::~blocking_behavior() {
  // nop
}

blocking_behavior::blocking_behavior(behavior& x) : nested(x) {
  // nop
}

result<message> blocking_behavior::fallback(message_view&) {
  return skip;
}

duration blocking_behavior::timeout() {
  return {};
}

void blocking_behavior::handle_timeout() {
  // nop
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/actor.hpp"

#include <cassert>
#include <utility>

#include "caf/actor_addr.hpp"
#include "caf/make_actor.hpp"
#include "caf/serializer.hpp"
#include "caf/actor_proxy.hpp"
#include "caf/local_actor.hpp"
#include "caf/deserializer.hpp"
#include "caf/scoped_actor.hpp"
#include "caf/event_based_actor.hpp"

#include "caf/decorator/splitter.hpp"
#include "caf/decorator/sequencer.hpp"

namespace caf {

actor::actor(std::nullptr_t) : ptr_(nullptr) {
  // nop
}

actor::actor(const scoped_actor& x) : ptr_(actor_cast<strong_actor_ptr>(x)) {
  // nop
}

actor::actor(const unsafe_actor_handle_init_t&) : ptr_(nullptr) {
  // nop
}

actor::actor(actor_control_block* ptr) : ptr_(ptr) {
  // nop
}

actor::actor(actor_control_block* ptr, bool add_ref) : ptr_(ptr, add_ref) {
  // nop
}

actor& actor::operator=(std::nullptr_t) {
  ptr_.reset();
  return *this;
}

actor& actor::operator=(const scoped_actor& x) {
  ptr_ = actor_cast<strong_actor_ptr>(x);
  return *this;
}

intptr_t actor::compare(const actor& x) const noexcept {
  return actor_addr::compare(ptr_.get(), x.ptr_.get());
}

intptr_t actor::compare(const actor_addr& x) const noexcept {
  return actor_addr::compare(ptr_.get(), actor_cast<actor_control_block*>(x));
}

intptr_t actor::compare(const strong_actor_ptr& x) const noexcept {
  return actor_addr::compare(ptr_.get(), x.get());
}

void actor::swap(actor& other) noexcept {
  ptr_.swap(other.ptr_);
}

actor_addr actor::address() const noexcept {
  return actor_cast<actor_addr>(ptr_);
}

actor operator*(actor f, actor g) {
  auto& sys = f->home_system();
  return make_actor<decorator::sequencer, actor>(
    sys.next_actor_id(), sys.node(), &sys,
    actor_cast<strong_actor_ptr>(std::move(f)),
    actor_cast<strong_actor_ptr>(std::move(g)), std::set<std::string>{});
}

actor actor::splice_impl(std::initializer_list<actor> xs) {
  assert(xs.size() >= 2);
  actor_system* sys = nullptr;
  std::vector<strong_actor_ptr> tmp;
  for (auto& x : xs) {
    if (sys == nullptr)
      sys = &(x->home_system());
    tmp.push_back(actor_cast<strong_actor_ptr>(x));
  }
  return make_actor<decorator::splitter, actor>(sys->next_actor_id(),
                                                sys->node(), sys,
                                                std::move(tmp),
                                                std::set<std::string>{});
}

bool operator==(const actor& lhs, abstract_actor* rhs) {
  return actor_cast<abstract_actor*>(lhs) == rhs;
}

bool operator==(abstract_actor* lhs, const actor& rhs) {
  return rhs == lhs;
}

bool operator!=(const actor& lhs, abstract_actor* rhs) {
  return !(lhs == rhs);
}

bool operator!=(abstract_actor* lhs, const actor& rhs) {
  return !(lhs == rhs);
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/outbound_path.hpp"

#include "caf/send.hpp"
#include "caf/logger.hpp"
#include "caf/no_stages.hpp"
#include "caf/local_actor.hpp"

namespace caf {

outbound_path::outbound_path(local_actor* selfptr, const stream_id& id,
                             strong_actor_ptr ptr)
    : self(selfptr),
      sid(id),
      hdl(std::move(ptr)),
      next_batch_id(0),
      open_credit(0),
      redeployable(false),
      next_ack_id(0) {
  // nop
}

outbound_path::~outbound_path() {
  CAF_LOG_TRACE(CAF_ARG(shutdown_reason));
  if (hdl) {
    if (shutdown_reason == none)
      unsafe_send_as(self, hdl, make<stream_msg::close>(sid, self->address()));
    else
      unsafe_send_as(
        self, hdl,
        make<stream_msg::forced_close>(sid, self->address(), shutdown_reason));
  }
  if (shutdown_reason != none)
    unsafe_response(self, std::move(cd.hdl), no_stages, cd.mid,
                    std::move(shutdown_reason));
}

void outbound_path::handle_ack_open(long initial_credit) {
  open_credit = initial_credit;
  cd.hdl = nullptr;
}

void outbound_path::emit_open(strong_actor_ptr origin,
                              mailbox_element::forwarding_stack stages,
                              message_id handshake_mid, message handshake_data,
                              stream_priority prio, bool is_redeployable) {
  CAF_LOG_TRACE(CAF_ARG(origin) << CAF_ARG(stages) << CAF_ARG(handshake_mid)
                << CAF_ARG(handshake_data) << CAF_ARG(prio)
                << CAF_ARG(is_redeployable));
  cd = client_data{origin, handshake_mid};
  redeployable = is_redeployable;
  hdl->enqueue(
    make_mailbox_element(std::move(origin), handshake_mid, std::move(stages),
                         make_message(make<stream_msg::open>(
                           sid, self->address(), std::move(handshake_data),
                           self->ctrl(), hdl, prio, is_redeployable))),
    self->context());
}

void outbound_path::emit_batch(long xs_size, message xs) {
  CAF_LOG_TRACE(CAF_ARG(xs_size) << CAF_ARG(xs));
  open_credit -= xs_size;
  auto bid = next_batch_id++;
  stream_msg::batch batch{static_cast<int32_t>(xs_size), std::move(xs), bid};
  if (redeployable)
    unacknowledged_batches.emplace_back(bid, batch);
  unsafe_send_as(self, hdl, stream_msg{sid, self->address(), std::move(batch)});
}

void outbound_path::emit_irregular_shutdown(local_actor* self,
                                            const stream_id& sid,
                                            const strong_actor_ptr& hdl,
                                            error reason) {
  CAF_LOG_TRACE(CAF_ARG(reason));
  unsafe_send_as(self, hdl, make<stream_msg::forced_close>(sid, self->address(),
                                                           std::move(reason)));
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/actor_system_config.hpp"

#include <limits>
#include <thread>
#include <fstream>
#include <sstream>

#include "caf/message_builder.hpp"

#include "caf/detail/parse_ini.hpp"

namespace caf {

namespace {

using option_vector = actor_system_config::option_vector;
const char actor_conf_prefix[] = "actor:";
constexpr size_t actor_conf_prefix_size = 6;

class actor_system_config_reader {
public:
  using sink = std::function<void (size_t, config_value&,
                                   optional<std::ostream&>)>;

  using named_actor_sink = std::function<void (size_t, const std::string&,
                                               config_value&)>;

  actor_system_config_reader(option_vector& xs, option_vector& ys,
                             named_actor_sink na_sink)
      : named_actor_sink_(std::move(na_sink)){
    add_opts(xs);
    add_opts(ys);
  }

  void add_opts(option_vector& xs) {
    for (auto& x : xs)
      sinks_.emplace(x->full_name(), x->to_sink());
  }

  void operator()(size_t ln, const std::string& name, config_value& cv,
                  optional<std::ostream&> out) {
    auto i = sinks_.find(name);
    if (i != sinks_.end()) {
      (i->second)(ln, cv, none);
      return;
    }
    // check whether this is an individual actor config
    if (name.compare(0, actor_conf_prefix_size, actor_conf_prefix) == 0) {
      auto substr = name.substr(actor_conf_prefix_size);
      named_actor_sink_(ln, substr, cv);
      return;
    }
    if (out)
        *out << "error in line " << ln
             << R"(: unrecognized parameter name ")" << name << R"(")"
             << std::endl;
  }

private:
  std::map<std::string, sink> sinks_;
  named_actor_sink named_actor_sink_;
};

} // namespace <anonymous>

actor_system_config::opt_group::opt_group(option_vector& xs,
                                          const char* category)
    : xs_(xs),
      cat_(category) {
  // nop
}

actor_system_config::~actor_system_config() {
  // nop
}

// in this config class, we have (1) hard-coded defaults that are overridden
// by (2) INI-file contents that are in turn overridden by (3) CLI arguments

actor_system_config::actor_system_config()
    : cli_helptext_printed(false),
      slave_mode(false),
      logger_filename(logger_file_name),
      logger_filter(logger_component_filter),
      slave_mode_fun(nullptr) {
  // add `vector<T>` and `stream<T>` for each statically known type
  add_message_type_impl<stream<actor>>("stream<@actor>");
  add_message_type_impl<stream<actor_addr>>("stream<@addr>");
  add_message_type_impl<stream<atom_value>>("stream<@atom>");
  add_message_type_impl<stream<message>>("stream<@message>");
  add_message_type_impl<std::vector<actor>>("std::vector<@actor>");
  add_message_type_impl<std::vector<actor_addr>>("std::vector<@addr>");
  add_message_type_impl<std::vector<atom_value>>("std::vector<@atom>");
  add_message_type_impl<std::vector<message>>("std::vector<@message>");
  // (1) hard-coded defaults
  scheduler_policy = atom("stealing");
  scheduler_max_threads = std::max(std::thread::hardware_concurrency(),
                                   unsigned{4});
  scheduler_max_throughput = std::numeric_limits<size_t>::max();
  scheduler_enable_profiling = false;
  scheduler_profiling_ms_resolution = 100;
  work_stealing_aggressive_poll_attempts = 100;
  work_stealing_aggressive_steal_interval = 10;
  work_stealing_moderate_poll_attempts = 500;
  work_stealing_moderate_steal_interval = 5;
  work_stealing_moderate_sleep_duration_us = 50;
  work_stealing_relaxed_steal_interval = 1;
  work_stealing_relaxed_sleep_duration_us = 10000;
  logger_file_name = "actor_log_[PID]_[TIMESTAMP]_[NODE].log";
  logger_file_format = "%r %c %p %a %t %C %M %F:%L %m%n";
  logger_console = atom("none");
  logger_console_format = "%m";
  logger_verbosity = atom("trace");
  logger_inline_output = false;
  middleman_network_backend = atom("default");
  middleman_enable_automatic_connections = false;
  middleman_max_consecutive_reads = 50;
  middleman_heartbeat_interval = 0;
  middleman_detach_utility_actors = true;
  middleman_detach_multiplexer = true;
  middleman_enable_tcp = true;
  middleman_enable_udp = false;
  middleman_cached_udp_buffers = 10;
  middleman_max_pending_msgs = 10;
  // fill our options vector for creating INI and CLI parsers
  opt_group{options_, "scheduler"}
  .add(scheduler_policy, "policy",
       "sets the scheduling policy to either 'stealing' (default) or 'sharing'")
  .add(scheduler_max_threads, "max-threads",
       "sets a fixed number of worker threads for the scheduler")
  .add(scheduler_max_throughput, "max-throughput",
       "sets the maximum number of messages an actor consumes before yielding")
  .add(scheduler_enable_profiling, "enable-profiling",
       "enables or disables profiler output")
  .add(scheduler_profiling_ms_resolution, "profiling-ms-resolution",
       "sets the rate in ms in which the profiler collects data")
  .add(scheduler_profiling_output_file, "profiling-output-file",
       "sets the output file for the profiler");
  opt_group(options_, "work-stealing")
  .add(work_stealing_aggressive_poll_attempts, "aggressive-poll-attempts",
       "sets the number of zero-sleep-interval polling attempts")
  .add(work_stealing_aggressive_steal_interval, "aggressive-steal-interval",
       "sets the frequency of steal attempts during aggressive polling")
  .add(work_stealing_moderate_poll_attempts, "moderate-poll-attempts",
       "sets the number of moderately aggressive polling attempts")
  .add(work_stealing_moderate_steal_interval, "moderate-steal-interval",
       "sets the frequency of steal attempts during moderate polling")
  .add(work_stealing_moderate_sleep_duration_us, "moderate-sleep-duration",
       "sets the sleep interval between poll attempts during moderate polling")
  .add(work_stealing_relaxed_steal_interval, "relaxed-steal-interval",
       "sets the frequency of steal attempts during relaxed polling")
  .add(work_stealing_relaxed_sleep_duration_us, "relaxed-sleep-duration",
       "sets the sleep interval between poll attempts during relaxed polling");
  opt_group{options_, "logger"}
  .add(logger_file_name, "file-name",
       "sets the filesystem path of the log file")
  .add(logger_file_format, "file-format",
       "sets the line format for individual log file entires")
  .add(logger_console, "console",
       "sets the type of output to std::clog (none|colored|uncolored)")
  .add(logger_console_format, "console-format",
       "sets the line format for printing individual log entires")
  .add(logger_component_filter, "component-filter",
       "exclude all listed components from logging")
  .add(logger_verbosity, "verbosity",
       "sets the verbosity (quiet|error|warning|info|debug|trace)")
  .add(logger_inline_output, "inline-output",
       "sets whether a separate thread is used for I/O")
  .add(logger_file_name, "filename",
       "deprecated (use file-name instead)")
  .add(logger_component_filter, "filter",
       "deprecated (use console-component-filter instead)");
  opt_group{options_, "middleman"}
  .add(middleman_network_backend, "network-backend",
       "sets the network backend to either 'default' or 'asio' (if available)")
  .add(middleman_app_identifier, "app-identifier",
       "sets the application identifier of this node")
  .add(middleman_enable_automatic_connections, "enable-automatic-connections",
       "enables or disables automatic connection management (off per default)")
  .add(middleman_max_consecutive_reads, "max-consecutive-reads",
       "sets the maximum number of consecutive I/O reads per broker")
  .add(middleman_heartbeat_interval, "heartbeat-interval",
       "sets the interval (ms) of heartbeat, 0 (default) means disabling it")
  .add(middleman_detach_utility_actors, "detach-utility-actors",
       "enables or disables detaching of utility actors")
  .add(middleman_detach_multiplexer, "detach-multiplexer",
       "enables or disables background activity of the multiplexer")
  .add(middleman_enable_tcp, "enable-tcp",
       "enable communication via TCP (on by default)")
  .add(middleman_enable_udp, "enable-udp",
       "enable communication via UDP (off by default)")
  .add(middleman_cached_udp_buffers, "cached-udp-buffers",
       "sets the max number of UDP send buffers that will be cached for reuse "
       "(default: 10)")
  .add(middleman_max_pending_msgs, "max-pending-messages",
       "sets the max number of UDP pending messages due to ordering "
       "(default: 10)");
  opt_group(options_, "opencl")
  .add(opencl_device_ids, "device-ids",
       "restricts which OpenCL devices are accessed by CAF");
  opt_group(options_, "openssl")
  .add(openssl_certificate, "certificate",
       "sets the path to the file containining the certificate for this node PEM format")
  .add(openssl_key, "key",
       "sets the path to the file containting the private key for this node")
  .add(openssl_passphrase, "passphrase",
       "sets the passphrase to decrypt the private key, if needed")
  .add(openssl_capath, "capath",
       "sets the path to an OpenSSL-style directory of trusted certificates")
  .add(openssl_cafile, "cafile",
       "sets the path to a file containing trusted certificates concatenated together in PEM format");
  // add renderers for default error categories
  error_renderers.emplace(atom("system"), render_sec);
  error_renderers.emplace(atom("exit"), render_exit_reason);
}

actor_system_config::actor_system_config(actor_system_config&& other)
    : cli_helptext_printed(other.cli_helptext_printed),
      slave_mode(other.slave_mode),
      slave_name(std::move(other.slave_name)),
      bootstrap_node(std::move(other.bootstrap_node)),
      args_remainder(std::move(other.args_remainder)),
      scheduler_policy(other.scheduler_policy),
      scheduler_max_threads(other.scheduler_max_threads),
      scheduler_max_throughput(other.scheduler_max_throughput),
      scheduler_enable_profiling(std::move(other.scheduler_enable_profiling)),
      scheduler_profiling_ms_resolution(
        other.scheduler_profiling_ms_resolution),
      scheduler_profiling_output_file(other.scheduler_profiling_output_file),
      work_stealing_aggressive_poll_attempts(
        other.work_stealing_aggressive_poll_attempts),
      work_stealing_aggressive_steal_interval(
        other.work_stealing_aggressive_steal_interval),
      work_stealing_moderate_poll_attempts(
        other.work_stealing_moderate_poll_attempts),
      work_stealing_moderate_steal_interval(
        other.work_stealing_moderate_steal_interval),
      work_stealing_moderate_sleep_duration_us(
        other.work_stealing_moderate_sleep_duration_us),
      work_stealing_relaxed_steal_interval(
        other.work_stealing_relaxed_steal_interval),
      work_stealing_relaxed_sleep_duration_us(
        other.work_stealing_relaxed_sleep_duration_us),
      logger_file_name(std::move(other.logger_file_name)),
      logger_file_format(std::move(other.logger_file_format)),
      logger_console(other.logger_console),
      logger_console_format(std::move(other.logger_console_format)),
      logger_component_filter(std::move(other.logger_component_filter)),
      logger_verbosity(other.logger_verbosity),
      logger_inline_output(other.logger_inline_output),
      logger_filename(logger_file_name),
      logger_filter(logger_component_filter),
      middleman_network_backend(other.middleman_network_backend),
      middleman_app_identifier(std::move(other.middleman_app_identifier)),
      middleman_enable_automatic_connections(
        other.middleman_enable_automatic_connections),
      middleman_max_consecutive_reads(other.middleman_max_consecutive_reads),
      middleman_heartbeat_interval(other.middleman_heartbeat_interval),
      middleman_detach_utility_actors(other.middleman_detach_utility_actors),
      middleman_detach_multiplexer(other.middleman_detach_multiplexer),
      opencl_device_ids(std::move(other.opencl_device_ids)),
      openssl_certificate(std::move(other.openssl_certificate)),
      openssl_key(std::move(other.openssl_key)),
      openssl_passphrase(std::move(other.openssl_passphrase)),
      openssl_capath(std::move(other.openssl_capath)),
      openssl_cafile(std::move(other.openssl_cafile)),
      value_factories_by_name(std::move(other.value_factories_by_name)),
      value_factories_by_rtti(std::move(other.value_factories_by_rtti)),
      actor_factories(std::move(other.actor_factories)),
      module_factories(std::move(other.module_factories)),
      hook_factories(std::move(other.hook_factories)),
      group_module_factories(std::move(other.group_module_factories)),
      type_names_by_rtti(std::move(other.type_names_by_rtti)),
      error_renderers(std::move(other.error_renderers)),
      named_actor_configs(std::move(other.named_actor_configs)),
      slave_mode_fun(other.slave_mode_fun),
      custom_options_(std::move(other.custom_options_)),
      options_(std::move(other.options_)) {
  // nop
}

std::string
actor_system_config::make_help_text(const std::vector<message::cli_arg>& xs) {
  auto is_no_caf_option = [](const message::cli_arg& arg) {
    return arg.name.compare(0, 4, "caf#") != 0;
  };
  auto op = [](size_t tmp, const message::cli_arg& arg) {
    return std::max(tmp, arg.helptext.size());
  };
  // maximum string lenght of all options
  auto name_width = std::accumulate(xs.begin(), xs.end(), size_t{0}, op);
  // iterators to the vector with respect to partition point
  auto first = xs.begin();
  auto last = xs.end();
  auto sep = std::find_if(first, last, is_no_caf_option);
  // output stream
  std::ostringstream oss;
  oss << std::left;
  oss << "CAF Options:" << std::endl;
  for (auto i = first; i != sep; ++i) {
    oss << "  ";
    oss.width(static_cast<std::streamsize>(name_width));
    oss << i->helptext << "  : " << i->text << std::endl;
  }
  if (sep != last) {
    oss << std::endl;
    oss << "Application Options:" << std::endl;
    for (auto i = sep; i != last; ++i) {
      oss << "  ";
      oss.width(static_cast<std::streamsize>(name_width));
      oss << i->helptext << "  : " << i->text << std::endl;
    }
  }
  return oss.str();
}

actor_system_config& actor_system_config::parse(int argc, char** argv,
                                                const char* ini_file_cstr) {
  message args;
  if (argc > 1)
    args = message_builder(argv + 1, argv + argc).move_to_message();
  // set default config file name if not set by user
  if (ini_file_cstr == nullptr)
    ini_file_cstr = "caf-application.ini";
  std::string config_file_name;
  // CLI file name has priority over default file name
  args.extract_opts({
    {"caf#config-file", "", config_file_name}
  });
  if (config_file_name.empty())
    config_file_name = ini_file_cstr;
  std::ifstream ini{config_file_name};
  return parse(args, ini);
}

actor_system_config& actor_system_config::parse(int argc, char** argv,
                                                std::istream& ini) {
  message args;
  if (argc > 1)
    args = message_builder(argv + 1, argv + argc).move_to_message();
  return parse(args, ini);
}

actor_system_config& actor_system_config::parse(message& args,
                                                std::istream& ini) {
  // (2) content of the INI file overrides hard-coded defaults
  if (ini.good()) {
    using conf_sink = std::function<void (size_t, config_value&,
                                          optional<std::ostream&>)>;
    using conf_sinks = std::unordered_map<std::string, conf_sink>;
    using conf_mapping = std::pair<option_vector, conf_sinks>;
    hash_map<std::string, conf_mapping> ovs;
    auto nac_sink = [&](size_t ln, const std::string& nm, config_value& cv) {
      std::string actor_name{nm.begin(), std::find(nm.begin(), nm.end(), '.')};
      auto ac = named_actor_configs.find(actor_name);
      if (ac == named_actor_configs.end())
        ac = named_actor_configs.emplace(actor_name,
                                         named_actor_config{}).first;
      auto& ov = ovs[actor_name];
      if (ov.first.empty()) {
        opt_group(ov.first, ac->first.c_str())
        .add(ac->second.strategy, "strategy", "")
        .add(ac->second.low_watermark, "low-watermark", "")
        .add(ac->second.max_pending, "max-pending", "");
        for (auto& opt : ov.first)
          ov.second.emplace(opt->full_name(), opt->to_sink());
      }
      auto i = ov.second.find(nm);
      if (i != ov.second.end())
        i->second(ln, cv, none);
      else
        std::cerr << "error in line " << ln
                  << R"(: unrecognized parameter name ")" << nm << R"(")"
                  << std::endl;
    };
    actor_system_config_reader consumer{options_, custom_options_, nac_sink};
    detail::parse_ini(ini, consumer, std::cerr);
  }
  // (3) CLI options override the content of the INI file
  std::string dummy; // caf#config-file either ignored or already open
  std::vector<message::cli_arg> cargs;
  for (auto& x : options_)
    cargs.emplace_back(x->to_cli_arg(true));
  cargs.emplace_back("caf#dump-config", "print config in INI format to stdout");
  //cargs.emplace_back("caf#help", "print this text");
  cargs.emplace_back("caf#config-file", "parse INI file", dummy);
  cargs.emplace_back("caf#slave-mode", "run in slave mode");
  cargs.emplace_back("caf#slave-name", "set name for this slave", slave_name);
  cargs.emplace_back("caf#bootstrap-node", "set bootstrapping", bootstrap_node);
  for (auto& x : custom_options_)
    cargs.emplace_back(x->to_cli_arg(false));
  using std::placeholders::_1;
  auto res = args.extract_opts(std::move(cargs),
                               std::bind(&actor_system_config::make_help_text,
                                         this, _1));
  using std::cerr;
  using std::cout;
  using std::endl;
  args_remainder = std::move(res.remainder);
  if (!res.error.empty()) {
    cli_helptext_printed = true;
    std::cerr << res.error << endl;
    return *this;
  }
  if (res.opts.count("help") != 0u) {
    cli_helptext_printed = true;
    cout << res.helptext << endl;
    return *this;
  }
  if (res.opts.count("caf#slave-mode") != 0u) {
    slave_mode = true;
    if (slave_name.empty())
      std::cerr << "running in slave mode but no name was configured" << endl;
    if (bootstrap_node.empty())
      std::cerr << "running in slave mode without bootstrap node" << endl;
  }
  auto verify_atom_opt = [](std::initializer_list<atom_value> xs, atom_value& x,
                            const char* xname) {
    if (std::find(xs.begin(), xs.end(), x) == xs.end()) {
      cerr << "[WARNING] invalid value for " << xname
           << " defined, falling back to "
           << deep_to_string(*xs.begin()) << endl;
      x = *xs.begin();
    }
  };
  verify_atom_opt({atom("default"),
#                  ifdef CAF_USE_ASIO
                   atom("asio")
#                  endif
                  }, middleman_network_backend, "middleman.network-backend");
  verify_atom_opt({atom("stealing"), atom("sharing"), atom("testing")},
                  scheduler_policy, "scheduler.policy ");
  if (res.opts.count("caf#dump-config") != 0u) {
    cli_helptext_printed = true;
    std::string category;
    for_each_option([&](const config_option& x) {
      if (category != x.category()) {
        category = x.category();
        cout << "[" << category << "]" << endl;
      }
      cout << x.name() << "=" << x.to_string() << endl;
    });
  }
  return *this;
}

actor_system_config&
actor_system_config::add_actor_factory(std::string name, actor_factory fun) {
  actor_factories.emplace(std::move(name), std::move(fun));
  return *this;
}

actor_system_config&
actor_system_config::add_error_category(atom_value x, error_renderer y) {
  error_renderers[x] = y;
  return *this;
}

actor_system_config& actor_system_config::set(const char* cn, config_value cv) {
  auto e = options_.end();
  auto i = std::find_if(options_.begin(), e, [cn](const option_ptr& ptr) {
    return ptr->full_name() == cn;
  });
  if (i != e) {
    auto f = (*i)->to_sink();
    f(0, cv, none);
  }
  return *this;
}

std::string actor_system_config::render_sec(uint8_t x, atom_value,
                                            const message& xs) {
  auto tmp = static_cast<sec>(x);
  return deep_to_string(meta::type_name("system_error"), tmp,
                        meta::omittable_if_empty(), xs);
}

std::string actor_system_config::render_exit_reason(uint8_t x, atom_value,
                                                    const message& xs) {
  auto tmp = static_cast<exit_reason>(x);
  return deep_to_string(meta::type_name("exit_reason"), tmp,
                        meta::omittable_if_empty(), xs);
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <vector>

#include "caf/message_builder.hpp"
#include "caf/message_handler.hpp"

#include "caf/detail/dynamic_message_data.hpp"

namespace caf {

message_builder::message_builder() {
  init();
}

message_builder::~message_builder() {
  // nop
}

void message_builder::init() {
  // this should really be done by delegating
  // constructors, but we want to support
  // some compilers without that feature...
  data_ = make_counted<detail::dynamic_message_data>();
}

void message_builder::clear() {
  data()->clear();
}

size_t message_builder::size() const {
  return data()->size();
}

bool message_builder::empty() const {
  return size() == 0;
}

message_builder& message_builder::emplace(type_erased_value_ptr x) {
  data()->append(std::move(x));
  return *this;
}

message message_builder::to_message() const {
  // this const_cast is safe, because the message is
  // guaranteed to detach its data before modifying it
  detail::message_data::cow_ptr ptr;
  ptr.reset(const_cast<detail::dynamic_message_data*>(data()));
  return message{std::move(ptr)};
}

message message_builder::move_to_message() {
  message result;
  result.vals().reset(static_cast<detail::dynamic_message_data*>(data_.detach()), false);
  return result;
}

optional<message> message_builder::apply(message_handler handler) {
  // avoid detaching of data_ by moving the data to a message object,
  // calling message::apply and moving the data back
  message::data_ptr ptr;
  ptr.reset(static_cast<detail::dynamic_message_data*>(data_.detach()), false);
  message msg{std::move(ptr)};
  auto res = msg.apply(std::move(handler));
  data_.reset(msg.vals().release(), false);
  return res;
}

detail::dynamic_message_data* message_builder::data() {
  // detach if needed, i.e., assume further non-const
  // operations on data_ can cause race conditions if
  // someone else holds a reference to data_
  if (!data_->unique()) {
    auto tmp = static_cast<detail::dynamic_message_data*>(data_.get())->copy();
    data_.reset(tmp.release(), false);
  }
  return static_cast<detail::dynamic_message_data*>(data_.get());
}

const detail::dynamic_message_data* message_builder::data() const {
  return static_cast<const detail::dynamic_message_data*>(data_.get());
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/random_gatherer.hpp"

namespace caf {

random_gatherer::random_gatherer(local_actor* selfptr) : super(selfptr) {
  // nop
}

random_gatherer::~random_gatherer() {
  // nop
}

void random_gatherer::assign_credit(long available) {
    CAF_LOG_TRACE(CAF_ARG(available));
    for (auto& kvp : assignment_vec_) {
      auto x = std::min(available, max_credit() - kvp.first->assigned_credit);
      available -= x;
      kvp.second = x;
    }
    emit_credits();
}

long random_gatherer::initial_credit(long available, path_type*) {
  return std::min(available, max_credit());
}

/*
void random_gatherer::fill_assignment_vec(long downstream_credit) {
  CAF_LOG_TRACE(CAF_ARG(downstream_credit));
  // Zero-out assignment vector if no credit is available at downstream paths.
  if (downstream_credit <= 0) {
    for (auto& x : assignment_vec_)
      x.second = 0;
    return;
  }
  // Assign credit to upstream paths until no more credit is available. We must
  // make sure to write to each element in the vector.
  auto available = downstream_credit;
  for (auto& p : assignment_vec_) {
    auto& x = p.first->assigned_credit; // current value
    auto y = std::min(max_credit(), x + available);
    auto delta = y - x;
    if (delta >= min_credit_assignment()) {
      p.second = delta;
      available -= delta;
    } else {
      p.second = 0;
    }
  }
}
*/

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/stream_gatherer.hpp"

#include "caf/actor_addr.hpp"
#include "caf/actor_cast.hpp"
#include "caf/inbound_path.hpp"
#include "caf/actor_control_block.hpp"

namespace caf {

stream_gatherer::~stream_gatherer() {
  // nop
}

bool stream_gatherer::remove_path(const stream_id& sid,
                                  const strong_actor_ptr& x, error reason,
                                  bool silent) {
  return remove_path(sid, actor_cast<actor_addr>(x), std::move(reason), silent);
}

stream_gatherer::path_type* stream_gatherer::find(const stream_id& sid,
                                                  const strong_actor_ptr& x) {
  return find(sid, actor_cast<actor_addr>(x));
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/detail/simple_actor_clock.hpp"

#include "caf/actor_cast.hpp"
#include "caf/sec.hpp"
#include "caf/system_messages.hpp"

namespace caf {
namespace detail {

bool simple_actor_clock::receive_predicate::
operator()(const secondary_map::value_type& x) const noexcept {
  return holds_alternative<receive_timeout>(x.second->second);
}

bool simple_actor_clock::request_predicate::
operator()(const secondary_map::value_type& x) const noexcept {
  if (holds_alternative<request_timeout>(x.second->second)) {
    auto& rt = get<request_timeout>(x.second->second);
    return rt.id == id;
  }
  return false;
}

void simple_actor_clock::visitor::operator()(receive_timeout& x) {
  CAF_ASSERT(x.self != nullptr);
  x.self->get()->eq_impl(make_message_id(), x.self, nullptr,
                         timeout_msg{x.id});
  receive_predicate pred;
  thisptr->drop_lookup(x.self->get(), pred);
}

void simple_actor_clock::visitor::operator()(request_timeout& x) {
  CAF_ASSERT(x.self != nullptr);
  x.self->get()->eq_impl(x.id, x.self, nullptr, sec::request_timeout);
  request_predicate pred{x.id};
  thisptr->drop_lookup(x.self->get(), pred);
}

void simple_actor_clock::visitor::operator()(actor_msg& x) {
  x.receiver->enqueue(std::move(x.content), nullptr);
}

void simple_actor_clock::visitor::operator()(group_msg& x) {
  x.target->eq_impl(make_message_id(), std::move(x.sender), nullptr,
                    std::move(x.content));
}

void simple_actor_clock::set_receive_timeout(time_point t, abstract_actor* self,
                                             uint32_t id) {
  receive_predicate pred;
  auto i = lookup(self, pred);
  auto sptr = actor_cast<strong_actor_ptr>(self);
  if (i != actor_lookup_.end()) {
    schedule_.erase(i->second);
    i->second = schedule_.emplace(t, receive_timeout{std::move(sptr), id});
  } else {
    auto j = schedule_.emplace(t, receive_timeout{std::move(sptr), id});
    actor_lookup_.emplace(self, j);
  }
}

void simple_actor_clock::set_request_timeout(time_point t, abstract_actor* self,
                                             message_id id) {
  request_predicate pred{id};
  auto i = lookup(self, pred);
  auto sptr = actor_cast<strong_actor_ptr>(self);
  if (i != actor_lookup_.end()) {
    schedule_.erase(i->second);
    i->second = schedule_.emplace(t, request_timeout{std::move(sptr), id});
  } else {
    auto j = schedule_.emplace(t, request_timeout{std::move(sptr), id});
    actor_lookup_.emplace(self, j);
  }
}

void simple_actor_clock::cancel_receive_timeout(abstract_actor* self) {
  receive_predicate pred;
  cancel(self, pred);
}

void simple_actor_clock::cancel_request_timeout(abstract_actor* self,
                                                message_id id) {
  request_predicate pred{id};
  cancel(self, pred);
}

void simple_actor_clock::cancel_timeouts(abstract_actor* self) {
  auto range = actor_lookup_.equal_range(self);
  if (range.first == range.second)
    return;
  for (auto i = range.first; i != range.second; ++i)
    schedule_.erase(i->second);
  actor_lookup_.erase(range.first, range.second);
}

void simple_actor_clock::schedule_message(time_point t,
                                          strong_actor_ptr receiver,
                                          mailbox_element_ptr content) {
  schedule_.emplace(t, actor_msg{std::move(receiver), std::move(content)});
}

void simple_actor_clock::schedule_message(time_point t, group target,
                                          strong_actor_ptr sender,
                                          message content) {
  schedule_.emplace(
    t, group_msg{std::move(target), std::move(sender), std::move(content)});
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/message.hpp"

#include <iostream>
#include <utility>
#include <utility>

#include "caf/serializer.hpp"
#include "caf/actor_system.hpp"
#include "caf/deserializer.hpp"
#include "caf/message_builder.hpp"
#include "caf/message_handler.hpp"
#include "caf/string_algorithms.hpp"

#include "caf/detail/decorated_tuple.hpp"
#include "caf/detail/concatenated_tuple.hpp"
#include "caf/detail/dynamic_message_data.hpp"

namespace caf {

message::message(none_t) noexcept {
  // nop
}

message::message(message&& other) noexcept : vals_(std::move(other.vals_)) {
  // nop
}

message::message(data_ptr ptr) noexcept : vals_(std::move(ptr)) {
  // nop
}

message& message::operator=(message&& other) noexcept {
  vals_.swap(other.vals_);
  return *this;
}

message::~message() {
  // nop
}

void message::reset(raw_ptr new_ptr, bool add_ref) noexcept {
  vals_.reset(new_ptr, add_ref);
}

void message::swap(message& other) noexcept {
  vals_.swap(other.vals_);
}

void* message::get_mutable(size_t p) {
  CAF_ASSERT(vals_);
  return vals_->get_mutable(p);
}

message message::copy(const type_erased_tuple& xs) {
  message_builder mb;
  for (size_t i = 0; i < xs.size(); ++i)
    mb.emplace(xs.copy(i));
  return mb.move_to_message();
}

message& message::operator+=(const message& x) {
  auto tmp = *this + x;
  swap(tmp);
  return *this;
}

message message::drop(size_t n) const {
  CAF_ASSERT(vals_);
  if (n == 0)
    return *this;
  if (n >= size())
    return message{};
  std::vector<size_t> mapping (size() - n);
  size_t i = n;
  std::generate(mapping.begin(), mapping.end(), [&] { return i++; });
  return message {detail::decorated_tuple::make(vals_, mapping)};
}

message message::drop_right(size_t n) const {
  CAF_ASSERT(vals_);
  if (n == 0) {
    return *this;
  }
  if (n >= size()) {
    return message{};
  }
  std::vector<size_t> mapping(size() - n);
  std::iota(mapping.begin(), mapping.end(), size_t{0});
  return message{detail::decorated_tuple::make(vals_, std::move(mapping))};
}

message message::slice(size_t pos, size_t n) const {
  auto s = size();
  if (pos >= s) {
    return message{};
  }
  std::vector<size_t> mapping(std::min(s - pos, n));
  std::iota(mapping.begin(), mapping.end(), pos);
  return message{detail::decorated_tuple::make(vals_, std::move(mapping))};
}

optional<message> message::apply(message_handler handler) {
  return handler(*this);
}

message message::extract_impl(size_t start, message_handler handler) const {
  auto s = size();
  for (size_t i = start; i < s; ++i) {
    for (size_t n = (s - i) ; n > 0; --n) {
      auto next_slice = slice(i, n);
      auto res = handler(next_slice);
      if (res) {
        std::vector<size_t> mapping(s);
        std::iota(mapping.begin(), mapping.end(), size_t{0});
        auto first = mapping.begin() + static_cast<ptrdiff_t>(i);
        auto last = first + static_cast<ptrdiff_t>(n);
        mapping.erase(first, last);
        if (mapping.empty()) {
          return message{};
        }
        message next{detail::decorated_tuple::make(vals_, std::move(mapping))};
        return next.extract_impl(i, handler);
      }
    }
  }
  return *this;
}

message message::extract(message_handler handler) const {
  return extract_impl(0, std::move(handler));
}

message::cli_res message::extract_opts(std::vector<cli_arg> xs,
                                       const help_factory& f, bool no_help) const {
  std::string helpstr;
  auto make_error = [&](std::string err) -> cli_res {
    return {*this, std::set<std::string>{}, std::move(helpstr), std::move(err)};
  };
  // add default help item if user did not specify any help option
  auto pred = [](const cli_arg& arg) -> bool {
    std::vector<std::string> s;
    split(s, arg.name, is_any_of(","), token_compress_on);
    if (s.empty())
      return false;
    auto has_short_help = [](const std::string& opt) {
      return opt.find_first_of("h?") != std::string::npos;
    };
    return s[0] == "help"
           || std::find_if(s.begin() + 1, s.end(), has_short_help) != s.end();
  };
  if (!no_help && std::none_of(xs.begin(), xs.end(), pred)) {
    xs.emplace_back("help,h,?", "print this text");
  }
  std::map<std::string, cli_arg*> shorts;
  std::map<std::string, cli_arg*> longs;
  for (auto& cliarg : xs) {
    std::vector<std::string> s;
    split(s, cliarg.name, is_any_of(","), token_compress_on);
    if (s.empty()) {
      return make_error("invalid option name: " + cliarg.name);
    }
    longs["--" + s.front()] = &cliarg;
    for (size_t i = 1; i < s.size(); ++i) {
      if (s[i].size() != 1) {
        return make_error("invalid short option name: " + s[i]);
      }
      shorts["-" + s[i]] = &cliarg;
    }
    // generate helptext for this item
    auto& ht = cliarg.helptext;
    if (s.size() == 1) {
      ht += "--";
      ht += s.front();
    } else {
      ht += "-";
      ht += s[1];
      ht += " [";
      for (size_t i = 2; i < s.size(); ++i) {
        ht += "-";
        ht += s[i];
        ht += ",";
      }
      ht += "--";
      ht += s.front();
      ht += "]";
    }
    if (cliarg.fun) {
      ht += " arg";
    }
  }
  if (f) {
    helpstr = f(xs);
  } else {
    auto op = [](size_t tmp, const cli_arg& arg) {
      return std::max(tmp, arg.helptext.size());
    };
    auto name_width = std::accumulate(xs.begin(), xs.end(), size_t{0}, op);
    std::ostringstream oss;
    oss << std::left;
    oss << "Allowed options:" << std::endl;
    for (auto& ca : xs) {
      oss << "  ";
      oss.width(static_cast<std::streamsize>(name_width));
      oss << ca.helptext << "  : " << ca.text << std::endl;
    }
    helpstr = oss.str();
  }
  std::set<std::string> opts;
  auto insert_opt_name = [&](const cli_arg* ptr) {
    auto separator = ptr->name.find(',');
    if (separator == std::string::npos) {
      opts.insert(ptr->name);
    } else {
      opts.insert(ptr->name.substr(0, separator));
    }
  };
  // we can't `return make_error(...)` from inside `extract`, hence we
  // store any occurred error in a temporary variable returned at the end
  std::string error;
  bool skip_remainder = false;
  auto res = extract({
    [&](const std::string& arg) -> optional<skip_t> {
      if (skip_remainder)
        return skip();
      if (arg == "--") {
        skip_remainder = true;
        // drop frist remainder indicator
        return none;
      }
      if (arg.empty() || arg.front() != '-') {
        return skip();
      }
      auto i = shorts.find(arg.substr(0, 2));
      if (i != shorts.end()) {
        if (i->second->fun) {
          // this short opt expects two arguments
          if (arg.size() > 2) {
             // this short opt comes with a value (no space), e.g., -x2
            if (!i->second->fun(arg.substr(2))) {
              error = "invalid value for " + i->second->name + ": " + arg;
              return skip();
            }
            insert_opt_name(i->second);
            return none;
          }
          // no value given, try two-argument form below
          return skip();
        }
        if (i->second->flag != nullptr)
          *i->second->flag = true;
        insert_opt_name(i->second);
        return none;
      }
      auto eq_pos = arg.find('=');
      auto j = longs.find(arg.substr(0, eq_pos));
      if (j != longs.end()) {
        if (j->second->fun) {
          if (eq_pos == std::string::npos) {
            error =  "missing argument to " + arg;
            return skip();
          }
          if (!j->second->fun(arg.substr(eq_pos + 1))) {
            error = "invalid value for " + j->second->name + ": " + arg;
            return skip();
          }
          insert_opt_name(j->second);
          return none;
        }
        if (j->second->flag != nullptr)
          *j->second->flag = true;
        insert_opt_name(j->second);
        return none;
      }
      error = "unknown command line option: " + arg;
      return skip();
    },
    [&](const std::string& arg1,
        const std::string& arg2) -> optional<skip_t> {
      if (arg1 == "--") {
        return skip();
      }
      if (skip_remainder)
        return skip();
      if (arg1.size() < 2 || arg1[0] != '-' || arg1[1] == '-') {
        return skip();
      }
      auto i = shorts.find(arg1.substr(0, 2));
      if (i != shorts.end()) {
        if (!i->second->fun || arg1.size() > 2) {
          // this short opt either expects no argument or comes with a value
          // (no  space), e.g., -x2, so we have to parse it with the
          // one-argument form above
          return skip();
        }
        CAF_ASSERT(arg1.size() == 2);
        if (!i->second->fun(arg2)) {
          error = "invalid value for option " + i->second->name + ": " + arg2;
          return skip();
        }
        insert_opt_name(i->second);
        return none;
      }
      error = "unknown command line option: " + arg1;
      return skip();
    }
  });
  return {res, std::move(opts), std::move(helpstr), std::move(error)};
}

message::cli_arg::cli_arg(std::string nstr, std::string tstr)
    : name(std::move(nstr)),
      text(std::move(tstr)),
      flag(nullptr) {
  // nop
}

message::cli_arg::cli_arg(std::string nstr, std::string tstr, bool& arg)
  : name(std::move(nstr)),
    text(std::move(tstr)),
    flag(&arg) {
  // nop
}

message::cli_arg::cli_arg(std::string nstr, std::string tstr, consumer f)
    : name(std::move(nstr)),
      text(std::move(tstr)),
      fun(std::move(f)),
      flag(nullptr) {
  // nop
}

message::cli_arg::cli_arg(std::string nstr, std::string tstr, atom_value& arg)
    : name(std::move(nstr)),
      text(std::move(tstr)),
      fun([&arg](const std::string& str) -> bool {
        if (str.size() <= 10) {
          arg = static_cast<atom_value>(detail::atom_val(str.c_str()));
          return true;
        }
        return false;
      }),
      flag(nullptr) {
  // nop
}

message::cli_arg::cli_arg(std::string nstr, std::string tstr, std::string& arg)
    : name(std::move(nstr)),
      text(std::move(tstr)),
      fun([&arg](const std::string& str) -> bool {
            arg = str;
            return true;
          }),
      flag(nullptr) {
  // nop
}

message::cli_arg::cli_arg(std::string nstr, std::string tstr,
                          std::vector<std::string>& arg)
    : name(std::move(nstr)),
      text(std::move(tstr)),
      fun([&arg](const std::string& str) -> bool {
        arg.push_back(str);
        return true;
      }),
      flag(nullptr) {
  // nop
}

message message::concat_impl(std::initializer_list<data_ptr> xs) {
  auto not_nullptr = [](const data_ptr& ptr) { return ptr.get() != nullptr; };
  switch (std::count_if(xs.begin(), xs.end(), not_nullptr)) {
    case 0:
      return message{};
    case 1:
      return message{*std::find_if(xs.begin(), xs.end(), not_nullptr)};
    default:
      return message{detail::concatenated_tuple::make(xs)};
  }
}

error inspect(serializer& sink, message& msg) {
  if (sink.context() == nullptr)
    return sec::no_context;
  // build type name
  uint16_t zero = 0;
  std::string tname = "@<>";
  if (msg.empty())
    return error::eval([&] { return sink.begin_object(zero, tname); },
                       [&] { return sink.end_object(); });
  auto& types = sink.context()->system().types();
  auto n = msg.size();
  for (size_t i = 0; i < n; ++i) {
    auto rtti = msg.cvals()->type(i);
    auto ptr = types.portable_name(rtti);
    if (ptr == nullptr) {
      std::cerr << "[ERROR]: cannot serialize message because a type was "
                   "not added to the types list, typeid name: "
                << (rtti.second != nullptr ? rtti.second->name() : "-not-available-")
                << std::endl;
      return make_error(sec::unknown_type,
                        rtti.second != nullptr ? rtti.second->name() : "-not-available-");
    }
    tname += '+';
    tname += *ptr;
  }
  auto save_loop = [&]() -> error {
    for (size_t i = 0; i < n; ++i) {
      auto e = msg.cvals()->save(i, sink);
      if (e)
        return e;
    }
    return none;
  };
  return error::eval([&] { return sink.begin_object(zero, tname); },
                     [&] { return save_loop();  },
                     [&] { return sink.end_object(); });
}

error inspect(deserializer& source, message& msg) {
  if (source.context() == nullptr)
    return sec::no_context;
  uint16_t zero;
  std::string tname;
  error err;
  err = source.begin_object(zero, tname);
  if (err)
    return err;
  if (zero != 0)
    return sec::unknown_type;
  if (tname == "@<>") {
    msg = message{};
    return none;
  }
  if (tname.compare(0, 4, "@<>+") != 0)
    return sec::unknown_type;
  // iterate over concatenated type names
  auto eos = tname.end();
  auto next = [&](std::string::iterator iter) {
    return std::find(iter, eos, '+');
  };
  auto& types = source.context()->system().types();
  auto dmd = make_counted<detail::dynamic_message_data>();
  std::string tmp;
  std::string::iterator i = next(tname.begin());
  ++i; // skip first '+' sign
  do {
    auto n = next(i);
    tmp.assign(i, n);
    auto ptr = types.make_value(tmp);
    if (!ptr)
      return make_error(sec::unknown_type, tmp);
    err = ptr->load(source);
    if (err)
      return err;
    dmd->append(std::move(ptr));
    if (n != eos)
      i = n + 1;
    else
      i = eos;
  } while (i != eos);
  err = source.end_object();
  if (err)
    return err;
  message result{std::move(dmd)};
  msg.swap(result);
  return none;
}

std::string to_string(const message& msg) {
  if (msg.empty())
    return "<empty-message>";
  std::string str = "(";
  str += msg.cvals()->stringify(0);
  for (size_t i = 1; i < msg.size(); ++i) {
    str += ", ";
    str += msg.cvals()->stringify(i);
  }
  str += ")";
  return str;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/type_erased_value.hpp"

namespace caf {

type_erased_value::~type_erased_value() {
  // nop
}

bool type_erased_value::matches(uint16_t nr, const std::type_info* ptr) const {
  auto tp = type();
  if (tp.first != nr)
    return false;
  if (nr == 0)
    return ptr != nullptr ? *tp.second == *ptr : false;
  return true;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/detail/thread_safe_actor_clock.hpp"

namespace caf {
namespace detail {

namespace {

using guard_type = std::unique_lock<std::mutex>;

} // namespace <anonymous>

thread_safe_actor_clock::thread_safe_actor_clock() : done_(false) {
  // nop
}

void thread_safe_actor_clock::set_receive_timeout(time_point t,
                                                  abstract_actor* self,
                                                  uint32_t id) {
  guard_type guard{mx_};
  if (!done_) {
    super::set_receive_timeout(t, self, id);
    cv_.notify_all();
  }
}

void thread_safe_actor_clock::set_request_timeout(time_point t,
                                                  abstract_actor* self,
                                                  message_id id) {
  guard_type guard{mx_};
  if (!done_) {
    super::set_request_timeout(t, self, id);
    cv_.notify_all();
  }
}

void thread_safe_actor_clock::cancel_receive_timeout(abstract_actor* self) {
  guard_type guard{mx_};
  if (!done_) {
    super::cancel_receive_timeout(self);
    cv_.notify_all();
  }
}

void thread_safe_actor_clock::cancel_request_timeout(abstract_actor* self,
                                                     message_id id) {
  guard_type guard{mx_};
  if (!done_) {
    super::cancel_request_timeout(self, id);
    cv_.notify_all();
  }
}

void thread_safe_actor_clock::cancel_timeouts(abstract_actor* self) {
  guard_type guard{mx_};
  if (!done_) {
    super::cancel_timeouts(self);
    cv_.notify_all();
  }
}

void thread_safe_actor_clock::schedule_message(time_point t,
                                               strong_actor_ptr receiver,
                                               mailbox_element_ptr content) {
  guard_type guard{mx_};
  if (!done_) {
    super::schedule_message(t, std::move(receiver), std::move(content));
    cv_.notify_all();
  }
}

void thread_safe_actor_clock::schedule_message(time_point t, group target,
                                               strong_actor_ptr sender,
                                               message content) {
  guard_type guard{mx_};
  if (!done_) {
    super::schedule_message(t, std::move(target), std::move(sender),
                            std::move(content));
    cv_.notify_all();
  }
}

void thread_safe_actor_clock::run_dispatch_loop() {
  visitor f{this};
  guard_type guard{mx_};
  while (done_ == false) {
    // Wait for non-empty schedule.
    if (schedule_.empty()) {
      cv_.wait(guard);
    } else {
      auto tout = schedule_.begin()->first;
      cv_.wait_until(guard, tout);
    }
    // Double-check whether schedule is non-empty and execute it.
    if (!schedule_.empty()) {
      auto t = now();
      auto i = schedule_.begin();
      while (i != schedule_.end() && i->first <= t) {
        visit(f, i->second);
        i = schedule_.erase(i);
      }
    }
  }
  schedule_.clear();
}

void thread_safe_actor_clock::cancel_dispatch_loop() {
  guard_type guard{mx_};
  done_ = true;
  cv_.notify_all();
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/stream_gatherer_impl.hpp"

namespace caf {

stream_gatherer_impl::stream_gatherer_impl(local_actor* selfptr)
    : super(selfptr),
      high_watermark_(40),
      min_credit_assignment_(1),
      max_credit_(50) {
  // nop
}

stream_gatherer_impl::~stream_gatherer_impl() {
  // nop
}

stream_gatherer::path_ptr
stream_gatherer_impl::add_path(const stream_id& sid, strong_actor_ptr hdl,
                               strong_actor_ptr original_stage,
                               stream_priority prio, long available_credit,
                               bool redeployable, response_promise result_cb) {
  CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(hdl) << CAF_ARG(original_stage)
                << CAF_ARG(prio) << CAF_ARG(available_credit));
  CAF_ASSERT(hdl != nullptr);
  if (find(sid, hdl) != nullptr) {
    inbound_path::emit_irregular_shutdown(self_, sid, hdl,
                                          sec::cannot_add_upstream);

    return nullptr;
  }
  auto ptr = add_path_impl(sid, std::move(hdl));
  CAF_ASSERT(ptr != nullptr);
  assignment_vec_.emplace_back(ptr, 0l);
  if (result_cb.pending())
    listeners_.emplace_back(std::move(result_cb));
  ptr->prio = prio;
  ptr->emit_ack_open(actor_cast<actor_addr>(original_stage),
                     initial_credit(available_credit, ptr), redeployable);
  return ptr;
}

bool stream_gatherer_impl::remove_path(const stream_id& sid,
                                       const actor_addr& x, error reason,
                                       bool silent) {
  CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(x)
                << CAF_ARG(reason) << CAF_ARG(silent));
  auto pred = [&](const assignment_pair& y) {
    return y.first->sid == sid && y.first->hdl == x;
  };
  auto e = assignment_vec_.end();
  auto i = std::find_if(assignment_vec_.begin(), e, pred);
  if (i != e) {
    assignment_vec_.erase(i);
    return super::remove_path(sid, x, std::move(reason), silent);
  }
  return false;
}

void stream_gatherer_impl::close(message result) {
  CAF_LOG_TRACE(CAF_ARG(result) << CAF_ARG2("remaining paths", paths_.size())
                << CAF_ARG2("listener", listeners_.size()));
  for (auto& path : paths_)
    stream_aborter::del(path->hdl, self_->address(), path->sid, aborter_type);
  paths_.clear();
  for (auto& listener : listeners_)
    listener.deliver(result);
  listeners_.clear();
}

void stream_gatherer_impl::abort(error reason) {
  for (auto& path : paths_) {
    stream_aborter::del(path->hdl, self_->address(), path->sid, aborter_type);
    path->shutdown_reason = reason;
  }
  paths_.clear();
  for (auto& listener : listeners_)
    listener.deliver(reason);
  listeners_.clear();
}

long stream_gatherer_impl::high_watermark() const {
  return high_watermark_;
}

long stream_gatherer_impl::min_credit_assignment() const {
  return min_credit_assignment_;
}

long stream_gatherer_impl::max_credit() const {
  return max_credit_;
}

void stream_gatherer_impl::high_watermark(long x) {
  high_watermark_ = x;
}

void stream_gatherer_impl::min_credit_assignment(long x) {
  min_credit_assignment_ = x;
}

void stream_gatherer_impl::max_credit(long x) {
  max_credit_ = x;
}

void stream_gatherer_impl::emit_credits() {
  for (auto& kvp : assignment_vec_)
    if (kvp.second > 0)
      kvp.first->emit_ack_batch(kvp.second);
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/match_case.hpp"

namespace caf {

match_case::~match_case() {
  // nop
}

match_case::match_case(uint32_t tt) : token_(tt) {
  // nop
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/ref_counted.hpp"

namespace caf {

ref_counted::~ref_counted() {
  // nop
}

ref_counted::ref_counted() : rc_(1) {
  // nop
}

ref_counted::ref_counted(const ref_counted&) : rc_(1) {
  // nop; don't copy reference count
}

ref_counted& ref_counted::operator=(const ref_counted&) {
  // nop; intentionally don't copy reference count
  return *this;
}

void ref_counted::deref() noexcept {
  if (unique()) {
    request_deletion(false);
    return;
  }
  if (rc_.fetch_sub(1, std::memory_order_acq_rel) == 1) {
    request_deletion(true);
  }
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/raw_event_based_actor.hpp"

#include "caf/detail/default_invoke_result_visitor.hpp"

namespace caf {

raw_event_based_actor::raw_event_based_actor(actor_config& cfg)
    : event_based_actor(cfg) {
  // nop
}

invoke_message_result raw_event_based_actor::consume(mailbox_element& x) {
  CAF_LOG_TRACE(CAF_ARG(x));
  current_element_ = &x;
  CAF_LOG_RECEIVE_EVENT(current_element_);
  // short-circuit awaited responses
  if (!awaited_responses_.empty()) {
    auto& pr = awaited_responses_.front();
    // skip all messages until we receive the currently awaited response
    if (x.mid != pr.first)
      return im_skipped;
    if (!pr.second(x.content())) {
      // try again with error if first attempt failed
      auto msg = make_message(make_error(sec::unexpected_response,
                                         x.move_content_to_message()));
      pr.second(msg);
    }
    awaited_responses_.pop_front();
    return im_success;
  }
  // handle multiplexed responses
  if (x.mid.is_response()) {
    auto mrh = multiplexed_responses_.find(x.mid);
    // neither awaited nor multiplexed, probably an expired timeout
    if (mrh == multiplexed_responses_.end())
      return im_dropped;
    if (!mrh->second(x.content())) {
      // try again with error if first attempt failed
      auto msg = make_message(make_error(sec::unexpected_response,
                                         x.move_content_to_message()));
      mrh->second(msg);
    }
    multiplexed_responses_.erase(mrh);
    return im_success;
  }
  auto& content = x.content();
  //  handle timeout messages
  if (x.content().type_token() == make_type_token<timeout_msg>()) {
    auto& tm = content.get_as<timeout_msg>(0);
    auto tid = tm.timeout_id;
    CAF_ASSERT(!x.mid.valid());
    if (is_active_timeout(tid)) {
      CAF_LOG_DEBUG("handle timeout message");
      if (bhvr_stack_.empty())
        return im_dropped;
      bhvr_stack_.back().handle_timeout();
      return im_success;
    }
    CAF_LOG_DEBUG("dropped expired timeout message");
    return im_dropped;
  }
  // handle everything else as ordinary message
  detail::default_invoke_result_visitor<event_based_actor> visitor{this};
  bool skipped = false;
  auto had_timeout = getf(has_timeout_flag);
  if (had_timeout)
    unsetf(has_timeout_flag);
  // restore timeout at scope exit if message was skipped
  auto timeout_guard = detail::make_scope_guard([&] {
    if (skipped && had_timeout)
      setf(has_timeout_flag);
  });
  auto call_default_handler = [&] {
    auto sres = call_handler(default_handler_, this, x);
    switch (sres.flag) {
      default:
        break;
      case rt_error:
      case rt_value:
        visitor.visit(sres);
        break;
      case rt_skip:
        skipped = true;
    }
  };
  if (bhvr_stack_.empty()) {
    call_default_handler();
    return !skipped ? im_success : im_skipped;
  }
  auto& bhvr = bhvr_stack_.back();
  switch (bhvr(visitor, x.content())) {
    default:
      break;
    case match_case::skip:
      skipped = true;
      break;
    case match_case::no_match:
      call_default_handler();
  }
  return !skipped ? im_success : im_skipped;
  // should be unreachable
  CAF_CRITICAL("invalid message type");
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/timestamp.hpp"

namespace caf {

timestamp make_timestamp() {
  return std::chrono::system_clock::now();
}

std::string timestamp_to_string(const timestamp& x) {
  return std::to_string(x.time_since_epoch().count());
}

void append_timestamp_to_string(std::string& x, const timestamp& y) {
  x += std::to_string(y.time_since_epoch().count());
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/stream_manager.hpp"

#include "caf/sec.hpp"
#include "caf/error.hpp"
#include "caf/logger.hpp"
#include "caf/message.hpp"
#include "caf/expected.hpp"
#include "caf/actor_addr.hpp"
#include "caf/actor_cast.hpp"
#include "caf/inbound_path.hpp"
#include "caf/outbound_path.hpp"
#include "caf/stream_gatherer.hpp"
#include "caf/stream_scatterer.hpp"
#include "caf/actor_control_block.hpp"

namespace caf {

stream_manager::~stream_manager() {
  // nop
}

error stream_manager::open(const stream_id& sid, strong_actor_ptr hdl,
                           strong_actor_ptr original_stage,
                           stream_priority prio, bool redeployable,
                           response_promise result_cb) {
  CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(hdl) << CAF_ARG(original_stage)
                << CAF_ARG(prio) << CAF_ARG(redeployable));
  if (hdl == nullptr)
    return sec::invalid_argument;
  if (in().add_path(sid, hdl, std::move(original_stage), prio,
                    out().credit(), redeployable, std::move(result_cb))
      != nullptr)
    return none;
  return sec::cannot_add_upstream;
}

error stream_manager::ack_open(const stream_id& sid,
                               const actor_addr& rebind_from,
                               strong_actor_ptr rebind_to, long initial_demand,
                               bool redeployable) {
  CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(rebind_from) << CAF_ARG(rebind_to)
                << CAF_ARG(initial_demand) << CAF_ARG(redeployable));
  if (rebind_from == nullptr)
    return sec::invalid_argument;
  if (rebind_to == nullptr) {
    auto from_ptr = actor_cast<strong_actor_ptr>(rebind_from);
    if (from_ptr)
      out().remove_path(sid, from_ptr, sec::invalid_downstream, false);
    return sec::invalid_downstream;
  }
  auto ptr = out().confirm_path(sid, rebind_from, std::move(rebind_to),
                                initial_demand, redeployable);
  if (ptr == nullptr)
    return sec::invalid_downstream;
  downstream_demand(ptr, initial_demand);
  return none;
}

error stream_manager::batch(const stream_id& sid, const actor_addr& hdl,
                            long xs_size, message& xs, int64_t xs_id) {
  CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(hdl) << CAF_ARG(xs_size)
                << CAF_ARG(xs) << CAF_ARG(xs_id));
  CAF_ASSERT(hdl != nullptr);
  auto ptr = in().find(sid, hdl);
  if (ptr == nullptr) {
    CAF_LOG_WARNING("received batch for unknown stream");
    return sec::invalid_downstream;
  }
  if (xs_size > ptr->assigned_credit) {
    CAF_LOG_WARNING("batch size of" << xs_size << "exceeds assigned credit of"
                    << ptr->assigned_credit);
    return sec::invalid_stream_state;
  }
  ptr->handle_batch(xs_size, xs_id);
  auto err = process_batch(xs);
  if (err == none) {
    push();
    auto current_size = out().buffered();
    auto desired_size = out().credit();
    if (current_size < desired_size)
      in().assign_credit(desired_size - current_size);
  }
  return err;
}

error stream_manager::ack_batch(const stream_id& sid, const actor_addr& hdl,
                                long demand, int64_t) {
  CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(hdl) << CAF_ARG(demand));
  auto ptr = out().find(sid, hdl);
  if (ptr == nullptr)
    return sec::invalid_downstream;
  ptr->open_credit += demand;
  downstream_demand(ptr, demand);
  return none;
}

error stream_manager::close(const stream_id& sid, const actor_addr& hdl) {
  CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(hdl));
  if (in().remove_path(sid, hdl, none, true) && in().closed())
    input_closed(none);
  return none;
}

error stream_manager::drop(const stream_id& sid, const actor_addr& hdl) {
  CAF_LOG_TRACE(CAF_ARG(hdl));
  if (out().remove_path(sid, hdl, none, true) && out().closed())
    output_closed(none);
  return none;
}

error stream_manager::forced_close(const stream_id& sid, const actor_addr& hdl,
                                   error reason) {
  CAF_LOG_TRACE(CAF_ARG(hdl) << CAF_ARG(reason));
  CAF_IGNORE_UNUSED(hdl);
  in().remove_path(sid, hdl, reason, true);
  abort(std::move(reason));
  return sec::unhandled_stream_error;
}

error stream_manager::forced_drop(const stream_id& sid, const actor_addr& hdl,
                                  error reason) {
  CAF_LOG_TRACE(CAF_ARG(hdl) << CAF_ARG(reason));
  CAF_IGNORE_UNUSED(hdl);
  out().remove_path(sid, hdl, reason, true);
  abort(std::move(reason));
  return sec::unhandled_stream_error;
}

void stream_manager::abort(caf::error reason) {
  CAF_LOG_TRACE(CAF_ARG(reason));
  in().abort(reason);
  input_closed(reason);
  out().abort(reason);
  output_closed(std::move(reason));
}

void stream_manager::close() {
  CAF_LOG_TRACE("");
  in().close(make_final_result());
  input_closed(none);
  out().close();
  output_closed(none);
}

bool stream_manager::add_sink(const stream_id& sid, strong_actor_ptr origin,
                        strong_actor_ptr sink_ptr,
                        mailbox_element::forwarding_stack stages,
                        message_id handshake_mid, message handshake_data,
                        stream_priority prio, bool redeployable) {
  return out().add_path(sid, std::move(origin), std::move(sink_ptr),
                        std::move(stages), handshake_mid,
                        std::move(handshake_data), prio, redeployable)
         != nullptr;
}

bool stream_manager::add_source(const stream_id& sid,
                                strong_actor_ptr source_ptr,
                                strong_actor_ptr original_stage,
                                stream_priority prio, bool redeployable,
                                response_promise result_cb) {
  // TODO: out().credit() gives the same amount of credit to any number of new
  //       sources -> feedback needed
  return in().add_path(sid, std::move(source_ptr), std::move(original_stage),
                       prio, out().credit(), redeployable, std::move(result_cb))
         != nullptr;
}

void stream_manager::push() {
  CAF_LOG_TRACE("");
  out().emit_batches();
}

bool stream_manager::generate_messages() {
  return false;
}

message stream_manager::make_final_result() {
  return none;
}

error stream_manager::process_batch(message&) {
  CAF_LOG_ERROR("stream_manager::process_batch called");
  return sec::invalid_stream_state;
}

void stream_manager::output_closed(error) {
  // nop
}

message stream_manager::make_output_token(const stream_id&) const {
  CAF_LOG_ERROR("stream_manager::make_output_token called");
  return none;
}

void stream_manager::downstream_demand(outbound_path*, long) {
  CAF_LOG_ERROR("stream_manager::downstream_demand called");
}

void stream_manager::input_closed(error) {
  // nop
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/message.hpp"
#include "caf/make_counted.hpp"

#include "caf/detail/concatenated_tuple.hpp"

#include <numeric>

namespace caf {
namespace detail {

concatenated_tuple::concatenated_tuple(std::initializer_list<cow_ptr> xs) {
  for (auto& x : xs) {
    if (x) {
      auto dptr = dynamic_cast<const concatenated_tuple*>(x.get());
      if (dptr != nullptr) {
        auto& vec = dptr->data_;
        data_.insert(data_.end(), vec.begin(), vec.end());
      } else {
        data_.push_back(std::move(x));
      }
    }
  }
  type_token_ = make_type_token();
  for (const auto& m : data_)
    for (size_t i = 0; i < m->size(); ++i)
      type_token_ = add_to_type_token(type_token_, m->type_nr(i));
  auto acc_size = [](size_t tmp, const cow_ptr& val) {
    return tmp + val->size();
  };
  size_ = std::accumulate(data_.begin(), data_.end(), size_t{0}, acc_size);
}

auto concatenated_tuple::make(std::initializer_list<cow_ptr> xs) -> cow_ptr {
  return cow_ptr{make_counted<concatenated_tuple>(xs)};
}

message_data::cow_ptr concatenated_tuple::copy() const {
  return cow_ptr(new concatenated_tuple(*this), false);
}

void* concatenated_tuple::get_mutable(size_t pos) {
  CAF_ASSERT(pos < size());
  auto selected = select(pos);
  return selected.first->get_mutable(selected.second);
}

error concatenated_tuple::load(size_t pos, deserializer& source) {
  CAF_ASSERT(pos < size());
  auto selected = select(pos);
  return selected.first->load(selected.second, source);
}

size_t concatenated_tuple::size() const noexcept {
  return size_;
}

uint32_t concatenated_tuple::type_token() const noexcept {
  return type_token_;
}

message_data::rtti_pair concatenated_tuple::type(size_t pos) const noexcept {
  CAF_ASSERT(pos < size());
  auto selected = select(pos);
  return selected.first->type(selected.second);
}

const void* concatenated_tuple::get(size_t pos) const noexcept {
  CAF_ASSERT(pos < size());
  auto selected = select(pos);
  return selected.first->get(selected.second);
}

std::string concatenated_tuple::stringify(size_t pos) const {
  CAF_ASSERT(pos < size());
  auto selected = select(pos);
  return selected.first->stringify(selected.second);
}

type_erased_value_ptr concatenated_tuple::copy(size_t pos) const {
  CAF_ASSERT(pos < size());
  auto selected = select(pos);
  return selected.first->copy(selected.second);
}

error concatenated_tuple::save(size_t pos, serializer& sink) const {
  CAF_ASSERT(pos < size());
  auto selected = select(pos);
  return selected.first->save(selected.second, sink);
}

std::pair<message_data*, size_t> concatenated_tuple::select(size_t pos) const {
  auto idx = pos;
  for (const auto& m : data_) {
    auto s = m->size();
    if (idx >= s)
      idx -= s;
    else
      return {m.get(), idx};
  }
  CAF_RAISE_ERROR("out of range: concatenated_tuple::select");
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/exit_reason.hpp"

#include "caf/message.hpp"

#include "caf/detail/enum_to_string.hpp"

namespace caf {

namespace {

const char* exit_reason_strings[] = {
  "normal",
  "unhandled_exception",
  "unknown",
  "out_of_workers",
  "user_shutdown",
  "kill",
  "remote_link_unreachable",
  "unreachable"
};

} // namespace <anonymous>


std::string to_string(exit_reason x) {
  return detail::enum_to_string(x, exit_reason_strings);
}

error make_error(exit_reason x) {
  return {static_cast<uint8_t>(x), atom("exit")};
}

error make_error(exit_reason x, message context) {
  return {static_cast<uint8_t>(x), atom("exit"), std::move(context)};
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#include <limits>
#include <thread>

#include "caf/detail/shared_spinlock.hpp"

#include "caf/detail/cas_weak.hpp"

namespace {

inline long min_long() {
  return std::numeric_limits<long>::min();
}

} // namespace <anonymous>

namespace caf {
namespace detail {

shared_spinlock::shared_spinlock() : flag_(0) {
  // nop
}

void shared_spinlock::lock() {
  long v = flag_.load();
  for (;;) {
    if (v != 0) {
      v = flag_.load();
    } else if (cas_weak(&flag_, &v, min_long())) {
      return;
    }
    // else: next iteration
  }
}

void shared_spinlock::lock_upgrade() {
  lock_shared();
}

void shared_spinlock::unlock_upgrade() {
  unlock_shared();
}

void shared_spinlock::unlock_upgrade_and_lock() {
  unlock_shared();
  lock();
}

void shared_spinlock::unlock_and_lock_upgrade() {
  unlock();
  lock_upgrade();
}

void shared_spinlock::unlock() {
  flag_.store(0);
}

bool shared_spinlock::try_lock() {
  long v = flag_.load();
  return (v == 0) ? cas_weak(&flag_, &v, min_long()) : false;
}

void shared_spinlock::lock_shared() {
  long v = flag_.load();
  for (;;) {
    if (v < 0) {
      // std::this_thread::yield();
      v = flag_.load();
    } else if (cas_weak(&flag_, &v, v + 1)) {
      return;
    }
    // else: next iteration
  }
}

void shared_spinlock::unlock_shared() {
  flag_.fetch_sub(1);
}

bool shared_spinlock::try_lock_shared() {
  long v = flag_.load();
  return (v >= 0) ? cas_weak(&flag_, &v, v + 1) : false;
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config_option.hpp"

#include <iostream>

namespace caf {

const char* type_name_visitor_tbl[] {
  "a boolean", 
  "a float", 
  "a double",
  "a string",
  "an atom_value",
  "an 8-bit integer",
  "an 8-bit unsigned integer",
  "a 16-bit integer",
  "a 16-bit unsigned integer",
  "a 32-bit integer",
  "a 32-bit unsigned integer",
  "a 64-bit integer",
  "a 64-bit unsigned integer"
};

config_option::config_option(const char* cat, const char* nm, const char* expl)
    : category_(cat),
      name_(nm),
      explanation_(expl),
      short_name_('\0') {
  auto last = name_.end();
  auto comma = std::find(name_.begin(), last, ',');
  if (comma != last) {
    auto i = comma;
    ++i;
    if (i != last)
      short_name_ = *i;
    name_.erase(comma, last);
  }
}

config_option::~config_option() {
  // nop
}

std::string config_option::full_name() const {
  std::string res = category();
  res += '.';
  auto name_begin = name();
  const char* name_end = strchr(name(), ',');
  if (name_end != nullptr)
    res.insert(res.end(), name_begin, name_end);
  else
    res += name();
  return res;
}

void config_option::report_type_error(size_t ln, config_value& x,
                                      const char* expected,
                                      optional<std::ostream&> out) {
  if (!out)
    return;
  type_name_visitor tnv;
  *out << "error in line " << ln << ": expected "
       << expected << " found "
       << visit(tnv, x) << '\n';
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/deserializer.hpp"

#include "caf/actor_system.hpp"

namespace caf {

deserializer::~deserializer() {
  // nop
}

deserializer::deserializer(actor_system& x) : super(x.dummy_execution_unit()) {
  // nop
}

deserializer::deserializer(execution_unit* x) : super(x) {
  // nop
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/memory_managed.hpp"

namespace caf {

memory_managed::~memory_managed() {
  // nop
}

void memory_managed::request_deletion(bool) noexcept {
  delete this;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <utility>

#include "caf/detail/behavior_impl.hpp"

#include "caf/message_handler.hpp"
#include "caf/make_type_erased_tuple_view.hpp"

namespace caf {
namespace detail {

namespace {

class combinator final : public behavior_impl {
public:
  match_case::result invoke(detail::invoke_result_visitor& f,
                            type_erased_tuple& xs) override {
    auto x = first->invoke(f, xs);
    return x == match_case::no_match ? second->invoke(f, xs) : x;
  }

  void handle_timeout() override {
    // the second behavior overrides the timeout handling of
    // first behavior
    return second->handle_timeout();
  }

  combinator(pointer p0, const pointer& p1)
      : behavior_impl(p1->timeout()),
        first(std::move(p0)),
        second(p1) {
    // nop
  }

private:
  pointer first;
  pointer second;
};

class maybe_message_visitor : public detail::invoke_result_visitor {
public:
  optional<message> value;

  void operator()() override {
    value = message{};
  }

  void operator()(error& x) override {
    value = make_message(std::move(x));
  }

  void operator()(message& x) override {
    value = std::move(x);
  }

  void operator()(const none_t&) override {
    (*this)();
  }
};

} // namespace <anonymous>

behavior_impl::~behavior_impl() {
  // nop
}

behavior_impl::behavior_impl(duration tout)
    : timeout_(tout),
      begin_(nullptr),
      end_(nullptr) {
  // nop
}

match_case::result
behavior_impl::invoke_empty(detail::invoke_result_visitor& f) {
  auto xs = make_type_erased_tuple_view();
  return invoke(f, xs);
}

match_case::result behavior_impl::invoke(detail::invoke_result_visitor& f,
                                         type_erased_tuple& xs) {
  auto msg_token = xs.type_token();
  for (auto i = begin_; i != end_; ++i)
    if (i->type_token == msg_token)
      switch (i->ptr->invoke(f, xs)) {
        case match_case::no_match:
          break;
        case match_case::match:
          return match_case::match;
        case match_case::skip:
          return match_case::skip;
      };
  return match_case::no_match;
}

optional<message> behavior_impl::invoke(message& xs) {
  maybe_message_visitor f;
  // the following const-cast is safe, because invoke() is aware of
  // copy-on-write and does not modify x if it's shared
  if (!xs.empty())
    invoke(f, *const_cast<message_data*>(xs.cvals().get()));
  else
    invoke_empty(f);
  return std::move(f.value);
}

optional<message> behavior_impl::invoke(type_erased_tuple& xs) {
  maybe_message_visitor f;
  invoke(f, xs);
  return std::move(f.value);
}

match_case::result behavior_impl::invoke(detail::invoke_result_visitor& f,
                                         message& xs) {
  // the following const-cast is safe, because invoke() is aware of
  // copy-on-write and does not modify x if it's shared
  if (!xs.empty())
    return invoke(f, *const_cast<message_data*>(xs.cvals().get()));
  return invoke_empty(f);
}

void behavior_impl::handle_timeout() {
  // nop
}

behavior_impl::pointer behavior_impl::or_else(const pointer& other) {
  CAF_ASSERT(other != nullptr);
  return make_counted<combinator>(this, other);
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/decorator/sequencer.hpp"

#include "caf/actor_system.hpp"
#include "caf/default_attachable.hpp"

#include "caf/detail/disposer.hpp"
#include "caf/detail/sync_request_bouncer.hpp"

namespace caf {
namespace decorator {

sequencer::sequencer(strong_actor_ptr f, strong_actor_ptr g,
                     message_types_set msg_types)
    : monitorable_actor(actor_config{}.add_flag(is_actor_dot_decorator_flag)),
      f_(std::move(f)),
      g_(std::move(g)),
      msg_types_(std::move(msg_types)) {
  CAF_ASSERT(f_);
  CAF_ASSERT(g_);
  // composed actor has dependency on constituent actors by default;
  // if either constituent actor is already dead upon establishing
  // the dependency, the actor is spawned dead
  f_->get()->attach(default_attachable::make_monitor(actor_cast<actor_addr>(f_),
                                                     address()));
  if (g_ != f_)
    g_->get()->attach(default_attachable::make_monitor(actor_cast<actor_addr>(g_),
                                                       address()));
}

void sequencer::enqueue(mailbox_element_ptr what, execution_unit* context) {
  auto down_msg_handler = [&](down_msg& dm) {
    // quit if either `f` or `g` are no longer available
    cleanup(std::move(dm.reason), context);
  };
  if (handle_system_message(*what, context, false, down_msg_handler))
    return;
  strong_actor_ptr f;
  strong_actor_ptr g;
  error err;
  shared_critical_section([&] {
    f = f_;
    g = g_;
    err = fail_state_;
  });
  if (!f) {
    // f and g are invalid only after the sequencer terminated
    bounce(what, err);
    return;
  }
  // process and forward the non-system message;
  // store `f` as the next stage in the forwarding chain
  what->stages.push_back(std::move(f));
  // forward modified message to `g`
  g->enqueue(std::move(what), context);
}

sequencer::message_types_set sequencer::message_types() const {
  return msg_types_;
}

void sequencer::on_cleanup() {
  f_.reset();
  g_.reset();
}

} // namespace decorator
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/stream_scatterer_impl.hpp"

#include "caf/logger.hpp"
#include "caf/outbound_path.hpp"

namespace caf {

stream_scatterer_impl::stream_scatterer_impl(local_actor* selfptr)
    : super(selfptr),
      min_batch_size_(1),
      max_batch_size_(150),
      min_buffer_size_(50),
      max_batch_delay_(infinite) {
  // nop
}

stream_scatterer_impl::~stream_scatterer_impl() {
  // nop
}

stream_scatterer::path_ptr
stream_scatterer_impl::add_path(const stream_id& sid, strong_actor_ptr origin,
                                strong_actor_ptr sink_ptr,
                                mailbox_element::forwarding_stack stages,
                                message_id handshake_mid,
                                message handshake_data, stream_priority prio,
                                bool redeployable) {
  CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(origin) << CAF_ARG(sink_ptr)
                << CAF_ARG(stages) << CAF_ARG(handshake_mid)
                << CAF_ARG(handshake_data) << CAF_ARG(prio)
                << CAF_ARG(redeployable));
  auto ptr = add_path_impl(sid, std::move(sink_ptr));
  if (ptr != nullptr)
    ptr->emit_open(std::move(origin), std::move(stages), handshake_mid,
                   std::move(handshake_data), prio, redeployable);
  return ptr;
}

stream_scatterer::path_ptr
stream_scatterer_impl::confirm_path(const stream_id& sid,
                                    const actor_addr& from, strong_actor_ptr to,
                                    long initial_demand, bool redeployable) {
  CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(from) << CAF_ARG(to)
                << CAF_ARG(initial_demand) << CAF_ARG(redeployable));
  auto ptr = find(sid, from);
  if (ptr == nullptr) {
    CAF_LOG_WARNING("cannot confirm unknown path");
    outbound_path::emit_irregular_shutdown(self_, sid, std::move(to),
                                           sec::invalid_downstream);
    return nullptr;
  }
  if (from != to)
    ptr->hdl = std::move(to);
  ptr->redeployable = redeployable;
  ptr->open_credit += initial_demand;
  return ptr;
}

bool stream_scatterer_impl::paths_clean() const {
  auto is_clean = [](const path_uptr& x) {
    return x->next_ack_id == x->next_batch_id;
  };
  return buffered() == 0 && std::all_of(paths_.begin(), paths_.end(), is_clean);
}

void stream_scatterer_impl::close() {
  CAF_LOG_TRACE("");
  for (auto& path : paths_)
    stream_aborter::del(path->hdl, self_->address(), path->sid, aborter_type);
  paths_.clear();
}

void stream_scatterer_impl::abort(error reason) {
  for (auto& path : paths_) {
    stream_aborter::del(path->hdl, self_->address(), path->sid, aborter_type);
    path->shutdown_reason = reason;
  }
  paths_.clear();
}

long stream_scatterer_impl::total_credit() const {
  return total_credit(paths_);
}

long stream_scatterer_impl::min_credit() const {
  return min_credit(paths_);
}

long stream_scatterer_impl::max_credit() const {
  return max_credit(paths_);
}

long stream_scatterer_impl::min_batch_size() const {
  return min_batch_size_;
}

long stream_scatterer_impl::max_batch_size() const {
  return max_batch_size_;
}

long stream_scatterer_impl::min_buffer_size() const {
  return min_buffer_size_;
}

duration stream_scatterer_impl::max_batch_delay() const {
  return max_batch_delay_;
}

void stream_scatterer_impl::min_batch_size(long x) {
  min_batch_size_ = x;
}

void stream_scatterer_impl::max_batch_size(long x) {
  max_batch_size_ = x;
}

void stream_scatterer_impl::min_buffer_size(long x) {
  min_buffer_size_ = x;
}

void stream_scatterer_impl::max_batch_delay(duration x) {
  max_batch_delay_ = std::move(x);
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/scheduled_actor.hpp"

#include "caf/config.hpp"
#include "caf/to_string.hpp"
#include "caf/actor_ostream.hpp"
#include "caf/stream_msg_visitor.hpp"

#include "caf/detail/private_thread.hpp"
#include "caf/detail/sync_request_bouncer.hpp"
#include "caf/detail/default_invoke_result_visitor.hpp"

namespace caf {

// -- related free functions ---------------------------------------------------

result<message> reflect(scheduled_actor*, message_view& x) {
  return x.move_content_to_message();
}

result<message> reflect_and_quit(scheduled_actor* ptr, message_view& x) {
  error err = exit_reason::normal;
  scheduled_actor::default_error_handler(ptr, err);
  return reflect(ptr, x);
}

result<message> print_and_drop(scheduled_actor* ptr, message_view& x) {
  CAF_LOG_WARNING("unexpected message" << CAF_ARG(x.content()));
  aout(ptr) << "*** unexpected message [id: " << ptr->id()
            << ", name: " << ptr->name() << "]: "
            << x.content().stringify()
            << std::endl;
  return sec::unexpected_message;
}

result<message> drop(scheduled_actor*, message_view&) {
  return sec::unexpected_message;
}

// -- static helper functions --------------------------------------------------

void scheduled_actor::default_error_handler(scheduled_actor* ptr, error& x) {
  ptr->fail_state_ = std::move(x);
  ptr->setf(is_terminated_flag);
}

void scheduled_actor::default_down_handler(scheduled_actor* ptr, down_msg& x) {
  aout(ptr) << "*** unhandled down message [id: " << ptr->id()
             << ", name: " << ptr->name() << "]: " << to_string(x)
             << std::endl;
}

void scheduled_actor::default_exit_handler(scheduled_actor* ptr, exit_msg& x) {
  if (x.reason)
    default_error_handler(ptr, x.reason);
}

# ifndef CAF_NO_EXCEPTIONS
error scheduled_actor::default_exception_handler(pointer ptr,
                                                 std::exception_ptr& x) {
  CAF_ASSERT(x != nullptr);
  try {
    std::rethrow_exception(x);
  } catch (const std::exception& e) {
    aout(ptr) << "*** unhandled exception: [id: " << ptr->id()
              << ", name: " << ptr->name() << ", exception typeid: "
              << typeid(e).name() << "]: " << e.what()
              << std::endl;
  } catch (...) {
    aout(ptr) << "*** unhandled exception: [id: " << ptr->id()
              << ", name: " << ptr->name() << "]: unknown exception"
              << std::endl;
  }
  return sec::runtime_error;
}
# endif // CAF_NO_EXCEPTIONS

// -- constructors and destructors ---------------------------------------------

scheduled_actor::scheduled_actor(actor_config& cfg)
    : local_actor(cfg),
      timeout_id_(0),
      default_handler_(print_and_drop),
      error_handler_(default_error_handler),
      down_handler_(default_down_handler),
      exit_handler_(default_exit_handler),
      private_thread_(nullptr)
# ifndef CAF_NO_EXCEPTIONS
      , exception_handler_(default_exception_handler)
# endif // CAF_NO_EXCEPTIONS
      {
  // nop
}

scheduled_actor::~scheduled_actor() {
  // signalize to the private thread object that it is
  // unrachable and can be destroyed as well
  if (private_thread_ != nullptr)
    private_thread_->notify_self_destroyed();
}

// -- overridden functions of abstract_actor -----------------------------------

void scheduled_actor::enqueue(mailbox_element_ptr ptr, execution_unit* eu) {
  CAF_ASSERT(ptr != nullptr);
  CAF_ASSERT(!getf(is_blocking_flag));
  CAF_LOG_TRACE(CAF_ARG(*ptr));
  CAF_LOG_SEND_EVENT(ptr);
  auto mid = ptr->mid;
  auto sender = ptr->sender;
  switch (mailbox().enqueue(ptr.release())) {
    case detail::enqueue_result::unblocked_reader: {
      CAF_LOG_ACCEPT_EVENT(true);
      // add a reference count to this actor and re-schedule it
      intrusive_ptr_add_ref(ctrl());
      if (getf(is_detached_flag)) {
        CAF_ASSERT(private_thread_ != nullptr);
        private_thread_->resume();
      } else {
        if (eu != nullptr)
          eu->exec_later(this);
        else
          home_system().scheduler().enqueue(this);
      }
      break;
    }
    case detail::enqueue_result::queue_closed: {
      CAF_LOG_REJECT_EVENT();
      if (mid.is_request()) {
        detail::sync_request_bouncer f{exit_reason()};
        f(sender, mid);
      }
      break;
    }
    case detail::enqueue_result::success:
      // enqueued to a running actors' mailbox; nothing to do
      CAF_LOG_ACCEPT_EVENT(false);
      break;
  }
}

// -- overridden functions of local_actor --------------------------------------

const char* scheduled_actor::name() const {
  return "scheduled_actor";
}

void scheduled_actor::launch(execution_unit* eu, bool lazy, bool hide) {
  CAF_LOG_TRACE(CAF_ARG(lazy) << CAF_ARG(hide));
  CAF_ASSERT(!getf(is_blocking_flag));
  if (!hide)
    register_at_system();
  if (getf(is_detached_flag)) {
    private_thread_ = new detail::private_thread(this);
    private_thread_->start();
    return;
  }
  CAF_ASSERT(eu != nullptr);
  // do not schedule immediately when spawned with `lazy_init`
  // mailbox could be set to blocked
  if (lazy && mailbox().try_block())
    return;
  // scheduler has a reference count to the actor as long as
  // it is waiting to get scheduled
  intrusive_ptr_add_ref(ctrl());
  eu->exec_later(this);
}

bool scheduled_actor::cleanup(error&& fail_state, execution_unit* host) {
  // Shutdown hosting thread when running detached.
  if (getf(is_detached_flag)) {
    CAF_ASSERT(private_thread_ != nullptr);
    private_thread_->shutdown();
  }
  // Clear all state.
  awaited_responses_.clear();
  multiplexed_responses_.clear();
  if (fail_state != none)
    for (auto& kvp : streams_)
      kvp.second->abort(fail_state);
  else
    for (auto& kvp : streams_)
      kvp.second->close();
  streams_.clear();
  // Dispatch to parent's `cleanup` function.
  return local_actor::cleanup(std::move(fail_state), host);
}

// -- overridden functions of resumable ----------------------------------------

resumable::subtype_t scheduled_actor::subtype() const {
  return resumable::scheduled_actor;
}

void scheduled_actor::intrusive_ptr_add_ref_impl() {
  intrusive_ptr_add_ref(ctrl());
}

void scheduled_actor::intrusive_ptr_release_impl() {
  intrusive_ptr_release(ctrl());
}

resumable::resume_result
scheduled_actor::resume(execution_unit* ctx, size_t max_throughput) {
  CAF_PUSH_AID(id());
  if (!activate(ctx))
    return resume_result::done;
  size_t handled_msgs = 0;
  auto reset_timeout_if_needed = [&] {
    if (handled_msgs > 0 && !bhvr_stack_.empty())
      request_timeout(bhvr_stack_.back().timeout());
  };
  mailbox_element_ptr ptr;
  while (handled_msgs < max_throughput) {
    do {
      ptr = next_message();
      if (!ptr) {
        reset_timeout_if_needed();
        if (mailbox().try_block())
          return resumable::awaiting_message;
      }
    } while (!ptr);
    switch (reactivate(*ptr)) {
      case activation_result::terminated:
        return resume_result::done;
      case activation_result::success:
        ++handled_msgs;
        // iterate cache to see if we are now able
        // to process previously skipped messages
        while (consume_from_cache()) {
          ++handled_msgs;
          bhvr_stack_.cleanup();
          if (finalize()) {
            CAF_LOG_DEBUG("actor finalized while processing cache");
            return resume_result::done;
          }
        }
        break;
      case activation_result::skipped:
        push_to_cache(std::move(ptr));
        break;
      default:
        break;
    }
  }
  reset_timeout_if_needed();
  if (!has_next_message() && mailbox().try_block())
    return resumable::awaiting_message;
  // time's up
  return resumable::resume_later;
}

// -- scheduler callbacks ------------------------------------------------------

proxy_registry* scheduled_actor::proxy_registry_ptr() {
  return nullptr;
}

// -- state modifiers ----------------------------------------------------------

void scheduled_actor::quit(error x) {
  CAF_LOG_TRACE(CAF_ARG(x));
  fail_state_ = std::move(x);
  setf(is_terminated_flag);
}

// -- stream management --------------------------------------------------------

void scheduled_actor::trigger_downstreams() {
  for (auto& s : streams_)
    s.second->push();
}

// -- timeout management -------------------------------------------------------

uint32_t scheduled_actor::request_timeout(const duration& d) {
  if (!d.valid()) {
    unsetf(has_timeout_flag);
    return 0;
  }
  setf(has_timeout_flag);
  auto result = ++timeout_id_;
  auto msg = make_message(timeout_msg{result});
  CAF_LOG_TRACE("send new timeout_msg, " << CAF_ARG(timeout_id_));
  if (d.is_zero()) {
    // immediately enqueue timeout message if duration == 0s
    enqueue(ctrl(), invalid_message_id, std::move(msg), context());
  } else {
    auto t = clock().now();
    t += d;
    clock().set_receive_timeout(t, this, result);
  }
  return result;
}

void scheduled_actor::reset_timeout(uint32_t timeout_id) {
  if (is_active_timeout(timeout_id))
    unsetf(has_timeout_flag);
}

bool scheduled_actor::is_active_timeout(uint32_t tid) const {
  return getf(has_timeout_flag) && timeout_id_ == tid;
}

// -- message processing -------------------------------------------------------

void scheduled_actor::add_awaited_response_handler(message_id response_id,
                                                   behavior bhvr) {
  if (bhvr.timeout().valid())
    request_response_timeout(bhvr.timeout(), response_id);
  awaited_responses_.emplace_front(response_id, std::move(bhvr));
}

void scheduled_actor::add_multiplexed_response_handler(message_id response_id,
                                                       behavior bhvr) {
  if (bhvr.timeout().valid())
    request_response_timeout(bhvr.timeout(), response_id);
  multiplexed_responses_.emplace(response_id, std::move(bhvr));
}

scheduled_actor::message_category
scheduled_actor::categorize(mailbox_element& x) {
  auto& content = x.content();
  switch (content.type_token()) {
    case make_type_token<atom_value, atom_value, std::string>():
      if (content.get_as<atom_value>(0) == sys_atom::value
          && content.get_as<atom_value>(1) == get_atom::value) {
        auto& what = content.get_as<std::string>(2);
        if (what == "info") {
          CAF_LOG_DEBUG("reply to 'info' message");
          x.sender->enqueue(
            make_mailbox_element(ctrl(), x.mid.response_id(),
                                  {}, ok_atom::value, std::move(what),
                                  strong_actor_ptr{ctrl()}, name()),
            context());
        } else {
          x.sender->enqueue(
            make_mailbox_element(ctrl(), x.mid.response_id(),
                                  {}, sec::unsupported_sys_key),
            context());
        }
        return message_category::internal;
      }
      return message_category::ordinary;
    case make_type_token<timeout_msg>(): {
      auto& tm = content.get_as<timeout_msg>(0);
      auto tid = tm.timeout_id;
      CAF_ASSERT(!x.mid.valid());
      return is_active_timeout(tid) ? message_category::timeout
                                    : message_category::expired_timeout;
    }
    case make_type_token<exit_msg>(): {
      auto em = content.move_if_unshared<exit_msg>(0);
      // make sure to get rid of attachables if they're no longer needed
      unlink_from(em.source);
      // exit_reason::kill is always fatal
      if (em.reason == exit_reason::kill) {
        fail_state_ = std::move(em.reason);
        setf(is_terminated_flag);
      } else {
        call_handler(exit_handler_, this, em);
      }
      return message_category::internal;
    }
    case make_type_token<down_msg>(): {
      auto dm = content.move_if_unshared<down_msg>(0);
      call_handler(down_handler_, this, dm);
      return message_category::internal;
    }
    case make_type_token<error>(): {
      auto err = content.move_if_unshared<error>(0);
      call_handler(error_handler_, this, err);
      return message_category::internal;
    }
    case make_type_token<stream_msg>(): {
      auto& bs = bhvr_stack();
      handle_stream_msg(x, bs.empty() ? nullptr : &bs.back());
      return message_category::internal;
    }
    default:
      return message_category::ordinary;
  }
}

invoke_message_result scheduled_actor::consume(mailbox_element& x) {
  CAF_LOG_TRACE(CAF_ARG(x));
  current_element_ = &x;
  CAF_LOG_RECEIVE_EVENT(current_element_);
  // Helper function for dispatching a message to a response handler.
  using ptr_t = scheduled_actor*;
  using fun_t = bool (*)(ptr_t, behavior&, mailbox_element&);
  auto ordinary_invoke = [](ptr_t, behavior& f, mailbox_element& in) -> bool {
    return f(in.content()) != none;
  };
  auto stream_invoke = [](ptr_t p, behavior& f, mailbox_element& in) -> bool {
    // The only legal stream message in a response is `stream_open`.
    auto& var = in.content().get_as<stream_msg>(0).content;
    if (holds_alternative<stream_msg::open>(var))
      return p->handle_stream_msg(in, &f);
    return false;
  };
  auto select_invoke_fun = [&]() -> fun_t {
    if (x.content().type_token() != make_type_token<stream_msg>())
      return ordinary_invoke;
    return stream_invoke;
  };
  // Short-circuit awaited responses.
  if (!awaited_responses_.empty()) {
    auto invoke = select_invoke_fun();
    auto& pr = awaited_responses_.front();
    // skip all messages until we receive the currently awaited response
    if (x.mid != pr.first)
      return im_skipped;
    auto f = std::move(pr.second);
    awaited_responses_.pop_front();
    if (!invoke(this, f, x)) {
      // try again with error if first attempt failed
      auto msg = make_message(make_error(sec::unexpected_response,
                                         x.move_content_to_message()));
      f(msg);
    }
    return im_success;
  }
  // Handle multiplexed responses.
  if (x.mid.is_response()) {
    auto invoke = select_invoke_fun();
    auto mrh = multiplexed_responses_.find(x.mid);
    // neither awaited nor multiplexed, probably an expired timeout
    if (mrh == multiplexed_responses_.end())
      return im_dropped;
    if (!invoke(this, mrh->second, x)) {
      // try again with error if first attempt failed
      auto msg = make_message(make_error(sec::unexpected_response,
                                         x.move_content_to_message()));
      mrh->second(msg);
    }
    multiplexed_responses_.erase(mrh);
    return im_success;
  }
  // Dispatch on the content of x.
  switch (categorize(x)) {
    case message_category::expired_timeout:
      CAF_LOG_DEBUG("dropped expired timeout message");
      return im_dropped;
    case message_category::internal:
      CAF_LOG_DEBUG("handled system message");
      return im_success;
    case message_category::timeout: {
      CAF_LOG_DEBUG("handle timeout message");
      if (bhvr_stack_.empty())
        return im_dropped;
      bhvr_stack_.back().handle_timeout();
      return im_success;
    }
    case message_category::ordinary: {
      detail::default_invoke_result_visitor<scheduled_actor> visitor{this};
      bool skipped = false;
      auto had_timeout = getf(has_timeout_flag);
      if (had_timeout)
        unsetf(has_timeout_flag);
      // restore timeout at scope exit if message was skipped
      auto timeout_guard = detail::make_scope_guard([&] {
        if (skipped && had_timeout)
          setf(has_timeout_flag);
      });
      auto call_default_handler = [&] {
        auto sres = call_handler(default_handler_, this, x);
        switch (sres.flag) {
          default:
            break;
          case rt_error:
          case rt_value:
            visitor.visit(sres);
            break;
          case rt_skip:
            skipped = true;
        }
      };
      if (bhvr_stack_.empty()) {
        call_default_handler();
        return !skipped ? im_success : im_skipped;
      }
      auto& bhvr = bhvr_stack_.back();
      switch (bhvr(visitor, x.content())) {
        default:
          break;
        case match_case::skip:
          skipped = true;
          break;
        case match_case::no_match:
          call_default_handler();
      }
      return !skipped ? im_success : im_skipped;
    }
  }
  // Unreachable.
  CAF_CRITICAL("invalid message type");
}

/// Tries to consume `x`.
void scheduled_actor::consume(mailbox_element_ptr x) {
  switch (consume(*x)) {
    default:
      break;
    case im_skipped:
      push_to_cache(std::move(x));
  }
}

bool scheduled_actor::consume_from_cache() {
  CAF_LOG_TRACE("");
  auto& cache = mailbox().cache();
  auto i = cache.continuation();
  auto e = cache.end();
  while (i != e)
    switch (consume(*i)) {
      case im_success:
        cache.erase(i);
        return true;
      case im_skipped:
        ++i;
        break;
      case im_dropped:
        i = cache.erase(i);
        break;
    }
  return false;
}

bool scheduled_actor::activate(execution_unit* ctx) {
  CAF_LOG_TRACE("");
  CAF_ASSERT(ctx != nullptr);
  CAF_ASSERT(!getf(is_blocking_flag));
  context(ctx);
  if (getf(is_initialized_flag)
      && (!has_behavior() || getf(is_terminated_flag))) {
    CAF_LOG_DEBUG_IF(!has_behavior(),
                     "resume called on an actor without behavior");
    CAF_LOG_DEBUG_IF(getf(is_terminated_flag),
                     "resume called on a terminated actor");
    return false;
  }
# ifndef CAF_NO_EXCEPTIONS
  try {
# endif // CAF_NO_EXCEPTIONS
    if (!getf(is_initialized_flag)) {
      initialize();
      if (finalize()) {
        CAF_LOG_DEBUG("actor_done() returned true right after make_behavior()");
        return false;
      }
      CAF_LOG_DEBUG("initialized actor:" << CAF_ARG(name()));
    }
# ifndef CAF_NO_EXCEPTIONS
  }
  catch (...) {
    CAF_LOG_ERROR("actor died during initialization");
    auto eptr = std::current_exception();
    quit(call_handler(exception_handler_, this, eptr));
    finalize();
    return false;
  }
# endif // CAF_NO_EXCEPTIONS
  return true;
}

auto scheduled_actor::activate(execution_unit* ctx, mailbox_element& x)
-> activation_result {
  CAF_LOG_TRACE(CAF_ARG(x));
  if (!activate(ctx))
    return activation_result::terminated;
  auto res = reactivate(x);
  if (res == activation_result::success && !bhvr_stack_.empty())
    request_timeout(bhvr_stack_.back().timeout());
  return res;
}

auto scheduled_actor::reactivate(mailbox_element& x) -> activation_result {
  CAF_LOG_TRACE(CAF_ARG(x));
# ifndef CAF_NO_EXCEPTIONS
  try {
# endif // CAF_NO_EXCEPTIONS
    switch (consume(x)) {
      case im_dropped:
        return activation_result::dropped;
      case im_success:
        bhvr_stack_.cleanup();
        if (finalize()) {
          CAF_LOG_DEBUG("actor finalized");
          return activation_result::terminated;
        }
        return activation_result::success;
      case im_skipped:
        return activation_result::skipped;
    }
# ifndef CAF_NO_EXCEPTIONS
  }
  catch (std::exception& e) {
    CAF_LOG_INFO("actor died because of an exception, what: " << e.what());
    static_cast<void>(e); // keep compiler happy when not logging
    auto eptr = std::current_exception();
    quit(call_handler(exception_handler_, this, eptr));
  }
  catch (...) {
    CAF_LOG_INFO("actor died because of an unknown exception");
    auto eptr = std::current_exception();
    quit(call_handler(exception_handler_, this, eptr));
  }
  finalize();
  return activation_result::terminated;
# endif // CAF_NO_EXCEPTIONS
}

// -- behavior management ----------------------------------------------------

void scheduled_actor::do_become(behavior bhvr, bool discard_old) {
  if (discard_old && !bhvr_stack_.empty())
    bhvr_stack_.pop_back();
  // request_timeout simply resets the timeout when it's invalid
  request_timeout(bhvr.timeout());
  bhvr_stack_.push_back(std::move(bhvr));
}

bool scheduled_actor::finalize() {
  if (has_behavior() && !getf(is_terminated_flag))
    return false;
  CAF_LOG_DEBUG("actor either has no behavior or has set an exit reason");
  on_exit();
  bhvr_stack_.clear();
  bhvr_stack_.cleanup();
  cleanup(std::move(fail_state_), context());
  return true;
}

bool scheduled_actor::handle_stream_msg(mailbox_element& x,
                                        behavior* active_behavior) {
  CAF_LOG_TRACE(CAF_ARG(x));
  CAF_ASSERT(x.content().match_elements<stream_msg>());
  auto& sm = x.content().get_mutable_as<stream_msg>(0);
  if (sm.sender == nullptr) {
    CAF_LOG_ERROR("received a stream_msg with invalid sender field");
    return false;
  }
  stream_msg_visitor f{this, sm, active_behavior};
  auto result = visit(f, sm.content);
  if (streams_.empty() && !has_behavior())
    quit(exit_reason::normal);
  return result;
}

bool scheduled_actor::add_source(const stream_manager_ptr& mgr,
                                 const stream_id& sid,
                                 strong_actor_ptr source_ptr,
                                 strong_actor_ptr original_stage,
                                 stream_priority prio, bool redeployable,
                                 response_promise result_cb) {
  CAF_LOG_TRACE(CAF_ARG(mgr) << CAF_ARG(sid) << CAF_ARG(source_ptr)
                << CAF_ARG(original_stage) << CAF_ARG(prio)
                << CAF_ARG(redeployable) << CAF_ARG(result_cb));
  CAF_ASSERT(mgr != nullptr);
  if (!source_ptr) {
    CAF_LOG_ERROR("cannot add invalid source");
    return false;
  }
  if (!sid.valid()) {
    CAF_LOG_ERROR("cannot add source with invalid stream ID");
    return false;
  }
  return mgr->add_source(sid, std::move(source_ptr),
                         std::move(original_stage), prio, redeployable,
                         std::move(result_cb));
}

bool scheduled_actor::add_source(const stream_manager_ptr& mgr,
                                 const stream_id& sid,
                                 response_promise result_cb) {
  CAF_LOG_TRACE(CAF_ARG(mgr) << CAF_ARG(sid));
  CAF_ASSERT(mgr != nullptr);
  CAF_ASSERT(current_mailbox_element() != nullptr);
  if (!current_mailbox_element()->content().match_elements<stream_msg>()) {
    CAF_LOG_ERROR("scheduled_actor::add_source called outside "
                  "a stream_msg handler");
    return false;
  }
  auto& sm = current_mailbox_element()->content().get_mutable_as<stream_msg>(0);
  if (!holds_alternative<stream_msg::open>(sm.content)) {
    CAF_LOG_ERROR("scheduled_actor::add_source called outside "
                  "a stream_msg::open handler");
    return false;
  }
  auto& opn = get<stream_msg::open>(sm.content);
  auto source_ptr = std::move(opn.prev_stage);
  return mgr->add_source(sid, std::move(source_ptr),
                         std::move(opn.original_stage), opn.priority,
                         opn.redeployable, std::move(result_cb));
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/actor_ostream.hpp"

#include "caf/send.hpp"
#include "caf/scoped_actor.hpp"
#include "caf/abstract_actor.hpp"
#include "caf/default_attachable.hpp"

#include "caf/scheduler/abstract_coordinator.hpp"

namespace caf {

actor_ostream::actor_ostream(local_actor* self)
    : self_(self->id()),
      printer_(self->home_system().scheduler().printer()) {
  init(self);
}

actor_ostream::actor_ostream(scoped_actor& self)
    : self_(self->id()),
      printer_(self->home_system().scheduler().printer()) {
  init(actor_cast<abstract_actor*>(self));
}

actor_ostream& actor_ostream::write(std::string arg) {
  printer_->enqueue(make_mailbox_element(nullptr, make_message_id(), {},
                                         add_atom::value, self_,
                                         std::move(arg)),
                    nullptr);
  return *this;
}

actor_ostream& actor_ostream::flush() {
  printer_->enqueue(make_mailbox_element(nullptr, make_message_id(), {},
                                          flush_atom::value, self_),
                    nullptr);
  return *this;
}

void actor_ostream::redirect(abstract_actor* self, std::string fn, int flags) {
  if (self == nullptr)
    return;
  auto pr = self->home_system().scheduler().printer();
  pr->enqueue(make_mailbox_element(nullptr, make_message_id(), {},
                                    redirect_atom::value, self->id(),
                                    std::move(fn), flags),
              nullptr);
}

void actor_ostream::redirect_all(actor_system& sys, std::string fn, int flags) {
  auto pr = sys.scheduler().printer();
  pr->enqueue(make_mailbox_element(nullptr, make_message_id(), {},
                                    redirect_atom::value,
                                    std::move(fn), flags),
              nullptr);
}

void actor_ostream::init(abstract_actor* self) {
  if (!self->getf(abstract_actor::has_used_aout_flag))
    self->setf(abstract_actor::has_used_aout_flag);
}

actor_ostream aout(local_actor* self) {
  return actor_ostream{self};
}

actor_ostream aout(scoped_actor& self) {
  return actor_ostream{self};
}

} // namespace caf

namespace std {

caf::actor_ostream& endl(caf::actor_ostream& o) {
  return o.write("\n");
}

caf::actor_ostream& flush(caf::actor_ostream& o) {
  return o.flush();
}

} // namespace std
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <utility>

#include "caf/blocking_actor.hpp"

#include "caf/logger.hpp"
#include "caf/actor_system.hpp"
#include "caf/actor_registry.hpp"

#include "caf/detail/sync_request_bouncer.hpp"
#include "caf/detail/invoke_result_visitor.hpp"
#include "caf/detail/default_invoke_result_visitor.hpp"

namespace caf {

blocking_actor::receive_cond::~receive_cond() {
  // nop
}

bool blocking_actor::receive_cond::pre() {
  return true;
}

bool blocking_actor::receive_cond::post() {
  return true;
}

blocking_actor::accept_one_cond::~accept_one_cond() {
  // nop
}

bool blocking_actor::accept_one_cond::post() {
  return false;
}

blocking_actor::blocking_actor(actor_config& cfg)
    : extended_base(cfg.add_flag(local_actor::is_blocking_flag)) {
  // nop
}

blocking_actor::~blocking_actor() {
  // avoid weak-vtables warning
}

void blocking_actor::enqueue(mailbox_element_ptr ptr, execution_unit*) {
  CAF_ASSERT(ptr != nullptr);
  CAF_ASSERT(getf(is_blocking_flag));
  CAF_LOG_TRACE(CAF_ARG(*ptr));
  CAF_LOG_SEND_EVENT(ptr);
  auto mid = ptr->mid;
  auto src = ptr->sender;
  // returns false if mailbox has been closed
  if (!mailbox().synchronized_enqueue(mtx_, cv_, ptr.release())) {
    CAF_LOG_REJECT_EVENT();
    if (mid.is_request()) {
      detail::sync_request_bouncer srb{exit_reason()};
      srb(src, mid);
    }
  } else {
    CAF_LOG_ACCEPT_EVENT(false);
  }
}

const char* blocking_actor::name() const {
  return "blocking_actor";
}

void blocking_actor::launch(execution_unit*, bool, bool hide) {
  CAF_LOG_TRACE(CAF_ARG(hide));
  CAF_ASSERT(getf(is_blocking_flag));
  if (!hide)
    register_at_system();
  home_system().inc_detached_threads();
  std::thread([](strong_actor_ptr ptr) {
    // actor lives in its own thread
    ptr->home_system->thread_started();
    auto this_ptr = ptr->get();
    CAF_ASSERT(dynamic_cast<blocking_actor*>(this_ptr) != 0);
    auto self = static_cast<blocking_actor*>(this_ptr);
    CAF_SET_LOGGER_SYS(ptr->home_system);
    CAF_PUSH_AID_FROM_PTR(self);
    self->initialize();
    error rsn;
#   ifndef CAF_NO_EXCEPTIONS
    try {
      self->act();
      rsn = self->fail_state_;
    }
    catch (...) {
      rsn = exit_reason::unhandled_exception;
    }
    try {
      self->on_exit();
    }
    catch (...) {
      // simply ignore exception
    }
#   else
    self->act();
    rsn = self->fail_state_;
    self->on_exit();
#   endif
    self->cleanup(std::move(rsn), self->context());
    ptr->home_system->thread_terminates();
    ptr->home_system->dec_detached_threads();
  }, strong_actor_ptr{ctrl()}).detach();
}

blocking_actor::receive_while_helper
blocking_actor::receive_while(std::function<bool()> stmt) {
  return {this, std::move(stmt)};
}

blocking_actor::receive_while_helper
blocking_actor::receive_while(const bool& ref) {
  return receive_while([&] { return ref; });
}

void blocking_actor::await_all_other_actors_done() {
  system().registry().await_running_count_equal(getf(is_registered_flag) ? 1
                                                                         : 0);
}

void blocking_actor::act() {
  CAF_LOG_TRACE("");
  if (initial_behavior_fac_)
    initial_behavior_fac_(this);
}

void blocking_actor::fail_state(error err) {
  fail_state_ = std::move(err);
}

namespace {

class message_sequence {
public:
  virtual ~message_sequence() {
    // nop
  }
  virtual bool at_end() = 0;
  virtual bool await_value(bool reset_timeout) = 0;
  virtual mailbox_element& value() = 0;
  virtual void advance() = 0;
  virtual void erase_and_advance() = 0;
};

class cached_sequence : public message_sequence {
public:
  using cache_type = local_actor::mailbox_type::cache_type;
  using iterator = cache_type::iterator;

  cached_sequence(cache_type& cache)
      : cache_(cache),
        i_(cache.continuation()),
        e_(cache.end()) {
    // iterater to the first un-marked element
    i_ = advance_impl(i_);
  }

  bool at_end() override {
    return i_ == e_;
  }

  void advance() override {
    CAF_ASSERT(i_->marked);
    i_->marked = false;
    i_ = advance_impl(i_.next());
  }

  void erase_and_advance() override {
    CAF_ASSERT(i_->marked);
    i_ = advance_impl(cache_.erase(i_));
  }

  bool await_value(bool) override {
    return true;
  }

  mailbox_element& value() override {
    CAF_ASSERT(i_->marked);
    return *i_;
  }

public:
  iterator advance_impl(iterator i) {
    while (i != e_) {
      if (!i->marked) {
        i->marked = true;
        return i;
      }
      ++i;
    }
    return i;
  }

  cache_type& cache_;
  iterator i_;
  iterator e_;
};

class mailbox_sequence : public message_sequence {
public:
  mailbox_sequence(blocking_actor* self, duration rel_timeout)
      : self_(self),
        rel_tout_(rel_timeout) {
    next_timeout();

  }

  bool at_end() override {
    return false;
  }

  void advance() override {
    if (ptr_)
      self_->push_to_cache(std::move(ptr_));
    next_timeout();
  }

  void erase_and_advance() override {
    ptr_.reset();
    next_timeout();
  }

  bool await_value(bool reset_timeout) override {
    if (!rel_tout_.valid()) {
      self_->await_data();
      return true;
    }
    if (reset_timeout)
      next_timeout();
    return self_->await_data(abs_tout_);
  }

  mailbox_element& value() override {
    ptr_ = self_->dequeue();
    CAF_ASSERT(ptr_ != nullptr);
    return *ptr_;
  }

private:
  void next_timeout() {
    abs_tout_ = std::chrono::high_resolution_clock::now();
    abs_tout_ += rel_tout_;
  }

  blocking_actor* self_;
  duration rel_tout_;
  std::chrono::high_resolution_clock::time_point abs_tout_;
  mailbox_element_ptr ptr_;
};

class message_sequence_combinator : public message_sequence {
public:
  using pointer = message_sequence*;

  message_sequence_combinator(pointer first, pointer second)
      : ptr_(first),
        fallback_(second) {
    // nop
  }

  bool at_end() override {
    if (ptr_->at_end()) {
      if (fallback_ == nullptr)
        return true;
      ptr_ = fallback_;
      fallback_ = nullptr;
      return at_end();
    }
    return false;
  }

  void advance() override {
    ptr_->advance();
  }

  void erase_and_advance() override {
    ptr_->erase_and_advance();
  }

  bool await_value(bool reset_timeout) override {
    return ptr_->await_value(reset_timeout);
  }

  mailbox_element& value() override {
    return ptr_->value();
  }

private:
  pointer ptr_;
  pointer fallback_;
};

} // namespace <anonymous>

void blocking_actor::receive_impl(receive_cond& rcc,
                                  message_id mid,
                                  detail::blocking_behavior& bhvr) {
  CAF_LOG_TRACE(CAF_ARG(mid));
  // we start iterating the cache and iterating mailbox elements afterwards
  cached_sequence seq1{mailbox().cache()};
  mailbox_sequence seq2{this, bhvr.timeout()};
  message_sequence_combinator seq{&seq1, &seq2};
  detail::default_invoke_result_visitor<blocking_actor> visitor{this};
  // read incoming messages until we have a match or a timeout
  for (;;) {
    // check loop pre-condition
    if (!rcc.pre())
      return;
    // mailbox sequence is infinite, but at_end triggers the
    // transition from seq1 to seq2 if we iterated our cache
    if (seq.at_end())
      CAF_RAISE_ERROR("reached the end of an infinite sequence");
    // reset the timeout each iteration
    if (!seq.await_value(true)) {
      // short-circuit "loop body"
      bhvr.handle_timeout();
      if (!rcc.post())
        return;
      continue;
    }
    // skip messages in the loop body until we have a match
    bool skipped;
    bool timed_out;
    do {
      skipped = false;
      timed_out = false;
      auto& x = seq.value();
      CAF_LOG_RECEIVE_EVENT((&x));
      // skip messages that don't match our message ID
      if ((mid.valid() && mid != x.mid)
          || (!mid.valid() && x.mid.is_response())) {
        skipped = true;
        CAF_LOG_SKIP_EVENT();
      } else {
        // automatically unlink from actors when receiving exit messages
        if (x.content().match_elements<exit_msg>())
          unlink_from(x.content().get_as<exit_msg>(0).source);
        // blocking actors can use nested receives => restore current_element_
        auto prev_element = current_element_;
        current_element_ = &x;
        switch (bhvr.nested(visitor, x.content())) {
          case match_case::skip:
            skipped = true;
            CAF_LOG_SKIP_EVENT();
            break;
          default:
            break;
          case match_case::no_match: {
            auto sres = bhvr.fallback(*current_element_);
            // when dealing with response messages, there's either a match
            // on the first handler or we produce an error to
            // get a match on the second (error) handler
            if (sres.flag != rt_skip) {
              visitor.visit(sres);
              CAF_LOG_FINALIZE_EVENT();
            } else if (mid.valid()) {
             // invoke again with an unexpected_response error
             auto& old = *current_element_;
             auto err = make_error(sec::unexpected_response,
                                   old.move_content_to_message());
             mailbox_element_view<error> tmp{std::move(old.sender), old.mid,
                                             std::move(old.stages), err};
             current_element_ = &tmp;
             bhvr.nested(tmp.content());
              CAF_LOG_FINALIZE_EVENT();
            } else {
              skipped = true;
              CAF_LOG_SKIP_EVENT();
            }
          }
        }
        current_element_ = prev_element;
      }
      if (skipped) {
        seq.advance();
        if (seq.at_end())
          CAF_RAISE_ERROR("reached the end of an infinite sequence");
        if (!seq.await_value(false)) {
          timed_out = true;
        }
      }
    } while (skipped && !timed_out);
    if (timed_out) {
      bhvr.handle_timeout();
      if (!rcc.post())
        return;
    } else {
      if (rcc.post())
        seq.erase_and_advance();
      else
        return;
    }
  }
}

void blocking_actor::await_data() {
  if (!has_next_message())
    mailbox().synchronized_await(mtx_, cv_);
}

bool blocking_actor::await_data(timeout_type timeout) {
  if (has_next_message())
    return true;
  return mailbox().synchronized_await(mtx_, cv_, timeout);
}

mailbox_element_ptr blocking_actor::dequeue() {
  return next_message();
}

void blocking_actor::varargs_tup_receive(receive_cond& rcc, message_id mid,
                                         std::tuple<behavior&>& tup) {
  using namespace detail;
  auto& bhvr = std::get<0>(tup);
  if (bhvr.timeout().valid()) {
    auto tmp = after(bhvr.timeout()) >> [&] {
      bhvr.handle_timeout();
    };
    auto fun = make_blocking_behavior(&bhvr, std::move(tmp));
    receive_impl(rcc, mid, fun);
  } else {
    auto fun = make_blocking_behavior(&bhvr);
    receive_impl(rcc, mid, fun);
  }
}

size_t blocking_actor::attach_functor(const actor& x) {
  return attach_functor(actor_cast<strong_actor_ptr>(x));
}

size_t blocking_actor::attach_functor(const actor_addr& x) {
  return attach_functor(actor_cast<strong_actor_ptr>(x));
}

size_t blocking_actor::attach_functor(const strong_actor_ptr& ptr) {
  using wait_for_atom = atom_constant<atom("waitFor")>;
  if (!ptr)
    return 0;
  actor self{this};
  ptr->get()->attach_functor([=](const error&) {
    anon_send(self, wait_for_atom::value);
  });
  return 1;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/actor_config.hpp"

#include "caf/abstract_actor.hpp"

namespace caf {

actor_config::actor_config(execution_unit* ptr)
  : host(ptr),
    flags(abstract_channel::is_abstract_actor_flag),
    groups(nullptr) {
  // nop
}

std::string to_string(const actor_config& x) {
  // Note: x.groups is an input range. Traversing it is emptying it, hence we
  // cannot look inside the range here.
  std::string result = "actor_config(";
  auto add = [&](int flag, const char* name) {
    if ((x.flags & flag) != 0) {
      result += ", ";
      result += name;
    }
  };
  add(abstract_channel::is_actor_bind_decorator_flag, "bind_decorator_flag");
  add(abstract_channel::is_actor_dot_decorator_flag, "dot_decorator_flag");
  add(abstract_actor::is_detached_flag, "detached_flag");
  add(abstract_actor::is_blocking_flag, "blocking_flag");
  add(abstract_actor::is_priority_aware_flag, "priority_aware_flag");
  add(abstract_actor::is_hidden_flag, "hidden_flag");
  result += ")";
  return result;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/detail/decorated_tuple.hpp"

#include "caf/make_counted.hpp"

namespace caf {
namespace detail {

decorated_tuple::decorated_tuple(cow_ptr&& d, vector_type&& v)
    : decorated_(std::move(d)),
      mapping_(std::move(v)),
      type_token_(0xFFFFFFFF) {
  CAF_ASSERT(mapping_.empty()
              || *(std::max_element(mapping_.begin(), mapping_.end()))
                 < static_cast<const cow_ptr&>(decorated_)->size());
  // calculate type token
  for (unsigned long i : mapping_) {
    type_token_ <<= 6;
    type_token_ |= static_cast<const cow_ptr&>(decorated_)->type_nr(i);
  }
}

decorated_tuple::cow_ptr decorated_tuple::make(cow_ptr d, vector_type v) {
  auto ptr = dynamic_cast<const decorated_tuple*>(d.get());
  if (ptr != nullptr) {
    d = ptr->decorated();
    auto& pmap = ptr->mapping();
    for (auto& i : v)
      i = pmap[i];
  }
  return make_counted<decorated_tuple>(std::move(d), std::move(v));
}

message_data::cow_ptr decorated_tuple::copy() const {
  return cow_ptr(new decorated_tuple(*this), false);
}

void* decorated_tuple::get_mutable(size_t pos) {
  CAF_ASSERT(pos < size());
  return decorated_->get_mutable(mapping_[pos]);
}

error decorated_tuple::load(size_t pos, deserializer& source) {
  CAF_ASSERT(pos < size());
  return decorated_->load(mapping_[pos], source);
}

size_t decorated_tuple::size() const noexcept {
  return mapping_.size();
}

uint32_t decorated_tuple::type_token() const noexcept {
  return type_token_;
}

message_data::rtti_pair decorated_tuple::type(size_t pos) const noexcept {
  CAF_ASSERT(pos < size());
  return decorated_->type(mapping_[pos]);
}

const void* decorated_tuple::get(size_t pos) const noexcept {
  CAF_ASSERT(pos < size());
  return decorated_->get(mapping_[pos]);
}

std::string decorated_tuple::stringify(size_t pos) const {
  CAF_ASSERT(pos < size());
  return decorated_->stringify(mapping_[pos]);
}

type_erased_value_ptr decorated_tuple::copy(size_t pos) const {
  CAF_ASSERT(pos < size());
  return decorated_->copy(mapping_[pos]);
}

error decorated_tuple::save(size_t pos, serializer& sink) const {
  CAF_ASSERT(pos < size());
  return decorated_->save(mapping_[pos], sink);
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/mailbox_element.hpp"

namespace caf {

namespace {

/// Wraps a `message` into a mailbox element.
class mailbox_element_wrapper : public mailbox_element {
public:
  mailbox_element_wrapper(strong_actor_ptr&& x0, message_id x1,
                          forwarding_stack&& x2, message&& x3)
      : mailbox_element(std::move(x0), x1, std::move(x2)),
        msg_(std::move(x3)) {
    // nop
  }

  type_erased_tuple& content() override {
    auto ptr = msg_.vals().raw_ptr();
    if (ptr != nullptr)
      return *ptr;
    return dummy_;
  }

  message move_content_to_message() override {
    return std::move(msg_);
  }

  message copy_content_to_message() const override {
    return msg_;
  }

private:
  /// Stores the content of this mailbox element.
  message msg_;
};

} // namespace <anonymous>

mailbox_element::mailbox_element()
    : next(nullptr),
      prev(nullptr),
      marked(false) {
  // nop
}

mailbox_element::mailbox_element(strong_actor_ptr&& x, message_id y,
                                 forwarding_stack&& z)
    : next(nullptr),
      prev(nullptr),
      marked(false),
      sender(std::move(x)),
      mid(y),
      stages(std::move(z)) {
  // nop
}

mailbox_element::~mailbox_element() {
  // nop
}

type_erased_tuple& mailbox_element::content() {
  return dummy_;
}

message mailbox_element::move_content_to_message() {
  return {};
}

message mailbox_element::copy_content_to_message() const {
  return {};
}

const type_erased_tuple& mailbox_element::content() const {
  return const_cast<mailbox_element*>(this)->content();
}

mailbox_element_ptr make_mailbox_element(strong_actor_ptr sender, message_id id,
                                         mailbox_element::forwarding_stack stages,
                                         message msg) {
  auto ptr = new mailbox_element_wrapper(std::move(sender), id,
                                         std::move(stages), std::move(msg));
  return mailbox_element_ptr{ptr};
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/actor_clock.hpp"

namespace caf {

// -- constructors, destructors, and assignment operators ----------------------

actor_clock::~actor_clock() {
  // nop
}

// -- observers ----------------------------------------------------------------

actor_clock::time_point actor_clock::now() const noexcept {
  return clock_type::now();
}

actor_clock::duration_type
actor_clock::difference(atom_value, time_point t0,
                        time_point t1) const noexcept {
  return t1 - t0;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/abstract_composable_behavior.hpp"

namespace caf {

abstract_composable_behavior::~abstract_composable_behavior() {
  // nop
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/skip.hpp"

#include "caf/result.hpp"
#include "caf/message.hpp"

namespace caf {

result<message> skip_t::skip_fun_impl(scheduled_actor*, message_view&) {
  return skip();
}

skip_t::operator fun() const {
  return skip_fun_impl;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/none.hpp"

#include "caf/behavior.hpp"
#include "caf/message_handler.hpp"

namespace caf {

behavior::behavior(const message_handler& mh) : impl_(mh.as_behavior_impl()) {
  // nop
}

void behavior::assign(message_handler other) {
  impl_.swap(other.impl_);
}

void behavior::assign(behavior other) {
  impl_.swap(other.impl_);
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/resumable.hpp"

#include "caf/ref_counted.hpp"

namespace caf {

resumable::~resumable() {
  // nop
}

resumable::subtype_t resumable::subtype() const {
  return unspecified;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/replies_to.hpp"
#include "caf/string_algorithms.hpp"

namespace caf {

std::string replies_to_type_name(size_t input_size,
                                 const std::string* input,
                                 size_t output_opt1_size,
                                 const std::string* output_opt1) {
  using irange = iterator_range<const std::string*>;
  std::string glue = ",";
  std::string result;
  // 'void' is not an announced type, hence we check whether uniform_typeid
  // did return a valid pointer to identify 'void' (this has the
  // possibility of false positives, but those will be catched anyways)
  result = "caf::replies_to<";
  result += join(irange{input, input + input_size}, glue);
  result += ">::with<";
  result += join(irange{output_opt1, output_opt1 + output_opt1_size}, glue);
  result += ">";
  return result;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/stream_scatterer.hpp"

#include "caf/logger.hpp"
#include "caf/actor_addr.hpp"
#include "caf/actor_cast.hpp"
#include "caf/outbound_path.hpp"

namespace caf {

stream_scatterer::~stream_scatterer() {
  // nop
}

bool stream_scatterer::remove_path(const stream_id& sid,
                                   const strong_actor_ptr& x, error reason,
                                   bool silent) {
  return remove_path(sid, actor_cast<actor_addr>(x), std::move(reason), silent);
}

stream_scatterer::path_type* stream_scatterer::find(const stream_id& sid,
                                                    const strong_actor_ptr& x) {
  return find(sid, actor_cast<actor_addr>(x));
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"
#include "caf/detail/get_root_uuid.hpp"

#ifndef CAF_MACOS // not needed on Mac OS X
namespace {
constexpr char uuid_format[] = "FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF";
} // namespace <anonmyous>
#endif // CAF_MACOS

#if defined(CAF_MACOS)

namespace {

inline void erase_trailing_newline(std::string& str) {
  while (!str.empty() && (*str.rbegin()) == '\n') {
    str.resize(str.size() - 1);
  }
}

constexpr const char* s_get_uuid =
  "/usr/sbin/diskutil info / | "
  "/usr/bin/awk '$0 ~ /UUID/ { print $3 }'";

} // namespace <anonymous>

namespace caf {
namespace detail {

std::string get_root_uuid() {
  char cbuf[100];
  // fetch hd serial
  std::string uuid;
  FILE* get_uuid_cmd = popen(s_get_uuid, "r");
  while (fgets(cbuf, 100, get_uuid_cmd) != nullptr) {
    uuid += cbuf;
  }
  pclose(get_uuid_cmd);
  erase_trailing_newline(uuid);
  return uuid;
}

} // namespace detail
} // namespace caf

#elif defined(CAF_LINUX) || defined(CAF_BSD) || defined(CAF_CYGWIN)

#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <iostream>
#include <iterator>
#include <algorithm>
#include <iostream>

#include "caf/string_algorithms.hpp"

using std::vector;
using std::string;
using std::ifstream;

namespace caf {
namespace detail {

namespace {

struct columns_iterator : std::iterator<std::forward_iterator_tag,
                                        vector<string>> {
  columns_iterator(ifstream* s = nullptr) : fs(s) {
    // nop
  }
  vector<string>& operator*() {
    return cols;
  }
  columns_iterator& operator++() {
    string line;
    if (!std::getline(*fs, line)) {
      fs = nullptr;
    } else {
      split(cols, line, is_any_of(" "), token_compress_on);
    }
    return *this;
  }
  ifstream* fs;
  vector<string> cols;
};

bool operator==(const columns_iterator& lhs, const columns_iterator& rhs) {
  return lhs.fs == rhs.fs;
}

bool operator!=(const columns_iterator& lhs, const columns_iterator& rhs) {
  return !(lhs == rhs);
}

} // namespace <anonymous>

std::string get_root_uuid() {
  string uuid;
  ifstream fs;
  fs.open("/etc/fstab", std::ios_base::in);
  columns_iterator end;
  auto i = find_if(columns_iterator{&fs}, end, [](const vector<string>& cols) {
    return cols.size() == 6 && cols[1] == "/";
  });
  if (i != end) {
    uuid = move((*i)[0]);
    const char cstr[] = {"UUID="};
    auto slen = sizeof(cstr) - 1;
    if (uuid.compare(0, slen, cstr) == 0) {
      uuid.erase(0, slen);
    }
    // UUIDs are formatted as 8-4-4-4-12 hex digits groups
    auto cpy = uuid;
    replace_if(cpy.begin(), cpy.end(), ::isxdigit, 'F');
    // discard invalid UUID
    if (cpy != uuid_format) {
      uuid.clear();
    }
    // "\\?\Volume{5ec70abf-058c-11e1-bdda-806e6f6e6963}\"
  }
  return uuid;
}

} // namespace detail
} // namespace caf

#elif defined(CAF_WINDOWS)

#include <string>
#include <iostream>
#include <algorithm>

#include <windows.h>
#include <tchar.h>

namespace caf {
namespace detail {

namespace {
constexpr size_t max_drive_name = MAX_PATH;
}

// if TCHAR is indeed a char, we can simply move rhs
void mv(std::string& lhs, std::string&& rhs) {
  lhs = std::move(rhs);
}

// if TCHAR is defined as WCHAR, we have to do unicode conversion
void mv(std::string& lhs, const std::basic_string<WCHAR>& rhs) {
  auto size_needed = WideCharToMultiByte(CP_UTF8, 0, rhs.c_str(),
                                         static_cast<int>(rhs.size()),
                                         nullptr, 0, nullptr, nullptr);
  lhs.resize(size_needed);
  WideCharToMultiByte(CP_UTF8, 0, rhs.c_str(), static_cast<int>(rhs.size()),
                      &lhs[0], size_needed, nullptr, nullptr);
}

std::string get_root_uuid() {
  using tchar_str = std::basic_string<TCHAR>;
  std::string uuid;
  TCHAR buf[max_drive_name];      // temporary buffer for volume name
  tchar_str drive = TEXT("c:\\"); // string "template" for drive specifier
  // walk through legal drive letters, skipping floppies
  for (TCHAR i = TEXT('c'); i < TEXT('z'); i++) {
    // Stamp the drive for the appropriate letter.
    drive[0] = i;
    if (GetVolumeNameForVolumeMountPoint(drive.c_str(), buf, max_drive_name)) {
      tchar_str drive_name = buf;
      auto first = drive_name.find(TEXT("Volume{"));
      if (first != std::string::npos) {
        first += 7;
        auto last = drive_name.find(TEXT("}"), first);
        if (last != std::string::npos && last > first) {
          mv(uuid, drive_name.substr(first, last - first));
          // UUIDs are formatted as 8-4-4-4-12 hex digits groups
          auto cpy = uuid;
          std::replace_if(cpy.begin(), cpy.end(), ::isxdigit, 'F');
          // discard invalid UUID
          if (cpy != uuid_format) {
            uuid.clear();
          } else {
            return uuid; // return first valid UUID we get
          }
        }
      }
    }
  }
  return uuid;
}

} // namespace detail
} // namespace caf


#elif defined(CAF_IOS) || defined(CAF_ANDROID)

// return a randomly-generated UUID on mobile devices

#include <random>

namespace caf {
namespace detail {

std::string get_root_uuid() {
  std::random_device rd;
  std::uniform_int_distribution<int> dist(0, 15);
  std::string uuid = uuid_format;
  for (auto& c : uuid) {
    if (c != '-') {
      auto n = dist(rd);
      c = static_cast<char>((n < 10) ? n + '0' : (n - 10) + 'A');
    }
  }
  return uuid;
}

} // namespace detail
} // namespace caf

#endif // CAF_WINDOWS
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/stream_id.hpp"

#include <cstddef>

namespace caf {

stream_id::stream_id() : origin(nullptr), nr(0) {
  // nop
}

stream_id::stream_id(none_t) : stream_id() {
  // nop
}

stream_id::stream_id(actor_addr origin_actor, uint64_t origin_nr)
    : origin(std::move(origin_actor)),
      nr(origin_nr) {
  // nop
}

stream_id::stream_id(actor_control_block* origin_actor, uint64_t origin_nr)
    : stream_id(origin_actor->address(), origin_nr) {
  // nop
}


stream_id::stream_id(const strong_actor_ptr& origin_actor, uint64_t origin_nr)
    : stream_id(origin_actor->address(), origin_nr) {
  // nop
}

int64_t stream_id::compare(const stream_id& other) const {
  auto r0 = static_cast<ptrdiff_t>(origin.get() - other.origin.get());
  if (r0 != 0)
    return static_cast<int64_t>(r0);
  return static_cast<int64_t>(nr) - static_cast<int64_t>(other.nr);
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/policy/unprofiled.hpp"

namespace caf {
namespace policy {

unprofiled::~unprofiled() {
  // nop
}

} // namespace policy
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/scheduler/test_coordinator.hpp"

#include <limits>

#include "caf/resumable.hpp"
#include "caf/monitorable_actor.hpp"

namespace caf {
namespace scheduler {

namespace {

class dummy_worker : public execution_unit {
public:
  dummy_worker(test_coordinator* parent)
      : execution_unit(&parent->system()),
        parent_(parent) {
    // nop
  }

  void exec_later(resumable* ptr) override {
    parent_->jobs.push_back(ptr);
  }

private:
  test_coordinator* parent_;
};

class dummy_printer : public monitorable_actor {
public:
  dummy_printer(actor_config& cfg) : monitorable_actor(cfg) {
    mh_.assign(
      [&](add_atom, actor_id, const std::string& str) {
        std::cout << str;
      }
    );
  }

  void enqueue(mailbox_element_ptr what, execution_unit*) override {
    mh_(what->content());
  }

private:
  message_handler mh_;
};

} // namespace <anonymous>

test_coordinator::test_coordinator(actor_system& sys) : super(sys) {
  // nop
}

bool test_coordinator::detaches_utility_actors() const {
  return false;
}

detail::test_actor_clock& test_coordinator::clock() noexcept {
  return clock_;
}

void test_coordinator::start() {
  dummy_worker worker{this};
  actor_config cfg{&worker};
  auto& sys = system();
  utility_actors_[printer_id] = make_actor<dummy_printer, actor>(
    sys.next_actor_id(), sys.node(), &sys, cfg);
}

void test_coordinator::stop() {
  run_dispatch_loop();
}

void test_coordinator::enqueue(resumable* ptr) {
  CAF_LOG_TRACE("");
  jobs.push_back(ptr);
  if (after_next_enqueue_ != nullptr) {
    std::function<void()> f;
    f.swap(after_next_enqueue_);
    f();
  }
}

bool test_coordinator::try_run_once() {
  if (jobs.empty())
    return false;
  auto job = jobs.front();
  jobs.pop_front();
  dummy_worker worker{this};
  switch (job->resume(&worker, 1)) {
    case resumable::resume_later:
      jobs.push_front(job);
      break;
    case resumable::done:
    case resumable::awaiting_message:
      intrusive_ptr_release(job);
      break;
    case resumable::shutdown_execution_unit:
      break;
  }
  return true;
}

bool test_coordinator::try_run_once_lifo() {
  if (jobs.empty())
    return false;
  if (jobs.size() >= 2)
    std::rotate(jobs.rbegin(), jobs.rbegin() + 1, jobs.rend());
  return try_run_once();
}

void test_coordinator::run_once() {
  if (jobs.empty())
    CAF_RAISE_ERROR("No job to run available.");
  try_run_once();
}

void test_coordinator::run_once_lifo() {
  if (jobs.empty())
    CAF_RAISE_ERROR("No job to run available.");
  try_run_once_lifo();
}

size_t test_coordinator::run(size_t max_count) {
  size_t res = 0;
  while (res < max_count && try_run_once())
    ++res;
  return res;
}

bool test_coordinator::dispatch_once() {
  return clock().dispatch_once();
}

size_t test_coordinator::dispatch() {
  return clock().dispatch();
}

std::pair<size_t, size_t> test_coordinator::run_dispatch_loop() {
  std::pair<size_t, size_t> res;
  size_t i = 0;
  do {
    auto x = run();
    auto y = dispatch();
    res.first += x;
    res.second += y;
    i = x + y;
  } while (i > 0);
  return res;
}

void test_coordinator::inline_next_enqueue() {
  after_next_enqueue([=] { run_once_lifo(); });
}

void test_coordinator::inline_all_enqueues() {
  after_next_enqueue([=] { inline_all_enqueues_helper(); });
}

void test_coordinator::inline_all_enqueues_helper() {
  run_once_lifo();
  after_next_enqueue([=] { inline_all_enqueues_helper(); });
}

} // namespace caf
} // namespace scheduler

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/invalid_stream_scatterer.hpp"

#include "caf/logger.hpp"

namespace caf {

invalid_stream_scatterer::~invalid_stream_scatterer() {
  // nop
}

stream_scatterer::path_ptr
invalid_stream_scatterer::add_path(const stream_id&, strong_actor_ptr,
                                   strong_actor_ptr,
                                   mailbox_element::forwarding_stack,
                                   message_id, message, stream_priority, bool) {
  CAF_LOG_ERROR("invalid_stream_scatterer::add_path called");
  return nullptr;
}

stream_scatterer::path_ptr
invalid_stream_scatterer::confirm_path(const stream_id&, const actor_addr&,
                                       strong_actor_ptr, long, bool) {
  CAF_LOG_ERROR("invalid_stream_scatterer::confirm_path called");
  return nullptr;
}

bool invalid_stream_scatterer::remove_path(const stream_id&, const actor_addr&,
                                           error, bool) {
  CAF_LOG_ERROR("invalid_stream_scatterer::remove_path called");
  return false;
}

void invalid_stream_scatterer::close() {
  // nop
}

void invalid_stream_scatterer::abort(error) {
  // nop
}

long invalid_stream_scatterer::num_paths() const {
  return 0;
}

bool invalid_stream_scatterer::closed() const {
  return true;
}

bool invalid_stream_scatterer::continuous() const {
  return false;
}

void invalid_stream_scatterer::continuous(bool) {
  // nop
}

stream_scatterer::path_type* invalid_stream_scatterer::path_at(size_t) {
  return nullptr;
}

void invalid_stream_scatterer::emit_batches() {
  // nop
}

stream_scatterer::path_type* invalid_stream_scatterer::find(const stream_id&,
                                                            const actor_addr&) {
  return nullptr;
}

long invalid_stream_scatterer::credit() const {
  return 0;
}

long invalid_stream_scatterer::buffered() const {
  return 0;
}

long invalid_stream_scatterer::min_batch_size() const {
  return 0;
}

long invalid_stream_scatterer::max_batch_size() const {
  return 0;
}

long invalid_stream_scatterer::min_buffer_size() const {
  return 0;
}

duration invalid_stream_scatterer::max_batch_delay() const {
  return infinite;
}

void invalid_stream_scatterer::min_batch_size(long) {
  // nop
}

void invalid_stream_scatterer::max_batch_size(long) {
  // nop
}

void invalid_stream_scatterer::min_buffer_size(long) {
  // nop
}

void invalid_stream_scatterer::max_batch_delay(duration) {
  // nop
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/default_attachable.hpp"

#include "caf/actor.hpp"
#include "caf/message.hpp"
#include "caf/actor_cast.hpp"
#include "caf/system_messages.hpp"

namespace caf {

namespace {

template <class MsgType>
message make(abstract_actor* self, const error& reason) {
  return make_message(MsgType{self->address(), reason});
}

} // namespace <anonymous>

void default_attachable::actor_exited(const error& rsn, execution_unit* host) {
  CAF_ASSERT(observed_ != observer_);
  auto factory = type_ == monitor ? &make<down_msg> : &make<exit_msg>;
  auto observer = actor_cast<strong_actor_ptr>(observer_);
  auto observed = actor_cast<strong_actor_ptr>(observed_);
  if (observer)
    observer->enqueue(std::move(observed), make_message_id(),
                      factory(actor_cast<abstract_actor*>(observed_), rsn),
                      host);
}

bool default_attachable::matches(const token& what) {
  if (what.subtype != attachable::token::observer)
    return false;
  auto& ot = *reinterpret_cast<const observe_token*>(what.ptr);
  return ot.observer == observer_ && ot.type == type_;
}

default_attachable::default_attachable(actor_addr observed, actor_addr observer,
                                       observe_type type)
    : observed_(std::move(observed)),
      observer_(std::move(observer)),
      type_(type) {
  // nop
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/inbound_path.hpp"

#include "caf/send.hpp"
#include "caf/logger.hpp"
#include "caf/no_stages.hpp"
#include "caf/local_actor.hpp"

namespace caf {

inbound_path::inbound_path(local_actor* selfptr, const stream_id& id,
                           strong_actor_ptr ptr)
    : self(selfptr),
      sid(std::move(id)),
      hdl(std::move(ptr)),
      prio(stream_priority::normal),
      last_acked_batch_id(0),
      last_batch_id(0),
      assigned_credit(0),
      redeployable(false) {
  // nop
}

inbound_path::~inbound_path() {
  if (hdl) {
    if (shutdown_reason == none)
      unsafe_send_as(self, hdl, make<stream_msg::drop>(sid, self->address()));
    else
      unsafe_send_as(self, hdl,
                     make<stream_msg::forced_drop>(sid, self->address(),
                                                   shutdown_reason));
  }
}

void inbound_path::handle_batch(long batch_size, int64_t batch_id) {
  assigned_credit -= batch_size;
  last_batch_id = batch_id;
}

void inbound_path::emit_ack_open(actor_addr rebind_from,
                                 long initial_demand, bool is_redeployable) {
  CAF_LOG_TRACE(CAF_ARG(rebind_from) << CAF_ARG(initial_demand)
                << CAF_ARG(is_redeployable));
  assigned_credit = initial_demand;
  redeployable = is_redeployable;
  unsafe_send_as(self, hdl,
                 make<stream_msg::ack_open>(
                   sid, self->address(), std::move(rebind_from), self->ctrl(),
                   static_cast<int32_t>(initial_demand), is_redeployable));
}

void inbound_path::emit_ack_batch(long new_demand) {
  CAF_LOG_TRACE(CAF_ARG(new_demand));
  last_acked_batch_id = last_batch_id;
  assigned_credit += new_demand;
  unsafe_send_as(self, hdl,
                 make<stream_msg::ack_batch>(sid, self->address(),
                                             static_cast<int32_t>(new_demand),
                                             last_batch_id));
}

void inbound_path::emit_irregular_shutdown(local_actor* self,
                                           const stream_id& sid,
                                           const strong_actor_ptr& hdl,
                                           error reason) {
  CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(hdl) << CAF_ARG(reason));
  unsafe_send_as(self, hdl, make<stream_msg::forced_drop>(sid, self->address(),
                                                          std::move(reason)));
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <utility>
#include <algorithm>

#include "caf/response_promise.hpp"

#include "caf/logger.hpp"
#include "caf/local_actor.hpp"

namespace caf {

response_promise::response_promise() : self_(nullptr) {
  // nop
}

response_promise::response_promise(none_t) : response_promise() {
  // nop
}

response_promise::response_promise(strong_actor_ptr self, mailbox_element& src)
    : self_(std::move(self)),
      id_(src.mid) {
  // form an invalid request promise when initialized from a
  // response ID, since CAF always drops messages in this case
  if (!src.mid.is_response()) {
    source_ = std::move(src.sender);
    stages_ = std::move(src.stages);
  }
}

response_promise response_promise::deliver(error x) {
  //if (id_.valid())
  return deliver_impl(make_message(std::move(x)));
}

bool response_promise::async() const {
  return id_.is_async();
}


execution_unit* response_promise::context() {
  return self_ == nullptr
         ? nullptr
         : static_cast<local_actor*>(actor_cast<abstract_actor*>(self_))
           ->context();
}

response_promise response_promise::deliver_impl(message msg) {
  if (!stages_.empty()) {
    auto next = std::move(stages_.back());
    stages_.pop_back();
    next->enqueue(make_mailbox_element(std::move(source_), id_,
                                       std::move(stages_), std::move(msg)),
                  context());
    return *this;
  }
  if (source_) {
    source_->enqueue(std::move(self_), id_.response_id(),
                     std::move(msg), context());
    source_.reset();
    return *this;
  }
  if (self_)
    CAF_LOG_INFO("response promise already satisfied");
  else
    CAF_LOG_INFO("invalid response promise");
  return *this;
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/locks.hpp"
#include "caf/actor_companion.hpp"

namespace caf {

actor_companion::actor_companion(actor_config& cfg) : extended_base(cfg) {
  // nop
}

actor_companion::~actor_companion() {
  // nop
}

void actor_companion::on_enqueue(enqueue_handler handler) {
  std::lock_guard<lock_type> guard(lock_);
  on_enqueue_ = std::move(handler);
}

void actor_companion::on_exit(on_exit_handler handler) {
  on_exit_ = std::move(handler);
}

void actor_companion::enqueue(mailbox_element_ptr ptr, execution_unit*) {
  CAF_ASSERT(ptr);
  shared_lock<lock_type> guard(lock_);
  if (on_enqueue_)
    on_enqueue_(std::move(ptr));
}

void actor_companion::enqueue(strong_actor_ptr src, message_id mid,
                              message content, execution_unit* eu) {
  auto ptr = make_mailbox_element(std::move(src), mid, {}, std::move(content));
  enqueue(std::move(ptr), eu);
}

void actor_companion::launch(execution_unit*, bool, bool hide) {
  if (!hide)
    register_at_system();
}

void actor_companion::on_exit() {
  enqueue_handler tmp;
  { // lifetime scope of guard
    std::lock_guard<lock_type> guard(lock_);
    on_enqueue_.swap(tmp);
  }
  if (on_exit_)
    on_exit_();
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/actor_registry.hpp"

#include <mutex>
#include <limits>
#include <stdexcept>
#include <unordered_map>
#include <unordered_set>

#include "caf/sec.hpp"
#include "caf/locks.hpp"
#include "caf/logger.hpp"
#include "caf/attachable.hpp"
#include "caf/exit_reason.hpp"
#include "caf/actor_system.hpp"
#include "caf/scoped_actor.hpp"
#include "caf/stateful_actor.hpp"
#include "caf/event_based_actor.hpp"
#include "caf/uniform_type_info_map.hpp"

#include "caf/detail/shared_spinlock.hpp"

namespace caf {

namespace {

using exclusive_guard = unique_lock<detail::shared_spinlock>;
using shared_guard = shared_lock<detail::shared_spinlock>;

} // namespace <anonymous>

actor_registry::~actor_registry() {
  // nop
}

actor_registry::actor_registry(actor_system& sys) : running_(0), system_(sys) {
  // nop
}

strong_actor_ptr actor_registry::get_impl(actor_id key) const {
  shared_guard guard(instances_mtx_);
  auto i = entries_.find(key);
  if (i != entries_.end())
    return i->second;
  CAF_LOG_DEBUG("key invalid, assume actor no longer exists:" << CAF_ARG(key));
  return nullptr;
}

void actor_registry::put_impl(actor_id key, strong_actor_ptr val) {
  CAF_LOG_TRACE(CAF_ARG(key));
  if (!val)
    return;
  { // lifetime scope of guard
    exclusive_guard guard(instances_mtx_);
    if (!entries_.emplace(key, val).second)
      return;
  }
  // attach functor without lock
  CAF_LOG_INFO("added actor:" << CAF_ARG(key));
  actor_registry* reg = this;
  val->get()->attach_functor([key, reg]() {
    reg->erase(key);
  });
}

void actor_registry::erase(actor_id key) {
  exclusive_guard guard{instances_mtx_};
  entries_.erase(key);
}

void actor_registry::inc_running() {
# if defined(CAF_LOG_LEVEL) && CAF_LOG_LEVEL >= CAF_LOG_LEVEL_DEBUG
  auto value = ++running_;
  CAF_LOG_DEBUG(CAF_ARG(value));
# else
  ++running_;
# endif
}

size_t actor_registry::running() const {
  return running_.load();
}

void actor_registry::dec_running() {
  size_t new_val = --running_;
  if (new_val <= 1) {
    std::unique_lock<std::mutex> guard(running_mtx_);
    running_cv_.notify_all();
  }
  CAF_LOG_DEBUG(CAF_ARG(new_val));
}

void actor_registry::await_running_count_equal(size_t expected) const {
  CAF_ASSERT(expected == 0 || expected == 1);
  CAF_LOG_TRACE(CAF_ARG(expected));
  std::unique_lock<std::mutex> guard{running_mtx_};
  while (running_ != expected) {
    CAF_LOG_DEBUG(CAF_ARG(running_.load()));
    running_cv_.wait(guard);
  }
}

strong_actor_ptr actor_registry::get_impl(atom_value key) const {
  shared_guard guard{named_entries_mtx_};
  auto i = named_entries_.find(key);
  if (i == named_entries_.end())
    return nullptr;
  return i->second;
}

void actor_registry::put_impl(atom_value key, strong_actor_ptr value) {
  if (value)
    value->get()->attach_functor([=] {
      system_.registry().put_impl(key, nullptr);
    });
  exclusive_guard guard{named_entries_mtx_};
  named_entries_.emplace(key, std::move(value));
}

void actor_registry::erase(atom_value key) {
  exclusive_guard guard{named_entries_mtx_};
  named_entries_.erase(key);
}

auto actor_registry::named_actors() const -> name_map {
  shared_guard guard{named_entries_mtx_};
  return named_entries_;
}

void actor_registry::start() {
  // nop
}

void actor_registry::stop() {
  // nop
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/actor_addr.hpp"

#include "caf/actor.hpp"
#include "caf/node_id.hpp"
#include "caf/serializer.hpp"
#include "caf/local_actor.hpp"
#include "caf/deserializer.hpp"
#include "caf/proxy_registry.hpp"

namespace caf {

actor_addr::actor_addr(std::nullptr_t) {
  // nop
}

actor_addr::actor_addr(const unsafe_actor_handle_init_t&) {
  // nop
}

actor_addr& actor_addr::operator=(std::nullptr_t) {
  ptr_.reset();
  return *this;
}

actor_addr::actor_addr(actor_control_block* ptr) : ptr_(ptr) {
  // nop
}

actor_addr::actor_addr(actor_control_block* ptr, bool add_ref)
    : ptr_(ptr, add_ref) {
  // nop
}

intptr_t actor_addr::compare(const actor_control_block* lhs,
                             const actor_control_block* rhs) {
  // invalid actors are always "less" than valid actors
  if (lhs == nullptr)
    return rhs != nullptr ? -1 : 0;
  if (rhs == nullptr)
    return 1;
  // check for identity
  if (lhs == rhs)
    return 0;
  // check for equality (a decorator is equal to the actor it represents)
  auto x = lhs->id();
  auto y = rhs->id();
  if (x == y)
    return lhs->node().compare(rhs->node());
  return static_cast<intptr_t>(x) - static_cast<intptr_t>(y);
}

intptr_t actor_addr::compare(const actor_addr& other) const noexcept {
  return compare(ptr_.get(), other.ptr_.get());
}

intptr_t actor_addr::compare(const abstract_actor* other) const noexcept {
  return compare(ptr_.get(), actor_control_block::from(other));
}

intptr_t actor_addr::compare(const actor_control_block* other) const noexcept {
  return compare(ptr_.get(), other);
}

void actor_addr::swap(actor_addr& other) noexcept {
  ptr_.swap(other.ptr_);
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/detail/pretty_type_name.hpp"

#include "caf/config.hpp"

#if defined(CAF_LINUX) || defined(CAF_MACOS)
#include <unistd.h>
#include <cxxabi.h>
#include <sys/types.h>
#endif

#include "caf/string_algorithms.hpp"

namespace caf {
namespace detail {

void prettify_type_name(std::string& class_name) {
  //replace_all(class_name, " ", "");
  replace_all(class_name, "::", ".");
  replace_all(class_name, "(anonymousnamespace)", "ANON");
  replace_all(class_name, ".__1.", "."); // gets rid of weird Clang-lib names
  // hide CAF magic in logs
  auto strip_magic = [&](const char* prefix_begin, const char* prefix_end) {
    auto last = class_name.end();
    auto i = std::search(class_name.begin(), last, prefix_begin, prefix_end);
    auto comma_or_angle_bracket = [](char c) { return c == ',' || c == '>'; };
    auto e = std::find_if(i, last, comma_or_angle_bracket);
    if (i != e) {
      std::string substr(i + (prefix_end - prefix_begin), e);
      class_name.swap(substr);
    }
  };
  char prefix1[] = "caf.detail.embedded<";
  strip_magic(prefix1, prefix1 + (sizeof(prefix1) - 1));
  // finally, replace any whitespace with %20
  replace_all(class_name, " ", "%20");
}

void prettify_type_name(std::string& class_name, const char* c_class_name) {
# if defined(CAF_LINUX) || defined(CAF_MACOS)
  int stat = 0;
  std::unique_ptr<char, decltype(free)*> real_class_name{nullptr, free};
  auto tmp = abi::__cxa_demangle(c_class_name, nullptr, nullptr, &stat);
  real_class_name.reset(tmp);
  class_name = stat == 0 ? real_class_name.get() : c_class_name;
# else
  class_name = c_class_name;
# endif
  prettify_type_name(class_name);
}

std::string pretty_type_name(const std::type_info& x) {
  std::string result;
  prettify_type_name(result, x.name());
  return result;
}

} // namespace detail 
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/detail/get_process_id.hpp"

#include "caf/config.hpp"

 #ifdef CAF_WINDOWS
#  include <windows.h>
#else
#  include <sys/types.h>
#  include <unistd.h>
#endif

namespace caf {
namespace detail {

unsigned get_process_id() {
# ifdef CAF_WINDOWS
  return GetCurrentProcessId();
# else
  return static_cast<unsigned>(getpid());
# endif
}

} // namespace detail
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/stream_msg_visitor.hpp"

#include "caf/send.hpp"
#include "caf/logger.hpp"
#include "caf/inbound_path.hpp"
#include "caf/outbound_path.hpp"
#include "caf/scheduled_actor.hpp"

namespace caf {

stream_msg_visitor::stream_msg_visitor(scheduled_actor* self,
                                       const stream_msg& msg, behavior* bhvr)
    : self_(self),
      sid_(msg.sid),
      sender_(msg.sender),
      bhvr_(bhvr) {
  CAF_ASSERT(sender_ != nullptr);
}

auto stream_msg_visitor::operator()(stream_msg::open& x) -> result_type {
  CAF_LOG_TRACE(CAF_ARG(x));
  CAF_ASSERT(x.prev_stage != nullptr);
  CAF_ASSERT(x.original_stage != nullptr);
  auto& predecessor = x.prev_stage;
  // Convenience function for aborting the stream on error.
  auto fail = [&](error err) -> result_type {
    inbound_path::emit_irregular_shutdown(self_, sid_, predecessor,
                                          std::move(err));
    return false;
  };
  // Sanity checks.
  if (!predecessor) {
    CAF_LOG_WARNING("received stream_msg::open with empty prev_stage");
    return fail(sec::invalid_upstream);
  }
  if (bhvr_ == nullptr) {
    CAF_LOG_WARNING("received stream_msg::open with empty behavior");
    return fail(sec::stream_init_failed);
  }
  if (self_->streams().count(sid_) != 0) {
    CAF_LOG_WARNING("received duplicate stream_msg::open");
    return fail(sec::stream_init_failed);
  }
  // Invoke behavior of parent to perform handshake.
  (*bhvr_)(x.msg);
  if (self_->streams().count(sid_) == 0) {
    CAF_LOG_WARNING("actor did not provide a stream "
                    "handler after receiving handshake:"
                    << CAF_ARG(x.msg));
    return fail(sec::stream_init_failed);
  }
  return true;
}

auto stream_msg_visitor::operator()(stream_msg::close&) -> result_type {
  CAF_LOG_TRACE("");
  return invoke([&](stream_manager_ptr& mgr) {
    return mgr->close(sid_, sender_);
  });
}

auto stream_msg_visitor::operator()(stream_msg::drop&) -> result_type {
  CAF_LOG_TRACE("");
  return invoke([&](stream_manager_ptr& mgr) {
    return mgr->drop(sid_, sender_);
  });
}

auto stream_msg_visitor::operator()(stream_msg::forced_close& x) -> result_type {
  CAF_LOG_TRACE(CAF_ARG(x));
  return invoke([&](stream_manager_ptr& mgr) {
    return mgr->forced_close(sid_, sender_, std::move(x.reason));
  });
}

auto stream_msg_visitor::operator()(stream_msg::forced_drop& x) -> result_type {
  CAF_LOG_TRACE(CAF_ARG(x));
  return invoke([&](stream_manager_ptr& mgr) {
    return mgr->forced_drop(sid_, sender_, std::move(x.reason));
  });
}

auto stream_msg_visitor::operator()(stream_msg::ack_open& x) -> result_type {
  CAF_LOG_TRACE(CAF_ARG(x));
  return invoke([&](stream_manager_ptr& mgr) {
    return mgr->ack_open(sid_, x.rebind_from, std::move(x.rebind_to),
                         x.initial_demand, x.redeployable);
  });
}

auto stream_msg_visitor::operator()(stream_msg::batch& x) -> result_type {
  CAF_LOG_TRACE(CAF_ARG(x));
  return invoke([&](stream_manager_ptr& mgr) {
    return mgr->batch(sid_, sender_, static_cast<long>(x.xs_size), x.xs, x.id);
  });
}

auto stream_msg_visitor::operator()(stream_msg::ack_batch& x) -> result_type {
  CAF_LOG_TRACE(CAF_ARG(x));
  return invoke([&](stream_manager_ptr& mgr) {
    return mgr->ack_batch(sid_, sender_, static_cast<long>(x.new_capacity),
                          x.acknowledged_id);
  });
}

} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE limited_vector
#include "caf/test/unit_test.hpp"

#include <algorithm>

#include "caf/detail/limited_vector.hpp"

using caf::detail::limited_vector;

CAF_TEST(basics) {
  using std::equal;
  int arr1[] {1, 2, 3, 4};
  limited_vector<int, 4> vec1 {1, 2, 3, 4};
  limited_vector<int, 5> vec2 {4, 3, 2, 1};
  limited_vector<int, 4> vec3;
  for (int i = 1; i <= 4; ++i) vec3.push_back(i);
  limited_vector<int, 4> vec4 {1, 2};
  limited_vector<int, 2> vec5 {3, 4};
  vec4.insert(vec4.end(), vec5.begin(), vec5.end());
  auto vec6 = vec4;
  CAF_CHECK_EQUAL(vec1.size(), 4u);
  CAF_CHECK_EQUAL(vec2.size(), 4u);
  CAF_CHECK_EQUAL(vec3.size(), 4u);
  CAF_CHECK_EQUAL(vec4.size(), 4u);
  CAF_CHECK_EQUAL(vec5.size(), 2u);
  CAF_CHECK_EQUAL(vec6.size(), 4u);
  CAF_CHECK_EQUAL(vec1.full(), true);
  CAF_CHECK_EQUAL(vec2.full(), false);
  CAF_CHECK_EQUAL(vec3.full(), true);
  CAF_CHECK_EQUAL(vec4.full(), true);
  CAF_CHECK_EQUAL(vec5.full(), true);
  CAF_CHECK_EQUAL(vec6.full(), true);
  CAF_CHECK(std::equal(vec1.begin(), vec1.end(), arr1));
  CAF_CHECK(std::equal(vec2.rbegin(), vec2.rend(), arr1));
  CAF_CHECK(std::equal(vec4.begin(), vec4.end(), arr1));
  CAF_CHECK(std::equal(vec6.begin(), vec6.end(), arr1));
  CAF_CHECK(std::equal(vec6.begin(), vec6.end(), vec2.rbegin()));
  limited_vector<int, 10> vec7 {5, 9};
  limited_vector<int, 10> vec8 {1, 2, 3, 4};
  limited_vector<int, 10> vec9 {6, 7, 8};
  vec7.insert(vec7.begin() + 1, vec9.begin(), vec9.end());
  vec7.insert(vec7.begin(), vec8.begin(), vec8.end());
  CAF_CHECK_EQUAL(vec7.full(), false);
  limited_vector<int, 1> vec10 {10};
  vec7.insert(vec7.end(), vec10.begin(), vec10.end());
  CAF_CHECK_EQUAL(vec7.full(), true);
  CAF_CHECK((std::is_sorted(vec7.begin(), vec7.end())));
  int arr2[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  CAF_CHECK((std::equal(vec7.begin(), vec7.end(), std::begin(arr2))));
  vec7.assign(std::begin(arr2), std::end(arr2));
  CAF_CHECK((std::equal(vec7.begin(), vec7.end(), std::begin(arr2))));
  vec7.assign(5, 0);
  CAF_CHECK_EQUAL(vec7.size(), 5u);
  CAF_CHECK((std::all_of(vec7.begin(), vec7.end(),
              [](int i) { return i == 0; })));
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE ripemd_160
#include "caf/test/unit_test.hpp"

#include <iomanip>
#include <iostream>

#include "caf/detail/ripemd_160.hpp"

using caf::detail::ripemd_160;

namespace {

std::string str_hash(const std::string& what) {
  std::array<uint8_t, 20> hash;
  ripemd_160(hash, what);
  std::ostringstream oss;
  oss << std::setfill('0') << std::hex;
  for (auto i : hash) {
    oss << std::setw(2) << static_cast<int>(i);
  }
  return oss.str();
}

} // namespace <anonymous>

// verify ripemd implementation with example hash results from
// http://homes.esat.kuleuven.be/~bosselae/ripemd160.html
CAF_TEST(hash_results) {
  CAF_CHECK_EQUAL("9c1185a5c5e9fc54612808977ee8f548b2258d31", str_hash(""));
  CAF_CHECK_EQUAL("0bdc9d2d256b3ee9daae347be6f4dc835a467ffe", str_hash("a"));
  CAF_CHECK_EQUAL("8eb208f7e05d987a9b044a8e98c6b087f15a0bfc", str_hash("abc"));
  CAF_CHECK_EQUAL("5d0689ef49d2fae572b881b123a85ffa21595f36",
                  str_hash("message digest"));
  CAF_CHECK_EQUAL("f71c27109c692c1b56bbdceb5b9d2865b3708dbc",
                  str_hash("abcdefghijklmnopqrstuvwxyz"));
  CAF_CHECK_EQUAL("12a053384a9c0c88e405a06c27dcf49ada62eb2b",
                  str_hash("abcdbcdecdefdefgefghfghighij"
                           "hijkijkljklmklmnlmnomnopnopq"));
  CAF_CHECK_EQUAL("b0e20b6e3116640286ed3a87a5713079b21f5189",
                  str_hash("ABCDEFGHIJKLMNOPQRSTUVWXYZabcde"
                           "fghijklmnopqrstuvwxyz0123456789"));
  CAF_CHECK_EQUAL("9b752e45573d4b39f4dbd3323cab82bf63326bfb",
                  str_hash("1234567890123456789012345678901234567890"
                           "1234567890123456789012345678901234567890"));
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE variant
#include "caf/test/unit_test.hpp"

#include <string>

#include "caf/none.hpp"
#include "caf/variant.hpp"
#include "caf/actor_system.hpp"
#include "caf/deep_to_string.hpp"
#include "caf/binary_serializer.hpp"
#include "caf/binary_deserializer.hpp"
#include "caf/actor_system_config.hpp"

using namespace std;
using namespace caf;

struct tostring_visitor : static_visitor<string> {
  template <class T>
  inline string operator()(const T& value) {
    return to_string(value);
  }
};

// 20 integer wrappers for building a variant with 20 distint types
#define i_n(n)                                                                 \
  class i##n {                                                                 \
  public:                                                                      \
    i##n(int y = 0) : x(y) {                                                   \
    }                                                                          \
    i##n(i##n&& other) : x(other.x) {                                          \
      other.x = 0;                                                             \
    }                                                                          \
    i##n& operator=(i##n&& other) {                                            \
      x = other.x;                                                             \
      other.x = 0;                                                             \
      return *this;                                                            \
    }                                                                          \
    i##n(const i##n&) = default;                                               \
    i##n& operator=(const i##n&) = default;                                    \
    int x;                                                                     \
  };                                                                           \
  bool operator==(int x, i##n y) {                                             \
    return x == y.x;                                                           \
  }                                                                            \
  bool operator==(i##n x, int y) {                                             \
    return y == x;                                                             \
  }                                                                            \
  bool operator==(i##n x, i##n y) {                                            \
    return x.x == y.x;                                                         \
  }                                                                            \
  template <class Inspector>                                                   \
  typename Inspector::result_type inspect(Inspector& f, i##n& x) {             \
    return f(meta::type_name(CAF_STR(i##n)), x.x);                             \
  }

#define macro_repeat20(macro)                                                  \
  macro(01) macro(02) macro(03) macro(04) macro(05) macro(06) macro(07)        \
    macro(08) macro(09) macro(10) macro(11) macro(12) macro(13) macro(14)      \
      macro(15) macro(16) macro(17) macro(18) macro(19) macro(20)

macro_repeat20(i_n)

// a variant with 20 element types
using v20 = variant<i01, i02, i03, i04, i05, i06, i07, i08, i09, i10,
                    i11, i12, i13, i14, i15, i16, i17, i18, i19, i20>;

#define announce_n(n) cfg.add_message_type<i##n>(CAF_STR(i##n));

#define v20_test(n)                                                            \
  x3 = i##n{0x##n};                                                            \
  CAF_CHECK_EQUAL(deep_to_string(x3), CAF_STR(i##n) + std::string("(")         \
                                        + std::to_string(0x##n) + ")");        \
  CAF_CHECK_EQUAL(v20{x3}, i##n{0x##n});                                       \
  x4 = x3;                                                                     \
  CAF_CHECK_EQUAL(x4, i##n{0x##n});                                            \
  CAF_CHECK_EQUAL(v20{std::move(x3)}, i##n{0x##n});                            \
  CAF_CHECK_EQUAL(x3, i##n{0});                                                \
  x3 = std::move(x4);                                                          \
  CAF_CHECK_EQUAL(x4, i##n{0});                                                \
  CAF_CHECK_EQUAL(x3, i##n{0x##n});                                            \
  {                                                                            \
    std::vector<char> buf;                                                     \
    binary_serializer bs{sys.dummy_execution_unit(), buf};                     \
    inspect(bs, x3);                                                           \
    CAF_CHECK_EQUAL(x3, i##n{0x##n});                                          \
    v20 tmp;                                                                   \
    binary_deserializer bd{sys.dummy_execution_unit(), buf};                   \
    inspect(bd, tmp);                                                          \
    CAF_CHECK_EQUAL(tmp, i##n{0x##n});                                         \
    CAF_CHECK_EQUAL(tmp, x3);                                                  \
  }

// copy construction, copy assign, move construction, move assign
// and finally serialization round-trip
CAF_TEST(copying_moving_roundtrips) {
  actor_system_config cfg;
  macro_repeat20(announce_n)
  actor_system sys{cfg};
  // default construction
  variant<none_t> x1;
  CAF_CHECK_EQUAL(x1, none);
  variant<int, none_t> x2;
  CAF_CHECK_EQUAL(x2, 0);
  v20 x3;
  CAF_CHECK_EQUAL(x3, i01{0});
  v20 x4;
  macro_repeat20(v20_test);
}

namespace {

struct test_visitor {
  template <class... Ts>
  string operator()(const Ts&... xs) {
    return deep_to_string(std::forward_as_tuple(xs...));
  }
};

} // namespace <anonymous>

CAF_TEST(n_ary_visit) {
  variant<int, string> a{42};
  variant<string, atom_value> b{atom("foo")};
  variant<float, int, string> c{string{"bar"}};
  variant<int, string, double> d{123};
  test_visitor f;
  CAF_CHECK_EQUAL(visit(f, a, b), "(42, 'foo')");
  CAF_CHECK_EQUAL(visit(f, a, b, c), "(42, 'foo', \"bar\")");
  CAF_CHECK_EQUAL(visit(f, a, b, c, d), "(42, 'foo', \"bar\", 123)");
}

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE or_else
#include "caf/test/unit_test.hpp"

#include "caf/all.hpp"

#define ERROR_HANDLER                                                          \
  [&](error& err) { CAF_FAIL(system.render(err)); }

using namespace caf;

namespace {

using a_atom = atom_constant<atom("a")>;
using b_atom = atom_constant<atom("b")>;
using c_atom = atom_constant<atom("c")>;

message_handler handle_a() {
  return [](a_atom) { return 1; };
}

message_handler handle_b() {
  return [](b_atom) { return 2; };
}

message_handler handle_c() {
  return [](c_atom) { return 3; };
}

struct fixture {
  fixture() : system(cfg) {
    // nop
  }

  actor_system_config cfg;
  actor_system system;

  void run_testee(const actor& testee) {
    scoped_actor self{system};
    self->request(testee, infinite, a_atom::value).receive(
      [](int i) {
        CAF_CHECK_EQUAL(i, 1);
      },
      ERROR_HANDLER
    );
    self->request(testee, infinite, b_atom::value).receive(
      [](int i) {
        CAF_CHECK_EQUAL(i, 2);
      },
      ERROR_HANDLER
    );
    self->request(testee, infinite, c_atom::value).receive(
      [](int i) {
        CAF_CHECK_EQUAL(i, 3);
      },
      ERROR_HANDLER
    );
    self->send_exit(testee, exit_reason::user_shutdown);
    self->await_all_other_actors_done();
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(atom_tests, fixture)

CAF_TEST(composition1) {
  run_testee(
    system.spawn([=] {
      return handle_a().or_else(handle_b()).or_else(handle_c());
    })
  );
}

CAF_TEST(composition2) {
  run_testee(
    system.spawn([=] {
      return handle_a().or_else(handle_b()).or_else([](c_atom) { return 3; });
    })
  );
}

CAF_TEST(composition3) {
  run_testee(
    system.spawn([=] {
      return message_handler{[](a_atom) { return 1; }}.
             or_else(handle_b()).or_else(handle_c());
    })
  );
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE parse_ini
#include "caf/test/unit_test.hpp"

#include <sstream>
#include <iostream>

#include "caf/string_algorithms.hpp"

#include "caf/all.hpp"

#include "caf/detail/parse_ini.hpp"
#include "caf/detail/safe_equal.hpp"

#define ERROR_HANDLER                                                          \
  [&](error& err) { CAF_FAIL(system.render(err)); }

using namespace caf;

namespace {

constexpr const char* case1 = R"__(
[scheduler]
policy="work-sharing"
max-threads=2
; the middleman
[middleman]
automatic-connections=true

[nexus]
host="127.0.0.1"
port=4242

[cash]
greeting="Hi there, this is \"CASH!\"\n ~\\~ use at your own risk ~\\~"
)__";

constexpr const char* case2 = R"__(
[test]
foo=-0xff
bar=034
baz=-0.23
buzz=1E-34
bazz=0b10101010110011
)__";

constexpr const char* case3 = R"__("
[whoops
foo="bar"
[test]
; provoke some more errors
foo bar
=42
baz=
foo="
bar="foo
some-int=42
some-string="hi there!\"
neg=-
wtf=0x3733T
not-a-bin=0b101002
hu=0779
hop=--"hiho"
)__";

class message_visitor : public static_visitor<message> {
public:
  template <class T>
  message operator()(T& value) const {
    return make_message(std::move(value));
  }
};

struct config : actor_system_config {
  config() {
    parse(test::engine::argc(), test::engine::argv());
  }
};

struct fixture {
  actor_system_config cfg;
  actor_system system;

  fixture() : system(cfg) {
    // nop
  }

  template <class F>
  void load_impl(F consumer, const char* str) {
    std::stringstream ss;
    std::stringstream err;
    ss << str;
    detail::parse_ini(ss, consumer, static_cast<std::ostream&>(err));
    split(errors, err.str(), is_any_of("\n"), token_compress_on);
  }

  void load_to_config_server(const char* str) {
    config_server = actor_cast<actor>(system.registry().get(atom("ConfigServ")));
    // clear config
    scoped_actor self{system};
    self->request(config_server, infinite, get_atom::value, "*").receive(
      [&](std::vector<std::pair<std::string, message>>& msgs) {
        for (auto& kvp : msgs)
          self->send(config_server, put_atom::value, kvp.first, message{});
      },
      ERROR_HANDLER
    );
    auto consume = [&](size_t, std::string key, config_value& value,
                       optional<std::ostream&>) {
      message_visitor mv;
      anon_send(config_server, put_atom::value,
                std::move(key), visit(mv, value));
    };
    load_impl(consume, str);
  }

  void load(const char* str) {
    auto consume = [&](size_t, std::string key, config_value& value,
                       optional<std::ostream&>) {
      values.emplace(std::move(key), std::move(value));
    };
    load_impl(consume, str);
  }

  bool has_error(const char* err) {
    return std::any_of(errors.begin(), errors.end(),
                       [=](const std::string& str) { return str == err; });
  }

  template <class T>
  bool config_server_has(const char* key, const T& what) {
    using type =
      typename std::conditional<
        std::is_convertible<T, std::string>::value,
        std::string,
        typename std::conditional<
          std::is_integral<T>::value && !std::is_same<T, bool>::value,
          int64_t,
          T
        >::type
      >::type;
    bool result = false;
    scoped_actor self{system};
    self->request(config_server, infinite, get_atom::value, key).receive(
      [&](std::string&, message& msg) {
        msg.apply(
          [&](type& val) {
            result = detail::safe_equal(what, val);
          }
        );
      },
      ERROR_HANDLER
    );
    return result;
  }

  template <class T>
  bool value_is(const char* key, const T& what) {
    if (config_server)
      return config_server_has(key, what);
    auto& cv = values[key];
    using type =
      typename std::conditional<
        std::is_convertible<T, std::string>::value,
        std::string,
        typename std::conditional<
          std::is_integral<T>::value && !std::is_same<T, bool>::value,
          int64_t,
          T
        >::type
      >::type;
    auto ptr = get_if<type>(&cv);
    return ptr != nullptr && detail::safe_equal(*ptr, what);
  }

  size_t num_values() {
    if (config_server) {
      size_t result = 0;
      scoped_actor self{system};
      self->request(config_server, infinite, get_atom::value, "*").receive(
        [&](std::vector<std::pair<std::string, message>>& msgs) {
          for (auto& kvp : msgs)
            if (!kvp.second.empty())
              ++result;
        },
        ERROR_HANDLER
      );
      return result;
    }
    return values.size();
  }

  void check_case1() {
    CAF_CHECK(errors.empty());
    CAF_CHECK(num_values() == 6);
    CAF_CHECK(value_is("nexus.port", 4242));
    CAF_CHECK(value_is("nexus.host", "127.0.0.1"));
    CAF_CHECK(value_is("scheduler.policy", "work-sharing"));
    CAF_CHECK(value_is("scheduler.max-threads", 2));
    CAF_CHECK(value_is("middleman.automatic-connections", true));
    CAF_CHECK(value_is("cash.greeting",
              "Hi there, this is \"CASH!\"\n ~\\~ use at your own risk ~\\~"));
  }

  void check_case2() {
    CAF_CHECK(errors.empty());
    CAF_CHECK(num_values() == 5);
    CAF_CHECK(value_is("test.foo", -0xff));
    CAF_CHECK(value_is("test.bar", 034));
    CAF_CHECK(value_is("test.baz", -0.23));
    CAF_CHECK(value_is("test.buzz", 1E-34));
    CAF_CHECK(value_is("test.bazz", 10931));
  }

  void check_case3() {
    CAF_CHECK(has_error("[ERROR] INI file line 2: missing ] at end of line"));
    CAF_CHECK(has_error("[ERROR] INI file line 3: value outside of a group"));
    CAF_CHECK(has_error("[ERROR] INI file line 6: no '=' found"));
    CAF_CHECK(has_error("[ERROR] INI file line 7: line starting with '='"));
    CAF_CHECK(has_error("[ERROR] INI file line 8: line ends with '='"));
    CAF_CHECK(has_error("[ERROR] INI file line 9: stray '\"'"));
    CAF_CHECK(has_error("[ERROR] INI file line 10: string not terminated by '\"'"));
    CAF_CHECK(has_error("[WARNING] INI file line 12: trailing quotation mark escaped"));
    CAF_CHECK(has_error("[ERROR] INI file line 13: '-' is not a number"));
    CAF_CHECK(has_error("[ERROR] INI file line 14: invalid hex value"));
    CAF_CHECK(has_error("[ERROR] INI file line 15: invalid binary value"));
    CAF_CHECK(has_error("[ERROR] INI file line 16: invalid oct value"));
    CAF_CHECK(has_error("[ERROR] INI file line 17: invalid value"));
    CAF_CHECK(num_values() == 2);
    CAF_CHECK(value_is("test.some-int", 42));
    CAF_CHECK(value_is("test.some-string", "hi there!"));
  }

  std::map<std::string, config_value> values;
  actor config_server;
  std::vector<std::string> errors;
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(parse_ini_tests, fixture)

CAF_TEST(simple_ini) {
  load(case1);
  check_case1();
}

CAF_TEST(numbers) {
  load(case2);
  check_case2();
}

CAF_TEST(errors) {
  load(case3);
  check_case3();
}

CAF_TEST(simple_ini_via_config_server) {
  load_to_config_server(case1);
  CAF_CHECK(values.empty());
  check_case1();
}

CAF_TEST(numbers_via_config_server) {
  load_to_config_server(case2);
  CAF_CHECK(values.empty());
  check_case2();
}

CAF_TEST(errors_via_config_server) {
  load_to_config_server(case3);
  CAF_CHECK(values.empty());
  check_case3();
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE result
#include "caf/test/unit_test.hpp"

#include "caf/sec.hpp"
#include "caf/result.hpp"

using namespace std;
using namespace caf;

CAF_TEST(skip) {
  auto x = result<>{skip()};
  CAF_CHECK_EQUAL(x.flag, rt_skip);
  CAF_CHECK(x.value.empty());
}

CAF_TEST(value) {
  auto x = result<int>{42};
  CAF_CHECK_EQUAL(x.flag, rt_value);
  CAF_CHECK_EQUAL(x.value.get_as<int>(0), 42);
}

CAF_TEST(expected) {
  auto x = result<int>{expected<int>{42}};
  CAF_CHECK_EQUAL(x.flag, rt_value);
  CAF_CHECK_EQUAL(x.value.get_as<int>(0), 42);
  x = expected<int>{sec::unexpected_message};
  CAF_CHECK_EQUAL(x.flag, rt_error);
  CAF_CHECK_EQUAL(x.err, make_error(sec::unexpected_message));
  CAF_CHECK(x.value.empty());
}

CAF_TEST(void_specialization) {
  auto x = result<void>{};
  CAF_CHECK_EQUAL(x.flag, rt_value);
  x = skip();
  CAF_CHECK_EQUAL(x.flag, rt_skip);
  x = expected<void>{};
  CAF_CHECK_EQUAL(x.flag, rt_value);
  x = expected<void>{sec::unexpected_message};
  CAF_CHECK_EQUAL(x.flag, rt_error);
  CAF_CHECK_EQUAL(x.err, make_error(sec::unexpected_message));
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE custom_exception_handler
#include "caf/test/unit_test.hpp"

#include "caf/all.hpp"

using namespace caf;

#ifndef CAF_NO_EXCEPTIONS

class exception_testee : public event_based_actor {
public:
  ~exception_testee() override;
  exception_testee(actor_config& cfg) : event_based_actor(cfg) {
    set_exception_handler([](std::exception_ptr&) -> error {
      return exit_reason::remote_link_unreachable;
    });
  }

  behavior make_behavior() override {
    return {
      [](const std::string&) {
        throw std::runtime_error("whatever");
      }
    };
  }
};

exception_testee::~exception_testee() {
  // avoid weak-vtables warning
}

CAF_TEST(test_custom_exception_handler) {
  actor_system_config cfg;
  actor_system system{cfg};
  auto handler = [](std::exception_ptr& eptr) -> error {
    try {
      std::rethrow_exception(eptr);
    }
    catch (std::runtime_error&) {
      return exit_reason::normal;
    }
    catch (...) {
      // "fall through"
    }
    return exit_reason::unhandled_exception;
  };
  scoped_actor self{system};
  auto testee1 = self->spawn<monitored>([=](event_based_actor* eb_self) {
    eb_self->set_exception_handler(handler);
    throw std::runtime_error("ping");
  });
  auto testee2 = self->spawn<monitored>([=](event_based_actor* eb_self) {
    eb_self->set_exception_handler(handler);
    throw std::logic_error("pong");
  });
  auto testee3 = self->spawn<exception_testee, monitored>();
  self->send(testee3, "foo");
  // receive all down messages
  self->wait_for(testee1, testee2, testee3);
}

#else // CAF_NO_EXCEPTIONS

CAF_TEST(no_exceptions_dummy) {
  CAF_CHECK_EQUAL(true, true);
}

#endif // CAF_NO_EXCEPTIONS
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

// this test is essentially a subset of streaming.cpp and tests whether the
// 3-stage pipeline compiles and runs when using a type-safe version of each
// stage

#include <deque>
#include <string>
#include <vector>

#define CAF_SUITE typed_stream_stages
#include "caf/test/dsl.hpp"

using std::string;

using namespace caf;

namespace {

using file_reader_actor = typed_actor<replies_to<string>
                                      ::with<stream<int>, string>>;

using filter_actor = typed_actor<replies_to<stream<int>, string>
                                 ::with<stream<int>, string>>;

using sum_up_actor = typed_actor<replies_to<stream<int>, string>::with<int>>;

file_reader_actor::behavior_type file_reader(file_reader_actor::pointer self) {
  using buf = std::deque<int>;
  return {
    [=](std::string& fname) {
      CAF_CHECK_EQUAL(fname, "test.txt");
      return self->make_source(
        // forward file name in handshake to next stage
        std::forward_as_tuple(std::move(fname)),
        // initialize state
        [=](buf& xs) {
          xs = buf{1, 2, 3, 4, 5, 6, 7, 8, 9};
        },
        // get next element
        [=](buf& xs, downstream<int>& out, size_t num) {
          auto n = std::min(num, xs.size());
          for (size_t i = 0; i < n; ++i)
            out.push(xs[i]);
          xs.erase(xs.begin(), xs.begin() + static_cast<ptrdiff_t>(n));
        },
        // check whether we reached the end
        [=](const buf& xs) {
          return xs.empty();
        }
      );
    }
  };
}

filter_actor::behavior_type filter(filter_actor::pointer self) {
  return {
    [=](stream<int>& in, std::string& fname) {
      CAF_CHECK_EQUAL(fname, "test.txt");
      return self->make_stage(
        // input stream
        in,
        // forward file name in handshake to next stage
        std::forward_as_tuple(std::move(fname)),
        // initialize state
        [=](unit_t&) {
          // nop
        },
        // processing step
        [=](unit_t&, downstream<int>& out, int x) {
          if ((x & 0x01) != 0)
            out.push(x);
        },
        // cleanup
        [=](unit_t&) {
          // nop
        }
      );
    }
  };
}

sum_up_actor::behavior_type sum_up(sum_up_actor::pointer self) {
  return {
    [=](stream<int>& in, std::string& fname) {
      CAF_CHECK_EQUAL(fname, "test.txt");
      return self->make_sink(
        // input stream
        in,
        // initialize state
        [](int& x) {
          x = 0;
        },
        // processing step
        [](int& x, int y) {
          x += y;
        },
        // cleanup and produce result message
        [](int& x) -> int {
          return x;
        }
      );
    }
  };
}

using fixture = test_coordinator_fixture<>;

using pipeline_actor = typed_actor<replies_to<string>::with<int>>;

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(typed_streaming_tests, fixture)

CAF_TEST(depth3_pipeline) {
  scoped_actor self{sys};
  auto source = sys.spawn(file_reader);
  auto stage = sys.spawn(filter);
  auto sink = sys.spawn(sum_up);
  auto pipeline = (sink * stage) * source;
  CAF_MESSAGE("source: " << to_string(source));
  CAF_MESSAGE("stage: " << to_string(stage));
  CAF_MESSAGE("sink: " << to_string(sink));
  CAF_MESSAGE("pipeline: " << to_string(pipeline));
  static_assert(std::is_same<decltype(pipeline), pipeline_actor>::value,
                "pipeline composition returned wrong type");
  sched.run();
  sched.after_next_enqueue([&] { sched.run(); });
  self->request(pipeline, infinite, "test.txt").receive(
    [&](int x) {
      CAF_CHECK_EQUAL(x, 25);
    },
    [&](error& err) {
      CAF_FAIL("error: " << sys.render(err));
    }
  );
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <set>
#include <map>
#include <list>
#include <vector>
#include <string>
#include <unordered_set>
#include <unordered_map>

#include "caf/config.hpp"

#define CAF_SUITE inspector
#include "caf/test/unit_test.hpp"

#include "caf/actor_system.hpp"
#include "caf/type_erased_value.hpp"
#include "caf/binary_serializer.hpp"
#include "caf/actor_system_config.hpp"
#include "caf/binary_deserializer.hpp"
#include "caf/make_type_erased_value.hpp"

#include "caf/detail/stringification_inspector.hpp"

using namespace caf;

namespace {

template <class T>
class inspector_adapter_base {
public:
  inspector_adapter_base(T& impl) : impl_(impl) {
    // nop
  }

protected:
  T& impl_;
};

template <class RoundtripPolicy>
struct check_impl {
  RoundtripPolicy& p_;

  template <class T>
  bool operator()(T x) {
    return p_(x);
  }
};

template <class T>
using nl = std::numeric_limits<T>;

// an empty type
struct dummy_tag_type {};

constexpr bool operator==(dummy_tag_type, dummy_tag_type) {
  return true;
}

// a POD type
struct dummy_struct {
  int a;
  std::string b;
};

bool operator==(const dummy_struct& x, const dummy_struct& y) {
  return x.a == y.a && x.b == y.b;
}

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, dummy_struct& x) {
  return f(meta::type_name("dummy_struct"), x.a, x.b);
}

// two different styles of enums
enum dummy_enum { de_foo, de_bar };

enum dummy_enum_class : short { foo, bar };

std::string to_string(dummy_enum_class x) {
  return x == dummy_enum_class::foo ? "foo" : "bar";
}

template <class Policy>
void test_impl(Policy& p) {
  check_impl<Policy> check{p};
  // check primitive types
  CAF_CHECK(check(true));
  CAF_CHECK(check(false));
  CAF_CHECK(check(nl<int8_t>::lowest()));
  CAF_CHECK(check(nl<int8_t>::max()));
  CAF_CHECK(check(nl<uint8_t>::lowest()));
  CAF_CHECK(check(nl<uint8_t>::max()));
  CAF_CHECK(check(nl<int16_t>::lowest()));
  CAF_CHECK(check(nl<int16_t>::max()));
  CAF_CHECK(check(nl<uint16_t>::lowest()));
  CAF_CHECK(check(nl<uint16_t>::max()));
  CAF_CHECK(check(nl<int32_t>::lowest()));
  CAF_CHECK(check(nl<int32_t>::max()));
  CAF_CHECK(check(nl<uint32_t>::lowest()));
  CAF_CHECK(check(nl<uint32_t>::max()));
  CAF_CHECK(check(nl<int64_t>::lowest()));
  CAF_CHECK(check(nl<int64_t>::max()));
  CAF_CHECK(check(nl<uint64_t>::lowest()));
  CAF_CHECK(check(nl<uint64_t>::max()));
  CAF_CHECK(check(nl<float>::lowest()));
  CAF_CHECK(check(nl<float>::max()));
  CAF_CHECK(check(nl<double>::lowest()));
  CAF_CHECK(check(nl<double>::max()));
  CAF_CHECK(check(nl<long double>::lowest()));
  CAF_CHECK(check(nl<long double>::max()));
  // atoms
  CAF_CHECK(check(atom("")));
  CAF_CHECK(check(atom("0123456789")));
  // various containers
  CAF_CHECK(check(std::array<int, 3>{{1, 2, 3}}));
  CAF_CHECK(check(std::vector<char>{}));
  CAF_CHECK(check(std::vector<char>{1, 2, 3}));
  CAF_CHECK(check(std::vector<int>{}));
  CAF_CHECK(check(std::vector<int>{1, 2, 3}));
  CAF_CHECK(check(std::list<int>{}));
  CAF_CHECK(check(std::list<int>{1, 2, 3}));
  CAF_CHECK(check(std::set<int>{}));
  CAF_CHECK(check(std::set<int>{1, 2, 3}));
  CAF_CHECK(check(std::unordered_set<int>{}));
  CAF_CHECK(check(std::unordered_set<int>{1, 2, 3}));
  CAF_CHECK(check(std::map<int, int>{}));
  CAF_CHECK(check(std::map<int, int>{{1, 1}, {2, 2}, {3, 3}}));
  CAF_CHECK(check(std::unordered_map<int, int>{}));
  CAF_CHECK(check(std::unordered_map<int, int>{{1, 1}, {2, 2}, {3, 3}}));
  // user-defined types
  CAF_CHECK(check(dummy_struct{10, "hello"}));
  // optionals
  CAF_CHECK(check(optional<int>{}));
  CAF_CHECK(check(optional<int>{42}));
  // strings
  CAF_CHECK(check(std::string{}));
  CAF_CHECK(check(std::string{""}));
  CAF_CHECK(check(std::string{"test"}));
  CAF_CHECK(check(std::u16string{}));
  CAF_CHECK(check(std::u16string{u""}));
  CAF_CHECK(check(std::u16string{u"test"}));
  CAF_CHECK(check(std::u32string{}));
  CAF_CHECK(check(std::u32string{U""}));
  CAF_CHECK(check(std::u32string{U"test"}));
  // enums
  CAF_CHECK(check(de_foo));
  CAF_CHECK(check(de_bar));
  CAF_CHECK(check(dummy_enum_class::foo));
  CAF_CHECK(check(dummy_enum_class::bar));
  // empty type
  CAF_CHECK(check(dummy_tag_type{}));
  // pair and tuple
  CAF_CHECK(check(std::make_pair(std::string("hello"), 42)));
  CAF_CHECK(check(std::make_pair(std::make_pair(1, 2), 3)));
  CAF_CHECK(check(std::make_pair(std::make_tuple(1, 2), 3)));
  CAF_CHECK(check(std::make_tuple(1, 2, 3, 4)));
  CAF_CHECK(check(std::make_tuple(std::make_tuple(1, 2, 3), 4)));
  CAF_CHECK(check(std::make_tuple(std::make_pair(1, 2), 3, 4)));
  // variant<>
  CAF_CHECK(check(variant<none_t>{}));
  CAF_CHECK(check(variant<none_t, int, std::string>{}));
  CAF_CHECK(check(variant<none_t, int, std::string>{42}));
  CAF_CHECK(check(variant<none_t, int, std::string>{std::string{"foo"}}));
}

} // namespace <anonymous>

namespace {
struct stringification_inspector_policy {
  template <class T>
  std::string f(T& x) {
    std::string str;
    detail::stringification_inspector fun{str};
    fun(x);
    return str;
  }

  // only check for compilation for complex types
  template <class T>
  typename std::enable_if<!std::is_integral<T>::value, bool>::type
  operator()(T& x) {
    CAF_MESSAGE("f(x) = " << f(x));
    return true;
  }

  // check result for integral types
  template <class T>
  typename std::enable_if<std::is_integral<T>::value, bool>::type
  operator()(T& x) {
    CAF_CHECK_EQUAL(f(x), std::to_string(x));
    return true;
  }

  // check result for bool
  bool operator()(bool& x) {
    CAF_CHECK_EQUAL(f(x), std::string{x ? "true" : "false"});
    return true;
  }

  // check result for atoms
  bool operator()(atom_value& x) {
    CAF_CHECK_EQUAL(f(x), "'" + to_string(x) + "'");
    return true;
  }
};
} // namespace <anonymous>

CAF_TEST(stringification_inspector) {
  stringification_inspector_policy p;
  test_impl(p);
}

namespace {
struct binary_serialization_policy {
  execution_unit& context;

  template <class T>
  bool operator()(T& x) {
    std::vector<char> buf;
    binary_serializer f{&context, buf};
    f(x);
    binary_deserializer g{&context, buf};
    T y;
    g(y);
    CAF_CHECK_EQUAL(x, y);
    return detail::safe_equal(x, y);
  }
};
} // namespace <anonymous>

CAF_TEST(binary_serialization_inspectors) {
  actor_system_config cfg;
  cfg.add_message_type<dummy_struct>("dummy_struct");
  actor_system sys{cfg};
  scoped_execution_unit context;
  binary_serialization_policy p{context};
  test_impl(p);

}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE match
#include "caf/test/unit_test.hpp"

#include <functional>

#include "caf/message_builder.hpp"
#include "caf/message_handler.hpp"
#include "caf/make_type_erased_tuple_view.hpp"

using namespace caf;
using namespace std;

using hi_atom = atom_constant<atom("hi")>;
using ho_atom = atom_constant<atom("ho")>;

namespace {

using rtti_pair = std::pair<uint16_t, const std::type_info*>;

std::string to_string(const rtti_pair& x) {
  std::string result = "(";
  result += std::to_string(x.first);
  result += ", ";
  result += x.second != nullptr ? x.second->name() : "<null>";
  result += ")";
  return result;
}

struct fixture {
  using array_type = std::array<bool, 4>;

  fixture() {
    reset();
  }

  void reset() {
    for (auto& x : invoked)
      x = false;
  }

  template <class... Ts>
  ptrdiff_t invoke(message_handler expr, Ts... xs) {
    auto msg1 = make_message(xs...);
    auto msg2 = message_builder{}.append_all(xs...).move_to_message();
    auto msg3 = make_type_erased_tuple_view(xs...);
    CAF_CHECK_EQUAL(to_string(msg1), to_string(msg2));
    CAF_CHECK_EQUAL(to_string(msg1), to_string(msg3));
    CAF_CHECK_EQUAL(msg1.type_token(), msg2.type_token());
    CAF_CHECK_EQUAL(msg1.type_token(), msg3.type_token());
    std::vector<std::string> msg1_types;
    std::vector<std::string> msg2_types;
    std::vector<std::string> msg3_types;
    for (size_t i = 0; i < msg1.size(); ++i) {
      msg1_types.push_back(to_string(msg1.type(i)));
      msg2_types.push_back(to_string(msg2.type(i)));
      msg3_types.push_back(to_string(msg3.type(i)));
    }
    CAF_CHECK_EQUAL(msg1_types, msg2_types);
    CAF_CHECK_EQUAL(msg1_types, msg3_types);
    set<ptrdiff_t> results;
    process(results, expr, msg1, msg2, msg3);
    if (results.size() > 1) {
      CAF_ERROR("different results reported: " << deep_to_string(results));
      return -2;
    }
    return *results.begin();
  }

  void process(std::set<ptrdiff_t>&, message_handler&) {
    // end of recursion
  }

  template <class T, class... Ts>
  void process(std::set<ptrdiff_t>& results, message_handler& expr,
               T& x, Ts&... xs) {
    expr(x);
    results.insert(invoked_res());
    reset();
    process(results, expr, xs...);
  }

  ptrdiff_t invoked_res() {
    auto first = begin(invoked);
    auto last = end(invoked);
    auto i = find(first, last, true);
    if (i != last) {
      CAF_REQUIRE_EQUAL(count(i, last, true), 1u);
      return distance(first, i);
    }
    return -1;
  }

  array_type invoked;
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(atom_constants_tests, fixture)

CAF_TEST(atom_constants) {
  message_handler expr{
    [&](hi_atom) {
      invoked[0] = true;
    },
    [&](ho_atom) {
      invoked[1] = true;
    }
  };
  CAF_CHECK_EQUAL(invoke(expr, atom_value{ok_atom::value}), -1);
  CAF_CHECK_EQUAL(invoke(expr, atom_value{hi_atom::value}), 0);
  CAF_CHECK_EQUAL(invoke(expr, atom_value{ho_atom::value}), 1);
}

CAF_TEST(manual_matching) {
  using foo_atom = atom_constant<atom("foo")>;
  using bar_atom = atom_constant<atom("bar")>;
  auto msg1 = make_message(foo_atom::value, 42);
  auto msg2 = make_message(bar_atom::value, 42);
  CAF_MESSAGE("check individual message elements");
  CAF_CHECK((msg1.match_element<int>(1)));
  CAF_CHECK((msg2.match_element<int>(1)));
  CAF_CHECK((msg1.match_element<foo_atom>(0)));
  CAF_CHECK((!msg2.match_element<foo_atom>(0)));
  CAF_CHECK((!msg1.match_element<bar_atom>(0)));
  CAF_CHECK((msg2.match_element<bar_atom>(0)));
  CAF_MESSAGE("check matching whole tuple");
  CAF_CHECK((msg1.match_elements<foo_atom, int>()));
  CAF_CHECK(!(msg2.match_elements<foo_atom, int>()));
  CAF_CHECK(!(msg1.match_elements<bar_atom, int>()));
  CAF_CHECK((msg2.match_elements<bar_atom, int>()));
  CAF_CHECK((msg1.match_elements<atom_value, int>()));
  CAF_CHECK((msg2.match_elements<atom_value, int>()));
  CAF_CHECK(!(msg1.match_elements<atom_value, double>()));
  CAF_CHECK(!(msg2.match_elements<atom_value, double>()));
  CAF_CHECK(!(msg1.match_elements<atom_value, int, int>()));
  CAF_CHECK(!(msg2.match_elements<atom_value, int, int>()));
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE splitter
#include "caf/test/unit_test.hpp"

#include "caf/all.hpp"

#define ERROR_HANDLER                                                          \
  [&](error& err) { CAF_FAIL(system.render(err)); }

using namespace caf;

namespace {

using first_stage = typed_actor<replies_to<double>::with<double, double>>;
using second_stage = typed_actor<replies_to<double, double>::with<double>,
                                 replies_to<double>::with<double>>;

first_stage::behavior_type typed_first_stage() {
  return [](double x) {
    return std::make_tuple(x * 2.0, x * 4.0);
  };
}

second_stage::behavior_type typed_second_stage() {
  return {
    [](double x, double y) {
      return x * y;
    },
    [](double x) {
      return 23.0 * x;
    }
  };
}

behavior untyped_first_stage() {
  return typed_first_stage().unbox();
}

behavior untyped_second_stage() {
  return typed_second_stage().unbox();
}

struct fixture {
  actor_system_config cfg;
  actor_system system;
  scoped_actor self;
  actor first;
  actor second;
  actor first_and_second;

  fixture() : system(cfg), self(system, true) {
    // nop
  }

  void init_untyped() {
    using namespace std::placeholders;
    first = system.spawn(untyped_first_stage);
    second = system.spawn(untyped_second_stage);
    first_and_second = splice(first, second);
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(sequencer_tests, fixture)

CAF_TEST(identity) {
  init_untyped();
  CAF_CHECK_NOT_EQUAL(first, second);
  CAF_CHECK_NOT_EQUAL(first, first_and_second);
  CAF_CHECK_NOT_EQUAL(second, first_and_second);
}

CAF_TEST(kill_first) {
  init_untyped();
  anon_send_exit(first, exit_reason::kill);
  self->wait_for(first_and_second);
}

CAF_TEST(kill_second) {
  init_untyped();
  anon_send_exit(second, exit_reason::kill);
  self->wait_for(first_and_second);
}

CAF_TEST(untyped_splicing) {
  init_untyped();
  self->request(first_and_second, infinite, 42.0).receive(
    [](double x, double y, double z) {
      CAF_CHECK_EQUAL(x, (42.0 * 2.0));
      CAF_CHECK_EQUAL(y, (42.0 * 4.0));
      CAF_CHECK_EQUAL(z, (23.0 * 42.0));
    },
    ERROR_HANDLER
  );
}

/*
CAF_TEST(typed_splicing) {
  using namespace std::placeholders;
  auto stage0 = system.spawn(typed_first_stage);
  auto stage2 = system.spawn(typed_second_stage);
  auto stages = splice(stage0, stage2);
  using expected_type = typed_actor<replies_to<double>
                                    ::with<double, double, double>>;
  static_assert(std::is_same<decltype(stages), expected_type>::value,
                "splice() did not compute the correct result");
  self->request(stages, infinite, 42.0).receive(
    [](double x, double y, double z) {
      CAF_CHECK_EQUAL(x, (42.0 * 2.0));
      CAF_CHECK_EQUAL(y, (42.0 * 4.0));
      CAF_CHECK_EQUAL(z, (23.0 * 42.0));
    },
    ERROR_HANDLER
  );
  // stage0 and stage2 go out of scope, leaving only the references
  // in stages, which will also go out of scope
}
*/

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE atom
#include "caf/test/unit_test.hpp"

#include <string>

#include "caf/all.hpp"

using namespace caf;

namespace {

constexpr auto s_foo = atom("FooBar");

using a_atom = atom_constant<atom("a")>;
using b_atom = atom_constant<atom("b")>;
using c_atom = atom_constant<atom("c")>;
using abc_atom = atom_constant<atom("abc")>;
using def_atom = atom_constant<atom("def")>;
using foo_atom = atom_constant<atom("foo")>;

struct fixture {
  fixture() : system(cfg) {
    // nop
  }

  actor_system_config cfg;
  actor_system system;
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(atom_tests, fixture)

CAF_TEST(basics) {
  // check if there are leading bits that distinguish "zzz" and "000 "
  CAF_CHECK_NOT_EQUAL(atom("zzz"), atom("000 "));
  // check if there are leading bits that distinguish "abc" and " abc"
  CAF_CHECK_NOT_EQUAL(atom("abc"), atom(" abc"));
  // 'illegal' characters are mapped to whitespaces
  CAF_CHECK_EQUAL(atom("   "), atom("@!?"));
  // check to_string impl
  CAF_CHECK_EQUAL(to_string(s_foo), "FooBar");
}

struct send_to_self {
  explicit send_to_self(blocking_actor* self) : self_(self) {
    // nop
  }
  template <class... Ts>
  void operator()(Ts&&... xs) {
    self_->send(self_, std::forward<Ts>(xs)...);
  }
  blocking_actor* self_;
};

CAF_TEST(receive_atoms) {
  scoped_actor self{system};
  send_to_self f{self.ptr()};
  f(foo_atom::value, static_cast<uint32_t>(42));
  f(abc_atom::value, def_atom::value, "cstring");
  f(1.f);
  f(a_atom::value, b_atom::value, c_atom::value, 23.f);
  bool matched_pattern[3] = {false, false, false};
  int i = 0;
  CAF_MESSAGE("start receive loop");
  for (i = 0; i < 3; ++i) {
    self->receive(
      [&](foo_atom, uint32_t value) {
        matched_pattern[0] = true;
        CAF_CHECK_EQUAL(value, 42u);
      },
      [&](abc_atom, def_atom, const std::string& str) {
        matched_pattern[1] = true;
        CAF_CHECK_EQUAL(str, "cstring");
      },
      [&](a_atom, b_atom, c_atom, float value) {
        matched_pattern[2] = true;
        CAF_CHECK_EQUAL(value, 23.f);
      }
    );
  }
  CAF_CHECK(matched_pattern[0] && matched_pattern[1] && matched_pattern[2]);
  self->receive(
    [](float) {
      // erase float message
    }
  );
  atom_value x = atom("abc");
  atom_value y = abc_atom::value;
  CAF_CHECK_EQUAL(x, y);
  auto msg = make_message(atom("abc"));
  self->send(self, msg);
  self->receive(
    [](abc_atom) {
      CAF_MESSAGE("received 'abc'");
    }
  );
}

using testee = typed_actor<replies_to<abc_atom>::with<int>>;

testee::behavior_type testee_impl(testee::pointer self) {
  return {
    [=](abc_atom) {
      self->quit();
      return 42;
    }
  };
}

CAF_TEST(request_atom_constants) {
  scoped_actor self{system};
  auto tst = system.spawn(testee_impl);
  self->request(tst, infinite, abc_atom::value).receive(
    [](int i) {
      CAF_CHECK_EQUAL(i, 42);
    },
    [&](error& err) {
      CAF_FAIL("err: " << system.render(err));
    }
  );
}

CAF_TEST(runtime_conversion) {
  CAF_CHECK_EQUAL(atom("foo"), atom_from_string("foo"));
  CAF_CHECK_EQUAL(atom(""), atom_from_string("tooManyCharacters"));
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE type_erased_tuple
#include "caf/test/unit_test.hpp"

#include "caf/all.hpp"
#include "caf/make_type_erased_tuple_view.hpp"

using namespace std;
using namespace caf;

CAF_TEST(get_as_tuple) {
  int x = 1;
  int y = 2;
  int z = 3;
  auto tup = make_type_erased_tuple_view(x, y, z);
  auto xs = tup.get_as_tuple<int, int, int>();
  CAF_CHECK_EQUAL(xs, std::make_tuple(1, 2, 3));
}

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE to_string
#include "caf/test/unit_test.hpp"

#include "caf/to_string.hpp"

using namespace std;
using namespace caf;

CAF_TEST(buffer) {
  // Use `signed char` explicitly to make sure all compilers agree.
  std::vector<signed char> buf;
  CAF_CHECK_EQUAL(deep_to_string(buf), "[]");
  CAF_CHECK_EQUAL(deep_to_string(meta::hex_formatted(), buf), "00");
  buf.push_back(-1);
  CAF_CHECK_EQUAL(deep_to_string(buf), "[-1]");
  CAF_CHECK_EQUAL(deep_to_string(meta::hex_formatted(), buf), "FF");
  buf.push_back(0);
  CAF_CHECK_EQUAL(deep_to_string(buf), "[-1, 0]");
  CAF_CHECK_EQUAL(deep_to_string(meta::hex_formatted(), buf), "FF00");
  buf.push_back(127);
  CAF_CHECK_EQUAL(deep_to_string(buf), "[-1, 0, 127]");
  CAF_CHECK_EQUAL(deep_to_string(meta::hex_formatted(), buf), "FF007F");
  buf.push_back(10);
  CAF_CHECK_EQUAL(deep_to_string(buf), "[-1, 0, 127, 10]");
  CAF_CHECK_EQUAL(deep_to_string(meta::hex_formatted(), buf), "FF007F0A");
  buf.push_back(16);
  CAF_CHECK_EQUAL(deep_to_string(buf), "[-1, 0, 127, 10, 16]");
  CAF_CHECK_EQUAL(deep_to_string(meta::hex_formatted(), buf), "FF007F0A10");
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE local_migration
#include "caf/test/unit_test.hpp"

/* --- "disabled" (see #199) ---

#include "caf/all.hpp"

#include "caf/actor_registry.hpp"

using namespace caf;

using std::endl;

namespace {

struct migratable_state {
  int value = 0;
  static const char* name;
};

const char* migratable_state::name = "migratable_actor";

template <class Processor>
void serialize(Processor& proc, migratable_state& x, const unsigned int) {
  proc & x.value;
}

struct migratable_actor : stateful_actor<migratable_state> {
  migratable_actor(actor_config& cfg) : stateful_actor<migratable_state>(cfg) {
    // nop
  }

  behavior make_behavior() override {
    return {
      [=](get_atom) {
        return state.value;
      },
      [=](put_atom, int value) {
        state.value = value;
      }
    };
  }
};

// always migrates to `dest`
behavior pseudo_mm(event_based_actor* self, const actor& dest) {
  return {
    [=](migrate_atom, const std::string& name, std::vector<char>& buf) {
      CAF_CHECK(name == "migratable_actor");
      self->delegate(dest, sys_atom::value, migrate_atom::value,
                     std::move(buf));
    }
  };
}

} // namespace <anonymous>

CAF_TEST(migrate_locally) {
  actor_system system;
  auto a = system.spawn<migratable_actor>();
  auto b = system.spawn<migratable_actor>();
  auto mm1 = system.spawn(pseudo_mm, b);
  { // Lifetime scope of scoped_actor
    scoped_actor self{system};
    self->send(a, put_atom::value, 42);
    // migrate from a to b
    self->request(a, infinite, sys_atom::value,
                  migrate_atom::value, mm1).receive(
      [&](ok_atom, const actor_addr& dest) {
        CAF_CHECK(dest == b);
      }
    );
    self->request(a, infinite, get_atom::value).receive(
      [&](int result) {
        CAF_CHECK(result == 42);
        CAF_CHECK(self->current_sender() == b.address());
      }
    );
    auto mm2 = system.spawn(pseudo_mm, a);
    self->send(b, put_atom::value, 23);
    // migrate back from b to a
    self->request(b, infinite, sys_atom::value,
                  migrate_atom::value, mm2).receive(
      [&](ok_atom, const actor_addr& dest) {
        CAF_CHECK(dest == a);
      }
    );
    self->request(b, infinite, get_atom::value).receive(
      [&](int result) {
        CAF_CHECK(result == 23);
        CAF_CHECK(self->current_sender() == a.address());
      }
    );
    self->send_exit(a, exit_reason::kill);
    self->send_exit(b, exit_reason::kill);
    self->send_exit(mm1, exit_reason::kill);
    self->send_exit(mm2, exit_reason::kill);
    self->await_all_other_actors_done();
  }
}
*/

CAF_TEST(migrate_locally) {
  // nop
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE logger 
#include "caf/test/unit_test.hpp"

#include <ctime>
#include <string>

#include "caf/all.hpp"

using namespace caf;
using namespace std;
using namespace std::chrono;

namespace {

struct fixture {
  fixture() {
    cfg.scheduler_policy = caf::atom("testing");
  }

  void add(logger::field_type kind) {
    lf.emplace_back(logger::field{kind, nullptr, nullptr});
  }

  template <size_t N>
  void add(logger::field_type kind, const char (&str)[N]) {
    lf.emplace_back(logger::field{kind, str, str + (N - 1)}); // exclude \0
  }

  template <class F, class... Ts>
  string render(F f, Ts&&... xs) {
    ostringstream oss;
    f(oss, forward<Ts>(xs)...);
    return oss.str();
  }

  actor_system_config cfg;
  logger::line_format lf;
};

constexpr const char* file_format = "%r %c %p %a %t %C %M %F:%L %m%n";

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(logger_tests, fixture)

// copy construction, copy assign, move construction, move assign
// and finally serialization round-trip
CAF_TEST(parse_default_format_strings) {
  actor_system sys{cfg};
  CAF_CHECK_EQUAL(cfg.logger_file_format, file_format);
  add(logger::runtime_field);
  add(logger::plain_text_field, " ");
  add(logger::category_field);
  add(logger::plain_text_field, " ");
  add(logger::priority_field);
  add(logger::plain_text_field, " ");
  add(logger::actor_field);
  add(logger::plain_text_field, " ");
  add(logger::thread_field);
  add(logger::plain_text_field, " ");
  add(logger::class_name_field);
  add(logger::plain_text_field, " ");
  add(logger::method_field);
  add(logger::plain_text_field, " ");
  add(logger::file_field);
  add(logger::plain_text_field, ":");
  add(logger::line_field);
  add(logger::plain_text_field, " ");
  add(logger::message_field);
  add(logger::newline_field);
  CAF_CHECK_EQUAL(logger::parse_format(file_format), lf);
#ifdef CAF_LOG_LEVEL
  // Not parsed when compiling without logging enabled.
  CAF_CHECK_EQUAL(sys.logger().file_format(), lf);
#endif
}

CAF_TEST(rendering) {
  // Rendering of type names and function names.
  const char* foobar = "void ns::foo::bar()";
  CAF_CHECK_EQUAL(render(logger::render_fun_name, foobar), "bar");
  CAF_CHECK_EQUAL(render(logger::render_fun_prefix, foobar), "ns.foo");
  // Rendering of time points.
  timestamp t0;
  timestamp t1{timestamp::duration{5000000}}; // epoch + 5000000ns (5ms)
  CAF_CHECK_EQUAL(render(logger::render_time_diff, t0, t1), "5");
  time_t t0_t = 0;
  char t0_buf[50];
  CAF_REQUIRE(strftime(t0_buf, sizeof(t0_buf),
                       "%Y-%m-%d %H:%M:%S", localtime(&t0_t)));
  CAF_CHECK_EQUAL(render(logger::render_date, t0), t0_buf);
  // Rendering of events.
  logger::event e{
    nullptr,
    nullptr,
    CAF_LOG_LEVEL_WARNING,
    "unit.test",
    "void ns::foo::bar()",
    "foo.cpp",
    42,
    "hello world",
    this_thread::get_id(),
    0,
    t0
  };
  // Exclude %r and %t from rendering test because they are nondeterministic.
  actor_system sys{cfg};
  auto lf = logger::parse_format("%c %p %a %C %M %F:%L %m");
  auto& lg = sys.logger();
  using namespace std::placeholders;
  auto render_event = bind(&logger::render, &lg, _1, _2, _3);
  CAF_CHECK_EQUAL(render(render_event, lf, e),
                  "unit.test WARN actor0 ns.foo bar foo.cpp:42 hello world");
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE actor_lifetime
#include "caf/test/unit_test.hpp"

#include <mutex>
#include <atomic>
#include <condition_variable>

#include "caf/all.hpp"

#include "caf/test/dsl.hpp"

using check_atom = caf::atom_constant<caf::atom("check")>;

using namespace caf;

namespace {

std::mutex s_mtx;
std::condition_variable s_cv;
std::atomic<bool> s_tester_init_done;
std::atomic<bool> s_testee_cleanup_done;

std::atomic<long> s_testees;
std::atomic<long> s_pending_on_exits;

class testee : public event_based_actor {
public:
  testee(actor_config& cfg) : event_based_actor(cfg) {
    ++s_testees;
    ++s_pending_on_exits;
  }

  ~testee() override {
    --s_testees;
  }

  const char* name() const override {
    return "testee";
  }

  void on_exit() override {
    --s_pending_on_exits;
  }

  behavior make_behavior() override {
    return {
      [=](int x) {
        return x;
      }
    };
  }
};

template <class ExitMsgType>
behavior tester(event_based_actor* self, const actor& aut) {
  if (std::is_same<ExitMsgType, exit_msg>::value) {
    self->set_exit_handler([self](exit_msg& msg) {
      // must be still alive at this point
      CAF_CHECK_EQUAL(s_testees.load(), 1);
      CAF_CHECK_EQUAL(msg.reason, exit_reason::user_shutdown);
      self->send(self, check_atom::value);
    });
    self->link_to(aut);
  } else {
    self->set_down_handler([self](down_msg& msg) {
      // must be still alive at this point
      CAF_CHECK_EQUAL(s_testees.load(), 1);
      CAF_CHECK_EQUAL(msg.reason, exit_reason::user_shutdown);
      // testee might be still running its cleanup code in
      // another worker thread; by waiting some milliseconds, we make sure
      // testee had enough time to return control to the scheduler
      // which in turn destroys it by dropping the last remaining reference
      self->send(self, check_atom::value);
    });
    self->monitor(aut);
  }
  anon_send_exit(aut, exit_reason::user_shutdown);
  {
    std::unique_lock<std::mutex> guard{s_mtx};
    s_tester_init_done = true;
    s_cv.notify_one();
  }
  return {
    [self](check_atom) {
      { // make sure aut's dtor and on_exit() have been called
        std::unique_lock<std::mutex> guard{s_mtx};
        while (!s_testee_cleanup_done.load())
          s_cv.wait(guard);
      }
      CAF_CHECK_EQUAL(s_testees.load(), 0);
      CAF_CHECK_EQUAL(s_pending_on_exits.load(), 0);
      self->quit();
    }
  };
}



struct config : actor_system_config {
  config() {
    scheduler_policy = atom("testing");
  }
};

struct fixture {
  using sched_t = scheduler::test_coordinator;

  config cfg;
  actor_system system;
  sched_t& sched;

  fixture() : system(cfg), sched(dynamic_cast<sched_t&>(system.scheduler())) {
    // nop
  }

  template <spawn_options Os, class... Ts>
  actor spawn(Ts&&... xs) {
    return system.spawn<Os>(xs...);
  }

  template <class T, spawn_options Os, class... Ts>
  actor spawn(Ts&&... xs) {
    return system.spawn<T, Os>(xs...);
  }

  template <class ExitMsgType, spawn_options TesterOptions,
            spawn_options TesteeOptions>
  void tst() {
    // We re-use these static variables with each run.
    s_tester_init_done = false;
    s_testee_cleanup_done = false;
    // Spawn test subject and tester.
    auto tst_subject = spawn<testee, TesteeOptions>();
    sched.run();
    auto tst_driver = spawn<TesterOptions>(tester<ExitMsgType>, tst_subject);
    tst_subject = nullptr;
    if (has_detach_flag(TesterOptions)) {
      // When dealing with a detached tester we need to insert two
      // synchronization points: 1) exit_msg sent and 2) cleanup code of tester
      // done.
      { // Wait for the exit_msg from the driver.
        std::unique_lock<std::mutex> guard{s_mtx};
        while (!s_tester_init_done)
          s_cv.wait(guard);
      }
      // Run the exit_msg.
      sched.run_once();
      //expect((exit_msg), from(tst_driver).to(tst_subject));
      { // Resume driver.
        std::unique_lock<std::mutex> guard{s_mtx};
        s_testee_cleanup_done = true;
        s_cv.notify_one();
      }
    } else {
      // When both actors are running in the scheduler we don't need any extra
      // synchronization.
      s_tester_init_done = true;
      s_testee_cleanup_done = true;
      sched.run();
    }
  }
};

} // namespace <anonymous>

CAF_TEST(destructor_call) {
  { // lifetime scope of actor systme
    actor_system_config cfg;
    actor_system system{cfg};
    system.spawn<testee>();
  }
  CAF_CHECK_EQUAL(s_testees.load(), 0);
  CAF_CHECK_EQUAL(s_pending_on_exits.load(), 0);
}

CAF_TEST_FIXTURE_SCOPE(actor_lifetime_tests, fixture)

CAF_TEST(no_spawn_options_and_exit_msg) {
  tst<exit_msg, no_spawn_options, no_spawn_options>();
}

CAF_TEST(no_spawn_options_and_down_msg) {
  tst<down_msg, no_spawn_options, no_spawn_options>();
}

CAF_TEST(mixed_spawn_options_and_exit_msg) {
  tst<exit_msg, detached, no_spawn_options>();
}

CAF_TEST(mixed_spawn_options_and_down_msg) {
  tst<down_msg, detached, no_spawn_options>();
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE expected
#include "caf/test/unit_test.hpp"

#include "caf/sec.hpp"
#include "caf/expected.hpp"

using namespace std;
using namespace caf;

#define CHECK(x) CAF_CHECK(x);

#define CHECK_EQ(x, y)                                                         \
  CAF_CHECK(x == y);                                                           \
  CAF_CHECK(y == x);

#define CHECK_NEQ(x, y)                                                        \
  CAF_CHECK(x != y);                                                           \
  CAF_CHECK(y != x);

namespace {

using e_int = expected<int>;
using e_str = expected<std::string>;

} // namespace <anonymous>

CAF_TEST(both_engaged_equal) {
  e_int x{42};
  e_int y{42};
  CHECK(x);
  CHECK(y);
  CHECK_EQ(x, y);
  CHECK_EQ(x, 42);
  CHECK_EQ(y, 42);
}

CAF_TEST(both_engaged_not_equal) {
  e_int x{42};
  e_int y{24};
  CHECK(x);
  CHECK(y);
  CHECK_NEQ(x, y);
  CHECK_NEQ(x, sec::unexpected_message);
  CHECK_NEQ(y, sec::unexpected_message);
  CHECK_EQ(x, 42);
  CHECK_EQ(y, 24);
}

CAF_TEST(engaged_plus_not_engaged) {
  e_int x{42};
  e_int y{sec::unexpected_message};
  CHECK(x);
  CHECK(!y);
  CHECK_EQ(x, 42);
  CHECK_EQ(y, sec::unexpected_message);
  CHECK_NEQ(x, sec::unexpected_message);
  CHECK_NEQ(x, y);
  CHECK_NEQ(y, 42);
  CHECK_NEQ(y, sec::unsupported_sys_key);
}

CAF_TEST(both_not_engaged) {
  e_int x{sec::unexpected_message};
  e_int y{sec::unexpected_message};
  CHECK(!x);
  CHECK(!y);
  CHECK_EQ(x, y);
  CHECK_EQ(x, sec::unexpected_message);
  CHECK_EQ(y, sec::unexpected_message);
  CHECK_EQ(x.error(), y.error());
  CHECK_NEQ(x, sec::unsupported_sys_key);
  CHECK_NEQ(y, sec::unsupported_sys_key);
}

CAF_TEST(move_and_copy) {
  e_str x{sec::unexpected_message};
  e_str y{"hello"};
  x = "hello";
  CHECK_NEQ(x, sec::unexpected_message);
  CHECK_EQ(x, "hello");
  CHECK_EQ(x, y);
  y = "world";
  x = std::move(y);
  CHECK_EQ(x, "world");
  e_str z{std::move(x)};
  CHECK_EQ(z, "world");
  e_str z_cpy{z};
  CHECK_EQ(z_cpy, "world");
  CHECK_EQ(z, z_cpy);
  z = e_str{sec::unsupported_sys_key};
  CHECK_NEQ(z, z_cpy);
  CHECK_EQ(z, sec::unsupported_sys_key);
}

CAF_TEST(construction_with_none) {
  e_int x{none};
  CHECK(!x);
  CHECK(!x.error());
}

CAF_TEST(construction_with_no_error) {
  e_int x{no_error};
  CHECK(!x);
  CHECK(!x.error());
  auto f = []() -> e_int {
    return no_error;
  };
  CHECK_EQ(f(), x);
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

// this suite tests whether actors terminate as expect in several use cases
#define CAF_SUITE thread_hook

#include "caf/all.hpp"
#include "caf/test/unit_test.hpp"

using namespace caf;

namespace {

using atomic_count = std::atomic<size_t>;

size_t assumed_thread_count;
size_t assumed_init_calls;

struct dummy_thread_hook : thread_hook {
  void init(actor_system&) override {
    // nop
  }

  void thread_started() override {
    // nop
  }

  void thread_terminates() override {
    // nop
  }
};

class counting_thread_hook : public thread_hook {
public:
  counting_thread_hook()
      : count_init_{0},
        count_thread_started_{0},
        count_thread_terminates_{0} {
    // nop
  }

  ~counting_thread_hook() override {
    CAF_CHECK_EQUAL(count_init_, assumed_init_calls);
    CAF_CHECK_EQUAL(count_thread_started_, assumed_thread_count);
    CAF_CHECK_EQUAL(count_thread_terminates_, assumed_thread_count);
  }

  void init(actor_system&) override {
    ++count_init_;
  }

  void thread_started() override {
    ++count_thread_started_;
  }

  void thread_terminates() override {
    ++count_thread_terminates_;
  }

private:
  atomic_count count_init_;
  atomic_count count_thread_started_;
  atomic_count count_thread_terminates_;
};

template <class Hook>
struct config : actor_system_config {
  config() {
    add_thread_hook<Hook>();
    logger_verbosity = atom("quiet");
  }
};

template <class Hook>
struct fixture {
  config<Hook> cfg;
  actor_system sys;
  fixture() : sys(cfg) {
    // nop
  }
};

} // namespace <anonymous>

CAF_TEST(counting_no_system) {
  assumed_init_calls = 0;
  actor_system_config cfg;
  cfg.add_thread_hook<counting_thread_hook>();
}

CAF_TEST_FIXTURE_SCOPE(dummy_hook, fixture<dummy_thread_hook>)

CAF_TEST(counting_no_args) {
  // nop
}

CAF_TEST_FIXTURE_SCOPE_END()

CAF_TEST_FIXTURE_SCOPE(counting_hook, fixture<counting_thread_hook>)

CAF_TEST(counting_system_without_actor) {
  assumed_init_calls = 1;
  assumed_thread_count = cfg.scheduler_max_threads;
  auto& sched = sys.scheduler();
  if (sched.detaches_utility_actors())
    assumed_thread_count += sched.num_utility_actors();
}

CAF_TEST(counting_system_with_actor) {
  assumed_init_calls = 1;
  assumed_thread_count = cfg.scheduler_max_threads + 1;
  auto& sched = sys.scheduler();
  if (sched.detaches_utility_actors())
    assumed_thread_count += sched.num_utility_actors();
  sys.spawn<detached>([] {});
  sys.spawn([] {});
}

CAF_TEST_FIXTURE_SCOPE_END()

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

// exclude this suite; seems to be too much to swallow for MSVC
#ifndef CAF_WINDOWS

#define CAF_SUITE typed_spawn
#include "caf/test/unit_test.hpp"

#include "caf/string_algorithms.hpp"

#include "caf/all.hpp"

#define ERROR_HANDLER                                                          \
  [&](error& err) { CAF_FAIL(system.render(err)); }

using namespace std;
using namespace caf;

using passed_atom = caf::atom_constant<caf::atom("passed")>;

namespace {

enum class mock_errc : uint8_t {
  cannot_revert_empty = 1
};

error make_error(mock_errc x) {
  return {static_cast<uint8_t>(x), atom("mock")};
}

// check invariants of type system
using dummy1 = typed_actor<reacts_to<int, int>,
                           replies_to<double>::with<double>>;

using dummy2 = dummy1::extend<reacts_to<ok_atom>>;

static_assert(std::is_convertible<dummy2, dummy1>::value,
              "handle not assignable to narrower definition");

//static_assert(!std::is_convertible<dummy1, dummy2>::value,
//              "handle is assignable to broader definition");

using dummy3 = typed_actor<reacts_to<float, int>>;
using dummy4 = typed_actor<replies_to<int>::with<double>>;
using dummy5 = dummy4::extend_with<dummy3>;

static_assert(std::is_convertible<dummy5, dummy3>::value,
              "handle not assignable to narrower definition");

static_assert(std::is_convertible<dummy5, dummy4>::value,
              "handle not assignable to narrower definition");

//static_assert(!std::is_convertible<dummy3, dummy5>::value,
//              "handle is assignable to broader definition");

//static_assert(!std::is_convertible<dummy4, dummy5>::value,
//              "handle is assignable to broader definition");

/******************************************************************************
 *                        simple request/response test                        *
 ******************************************************************************/

struct my_request {
  int a;
  int b;
};

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, my_request& x) {
  return f(x.a, x.b);
}

using server_type = typed_actor<replies_to<my_request>::with<bool>>;

server_type::behavior_type typed_server1() {
  return {
    [](const my_request& req) {
      return req.a == req.b;
    }
  };
}

server_type::behavior_type typed_server2(server_type::pointer) {
  return typed_server1();
}

class typed_server3 : public server_type::base {
public:
  typed_server3(actor_config& cfg, const string& line, actor buddy)
      : server_type::base(cfg) {
    anon_send(buddy, line);
  }

  behavior_type make_behavior() override {
    return typed_server2(this);
  }
};

void client(event_based_actor* self, const actor& parent, const server_type& serv) {
  self->request(serv, infinite, my_request{0, 0}).then(
    [=](bool val1) {
      CAF_CHECK_EQUAL(val1, true);
      self->request(serv, infinite, my_request{10, 20}).then(
        [=](bool val2) {
          CAF_CHECK_EQUAL(val2, false);
          self->send(parent, passed_atom::value);
        }
      );
    }
  );
}

/******************************************************************************
 *          test skipping of messages intentionally + using become()          *
 ******************************************************************************/

struct get_state_msg {};

using event_testee_type = typed_actor<replies_to<get_state_msg>::with<string>,
                                      replies_to<string>::with<void>,
                                      replies_to<float>::with<void>,
                                      replies_to<int>::with<int>>;

class event_testee : public event_testee_type::base {
public:
  event_testee(actor_config& cfg) : event_testee_type::base(cfg) {
    // nop
  }

  behavior_type wait4string() {
    return {
      [](const get_state_msg&) {
        return "wait4string";
      },
      [=](const string&) {
        become(wait4int());
      },
      [](float) {
        return skip();
      },
      [](int) {
        return skip();
      }
    };
  }

  behavior_type wait4int() {
    return {
      [](const get_state_msg&) {
        return "wait4int";
      },
      [=](int) -> int {
        become(wait4float());
        return 42;
      },
      [](float) {
        return skip();
      },
      [](const string&) {
        return skip();
      }
    };
  }

  behavior_type wait4float() {
    return {
      [](const get_state_msg&) {
        return "wait4float";
      },
      [=](float) {
        become(wait4string());
      },
      [](const string&) {
        return skip();
      },
      [](int) {
        return skip();
      }
    };
  }

  behavior_type make_behavior() override {
    return wait4int();
  }
};

/******************************************************************************
 *                         simple 'forwarding' chain                          *
 ******************************************************************************/

using string_actor = typed_actor<replies_to<string>::with<string>>;

string_actor::behavior_type string_reverter() {
  return {
    [](string& str) -> string {
      std::reverse(str.begin(), str.end());
      return std::move(str);
    }
  };
}

// uses `return delegate(...)`
string_actor::behavior_type string_delegator(string_actor::pointer self,
                                             string_actor master, bool leaf) {
  auto next = leaf ? self->spawn(string_delegator, master, false) : master;
  self->link_to(next);
  return {
    [=](string& str) -> delegated<string> {
      return self->delegate(next, std::move(str));
    }
  };
}

using maybe_string_actor = typed_actor<replies_to<string>
                                       ::with<ok_atom, string>>;

maybe_string_actor::behavior_type maybe_string_reverter() {
  return {
    [](string& str) -> result<ok_atom, string> {
      if (str.empty())
        return mock_errc::cannot_revert_empty;
      std::reverse(str.begin(), str.end());
      return {ok_atom::value, std::move(str)};
    }
  };
}

maybe_string_actor::behavior_type
maybe_string_delegator(maybe_string_actor::pointer self, const maybe_string_actor& x) {
  self->link_to(x);
  return {
    [=](string& s) -> delegated<ok_atom, string> {
      return self->delegate(x, std::move(s));
    }
  };
}

/******************************************************************************
 *                        sending typed actor handles                         *
 ******************************************************************************/

using int_actor = typed_actor<replies_to<int>::with<int>>;

using float_actor = typed_actor<reacts_to<float>>;

int_actor::behavior_type int_fun() {
  return {
    [](int i) { return i * i; }
  };
}

behavior foo(event_based_actor* self) {
  return {
    [=](int i, int_actor server) {
      self->delegate(server, i);
      self->quit();
    }
  };
}

int_actor::behavior_type int_fun2(int_actor::pointer self) {
  self->set_down_handler([=](down_msg& dm) {
    CAF_CHECK_EQUAL(dm.reason, exit_reason::normal);
    self->quit();
  });
  return {
    [=](int i) {
      self->monitor(self->current_sender());
      return i * i;
    },
  };
}

behavior foo2(event_based_actor* self) {
  return {
    [=](int i, int_actor server) {
      self->delegate(server, i);
      self->quit();
    }
  };
}

float_actor::behavior_type float_fun(float_actor::pointer self) {
  return {
    [=](float a) {
      CAF_CHECK_EQUAL(a, 1.0f);
      self->quit(exit_reason::user_shutdown);
    }
  };
}

int_actor::behavior_type foo3(int_actor::pointer self) {
  auto b = self->spawn<linked>(float_fun);
  self->send(b, 1.0f);
  return {
    [=](int) {
      return 0;
    }
  };
}

struct fixture {
  actor_system_config cfg;
  actor_system system;
  scoped_actor self;

  fixture() : system(cfg.add_message_type<get_state_msg>("get_state_msg")),
              self(system) {
    // nop
  }

  void test_typed_spawn(server_type ts) {
    self->send(ts, my_request{1, 2});
    self->receive(
      [](bool value) {
        CAF_CHECK_EQUAL(value, false);
      }
    );
    CAF_MESSAGE("async send + receive");
    self->send(ts, my_request{42, 42});
    self->receive(
      [](bool value) {
        CAF_CHECK_EQUAL(value, true);
      }
    );
    CAF_MESSAGE("request + receive with result true");
    self->request(ts, infinite, my_request{10, 20}).receive(
      [](bool value) {
        CAF_CHECK_EQUAL(value, false);
      },
      ERROR_HANDLER
    );
    CAF_MESSAGE("request + receive with result false");
    self->request(ts, infinite, my_request{0, 0}).receive(
      [](bool value) {
        CAF_CHECK_EQUAL(value, true);
      },
      ERROR_HANDLER
    );
    CAF_CHECK_EQUAL(system.registry().running(), 2u);
    auto c1 = self->spawn(client, self, ts);
    self->receive(
      [](passed_atom) {
        CAF_MESSAGE("received `passed_atom`");
      }
    );
    self->wait_for(c1);
    CAF_CHECK_EQUAL(system.registry().running(), 2u);
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(typed_spawn_tests, fixture)

/******************************************************************************
 *                             put it all together                            *
 ******************************************************************************/

CAF_TEST(typed_spawns) {
  // run test series with typed_server(1|2)
  test_typed_spawn(system.spawn(typed_server1));
  self->await_all_other_actors_done();
  CAF_MESSAGE("finished test series with `typed_server1`");
  test_typed_spawn(system.spawn(typed_server2));
  self->await_all_other_actors_done();
  CAF_MESSAGE("finished test series with `typed_server2`");
  test_typed_spawn(self->spawn<typed_server3>("hi there", self));
  self->receive(
    [](const string& str) {
      CAF_REQUIRE_EQUAL(str, "hi there");
    }
  );
}

CAF_TEST(event_testee_series) {
  auto et = self->spawn<event_testee>();
  string result;
  self->send(et, 1);
  self->send(et, 2);
  self->send(et, 3);
  self->send(et, .1f);
  self->send(et, "hello event testee!");
  self->send(et, .2f);
  self->send(et, .3f);
  self->send(et, "hello again event testee!");
  self->send(et, "goodbye event testee!");
  typed_actor<replies_to<get_state_msg>::with<string>> sub_et = et;
  set<string> iface{"caf::replies_to<get_state_msg>::with<@str>",
                    "caf::replies_to<@str>::with<void>",
                    "caf::replies_to<float>::with<void>",
                    "caf::replies_to<@i32>::with<@i32>"};
  CAF_CHECK_EQUAL(join(sub_et->message_types(), ","), join(iface, ","));
  self->send(sub_et, get_state_msg{});
  // we expect three 42s
  int i = 0;
  self->receive_for(i, 3)([](int value) { CAF_CHECK_EQUAL(value, 42); });
  self->receive(
    [&](const string& str) {
      result = str;
    },
    after(chrono::minutes(1)) >> [&] {
      CAF_FAIL("event_testee does not reply");
    }
  );
  CAF_CHECK_EQUAL(result, "wait4int");
}

CAF_TEST(string_delegator_chain) {
  // run test series with string reverter
  auto aut = self->spawn<monitored>(string_delegator,
                                    system.spawn(string_reverter),
                                    true);
  set<string> iface{"caf::replies_to<@str>::with<@str>"};
  CAF_CHECK_EQUAL(aut->message_types(), iface);
  self->request(aut, infinite, "Hello World!").receive(
    [](const string& answer) {
      CAF_CHECK_EQUAL(answer, "!dlroW olleH");
    },
    ERROR_HANDLER
  );
}

CAF_TEST(maybe_string_delegator_chain) {
  CAF_LOG_TRACE(CAF_ARG(self));
  auto aut = system.spawn(maybe_string_delegator,
                          system.spawn(maybe_string_reverter));
  CAF_MESSAGE("send empty string, expect error");
  self->request(aut, infinite, "").receive(
    [](ok_atom, const string&) {
      CAF_FAIL("unexpected string response");
    },
    [](const error& err) {
      CAF_CHECK_EQUAL(err.category(), atom("mock"));
      CAF_CHECK_EQUAL(err.code(),
                      static_cast<uint8_t>(mock_errc::cannot_revert_empty));
    }
  );
  CAF_MESSAGE("send abcd string, expect dcba");
  self->request(aut, infinite, "abcd").receive(
    [](ok_atom, const string& str) {
      CAF_CHECK_EQUAL(str, "dcba");
    },
    ERROR_HANDLER
  );
}

CAF_TEST(sending_typed_actors) {
  auto aut = system.spawn(int_fun);
  self->send(self->spawn(foo), 10, aut);
  self->receive(
    [](int i) {
      CAF_CHECK_EQUAL(i, 100);
    }
  );
  self->spawn(foo3);
}

CAF_TEST(sending_typed_actors_and_down_msg) {
  auto aut = system.spawn(int_fun2);
  self->send(self->spawn(foo2), 10, aut);
  self->receive([](int i) {
    CAF_CHECK_EQUAL(i, 100);
  });
}

CAF_TEST(check_signature) {
  using foo_type = typed_actor<replies_to<put_atom>::with<ok_atom>>;
  using foo_result_type = optional<ok_atom>;
  using bar_type = typed_actor<reacts_to<ok_atom>>;
  auto foo_action = [](foo_type::pointer ptr) -> foo_type::behavior_type {
    return {
      [=] (put_atom) -> foo_result_type {
        ptr->quit();
        return {ok_atom::value};
      }
    };
  };
  auto bar_action = [=](bar_type::pointer ptr) -> bar_type::behavior_type {
    auto foo = ptr->spawn<linked>(foo_action);
    ptr->send(foo, put_atom::value);
    return {
      [=](ok_atom) {
        ptr->quit();
      }
    };
  };
  auto x = self->spawn(bar_action);
  self->wait_for(x);
}

CAF_TEST_FIXTURE_SCOPE_END()

#endif // CAF_WINDOWS
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

// This unit test checks guarantees regarding ordering and equality for actor
// handles, i.e., actor_addr, actor, and typed_actor<...>.

#include "caf/config.hpp"

#define CAF_SUITE handles
#include "caf/test/unit_test.hpp"

#include "caf/all.hpp"

using namespace caf;

namespace {

// Simple int32_terface for testee actors.
using testee_actor = typed_actor<replies_to<int32_t>::with<int32_t>>;

// Dynamically typed testee.
behavior dt_testee() {
  return {
    [](int32_t x) {
      return x * x;
    }
  };
}

// Statically typed testee.
testee_actor::behavior_type st_testee() {
  return {
    [](int32_t x) {
      return x * x;
    }
  };
}

// A simple wrapper for storing a handle in all representations.
struct handle_set {
  // Weak handle to the actor.
  actor_addr wh;
  // Dynamically typed handle to the actor.
  actor dt;
  // Staically typed handle to the actor.
  testee_actor st;

  handle_set() = default;

  template <class T>
  handle_set(const T& hdl)
      : wh(hdl.address()),
        dt(actor_cast<actor>(hdl)),
        st(actor_cast<testee_actor>(hdl)) {
    // nop
  }
};

struct fixture {
  fixture()
      : sys(cfg),
        self(sys, true),
        a1{sys.spawn(dt_testee)},
        a2{sys.spawn(st_testee)} {
    // nop
  }

  actor_system_config cfg;
  actor_system sys;
  scoped_actor self;
  handle_set a0;
  handle_set a1{sys.spawn(dt_testee)};
  handle_set a2{sys.spawn(st_testee)};
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(handle_tests, fixture)

CAF_TEST(identity) {
  // all handles in a0 are equal
  CAF_CHECK_EQUAL(a0.wh, a0.wh);
  CAF_CHECK_EQUAL(a0.wh, a0.dt);
  CAF_CHECK_EQUAL(a0.wh, a0.st);
  CAF_CHECK_EQUAL(a0.dt, a0.wh);
  CAF_CHECK_EQUAL(a0.dt, a0.dt);
  CAF_CHECK_EQUAL(a0.dt, a0.st);
  CAF_CHECK_EQUAL(a0.st, a0.wh);
  CAF_CHECK_EQUAL(a0.st, a0.dt);
  CAF_CHECK_EQUAL(a0.st, a0.st);
  // all handles in a1 are equal
  CAF_CHECK_EQUAL(a1.wh, a1.wh);
  CAF_CHECK_EQUAL(a1.wh, a1.dt);
  CAF_CHECK_EQUAL(a1.wh, a1.st);
  CAF_CHECK_EQUAL(a1.dt, a1.wh);
  CAF_CHECK_EQUAL(a1.dt, a1.dt);
  CAF_CHECK_EQUAL(a1.dt, a1.st);
  CAF_CHECK_EQUAL(a1.st, a1.wh);
  CAF_CHECK_EQUAL(a1.st, a1.dt);
  CAF_CHECK_EQUAL(a1.st, a1.st);
  // all handles in a2 are equal
  CAF_CHECK_EQUAL(a2.wh, a2.wh);
  CAF_CHECK_EQUAL(a2.wh, a2.dt);
  CAF_CHECK_EQUAL(a2.wh, a2.st);
  CAF_CHECK_EQUAL(a2.dt, a2.wh);
  CAF_CHECK_EQUAL(a2.dt, a2.dt);
  CAF_CHECK_EQUAL(a2.dt, a2.st);
  CAF_CHECK_EQUAL(a2.st, a2.wh);
  CAF_CHECK_EQUAL(a2.st, a2.dt);
  CAF_CHECK_EQUAL(a2.st, a2.st);
  // all handles in a0 are *not* equal to any handle in a1 or a2
  CAF_CHECK_NOT_EQUAL(a0.wh, a1.wh);
  CAF_CHECK_NOT_EQUAL(a0.wh, a1.dt);
  CAF_CHECK_NOT_EQUAL(a0.wh, a1.st);
  CAF_CHECK_NOT_EQUAL(a0.dt, a1.wh);
  CAF_CHECK_NOT_EQUAL(a0.dt, a1.dt);
  CAF_CHECK_NOT_EQUAL(a0.dt, a1.st);
  CAF_CHECK_NOT_EQUAL(a0.st, a1.wh);
  CAF_CHECK_NOT_EQUAL(a0.st, a1.dt);
  CAF_CHECK_NOT_EQUAL(a0.st, a1.st);
  CAF_CHECK_NOT_EQUAL(a0.wh, a2.wh);
  CAF_CHECK_NOT_EQUAL(a0.wh, a2.dt);
  CAF_CHECK_NOT_EQUAL(a0.wh, a2.st);
  CAF_CHECK_NOT_EQUAL(a0.dt, a2.wh);
  CAF_CHECK_NOT_EQUAL(a0.dt, a2.dt);
  CAF_CHECK_NOT_EQUAL(a0.dt, a2.st);
  CAF_CHECK_NOT_EQUAL(a0.st, a2.wh);
  CAF_CHECK_NOT_EQUAL(a0.st, a2.dt);
  CAF_CHECK_NOT_EQUAL(a0.st, a2.st);
  // all handles in a1 are *not* equal to any handle in a0 or a2
  CAF_CHECK_NOT_EQUAL(a1.wh, a0.wh);
  CAF_CHECK_NOT_EQUAL(a1.wh, a0.dt);
  CAF_CHECK_NOT_EQUAL(a1.wh, a0.st);
  CAF_CHECK_NOT_EQUAL(a1.dt, a0.wh);
  CAF_CHECK_NOT_EQUAL(a1.dt, a0.dt);
  CAF_CHECK_NOT_EQUAL(a1.dt, a0.st);
  CAF_CHECK_NOT_EQUAL(a1.st, a0.wh);
  CAF_CHECK_NOT_EQUAL(a1.st, a0.dt);
  CAF_CHECK_NOT_EQUAL(a1.st, a0.st);
  CAF_CHECK_NOT_EQUAL(a1.wh, a2.wh);
  CAF_CHECK_NOT_EQUAL(a1.wh, a2.dt);
  CAF_CHECK_NOT_EQUAL(a1.wh, a2.st);
  CAF_CHECK_NOT_EQUAL(a1.dt, a2.wh);
  CAF_CHECK_NOT_EQUAL(a1.dt, a2.dt);
  CAF_CHECK_NOT_EQUAL(a1.dt, a2.st);
  CAF_CHECK_NOT_EQUAL(a1.st, a2.wh);
  CAF_CHECK_NOT_EQUAL(a1.st, a2.dt);
  CAF_CHECK_NOT_EQUAL(a1.st, a2.st);
  // all handles in a2 are *not* equal to any handle in a0 or a1
  CAF_CHECK_NOT_EQUAL(a2.wh, a0.wh);
  CAF_CHECK_NOT_EQUAL(a2.wh, a0.dt);
  CAF_CHECK_NOT_EQUAL(a2.wh, a0.st);
  CAF_CHECK_NOT_EQUAL(a2.dt, a0.wh);
  CAF_CHECK_NOT_EQUAL(a2.dt, a0.dt);
  CAF_CHECK_NOT_EQUAL(a2.dt, a0.st);
  CAF_CHECK_NOT_EQUAL(a2.st, a0.wh);
  CAF_CHECK_NOT_EQUAL(a2.st, a0.dt);
  CAF_CHECK_NOT_EQUAL(a2.st, a0.st);
  CAF_CHECK_NOT_EQUAL(a2.wh, a1.wh);
  CAF_CHECK_NOT_EQUAL(a2.wh, a1.dt);
  CAF_CHECK_NOT_EQUAL(a2.wh, a1.st);
  CAF_CHECK_NOT_EQUAL(a2.dt, a1.wh);
  CAF_CHECK_NOT_EQUAL(a2.dt, a1.dt);
  CAF_CHECK_NOT_EQUAL(a2.dt, a1.st);
  CAF_CHECK_NOT_EQUAL(a2.st, a1.wh);
  CAF_CHECK_NOT_EQUAL(a2.st, a1.dt);
  CAF_CHECK_NOT_EQUAL(a2.st, a1.st);
}

CAF_TEST(ordering) {
  // handles in a0 are all equal, i.e., are not in less-than relation
  CAF_CHECK_NOT_LESS(a0.wh, a0.wh);
  CAF_CHECK_NOT_LESS(a0.wh, a0.dt);
  CAF_CHECK_NOT_LESS(a0.wh, a0.st);
  CAF_CHECK_NOT_LESS(a0.dt, a0.wh);
  CAF_CHECK_NOT_LESS(a0.dt, a0.dt);
  CAF_CHECK_NOT_LESS(a0.dt, a0.st);
  CAF_CHECK_NOT_LESS(a0.st, a0.wh);
  CAF_CHECK_NOT_LESS(a0.st, a0.dt);
  CAF_CHECK_NOT_LESS(a0.st, a0.st);
  // handles in a1 are all equal, i.e., are not in less-than relation
  CAF_CHECK_NOT_LESS(a1.wh, a1.wh);
  CAF_CHECK_NOT_LESS(a1.wh, a1.dt);
  CAF_CHECK_NOT_LESS(a1.wh, a1.st);
  CAF_CHECK_NOT_LESS(a1.dt, a1.wh);
  CAF_CHECK_NOT_LESS(a1.dt, a1.dt);
  CAF_CHECK_NOT_LESS(a1.dt, a1.st);
  CAF_CHECK_NOT_LESS(a1.st, a1.wh);
  CAF_CHECK_NOT_LESS(a1.st, a1.dt);
  CAF_CHECK_NOT_LESS(a1.st, a1.st);
  // handles in a2 are all equal, i.e., are not in less-than relation
  CAF_CHECK_NOT_LESS(a2.wh, a2.wh);
  CAF_CHECK_NOT_LESS(a2.wh, a2.dt);
  CAF_CHECK_NOT_LESS(a2.wh, a2.st);
  CAF_CHECK_NOT_LESS(a2.dt, a2.wh);
  CAF_CHECK_NOT_LESS(a2.dt, a2.dt);
  CAF_CHECK_NOT_LESS(a2.dt, a2.st);
  CAF_CHECK_NOT_LESS(a2.st, a2.wh);
  CAF_CHECK_NOT_LESS(a2.st, a2.dt);
  CAF_CHECK_NOT_LESS(a2.st, a2.st);
  // all handles in a0 are less than handles in a1 or a2
  CAF_CHECK_LESS(a0.wh, a1.wh);
  CAF_CHECK_LESS(a0.wh, a1.dt);
  CAF_CHECK_LESS(a0.wh, a1.st);
  CAF_CHECK_LESS(a0.dt, a1.wh);
  CAF_CHECK_LESS(a0.dt, a1.dt);
  CAF_CHECK_LESS(a0.dt, a1.st);
  CAF_CHECK_LESS(a0.st, a1.wh);
  CAF_CHECK_LESS(a0.st, a1.dt);
  CAF_CHECK_LESS(a0.st, a1.st);
  CAF_CHECK_LESS(a0.wh, a2.wh);
  CAF_CHECK_LESS(a0.wh, a2.dt);
  CAF_CHECK_LESS(a0.wh, a2.st);
  CAF_CHECK_LESS(a0.dt, a2.wh);
  CAF_CHECK_LESS(a0.dt, a2.dt);
  CAF_CHECK_LESS(a0.dt, a2.st);
  CAF_CHECK_LESS(a0.st, a2.wh);
  CAF_CHECK_LESS(a0.st, a2.dt);
  CAF_CHECK_LESS(a0.st, a2.st);
  // all handles in a1 are less than handles in a2
  CAF_CHECK_LESS(a1.wh, a2.wh);
  CAF_CHECK_LESS(a1.wh, a2.dt);
  CAF_CHECK_LESS(a1.wh, a2.st);
  CAF_CHECK_LESS(a1.dt, a2.wh);
  CAF_CHECK_LESS(a1.dt, a2.dt);
  CAF_CHECK_LESS(a1.dt, a2.st);
  CAF_CHECK_LESS(a1.st, a2.wh);
  CAF_CHECK_LESS(a1.st, a2.dt);
  CAF_CHECK_LESS(a1.st, a2.st);
  // all handles in a1 are *not* less than handles in a0
  CAF_CHECK_NOT_LESS(a1.wh, a0.wh);
  CAF_CHECK_NOT_LESS(a1.wh, a0.dt);
  CAF_CHECK_NOT_LESS(a1.wh, a0.st);
  CAF_CHECK_NOT_LESS(a1.dt, a0.wh);
  CAF_CHECK_NOT_LESS(a1.dt, a0.dt);
  CAF_CHECK_NOT_LESS(a1.dt, a0.st);
  CAF_CHECK_NOT_LESS(a1.st, a0.wh);
  CAF_CHECK_NOT_LESS(a1.st, a0.dt);
  CAF_CHECK_NOT_LESS(a1.st, a0.st);
  // all handles in a2 are *not* less than handles in a0 or a1
  CAF_CHECK_NOT_LESS(a2.wh, a0.wh);
  CAF_CHECK_NOT_LESS(a2.wh, a0.dt);
  CAF_CHECK_NOT_LESS(a2.wh, a0.st);
  CAF_CHECK_NOT_LESS(a2.dt, a0.wh);
  CAF_CHECK_NOT_LESS(a2.dt, a0.dt);
  CAF_CHECK_NOT_LESS(a2.dt, a0.st);
  CAF_CHECK_NOT_LESS(a2.st, a0.wh);
  CAF_CHECK_NOT_LESS(a2.st, a0.dt);
  CAF_CHECK_NOT_LESS(a2.st, a0.st);
  CAF_CHECK_NOT_LESS(a2.wh, a1.wh);
  CAF_CHECK_NOT_LESS(a2.wh, a1.dt);
  CAF_CHECK_NOT_LESS(a2.wh, a1.st);
  CAF_CHECK_NOT_LESS(a2.dt, a1.wh);
  CAF_CHECK_NOT_LESS(a2.dt, a1.dt);
  CAF_CHECK_NOT_LESS(a2.dt, a1.st);
  CAF_CHECK_NOT_LESS(a2.st, a1.wh);
  CAF_CHECK_NOT_LESS(a2.st, a1.dt);
  CAF_CHECK_NOT_LESS(a2.st, a1.st);
}

CAF_TEST(string_representation) {
  auto s1 = a0.wh;
  auto s2 = a0.dt;
  auto s3 = a0.st;
  CAF_CHECK_EQUAL(s1, s2);
  CAF_CHECK_EQUAL(s2, s3);
}

CAF_TEST(mpi_string_representation) {
  CAF_CHECK(sys.message_types(a0.dt).empty());
  std::set<std::string> st_expected{"caf::replies_to<@i32>::with<@i32>"};
  CAF_CHECK_EQUAL(st_expected, sys.message_types(a0.st));
  CAF_CHECK_EQUAL(st_expected, sys.message_types<testee_actor>());
}

CAF_TEST_FIXTURE_SCOPE_END()

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE local_group
#include "caf/test/unit_test.hpp"

#include <array>
#include <chrono>
#include <algorithm>

#include "caf/all.hpp"

using namespace caf;

namespace {

using msg_atom = atom_constant<atom("msg")>;
using timeout_atom = atom_constant<atom("timeout")>;

using testee_if = typed_actor<replies_to<get_atom>::with<int>,
                              reacts_to<put_atom, int>>;

struct testee_state {
  int x = 0;
};

behavior testee_impl(stateful_actor<testee_state>* self) {
  auto subscriptions = self->joined_groups();
  return {
    [=](put_atom, int x) {
      self->state.x = x;
    },
    [=](get_atom) {
      return self->state.x;
    }
  };
};

struct fixture {
  actor_system_config config;
  actor_system system{config};
  scoped_actor self{system};
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(group_tests, fixture)

CAF_TEST(class_based_joined_at_spawn) {
  auto grp = system.groups().get_local("test");
  // initialize all testee actors, spawning them in the group
  std::array<actor, 10> xs;
  for (auto& x : xs)
    x = system.spawn_in_group(grp, testee_impl);
  // get a function view for all testees
  std::array<function_view<testee_if>, 10> fs;
  std::transform(xs.begin(), xs.end(), fs.begin(), [](const actor& x) {
    return make_function_view(actor_cast<testee_if>(x));
  });
  // make sure all actors start at 0
  for (auto& f : fs)
    CAF_CHECK_EQUAL(f(get_atom::value), 0);
  // send a put to all actors via the group and make sure they change state
  self->send(grp, put_atom::value, 42);
  for (auto& f : fs)
    CAF_CHECK_EQUAL(f(get_atom::value), 42);
  // shutdown all actors
  for (auto& x : xs)
    self->send_exit(x, exit_reason::user_shutdown);
}

CAF_TEST_FIXTURE_SCOPE_END()

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

// this suite tests whether actors terminate as expect in several use cases
#define CAF_SUITE actor_termination
#include "caf/test/dsl.hpp"

using namespace caf;

namespace {

behavior mirror_impl(event_based_actor* self) {
  self->set_default_handler(reflect);
  return [] {
    // nop
  };
}

struct fixture :  test_coordinator_fixture<> {
  actor mirror;
  actor testee;

  fixture() {
    mirror = sys.spawn(mirror_impl);
    // run initialization code or mirror
    sched.run_once();
  }

  template <class... Ts>
  void spawn(Ts&&... xs) {
    testee = self->spawn(std::forward<Ts>(xs)...);
  }

  ~fixture() {
    self->wait_for(testee);
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(actor_termination_tests, fixture)

CAF_TEST(single_multiplexed_request) {
  auto f = [&](event_based_actor* self, actor server) {
    self->request(server, infinite, 42).then(
      [=](int x) {
        CAF_REQUIRE_EQUAL(x, 42);
      }
    );
  };
  spawn(f, mirror);
  // run initialization code of testee
  sched.run_once();
  expect((int), from(testee).to(mirror).with(42));
  expect((int), from(mirror).to(testee).with(42));
}

CAF_TEST(multiple_multiplexed_requests) {
  auto f = [&](event_based_actor* self, actor server) {
    for (int i = 0; i < 3; ++i)
      self->request(server, infinite, 42).then(
        [=](int x) {
          CAF_REQUIRE_EQUAL(x, 42);
        }
      );
  };
  spawn(f, mirror);
  // run initialization code of testee
  sched.run_once();
  expect((int), from(testee).to(mirror).with(42));
  expect((int), from(testee).to(mirror).with(42));
  expect((int), from(testee).to(mirror).with(42));
  expect((int), from(mirror).to(testee).with(42));
  expect((int), from(mirror).to(testee).with(42));
  expect((int), from(mirror).to(testee).with(42));
}

CAF_TEST(single_awaited_request) {
  auto f = [&](event_based_actor* self, actor server) {
    self->request(server, infinite, 42).await(
      [=](int x) {
        CAF_REQUIRE_EQUAL(x, 42);
      }
    );
  };
  spawn(f, mirror);
  // run initialization code of testee
  sched.run_once();
  expect((int), from(testee).to(mirror).with(42));
  expect((int), from(mirror).to(testee).with(42));
}

CAF_TEST(multiple_awaited_requests) {
  auto f = [&](event_based_actor* self, actor server) {
    for (int i = 0; i < 3; ++i)
      self->request(server, infinite, i).await(
        [=](int x) {
          CAF_MESSAGE("received response #" << (i + 1));
          CAF_REQUIRE_EQUAL(x, i);
        }
      );
  };
  spawn(f, mirror);
  // run initialization code of testee
  sched.run_once();
  self->monitor(testee);
  expect((int), from(testee).to(mirror).with(0));
  expect((int), from(testee).to(mirror).with(1));
  expect((int), from(testee).to(mirror).with(2));
  // request().await() processes messages out-of-order,
  // which means we cannot check using expect()
  sched.run();
  expect((down_msg), from(testee).to(self).with(_));
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE request_timeout
#include "caf/test/unit_test.hpp"

#include <thread>
#include <chrono>

#include "caf/all.hpp"

using namespace caf;

using std::string;
using std::chrono::seconds;
using std::chrono::milliseconds;

namespace {

using ping_atom = atom_constant<atom("ping")>;
using pong_atom = atom_constant<atom("pong")>;
using timeout_atom = atom_constant<atom("timeout")>;

struct pong_state {
  static const char* name;
};

const char* pong_state::name = "pong";

behavior pong(stateful_actor<pong_state>*) {
  return {
    [=] (ping_atom) {
      return pong_atom::value;
    }
  };
}

struct ping_state {
  static const char* name;
  bool had_first_timeout = false; // unused in ping_singleN functions
};

const char* ping_state::name = "ping";

using ping_actor = stateful_actor<ping_state>;

using fptr = behavior (*)(ping_actor*, bool*, const actor&);
using test_vec = std::vector<std::pair<fptr, string>>;

// assumes to receive a timeout (sent via delayed_send) before pong replies
behavior ping_single1(ping_actor* self, bool* had_timeout, const actor& buddy) {
  self->send(buddy, ping_atom::value);
  self->delayed_send(self, std::chrono::seconds(1), timeout_atom::value);
  return {
    [=](pong_atom) {
      CAF_ERROR("received pong atom");
    },
    [=](timeout_atom) {
      *had_timeout = true;
      self->quit();
    }
  };
}

// assumes to receive a timeout (via after()) before pong replies
behavior ping_single2(ping_actor* self, bool* had_timeout, const actor& buddy) {
  self->send(buddy, ping_atom::value);
  return {
    [=](pong_atom) {
      CAF_ERROR("received pong atom");
    },
    after(std::chrono::seconds(1)) >> [=] {
      *had_timeout = true;
      self->quit();
    }
  };
}

// assumes to receive a timeout (via request error handler) before pong replies
behavior ping_single3(ping_actor* self, bool* had_timeout, const actor& buddy) {
  self->request(buddy, milliseconds(100), ping_atom::value).then(
    [=](pong_atom) {
      CAF_ERROR("received pong atom");
    },
    [=](const error& err) {
      CAF_REQUIRE(err == sec::request_timeout);
      *had_timeout = true;
    }
  );
  return {}; // dummy value in order to give all 3 variants the same fun sig
}

// assumes to receive an inner timeout (sent via delayed_send) before pong
// replies, then second timeout fires
behavior ping_nested1(ping_actor* self, bool* had_timeout,
                      const actor& buddy) {
  self->send(buddy, ping_atom::value);
  self->delayed_send(self, std::chrono::seconds(1), timeout_atom::value);
  return {
    [=](pong_atom) {
      CAF_ERROR("received pong atom");
    },
    [=](timeout_atom) {
      self->state.had_first_timeout = true;
      self->become(
        after(milliseconds(100)) >> [=] {
          CAF_CHECK(self->state.had_first_timeout);
          *had_timeout = true;
          self->quit();
        }
      );
    }
  };
}

// assumes to receive an inner timeout (via after()) before pong replies, then a
// second timeout fires
behavior ping_nested2(ping_actor* self, bool* had_timeout, const actor& buddy) {
  self->send(buddy, ping_atom::value);
  return {
    [=](pong_atom) {
      CAF_ERROR("received pong atom");
    },
    after(std::chrono::seconds(1)) >> [=] {
      self->state.had_first_timeout = true;
      self->become(
        after(milliseconds(100)) >> [=] {
          CAF_CHECK(self->state.had_first_timeout);
          *had_timeout = true;
          self->quit();
        }
      );
    }
  };
}

// assumes to receive an inner timeout (via request error handler) before pong
// replies, then a second timeout fires
behavior ping_nested3(ping_actor* self, bool* had_timeout, const actor& buddy) {
  self->request(buddy, milliseconds(100), ping_atom::value).then(
    [=](pong_atom) {
      CAF_ERROR("received pong atom");
      self->quit(sec::unexpected_message);
    },
    [=](const error& err) {
      CAF_REQUIRE_EQUAL(err, sec::request_timeout);
      self->state.had_first_timeout = true;
    }
  );
  return {
    after(milliseconds(100)) >> [=] {
      CAF_CHECK(self->state.had_first_timeout);
      *had_timeout = true;
      self->quit();
    }
  };
}

// uses .then on both requests
behavior ping_multiplexed1(ping_actor* self, bool* had_timeout,
                           const actor& pong_actor) {
  self->request(pong_actor, milliseconds(100), ping_atom::value).then(
    [=](pong_atom) {
      CAF_ERROR("received pong atom");
    },
    [=](const error& err) {
      CAF_REQUIRE_EQUAL(err, sec::request_timeout);
      if (!self->state.had_first_timeout)
        self->state.had_first_timeout = true;
      else
        *had_timeout = true;
    }
  );
  self->request(pong_actor, milliseconds(100), ping_atom::value).then(
    [=](pong_atom) {
      CAF_ERROR("received pong atom");
    },
    [=](const error& err) {
      CAF_REQUIRE_EQUAL(err, sec::request_timeout);
      if (!self->state.had_first_timeout)
        self->state.had_first_timeout = true;
      else
        *had_timeout = true;
    }
  );
  return {};
}

// uses .await on both requests
behavior ping_multiplexed2(ping_actor* self, bool* had_timeout,
                           const actor& pong_actor) {
  self->request(pong_actor, milliseconds(100), ping_atom::value).await(
    [=](pong_atom) {
      CAF_ERROR("received pong atom");
    },
    [=](const error& err) {
      CAF_REQUIRE_EQUAL(err, sec::request_timeout);
      if (!self->state.had_first_timeout)
        self->state.had_first_timeout = true;
      else
        *had_timeout = true;
    }
  );
  self->request(pong_actor, milliseconds(100), ping_atom::value).await(
    [=](pong_atom) {
      CAF_ERROR("received pong atom");
    },
    [=](const error& err) {
      CAF_REQUIRE_EQUAL(err, sec::request_timeout);
      if (!self->state.had_first_timeout)
        self->state.had_first_timeout = true;
      else
        *had_timeout = true;
    }
  );
  return {};
}

// uses .await and .then
behavior ping_multiplexed3(ping_actor* self, bool* had_timeout,
                           const actor& pong_actor) {
  self->request(pong_actor, milliseconds(100), ping_atom::value).then(
    [=](pong_atom) {
      CAF_ERROR("received pong atom");
    },
    [=](const error& err) {
      CAF_REQUIRE_EQUAL(err, sec::request_timeout);
      if (!self->state.had_first_timeout)
        self->state.had_first_timeout = true;
      else
        *had_timeout = true;
    }
  );
  self->request(pong_actor, milliseconds(100), ping_atom::value).await(
    [=](pong_atom) {
      CAF_ERROR("received pong atom");
    },
    [=](const error& err) {
      CAF_REQUIRE_EQUAL(err, sec::request_timeout);
      if (!self->state.had_first_timeout)
        self->state.had_first_timeout = true;
      else
        *had_timeout = true;
    }
  );
  return {};
}

struct config : actor_system_config {
  config() {
    scheduler_policy = atom("testing");
  }
};

struct fixture {
  config cfg;
  actor_system system;
  scoped_actor self;
  scheduler::test_coordinator& sched;

  fixture()
      : system(cfg),
        self(system),
        sched(dynamic_cast<scheduler::test_coordinator&>(system.scheduler())) {
    CAF_REQUIRE(sched.jobs.empty());
  }

  ~fixture() {
    sched.run_dispatch_loop();
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(request_timeout_tests, fixture)

CAF_TEST(single_timeout) {
  test_vec fs{{ping_single1, "ping_single1"},
              {ping_single2, "ping_single2"},
              {ping_single3, "ping_single3"}};
  for (auto f : fs) {
    bool had_timeout = false;
    CAF_MESSAGE("test implemenation " << f.second);
    auto testee = system.spawn(f.first, &had_timeout,
                               system.spawn<lazy_init>(pong));
    CAF_REQUIRE_EQUAL(sched.jobs.size(), 1u);
    CAF_REQUIRE_EQUAL(sched.next_job<local_actor>().name(), string{"ping"});
    sched.run_once();
    CAF_REQUIRE_EQUAL(sched.jobs.size(), 1u);
    CAF_REQUIRE_EQUAL(sched.next_job<local_actor>().name(), string{"pong"});
    sched.dispatch();
    CAF_REQUIRE_EQUAL(sched.jobs.size(), 2u);
    // now, the timeout message is already dispatched, while pong did
    // not respond to the message yet, i.e., timeout arrives before response
    CAF_CHECK_EQUAL(sched.run(), 2u);
    CAF_CHECK(had_timeout);
  }
}

CAF_TEST(nested_timeout) {
  test_vec fs{{ping_nested1, "ping_nested1"},
              {ping_nested2, "ping_nested2"},
              {ping_nested3, "ping_nested3"}};
  for (auto f : fs) {
    bool had_timeout = false;
    CAF_MESSAGE("test implemenation " << f.second);
    auto testee = system.spawn(f.first, &had_timeout,
                               system.spawn<lazy_init>(pong));
    CAF_REQUIRE_EQUAL(sched.jobs.size(), 1u);
    CAF_REQUIRE_EQUAL(sched.next_job<local_actor>().name(), string{"ping"});
    sched.run_once();
    CAF_REQUIRE_EQUAL(sched.jobs.size(), 1u);
    CAF_REQUIRE_EQUAL(sched.next_job<local_actor>().name(), string{"pong"});
    sched.dispatch();
    CAF_REQUIRE_EQUAL(sched.jobs.size(), 2u);
    // now, the timeout message is already dispatched, while pong did
    // not respond to the message yet, i.e., timeout arrives before response
    sched.run();
    // dispatch second timeout
    CAF_REQUIRE_EQUAL(sched.dispatch(), true);
    CAF_REQUIRE_EQUAL(sched.next_job<local_actor>().name(), string{"ping"});
    CAF_CHECK(!had_timeout);
    CAF_CHECK(sched.next_job<ping_actor>().state.had_first_timeout);
    sched.run();
    CAF_CHECK(had_timeout);
  }
}

CAF_TEST(multiplexed_timeout) {
  test_vec fs{{ping_multiplexed1, "ping_multiplexed1"},
              {ping_multiplexed2, "ping_multiplexed2"},
              {ping_multiplexed3, "ping_multiplexed3"}};
  for (auto f : fs) {
    bool had_timeout = false;
    CAF_MESSAGE("test implemenation " << f.second);
    auto testee = system.spawn(f.first, &had_timeout,
                               system.spawn<lazy_init>(pong));
    CAF_REQUIRE_EQUAL(sched.jobs.size(), 1u);
    CAF_REQUIRE_EQUAL(sched.next_job<local_actor>().name(), string{"ping"});
    sched.run_once();
    CAF_REQUIRE_EQUAL(sched.jobs.size(), 1u);
    CAF_REQUIRE_EQUAL(sched.next_job<local_actor>().name(), string{"pong"});
    sched.dispatch();
    CAF_REQUIRE_EQUAL(sched.jobs.size(), 2u);
    // now, the timeout message is already dispatched, while pong did
    // not respond to the message yet, i.e., timeout arrives before response
    sched.run();
    CAF_CHECK(had_timeout);
  }
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <string>
#include <numeric>
#include <fstream>
#include <iostream>
#include <iterator>

#define CAF_SUITE streaming
#include "caf/test/dsl.hpp"

#include "caf/detail/pull5_gatherer.hpp"
#include "caf/detail/push5_scatterer.hpp"

using std::cout;
using std::endl;
using std::string;

using namespace caf;

namespace {

struct file_reader_state {
  static const char* name;
};

const char* file_reader_state::name = "file_reader";

behavior file_reader(stateful_actor<file_reader_state>* self) {
  using buf = std::deque<int>;
  return {
    [=](std::string& fname) -> stream<int> {
      CAF_CHECK_EQUAL(fname, "test.txt");
      return self->make_source(
        // forward file name in handshake to next stage
        std::forward_as_tuple(std::move(fname)),
        // initialize state
        [&](buf& xs) {
          xs = buf{1, 2, 3, 4, 5, 6, 7, 8, 9};
        },
        // get next element
        [=](buf& xs, downstream<int>& out, size_t num) {
          CAF_MESSAGE("push " << num << " more messages downstream");
          auto n = std::min(num, xs.size());
          for (size_t i = 0; i < n; ++i)
            out.push(xs[i]);
          xs.erase(xs.begin(), xs.begin() + static_cast<ptrdiff_t>(n));
        },
        // check whether we reached the end
        [=](const buf& xs) {
          return xs.empty();
        },
        policy::arg<detail::push5_scatterer<int>>::value
      );
    }
  };
}

struct streamer_state {
  static const char* name;
};

const char* streamer_state::name = "streamer";

void streamer(stateful_actor<streamer_state>* self, const actor& dest) {
  using buf = std::deque<int>;
  self->make_source(
    // destination of the stream
    dest,
    // "file name" as seen by the next stage
    std::make_tuple("test.txt"),
    // initialize state
    [&](buf& xs) {
      xs = buf{1, 2, 3, 4, 5, 6, 7, 8, 9};
    },
    // get next element
    [=](buf& xs, downstream<int>& out, size_t num) {
      auto n = std::min(num, xs.size());
      for (size_t i = 0; i < n; ++i)
        out.push(xs[i]);
      xs.erase(xs.begin(), xs.begin() + static_cast<ptrdiff_t>(n));
    },
    // check whether we reached the end
    [=](const buf& xs) {
      return xs.empty();
    },
    // handle result of the stream
    [=](expected<int>) {
      // nop
    },
    policy::arg<detail::push5_scatterer<int>>::value
  );
}

struct filter_state {
  static const char* name;
};

const char* filter_state::name = "filter";

behavior filter(stateful_actor<filter_state>* self) {
  return {
    [=](stream<int>& in, std::string& fname) -> stream<int> {
      CAF_CHECK_EQUAL(fname, "test.txt");
      return self->make_stage(
        // input stream
        in,
        // forward file name in handshake to next stage
        std::forward_as_tuple(std::move(fname)),
        // initialize state
        [=](unit_t&) {
          // nop
        },
        // processing step
        [=](unit_t&, downstream<int>& out, int x) {
          if ((x & 0x01) != 0)
            out.push(x);
        },
        // cleanup
        [=](unit_t&) {
          // nop
        },
        policy::arg<detail::pull5_gatherer, detail::push5_scatterer<int>>::value
      );
    }
  };
}

struct broken_filter_state {
  static const char* name;
};

const char* broken_filter_state::name = "broken_filter";

behavior broken_filter(stateful_actor<broken_filter_state>*) {
  return {
    [=](stream<int>& x, const std::string& fname) -> stream<int> {
      CAF_CHECK_EQUAL(fname, "test.txt");
      return x;
    }
  };
}

struct sum_up_state {
  static const char* name;
};

const char* sum_up_state::name = "sum_up";

behavior sum_up(stateful_actor<sum_up_state>* self) {
  return {
    [=](stream<int>& in, std::string& fname) {
      CAF_CHECK_EQUAL(fname, "test.txt");
      return self->make_sink(
        // input stream
        in,
        // initialize state
        [](int& x) {
          x = 0;
        },
        // processing step
        [](int& x, int y) {
          x += y;
        },
        // cleanup and produce result message
        [](int& x) -> int {
          return x;
        },
        policy::arg<detail::pull5_gatherer, terminal_stream_scatterer>::value
      );
    }
  };
}

struct drop_all_state {
  static const char* name;
};

const char* drop_all_state::name = "drop_all";

behavior drop_all(stateful_actor<drop_all_state>* self) {
  return {
    [=](stream<int>& in, std::string& fname) {
      CAF_CHECK_EQUAL(fname, "test.txt");
      return self->make_sink(
        // input stream
        in,
        // initialize state
        [](unit_t&) {
          // nop
        },
        // processing step
        [](unit_t&, int) {
          // nop
        },
        // cleanup and produce void "result"
        [](unit_t&) {
          CAF_LOG_INFO("drop_all done");
        },
        policy::arg<detail::pull5_gatherer, terminal_stream_scatterer>::value
      );
    }
  };
}

struct nores_streamer_state {
  static const char* name;
};

const char* nores_streamer_state::name = "nores_streamer";

void nores_streamer(stateful_actor<nores_streamer_state>* self,
                             const actor& dest) {
  CAF_LOG_INFO("nores_streamer initialized");
  using buf = std::deque<int>;
  self->make_source(
    // destination of the stream
    dest,
    // "file name" for the next stage
    std::make_tuple("test.txt"),
    // initialize state
    [&](buf& xs) {
      xs = buf{1, 2, 3, 4, 5, 6, 7, 8, 9};
    },
    // get next element
    [=](buf& xs, downstream<int>& out, size_t num) {
      auto n = std::min(num, xs.size());
      for (size_t i = 0; i < n; ++i)
        out.push(xs[i]);
      xs.erase(xs.begin(), xs.begin() + static_cast<ptrdiff_t>(n));
    },
    // check whether we reached the end
    [=](const buf& xs) {
      return xs.empty();
    },
    // handle result of the stream
    [=](expected<void>) {
      // nop
    },
    policy::arg<detail::push5_scatterer<int>>::value
  );
}

struct stream_multiplexer_state {
  stream_manager_ptr stage;
  static const char* name;
};

const char* stream_multiplexer_state::name = "stream_multiplexer";

behavior stream_multiplexer(stateful_actor<stream_multiplexer_state>* self) {
  { // extra scope for hiding state for initialization from the lambdas below
    auto process = [](unit_t&, downstream<int>& out, int x) {
      out.push(x);
    };
    auto cleanup = [](unit_t&) {
      // nop
    };
    auto sid = self->make_stream_id();
    using impl = stream_stage_impl<decltype(process), decltype(cleanup),
          detail::pull5_gatherer,
          detail::push5_scatterer<int>>;
    self->state.stage = make_counted<impl>(self, sid, process, cleanup);
    self->state.stage->in().continuous(true);
    self->streams().emplace(sid, self->state.stage);
  }
  return {
    [=](join_atom) -> stream<int> {
      CAF_MESSAGE("received 'join' request");
      auto sid = self->streams().begin()->first;
      if (!self->add_sink<int>(
            self->state.stage, sid, nullptr, self->current_sender(), no_stages,
            self->current_message_id(), stream_priority::normal,
            std::make_tuple<std::string>("test.txt"))) {
        auto rp = self->make_response_promise();
        rp.deliver(sec::invalid_stream_state);
        return none;
      }
      self->drop_current_message_id();
      return sid;
    },
    [=](const stream<int>& in, std::string& fname) {
      CAF_CHECK_EQUAL(fname, "test.txt");
      auto& mgr = self->state.stage;
      if (!self->add_source(mgr, in.id(), none)) {
        CAF_FAIL("serve_as_stage failed");
      }
      self->streams().emplace(in.id(), mgr);
    },
  };
}

using fixture = test_coordinator_fixture<>;

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(local_streaming_tests, fixture)

CAF_TEST(no_downstream) {
  CAF_MESSAGE("opening streams must fail if no downstream stage exists");
  auto source = sys.spawn(file_reader);
  self->send(source, "test.txt");
  sched.run();
  CAF_CHECK_EQUAL(fetch_result(), sec::no_downstream_stages_defined);
  CAF_CHECK(deref(source).streams().empty());
}

CAF_TEST(broken_pipeline) {
  CAF_MESSAGE("streams must abort if a stage fails to initialize its state");
  auto source = sys.spawn(file_reader);
  auto stage = sys.spawn(broken_filter);
  auto pipeline = stage * source;
  sched.run();
  // self --("test.txt")--> source
  self->send(pipeline, "test.txt");
  expect((std::string), from(self).to(source).with("test.txt"));
  // source --(stream_msg::open)--> stage
  expect((stream_msg::open),
         from(self).to(stage).with(_, source, _, _, _, _, false));
  CAF_CHECK(!deref(source).streams().empty());
  CAF_CHECK(deref(stage).streams().empty());
  // stage --(stream_msg::forced_drop)--> source
  expect((stream_msg::forced_drop),
         from(stage).to(source).with(sec::stream_init_failed));
  CAF_CHECK(deref(source).streams().empty());
  CAF_CHECK(deref(stage).streams().empty());
  CAF_CHECK_EQUAL(fetch_result(), sec::stream_init_failed);
}

CAF_TEST(incomplete_pipeline) {
  CAF_MESSAGE("streams must abort if not reaching a sink");
  auto source = sys.spawn(file_reader);
  auto stage = sys.spawn(filter);
  auto pipeline = stage * source;
  sched.run();
  // self --("test.txt")--> source
  self->send(pipeline, "test.txt");
  expect((std::string), from(self).to(source).with("test.txt"));
  // source --(stream_msg::open)--> stage
  CAF_REQUIRE(sched.prioritize(stage));
  expect((stream_msg::open),
         from(self).to(stage).with(_, source, _, _,  _, _, false));
  CAF_CHECK(!deref(source).streams().empty());
  CAF_CHECK(deref(stage).streams().empty());
  // stage --(stream_msg::forced_drop)--> source
  expect((stream_msg::forced_drop),
         from(stage).to(source).with(sec::stream_init_failed));
  CAF_CHECK(deref(source).streams().empty());
  CAF_CHECK(deref(stage).streams().empty());
  CAF_CHECK_EQUAL(fetch_result(), sec::no_downstream_stages_defined);
}

CAF_TEST(depth2_pipeline) {
  auto source = sys.spawn(file_reader);
  auto sink = sys.spawn(sum_up);
  auto pipeline = sink * source;
  // run initialization code
  sched.run();
  // self -------("test.txt")-------> source
  self->send(pipeline, "test.txt");
  expect((std::string), from(self).to(source).with("test.txt"));
  CAF_CHECK(!deref(source).streams().empty());
  CAF_CHECK(deref(sink).streams().empty());
  // source ----(stream_msg::open)----> sink
  expect((stream_msg::open),
         from(self).to(sink).with(_, source, _, _, _, _, false));
  // source <----(stream_msg::ack_open)------ sink
  expect((stream_msg::ack_open), from(sink).to(source).with(_, _, 5, _, false));
  // source ----(stream_msg::batch)---> sink
  expect((stream_msg::batch),
         from(source).to(sink).with(5, std::vector<int>{1, 2, 3, 4, 5}, 0));
  // source <--(stream_msg::ack_batch)---- sink
  expect((stream_msg::ack_batch), from(sink).to(source).with(5, 0));
  // source ----(stream_msg::batch)---> sink
  expect((stream_msg::batch),
         from(source).to(sink).with(4, std::vector<int>{6, 7, 8, 9}, 1));
  // source <--(stream_msg::ack_batch)---- sink
  expect((stream_msg::ack_batch), from(sink).to(source).with(4, 1));
  // source ----(stream_msg::close)---> sink
  expect((stream_msg::close), from(source).to(sink).with());
  CAF_CHECK(deref(source).streams().empty());
  CAF_CHECK(deref(sink).streams().empty());
}

CAF_TEST(depth3_pipeline_order1) {
  // Order 1 is an idealized flow where batch messages travel from the source
  // to the sink and then ack_batch messages travel backwards, starting the
  // process over again.
  CAF_MESSAGE("check fully initialized pipeline with event order 1");
  auto source = sys.spawn(file_reader);
  auto stage = sys.spawn(filter);
  auto sink = sys.spawn(sum_up);
  auto pipeline = self * sink * stage * source;
  // run initialization code
  sched.run();
  // self --("test.txt")--> source
  CAF_CHECK(self->mailbox().empty());
  self->send(pipeline, "test.txt");
  expect((std::string), from(self).to(source).with("test.txt"));
  CAF_CHECK(self->mailbox().empty());
  CAF_CHECK(!deref(source).streams().empty());
  CAF_CHECK(deref(stage).streams().empty());
  CAF_CHECK(deref(sink).streams().empty());
  // source --(stream_msg::open)--> stage
  expect((stream_msg::open),
         from(self).to(stage).with(_, source, _, _, _, false));
  CAF_CHECK(!deref(source).streams().empty());
  CAF_CHECK(!deref(stage).streams().empty());
  CAF_CHECK(deref(sink).streams().empty());
  // stage --(stream_msg::open)--> sink
  expect((stream_msg::open),
         from(self).to(sink).with(_, stage, _, _, _, false));
  CAF_CHECK(!deref(source).streams().empty());
  CAF_CHECK(!deref(stage).streams().empty());
  CAF_CHECK(!deref(sink).streams().empty());
  // sink --(stream_msg::ack_open)--> stage
  expect((stream_msg::ack_open), from(sink).to(stage).with(_, _, 5, _, false));
  // stage --(stream_msg::ack_open)--> source
  expect((stream_msg::ack_open),
         from(stage).to(source).with(_, _, 5, _, false));
  // source --(stream_msg::batch)--> stage
  expect((stream_msg::batch),
         from(source).to(stage).with(5, std::vector<int>{1, 2, 3, 4, 5}, 0));
  // stage --(stream_msg::batch)--> sink
  expect((stream_msg::batch),
         from(stage).to(sink).with(3, std::vector<int>{1, 3, 5}, 0));
  // stage --(stream_msg::batch)--> source
  expect((stream_msg::ack_batch), from(stage).to(source).with(5, 0));
  // sink --(stream_msg::batch)--> stage
  expect((stream_msg::ack_batch), from(sink).to(stage).with(3, 0));
  // source --(stream_msg::batch)--> stage
  expect((stream_msg::batch),
         from(source).to(stage).with(4, std::vector<int>{6, 7, 8, 9}, 1));
  // stage --(stream_msg::batch)--> sink
  expect((stream_msg::batch),
         from(stage).to(sink).with(2, std::vector<int>{7, 9}, 1));
  // stage --(stream_msg::batch)--> source
  expect((stream_msg::ack_batch), from(stage).to(source).with(4, 1));
  // sink --(stream_msg::batch)--> stage
  expect((stream_msg::ack_batch), from(sink).to(stage).with(2, 1));
  // source ----(stream_msg::close)---> stage
  expect((stream_msg::close), from(source).to(stage).with());
  // stage ----(stream_msg::close)---> sink
  expect((stream_msg::close), from(stage).to(sink).with());
  // sink ----(result: 25)---> self
  expect((int), from(sink).to(self).with(25));
}

CAF_TEST(depth3_pipeline_order2) {
  // Order 2 assumes that source and stage communicate faster then the sink.
  // This means batches and acks go as fast as possible between source and
  // stage, only slowing down if an ack from the sink is needed to drive
  // computation forward.
  CAF_MESSAGE("check fully initialized pipeline with event order 2");
  auto source = sys.spawn(file_reader);
  auto stage = sys.spawn(filter);
  auto sink = sys.spawn(sum_up);
  CAF_MESSAGE("source: " << to_string(source));
  CAF_MESSAGE("stage: " << to_string(stage));
  CAF_MESSAGE("sink: " << to_string(sink));
  auto pipeline = self * sink * stage * source;
  // run initialization code
  sched.run();
  // self --("test.txt")--> source
  CAF_CHECK(self->mailbox().empty());
  self->send(pipeline, "test.txt");
  expect((std::string), from(self).to(source).with("test.txt"));
  // source --(stream_msg::open)--> stage
  expect((stream_msg::open),
         from(self).to(stage).with(_, source, _, _, _, false));
  // stage --(stream_msg::ack_open)--> source
  expect((stream_msg::ack_open),
         from(stage).to(source).with(_, _, 5, _, false));
  // source --(stream_msg::batch)--> stage
  expect((stream_msg::batch),
         from(source).to(stage).with(5, std::vector<int>{1, 2, 3, 4, 5}, 0));
  // stage --(stream_msg::ack_batch)--> source
  // The stage has filtered {2, 4}, which means {1, 3, 5} are now buffered at
  // the stage. New credit assigned to the source is 2, since there's no credit
  // to send data downstream and the buffer is only allowed to keep 5 elements
  // total.
  expect((stream_msg::ack_batch), from(stage).to(source).with(2, 0));
  // source --(stream_msg::batch)--> stage
  expect((stream_msg::batch),
         from(source).to(stage).with(2, std::vector<int>{6, 7}, 1));
  // stage --(stream_msg::ack_batch)--> source
  // The stage has filtered {6}, which means {1, 3, 5, 7} are now buffered at
  // the stage. New credit assigned to the source is hence 1.
  expect((stream_msg::ack_batch), from(stage).to(source).with(1, 1));
  // source --(stream_msg::batch)--> stage
  expect((stream_msg::batch),
         from(source).to(stage).with(1, std::vector<int>{8}, 2));
  // stage --(stream_msg::ack_batch)--> source
  // The stage has dropped 8, still leaving 1 space in the buffer.
  expect((stream_msg::ack_batch), from(stage).to(source).with(1, 2));
  // source --(stream_msg::batch)--> stage
  expect((stream_msg::batch),
         from(source).to(stage).with(1, std::vector<int>{9}, 3));
  // At this point, stage is not allowed to signal demand because it no longer
  // has any capacity in its buffer nor did it receive downstream demand yet.
  disallow((stream_msg::ack_batch), from(stage).to(source).with(_, _));
  // stage --(stream_msg::open)--> sink
  expect((stream_msg::open),
         from(self).to(sink).with(_, stage, _, _, _, false));
  // sink --(stream_msg::ack_open)--> stage (finally)
  expect((stream_msg::ack_open), from(sink).to(stage).with(_, _, 5, _, false));
  // stage --(stream_msg::ack_batch)--> source
  // The stage has now emptied its buffer and is able to grant more credit.
  expect((stream_msg::ack_batch), from(stage).to(source).with(5, 3));
  // source ----(stream_msg::close)---> stage
  // The source can now initiate shutting down the stream since it successfully
  // produced all elements.
  expect((stream_msg::close), from(source).to(stage).with());
  // stage --(stream_msg::batch)--> sink
  expect((stream_msg::batch),
         from(stage).to(sink).with(5, std::vector<int>{1, 3, 5, 7, 9}, 0));
  // sink --(stream_msg::ack_batch)--> stage
  expect((stream_msg::ack_batch), from(sink).to(stage).with(5, 0));
  // stage ----(stream_msg::close)---> sink
  expect((stream_msg::close), from(stage).to(sink).with());
  // sink ----(result: 25)---> self
  expect((int), from(sink).to(self).with(25));
}

CAF_TEST(broken_pipeline_stramer) {
  CAF_MESSAGE("streams must abort if a stage fails to initialize its state");
  auto stage = sys.spawn(broken_filter);
  // run initialization code
  sched.run();
  auto source = sys.spawn(streamer, stage);
  // run initialization code
  sched.run_once();
  // source --(stream_msg::open)--> stage
  expect((stream_msg::open),
         from(source).to(stage).with(_, source, _, _, _, false));
  CAF_CHECK(!deref(source).streams().empty());
  CAF_CHECK(deref(stage).streams().empty());
  // stage --(stream_msg::forced_drop)--> source
  expect((stream_msg::forced_drop),
         from(stage).to(source).with(sec::stream_init_failed));
  CAF_CHECK(deref(source).streams().empty());
  CAF_CHECK(deref(stage).streams().empty());
  // The stage failed during handshake. Thus, the source is still responsible
  // for sending an error message (to itself in this case).
  // source ----(error)---> source
  expect((error), from(source).to(source).with(_));
}

CAF_TEST(depth2_pipeline_streamer) {
  auto sink = sys.spawn(sum_up);
  // run initialization code
  sched.run();
  auto source = sys.spawn(streamer, sink);
  // run initialization code
  sched.run_once();
  // source ----(stream_msg::open)----> sink
  expect((stream_msg::open),
         from(source).to(sink).with(_, source, _, _, _, false));
  // source <----(stream_msg::ack_open)------ sink
  expect((stream_msg::ack_open), from(sink).to(source).with(_, _, 5, _, false));
  // source ----(stream_msg::batch)---> sink
  expect((stream_msg::batch),
         from(source).to(sink).with(5, std::vector<int>{1, 2, 3, 4, 5}, 0));
  // source <--(stream_msg::ack_batch)---- sink
  expect((stream_msg::ack_batch), from(sink).to(source).with(5, 0));
  // source ----(stream_msg::batch)---> sink
  expect((stream_msg::batch),
         from(source).to(sink).with(4, std::vector<int>{6, 7, 8, 9}, 1));
  // source <--(stream_msg::ack_batch)---- sink
  expect((stream_msg::ack_batch), from(sink).to(source).with(4, 1));
  // source ----(stream_msg::close)---> sink
  expect((stream_msg::close), from(source).to(sink).with());
  // sink ----(result: 25)---> source
  expect((int), from(sink).to(source).with(45));
}

CAF_TEST(stream_without_result) {
  auto sink = sys.spawn(drop_all);
  // run initialization code
  sched.run();
  auto source = sys.spawn(nores_streamer, sink);
  // run initialization code
  sched.run_once();
  // source ----(stream_msg::open)----> sink
  expect((stream_msg::open),
         from(source).to(sink).with(_, source, _, _, _, false));
  // source <----(stream_msg::ack_open)------ sink
  expect((stream_msg::ack_open), from(sink).to(source).with(_, _, 5, _, false));
  // source ----(stream_msg::batch)---> sink
  expect((stream_msg::batch),
         from(source).to(sink).with(5, std::vector<int>{1, 2, 3, 4, 5}, 0));
  // source <--(stream_msg::ack_batch)---- sink
  expect((stream_msg::ack_batch), from(sink).to(source).with(5, 0));
  // source ----(stream_msg::batch)---> sink
  expect((stream_msg::batch),
         from(source).to(sink).with(4, std::vector<int>{6, 7, 8, 9}, 1));
  // source <--(stream_msg::ack_batch)---- sink
  expect((stream_msg::ack_batch), from(sink).to(source).with(4, 1));
  // source ----(stream_msg::close)---> sink
  expect((stream_msg::close), from(source).to(sink).with());
  // sink ----(result: <empty>)---> source
  expect((void), from(sink).to(source).with());
}

CAF_TEST(multiplexed_pipeline) {
  auto multiplexer = sys.spawn(stream_multiplexer);
  auto joining_drop_all = [=](stateful_actor<drop_all_state>* self) {
    self->send(self * multiplexer, join_atom::value);
    return drop_all(self);
  };
  sched.run();
  CAF_MESSAGE("spawn first sink");
  auto d1 = sys.spawn(joining_drop_all);
  sched.run_once();
  expect((atom_value), from(d1).to(multiplexer).with(join_atom::value));
  expect((stream_msg::open),
         from(_).to(d1).with(_, multiplexer, _, _, _, false));
  expect((stream_msg::ack_open),
         from(d1).to(multiplexer).with(_, _, 5, _, false));
  CAF_MESSAGE("spawn second sink");
  auto d2 = sys.spawn(joining_drop_all);
  sched.run_once();
  expect((atom_value), from(d2).to(multiplexer).with(join_atom::value));
  expect((stream_msg::open),
         from(_).to(d2).with(_, multiplexer, _, _, _, false));
  expect((stream_msg::ack_open),
         from(d2).to(multiplexer).with(_, _, 5, _, false));
  CAF_MESSAGE("spawn source");
  auto src = sys.spawn(nores_streamer, multiplexer);
  sched.run_once();
  // Handshake between src and multiplexer.
  expect((stream_msg::open),
         from(_).to(multiplexer).with(_, src, _, _, _, false));
  expect((stream_msg::ack_open),
         from(multiplexer).to(src).with(_, _, 5, _, false));
  // First batch.
  expect((stream_msg::batch),
         from(src).to(multiplexer).with(5, std::vector<int>{1, 2, 3, 4, 5}, 0));
  expect((stream_msg::batch),
         from(multiplexer).to(d1).with(5, std::vector<int>{1, 2, 3, 4, 5}, 0));
  expect((stream_msg::batch),
         from(multiplexer).to(d2).with(5, std::vector<int>{1, 2, 3, 4, 5}, 0));
  expect((stream_msg::ack_batch), from(d1).to(multiplexer).with(5, 0));
  expect((stream_msg::ack_batch), from(d2).to(multiplexer).with(5, 0));
  expect((stream_msg::ack_batch), from(multiplexer).to(src).with(5, 0));
  // Second batch.
  expect((stream_msg::batch),
         from(src).to(multiplexer).with(4, std::vector<int>{6, 7, 8, 9}, 1));
  expect((stream_msg::batch),
         from(multiplexer).to(d1).with(4, std::vector<int>{6, 7, 8, 9}, 1));
  expect((stream_msg::batch),
         from(multiplexer).to(d2).with(4, std::vector<int>{6, 7, 8, 9}, 1));
  expect((stream_msg::ack_batch), from(d1).to(multiplexer).with(4, 1));
  expect((stream_msg::ack_batch), from(d2).to(multiplexer).with(4, 1));
  expect((stream_msg::ack_batch), from(multiplexer).to(src).with(4, 1));
  // Source is done, multiplexer remains open.
  expect((stream_msg::close), from(src).to(multiplexer).with());
  CAF_REQUIRE(!sched.has_job());
  CAF_MESSAGE("spawn a second source");
  auto src2 = sys.spawn(nores_streamer, multiplexer);
  sched.run_once();
  // Handshake between src2 and multiplexer.
  expect((stream_msg::open),
         from(_).to(multiplexer).with(_, src2, _, _, _, false));
  expect((stream_msg::ack_open),
       from(multiplexer).to(src2).with(_, _, 5, _, false));
  // First batch.
  expect((stream_msg::batch),
         from(src2).to(multiplexer).with(5, std::vector<int>{1, 2, 3, 4, 5}, 0));
  expect((stream_msg::batch),
         from(multiplexer).to(d1).with(5, std::vector<int>{1, 2, 3, 4, 5}, 2));
  expect((stream_msg::batch),
         from(multiplexer).to(d2).with(5, std::vector<int>{1, 2, 3, 4, 5}, 2));
  expect((stream_msg::ack_batch), from(d1).to(multiplexer).with(5, 2));
  expect((stream_msg::ack_batch), from(d2).to(multiplexer).with(5, 2));
  expect((stream_msg::ack_batch), from(multiplexer).to(src2).with(5, 0));
  // Second batch.
  expect((stream_msg::batch),
         from(src2).to(multiplexer).with(4, std::vector<int>{6, 7, 8, 9}, 1));
  expect((stream_msg::batch),
         from(multiplexer).to(d1).with(4, std::vector<int>{6, 7, 8, 9}, 3));
  expect((stream_msg::batch),
         from(multiplexer).to(d2).with(4, std::vector<int>{6, 7, 8, 9}, 3));
  expect((stream_msg::ack_batch), from(d1).to(multiplexer).with(4, 3));
  expect((stream_msg::ack_batch), from(d2).to(multiplexer).with(4, 3));
  expect((stream_msg::ack_batch), from(multiplexer).to(src2).with(4, 1));
  // Source is done, multiplexer remains open.
  expect((stream_msg::close), from(src2).to(multiplexer).with());
  CAF_REQUIRE(!sched.has_job());
  CAF_MESSAGE("shutdown");
  anon_send_exit(multiplexer, exit_reason::kill);
  sched.run();
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE serial_reply
#include "caf/test/unit_test.hpp"

#include "caf/all.hpp"

using namespace caf;

namespace {

using hi_atom = atom_constant<atom("hi")>;
using ho_atom = atom_constant<atom("ho")>;
using sub0_atom = atom_constant<atom("sub0")>;
using sub1_atom = atom_constant<atom("sub1")>;
using sub2_atom = atom_constant<atom("sub2")>;
using sub3_atom = atom_constant<atom("sub3")>;
using sub4_atom = atom_constant<atom("sub4")>;

} // namespace <anonymous>


CAF_TEST(test_serial_reply) {
  actor_system_config cfg;
  actor_system system{cfg};
  auto mirror_behavior = [=](event_based_actor* self) -> behavior {
    self->set_default_handler(reflect);
    return {
      [] {
        // nop
      }
    };
  };
  auto master = system.spawn([=](event_based_actor* self) {
    CAF_MESSAGE("ID of master: " << self->id());
    // spawn 5 mirror actors
    auto c0 = self->spawn<linked>(mirror_behavior);
    auto c1 = self->spawn<linked>(mirror_behavior);
    auto c2 = self->spawn<linked>(mirror_behavior);
    auto c3 = self->spawn<linked>(mirror_behavior);
    auto c4 = self->spawn<linked>(mirror_behavior);
    self->become (
      [=](hi_atom) mutable {
        auto rp = self->make_response_promise();
        CAF_MESSAGE("received 'hi there'");
        self->request(c0, infinite, sub0_atom::value).then(
          [=](sub0_atom) mutable {
            CAF_MESSAGE("received 'sub0'");
            self->request(c1, infinite, sub1_atom::value).then(
              [=](sub1_atom) mutable {
                CAF_MESSAGE("received 'sub1'");
                self->request(c2, infinite, sub2_atom::value).then(
                  [=](sub2_atom) mutable {
                    CAF_MESSAGE("received 'sub2'");
                    self->request(c3, infinite, sub3_atom::value).then(
                      [=](sub3_atom) mutable {
                        CAF_MESSAGE("received 'sub3'");
                        self->request(c4, infinite, sub4_atom::value).then(
                          [=](sub4_atom) mutable {
                            CAF_MESSAGE("received 'sub4'");
                            rp.deliver(ho_atom::value);
                          }
                        );
                      }
                    );
                  }
                );
              }
            );
          }
        );
      }
    );
  });
  scoped_actor self{system};
  CAF_MESSAGE("ID of main: " << self->id());
  self->request(master, infinite, hi_atom::value).receive(
    [](ho_atom) {
      CAF_MESSAGE("received 'ho'");
    },
    [&](const error& err) {
      CAF_ERROR("Error: " << self->system().render(err));
    }
  );
  CAF_REQUIRE(self->mailbox().count() == 0);
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE actor_pool
#include "caf/test/unit_test.hpp"

#include "caf/all.hpp"

using namespace caf;

namespace {

std::atomic<size_t> s_ctors;
std::atomic<size_t> s_dtors;

class worker : public event_based_actor {
public:
  worker(actor_config& cfg) : event_based_actor(cfg) {
    ++s_ctors;
  }

  ~worker() override {
    ++s_dtors;
  }

  behavior make_behavior() override {
    auto nested = exit_handler_;
    set_exit_handler([=](scheduled_actor* self, exit_msg& em) {
      nested(self, em);
    });
    return {
      [](int x, int y) {
        return x + y;
      }
    };
  }
};

struct fixture {
  // allows us to check s_dtors after dtor of actor_system
  actor_system_config cfg;
  union { actor_system system; };
  union { scoped_execution_unit context; };

  std::function<actor ()> spawn_worker;

  fixture() {
    new (&system) actor_system(cfg);
    new (&context) scoped_execution_unit(&system);
    spawn_worker = [&] {
      return system.spawn<worker>();
    };
  }

  ~fixture() {
    system.await_all_actors_done();
    context.~scoped_execution_unit();
    system.~actor_system();
    CAF_CHECK_EQUAL(s_dtors.load(), s_ctors.load());
  }
};

void handle_err(const error& err) {
  CAF_FAIL("AUT responded with an error: " + to_string(err));
}

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(actor_pool_tests, fixture)

CAF_TEST(round_robin_actor_pool) {
  scoped_actor self{system};
  auto pool = actor_pool::make(&context, 5, spawn_worker,
                               actor_pool::round_robin());
  self->send(pool, sys_atom::value, put_atom::value, spawn_worker());
  std::vector<actor> workers;
  for (int i = 0; i < 6; ++i) {
    self->request(pool, infinite, i, i).receive(
      [&](int res) {
        CAF_CHECK_EQUAL(res, i + i);
        auto sender = actor_cast<strong_actor_ptr>(self->current_sender());
        CAF_REQUIRE(sender);
        workers.push_back(actor_cast<actor>(std::move(sender)));
      },
      handle_err
    );
  }
  CAF_CHECK_EQUAL(workers.size(), 6u);
  CAF_CHECK(std::unique(workers.begin(), workers.end()) == workers.end());
  self->request(pool, infinite, sys_atom::value, get_atom::value).receive(
    [&](std::vector<actor>& ws) {
      std::sort(workers.begin(), workers.end());
      std::sort(ws.begin(), ws.end());
      CAF_REQUIRE_EQUAL(workers.size(), ws.size());
      CAF_CHECK(std::equal(workers.begin(), workers.end(), ws.begin()));
    },
    handle_err
  );
  CAF_MESSAGE("await last worker");
  anon_send_exit(workers.back(), exit_reason::user_shutdown);
  self->wait_for(workers.back());
  CAF_MESSAGE("last worker shut down");
  workers.pop_back();
  // poll actor pool up to 10 times or until it removes the failed worker
  bool success = false;
  size_t i = 0;
  while (!success && ++i <= 10) {
    self->request(pool, infinite, sys_atom::value, get_atom::value).receive(
      [&](std::vector<actor>& ws) {
        success = workers.size() == ws.size();
        if (success) {
          std::sort(ws.begin(), ws.end());
          CAF_CHECK_EQUAL(workers, ws);
        } else {
          // wait a bit until polling again
          std::this_thread::sleep_for(std::chrono::milliseconds(5));
        }
      },
      handle_err
    );
  }
  CAF_REQUIRE_EQUAL(success, true);
  CAF_MESSAGE("about to send exit to workers");
  self->send_exit(pool, exit_reason::user_shutdown);
  self->wait_for(workers);
}

CAF_TEST(broadcast_actor_pool) {
  scoped_actor self{system};
  auto spawn5 = [&] {
    return actor_pool::make(&context, 5, fixture::spawn_worker,
                            actor_pool::broadcast());
  };
  CAF_CHECK_EQUAL(system.registry().running(), 1u);
  auto pool = actor_pool::make(&context, 5, spawn5, actor_pool::broadcast());
  CAF_CHECK_EQUAL(system.registry().running(), 32u);
  self->send(pool, 1, 2);
  std::vector<int> results;
  int i = 0;
  self->receive_for(i, 25)(
    [&](int res) {
      results.push_back(res);
    },
    after(std::chrono::milliseconds(250)) >> [] {
      CAF_ERROR("didn't receive a result");
    }
  );
  CAF_CHECK_EQUAL(results.size(), 25u);
  CAF_CHECK(std::all_of(results.begin(), results.end(),
                        [](int res) { return res == 3; }));
  self->send_exit(pool, exit_reason::user_shutdown);
}

CAF_TEST(random_actor_pool) {
  scoped_actor self{system};
  auto pool = actor_pool::make(&context, 5, spawn_worker, actor_pool::random());
  for (int i = 0; i < 5; ++i) {
    self->request(pool, std::chrono::milliseconds(250), 1, 2).receive(
      [&](int res) {
        CAF_CHECK_EQUAL(res, 3);
      },
      handle_err
    );
  }
  self->send_exit(pool, exit_reason::user_shutdown);
}

CAF_TEST(split_join_actor_pool) {
  auto spawn_split_worker = [&] {
    return system.spawn<lazy_init>([]() -> behavior {
      return {
        [](size_t pos, const std::vector<int>& xs) {
          return xs[pos];
        }
      };
    });
  };
  auto split_fun = [](std::vector<std::pair<actor, message>>& xs, message& y) {
    for (size_t i = 0; i < xs.size(); ++i) {
      xs[i].second = make_message(i) + y;
    }
  };
  auto join_fun = [](int& res, message& msg) {
    msg.apply([&](int x) {
      res += x;
    });
  };
  scoped_actor self{system};
  CAF_MESSAGE("create actor pool");
  auto pool = actor_pool::make(&context, 5, spawn_split_worker,
                            actor_pool::split_join<int>(join_fun, split_fun));
  self->request(pool, infinite, std::vector<int>{1, 2, 3, 4, 5}).receive(
    [&](int res) {
      CAF_CHECK_EQUAL(res, 15);
    },
    handle_err
  );
  self->request(pool, infinite, std::vector<int>{6, 7, 8, 9, 10}).receive(
    [&](int res) {
      CAF_CHECK_EQUAL(res, 40);
    },
    handle_err
  );
  self->send_exit(pool, exit_reason::user_shutdown);
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE metaprogramming
#include "caf/test/unit_test.hpp"

#include <string>
#include <cstdint>
#include <typeinfo>
#include <type_traits>

#include "caf/all.hpp"

#include "caf/detail/int_list.hpp"
#include "caf/detail/type_list.hpp"

using namespace caf;
using namespace caf::detail;

namespace {


// misc

template <class T>
struct is_int : std::false_type {};

template <>
struct is_int<int> : std::true_type {};

} // namespace <anonymous>

CAF_TEST(metaprogramming) {
  using std::is_same;
  using l1 = type_list<int, float, std::string>;
  using r1 = tl_reverse<l1>::type;
  CAF_CHECK((is_same<int, tl_at<l1, 0>::type>::value));
  CAF_CHECK((is_same<float, tl_at<l1, 1>::type>::value));
  CAF_CHECK((is_same<std::string, tl_at<l1, 2>::type>::value));
  CAF_CHECK_EQUAL(3u, tl_size<l1>::value);
  CAF_CHECK_EQUAL(tl_size<r1>::value, tl_size<l1>::value);
  CAF_CHECK((is_same<tl_at<l1, 0>::type, tl_at<r1, 2>::type>::value));
  CAF_CHECK((is_same<tl_at<l1, 1>::type, tl_at<r1, 1>::type>::value));
  CAF_CHECK((is_same<tl_at<l1, 2>::type, tl_at<r1, 0>::type>::value));
  using l2 = tl_concat<type_list<int>, l1>::type;
  CAF_CHECK((is_same<int, tl_head<l2>::type>::value));
  CAF_CHECK((is_same<l1, tl_tail<l2>::type>::value));
  CAF_CHECK_EQUAL((detail::tl_count<l1, is_int>::value), 1u);
  CAF_CHECK_EQUAL((detail::tl_count<l2, is_int>::value), 2u);
  using il0 = int_list<0, 1, 2, 3, 4, 5>;
  using il1 = int_list<4, 5>;
  using il2 = il_right<il0, 2>::type;
  CAF_CHECK((is_same<il2, il1>::value));
  /* test tl_subset_of */ {
    using list_a = type_list<int, float, double>;
    using list_b = type_list<float, int, double, std::string>;
    CAF_CHECK((tl_subset_of<list_a, list_b>::value));
    CAF_CHECK(!(tl_subset_of<list_b, list_a>::value));
    CAF_CHECK((tl_subset_of<list_a, list_a>::value));
    CAF_CHECK((tl_subset_of<list_b, list_b>::value));
  }
}

template <class T>
struct token { };

template <class T>
std::ostream& operator<<(std::ostream& out, token<T>) {
  return out << typeid(T).name();
}

template <class T, class U>
constexpr bool operator==(token<T>, token<U>) {
  return std::is_same<T, U>::value;
}

template <class T>
constexpr token<T> tk() {
  return {};
}

template <class T, class U>
constexpr token<response_type_unbox_t<T, U>> res(token<T>, token<U>) {
  return {};
}

template <class T, class U>
constexpr token<none_t> res(T, U) {
  return {};
}

template <class T, class U>
constexpr token<composed_type_t<T, U>> dot_op(token<T>, token<U>) {
  return {};
}


// -- lift a list of callback types into a list of MPIs

// -- typed behavior dummy class

template <class... Ifs>
struct typed_beh {
  template <class... Ts>
  typed_beh(Ts&&... xs) {
    assign(std::forward<Ts>(xs)...);
  }

  template <class... Ts>
  typename std::enable_if<sizeof...(Ifs) == sizeof...(Ts)>::type
  assign(Ts...) {
    using expected = type_list<Ifs...>;
    using found = type_list<deduce_mpi_t<Ts>...>;
    pos = interface_mismatch_t<found, expected>::value;
    valid = pos == sizeof...(Ifs);
  }

  template <class... Ts>
  typename std::enable_if<sizeof...(Ifs) != sizeof...(Ts)>::type
  assign(Ts...) {
    // too many or too few handlers present
    pos = -1;
    valid = false;
  }

  bool valid = false;
  int pos = 0;
};

using bi_pair = std::pair<bool, int>;

template <class TypedBehavior, class... Ts>
bi_pair tb_assign(Ts&&... xs) {
  TypedBehavior x{std::forward<Ts>(xs)...};
  return {x.valid, x.pos};
}

namespace std {

ostream& operator<<(ostream& out, const pair<bool, int>& x) {
  // do not modify stream with boolalpha
  return out << '(' << (x.first ? "true" : "false") << ", " << x.second << ')';
}

} // namespace std

CAF_TEST(typed_behavior_assignment) {
  using bh1 = typed_beh<replies_to<int>::with<double>,
                        replies_to<double, double>::with<int, int>>;
  // compatible handlers resulting in perfect match
  auto f1 = [=](int) { return 0.; };
  auto f2 = [=](double, double) { return std::make_tuple(0, 0); };
  // compatible handlers using skip
  auto g1 = [=](int) { return skip(); };
  auto g2 = [=](double, double) { return skip(); };
  // incompatbile handlers
  auto e1 = [=](int) { return 0.f; };
  auto e2 = [=](double, double) { return std::make_tuple(0.f, 0.f); };
  // omit one handler
  CAF_CHECK_EQUAL(bi_pair(false, -1), tb_assign<bh1>(f1));
  CAF_CHECK_EQUAL(bi_pair(false, -1), tb_assign<bh1>(f2));
  CAF_CHECK_EQUAL(bi_pair(false, -1), tb_assign<bh1>(g1));
  CAF_CHECK_EQUAL(bi_pair(false, -1), tb_assign<bh1>(g2));
  CAF_CHECK_EQUAL(bi_pair(false, -1), tb_assign<bh1>(e1));
  CAF_CHECK_EQUAL(bi_pair(false, -1), tb_assign<bh1>(e2));
  // any valid alteration of (f1, f2, g1, g2)
  CAF_CHECK_EQUAL(bi_pair(true, 2), tb_assign<bh1>(f1, f2));
  CAF_CHECK_EQUAL(bi_pair(true, 2), tb_assign<bh1>(f2, f1));
  CAF_CHECK_EQUAL(bi_pair(true, 2), tb_assign<bh1>(g1, g2));
  CAF_CHECK_EQUAL(bi_pair(true, 2), tb_assign<bh1>(g2, g1));
  CAF_CHECK_EQUAL(bi_pair(true, 2), tb_assign<bh1>(g1, f2));
  CAF_CHECK_EQUAL(bi_pair(true, 2), tb_assign<bh1>(f2, g1));
  CAF_CHECK_EQUAL(bi_pair(true, 2), tb_assign<bh1>(f1, g2));
  CAF_CHECK_EQUAL(bi_pair(true, 2), tb_assign<bh1>(g2, f1));
  // any invalid alteration of (f1, f2, g1, g2)
  CAF_CHECK_EQUAL(bi_pair(false, 1), tb_assign<bh1>(f1, g1));
  CAF_CHECK_EQUAL(bi_pair(false, 1), tb_assign<bh1>(g1, f1));
  CAF_CHECK_EQUAL(bi_pair(false, 1), tb_assign<bh1>(f2, g2));
  CAF_CHECK_EQUAL(bi_pair(false, 1), tb_assign<bh1>(g2, g2));
  // any invalid alteration of (f1, f2, e1, e2)
  CAF_CHECK_EQUAL(bi_pair(false, 1), tb_assign<bh1>(f1, e1));
  CAF_CHECK_EQUAL(bi_pair(false, 1), tb_assign<bh1>(f1, e2));
  CAF_CHECK_EQUAL(bi_pair(false, 0), tb_assign<bh1>(e1, f1));
  CAF_CHECK_EQUAL(bi_pair(false, 0), tb_assign<bh1>(e1, f2));
  CAF_CHECK_EQUAL(bi_pair(false, 0), tb_assign<bh1>(e1, e2));
  CAF_CHECK_EQUAL(bi_pair(false, 1), tb_assign<bh1>(f2, e1));
  CAF_CHECK_EQUAL(bi_pair(false, 1), tb_assign<bh1>(f2, e2));
  CAF_CHECK_EQUAL(bi_pair(false, 0), tb_assign<bh1>(e2, f1));
  CAF_CHECK_EQUAL(bi_pair(false, 0), tb_assign<bh1>(e2, f2));
  CAF_CHECK_EQUAL(bi_pair(false, 0), tb_assign<bh1>(e2, e1));
  using bh2 = typed_beh<reacts_to<int>,
                        reacts_to<int, int>,
                        reacts_to<int, int, int>,
                        reacts_to<int, int, int, int>,
                        reacts_to<int, int, int, int, int>,
                        reacts_to<int, int, int, int, int, int>,
                        reacts_to<int, int, int, int, int, int, int>,
                        reacts_to<int, int, int, int, int, int, int, int>,
                        reacts_to<int, int, int, int, int,
                                     int, int, int, int>,
                        reacts_to<int, int, int, int, int,
                                     int, int, int, int, int>>;
  auto h0 = [](int) {};
  auto h1 = [](int, int) {};
  auto h2 = [](int, int, int) {};
  auto h3 = [](int, int, int, int) {};
  auto h4 = [](int, int, int, int, int) {};
  auto h5 = [](int, int, int, int, int, int) {};
  auto h6 = [](int, int, int, int, int, int, int) {};
  auto h7 = [](int, int, int, int, int, int, int, int) {};
  auto h8 = [](int, int, int, int, int, int, int, int, int) {};
  auto h9 = [](int, int, int, int, int, int, int, int, int, int) {};
  CAF_CHECK_EQUAL(bi_pair(true, 10), tb_assign<bh2>(h0, h1, h2, h3, h4,
                                                    h5, h6, h7, h8, h9));
  CAF_CHECK_EQUAL(bi_pair(false, 0), tb_assign<bh2>(e1, h1, h2, h3, h4,
                                                    h5, h6, h7, h8, h9));
  CAF_CHECK_EQUAL(bi_pair(false, 1), tb_assign<bh2>(h0, e1, h2, h3, h4,
                                                    h5, h6, h7, h8, h9));
  CAF_CHECK_EQUAL(bi_pair(false, 2), tb_assign<bh2>(h0, h1, e1, h3, h4,
                                                    h5, h6, h7, h8, h9));
  CAF_CHECK_EQUAL(bi_pair(false, 3), tb_assign<bh2>(h0, h1, h2, e1, h4,
                                                    h5, h6, h7, h8, h9));
  CAF_CHECK_EQUAL(bi_pair(false, 4), tb_assign<bh2>(h0, h1, h2, h3, e1,
                                                    h5, h6, h7, h8, h9));
  CAF_CHECK_EQUAL(bi_pair(false, 5), tb_assign<bh2>(h0, h1, h2, h3, h4,
                                                    e1, h6, h7, h8, h9));
  CAF_CHECK_EQUAL(bi_pair(false, 6), tb_assign<bh2>(h0, h1, h2, h3, h4,
                                                    h5, e1, h7, h8, h9));
  CAF_CHECK_EQUAL(bi_pair(false, 7), tb_assign<bh2>(h0, h1, h2, h3, h4,
                                                    h5, h6, e1, h8, h9));
  CAF_CHECK_EQUAL(bi_pair(false, 8), tb_assign<bh2>(h0, h1, h2, h3, h4,
                                                    h5, h6, h7, e1, h9));
  CAF_CHECK_EQUAL(bi_pair(false, 9), tb_assign<bh2>(h0, h1, h2, h3, h4,
                                                    h5, h6, h7, h8, e1));
  CAF_CHECK_EQUAL(bi_pair(false, -1), tb_assign<bh2>(h0, h1, h2, h3, h4,
                                                     h5, h6, h7, h8));
}

CAF_TEST(composed_types) {
  // message type for test message #1
  auto msg_1 = tk<type_list<int>>();
  // message type for test message #1
  auto msg_2 = tk<type_list<double>>();
  // interface type a
  auto if_a = tk<type_list<replies_to<int>::with<double>,
                           replies_to<double, double>::with<int, int>>>();
  // interface type b
  auto if_b = tk<type_list<replies_to<double>::with<std::string>>>();
  // interface type c
  auto if_c = tk<type_list<replies_to<int>::with_stream<double>>>();
  // interface type b . a
  auto if_ba = tk<typed_actor<replies_to<int>::with<std::string>>>();
  // interface type b . c
  auto if_bc = tk<typed_actor<replies_to<int>::with_stream<std::string>>>();
  CAF_MESSAGE("check whether actors return the correct types");
  auto nil = tk<none_t>();
  auto dbl = tk<type_list<double>>();
  //auto dbl_stream = tk<output_stream<double>>();
  CAF_CHECK_EQUAL(res(if_a, msg_1), dbl);
  CAF_CHECK_EQUAL(res(if_a, msg_2), nil);
  //CAF_CHECK_EQUAL(res(if_c, msg_1), dbl_stream);
  CAF_MESSAGE("check types of actor compositions");
  CAF_CHECK_EQUAL(dot_op(if_b, if_a), if_ba);
  CAF_CHECK_EQUAL(dot_op(if_b, if_c), if_bc);
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <map>

#include "caf/config.hpp"

#define CAF_SUITE typed_response_promise
#include "caf/test/unit_test.hpp"

#include "caf/all.hpp"

using namespace caf;

namespace {

using foo_actor = typed_actor<replies_to<int>::with<int>,
                              replies_to<get_atom, int>::with<int>,
                              replies_to<get_atom, int, int>::with<int, int>,
                              replies_to<get_atom, double>::with<double>,
                              replies_to<get_atom, double, double>
                              ::with<double, double>,
                              reacts_to<put_atom, int, int>,
                              reacts_to<put_atom, int, int, int>>;

using foo_promise = typed_response_promise<int>;
using foo2_promise = typed_response_promise<int, int>;
using foo3_promise = typed_response_promise<double>;

using get1_helper = typed_actor<replies_to<int, int>::with<put_atom, int, int>>;
using get2_helper = typed_actor<replies_to<int, int, int>::with<put_atom, int, int, int>>;

class foo_actor_impl : public foo_actor::base {
public:
  foo_actor_impl(actor_config& cfg) : foo_actor::base(cfg) {
    // nop
  }

  behavior_type make_behavior() override {
    return {
      [=](int x) -> foo_promise {
         auto resp = response(x * 2);
         CAF_CHECK(!resp.pending());
         return resp.deliver(x * 4); // has no effect
      },
      [=](get_atom, int x) -> foo_promise {
        auto calculator = spawn([]() -> get1_helper::behavior_type {
          return {
            [](int promise_id, int value) -> result<put_atom, int, int> {
              return {put_atom::value, promise_id, value * 2};
            }
          };
        });
        send(calculator, next_id_, x);
        auto& entry = promises_[next_id_++];
        entry = make_response_promise<foo_promise>();
        return entry;
      },
      [=](get_atom, int x, int y) -> foo2_promise {
        auto calculator = spawn([]() -> get2_helper::behavior_type {
          return {
            [](int promise_id, int v0, int v1) -> result<put_atom, int, int, int> {
              return {put_atom::value, promise_id, v0 * 2, v1 * 2};
            }
          };
        });
        send(calculator, next_id_, x, y);
        auto& entry = promises2_[next_id_++];
        entry = make_response_promise<foo2_promise>();
        // verify move semantics
        CAF_CHECK(entry.pending());
        foo2_promise tmp(std::move(entry));
        CAF_CHECK(!entry.pending());
        CAF_CHECK(tmp.pending());
        entry = std::move(tmp);
        CAF_CHECK(entry.pending());
        CAF_CHECK(!tmp.pending());
        return entry;
      },
      [=](get_atom, double) -> foo3_promise {
        auto resp = make_response_promise<double>();
        return resp.deliver(make_error(sec::unexpected_message));
      },
      [=](get_atom, double x, double y) {
        return response(x * 2, y * 2);
      },
      [=](put_atom, int promise_id, int x) {
        auto i = promises_.find(promise_id);
        if (i == promises_.end())
          return;
        i->second.deliver(x);
        promises_.erase(i);
      },
      [=](put_atom, int promise_id, int x, int y) {
        auto i = promises2_.find(promise_id);
        if (i == promises2_.end())
          return;
        i->second.deliver(x, y);
        promises2_.erase(i);
      }
    };
  }

private:
  int next_id_ = 0;
  std::map<int, foo_promise> promises_;
  std::map<int, foo2_promise> promises2_;
};

struct fixture {
  fixture()
      : system(cfg),
        self(system, true),
        foo(system.spawn<foo_actor_impl>()) {
    // nop
  }

  actor_system_config cfg;
  actor_system system;
  scoped_actor self;
  foo_actor foo;
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(typed_spawn_tests, fixture)

CAF_TEST(typed_response_promise) {
  typed_response_promise<int> resp;
  CAF_MESSAGE("trigger 'invalid response promise' error");
  resp.deliver(1); // delivers on an invalid promise has no effect
  auto f = make_function_view(foo);
  CAF_CHECK_EQUAL(f(get_atom::value, 42), 84);
  CAF_CHECK_EQUAL(f(get_atom::value, 42, 52), std::make_tuple(84, 104));
  CAF_CHECK_EQUAL(f(get_atom::value, 3.14, 3.14), std::make_tuple(6.28, 6.28));
}

CAF_TEST(typed_response_promise_chained) {
  auto f = make_function_view(foo * foo * foo);
  CAF_CHECK_EQUAL(f(1), 8);
}

// verify that only requests get an error response message
CAF_TEST(error_response_message) {
  auto f = make_function_view(foo);
  CAF_CHECK_EQUAL(f(get_atom::value, 3.14), sec::unexpected_message);
  self->send(foo, get_atom::value, 42);
  self->receive(
    [](int x) {
      CAF_CHECK_EQUAL(x, 84);
    },
    [](double x) {
      CAF_ERROR("unexpected ordinary response message received: " << x);
    }
  );
  self->send(foo, get_atom::value, 3.14);
  self->receive(
    [&](error& err) {
      CAF_CHECK_EQUAL(err, sec::unexpected_message);
      self->send(self, message{});
    }
  );
}

// verify that delivering to a satisfied promise has no effect
CAF_TEST(satisfied_promise) {
  self->send(foo, 1);
  self->send(foo, get_atom::value, 3.14, 3.14);
  int i = 0;
  self->receive_for(i, 2) (
    [](int x) {
      CAF_CHECK_EQUAL(x, 1 * 2);
    },
    [](double x, double y) {
      CAF_CHECK_EQUAL(x, 3.14 * 2);
      CAF_CHECK_EQUAL(y, 3.14 * 2);
    }
  );
}

CAF_TEST(delegating_promises) {
  using task = std::pair<typed_response_promise<int>, int>;
  struct state {
    std::vector<task> tasks;
  };
  using bar_actor = typed_actor<replies_to<int>::with<int>, reacts_to<ok_atom>>;
  auto bar_fun = [](bar_actor::stateful_pointer<state> self, foo_actor worker)
                 -> bar_actor::behavior_type {
    return {
      [=](int x) -> typed_response_promise<int> {
        auto& tasks = self->state.tasks;
        tasks.emplace_back(self->make_response_promise<int>(), x);
        self->send(self, ok_atom::value);
        return tasks.back().first;
      },
      [=](ok_atom) {
        auto& tasks = self->state.tasks;
        if (!tasks.empty()) {
          auto& task = tasks.back();
          task.first.delegate(worker, task.second);
          tasks.pop_back();
        }
      }
    };
  };
  auto f = make_function_view(system.spawn(bar_fun, foo));
  CAF_CHECK_EQUAL(f(42), 84);
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE aout
#include "caf/test/unit_test.hpp"

#include "caf/all.hpp"

using namespace caf;

using std::endl;

namespace {

constexpr const char* global_redirect = ":test";
constexpr const char* local_redirect = ":test2";

constexpr const char* chatty_line = "hi there!:)";
constexpr const char* chattier_line = "hello there, fellow friend!:)";

void chatty_actor(event_based_actor* self) {
  aout(self) << chatty_line << endl;
}

void chattier_actor(event_based_actor* self, const std::string& fn) {
  aout(self) << chatty_line << endl;
  actor_ostream::redirect(self, fn);
  aout(self) << chattier_line << endl;
}

struct fixture {
  fixture() : system(cfg) {
    // nop
  }

  actor_system_config cfg;
  actor_system system;
  scoped_actor self{system, true};
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(adapter_tests, fixture)

CAF_TEST(redirect_aout_globally) {
  self->join(system.groups().get_local(global_redirect));
  actor_ostream::redirect_all(system, global_redirect);
  system.spawn(chatty_actor);
  self->receive(
    [](const std::string& virtual_file, std::string& line) {
      // drop trailing '\n'
      if (!line.empty())
        line.pop_back();
      CAF_CHECK_EQUAL(virtual_file, ":test");
      CAF_CHECK_EQUAL(line, chatty_line);
    }
  );
  self->await_all_other_actors_done();
  CAF_CHECK_EQUAL(self->mailbox().count(), 0u);
}

CAF_TEST(global_and_local_redirect) {
  self->join(system.groups().get_local(global_redirect));
  self->join(system.groups().get_local(local_redirect));
  actor_ostream::redirect_all(system, global_redirect);
  system.spawn(chatty_actor);
  system.spawn(chattier_actor, local_redirect);
  std::vector<std::pair<std::string, std::string>> expected {
    {":test", chatty_line},
    {":test", chatty_line},
    {":test2", chattier_line}
  };
  std::vector<std::pair<std::string, std::string>> lines;
  int i = 0;
  self->receive_for(i, 3)(
    [&](std::string& virtual_file, std::string& line) {
      // drop trailing '\n'
      if (!line.empty())
        line.pop_back();
      lines.emplace_back(std::move(virtual_file), std::move(line));
    }
  );
  CAF_CHECK(std::is_permutation(lines.begin(), lines.end(), expected.begin()));
  self->await_all_other_actors_done();
  CAF_CHECK_EQUAL(self->mailbox().count(), 0u);
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <map>
#include <vector>
#include <string>
#include <numeric>
#include <iostream>

#include <set>
#include <unordered_set>

#include "caf/config.hpp"

#define CAF_SUITE message_operations
#include "caf/test/unit_test.hpp"

#include "caf/all.hpp"

using std::map;
using std::string;
using std::vector;
using std::make_tuple;

using namespace caf;

CAF_TEST(apply) {
  auto f1 = [] {
    CAF_ERROR("f1 invoked!");
  };
  auto f2 = [](int i) {
    CAF_CHECK_EQUAL(i, 42);
  };
  auto m = make_message(42);
  m.apply(f1);
  m.apply(f2);
}

CAF_TEST(drop) {
  auto m1 = make_message(1, 2, 3, 4, 5);
  std::vector<message> messages{
    m1,
    make_message(2, 3, 4, 5),
    make_message(3, 4, 5),
    make_message(4, 5),
    make_message(5),
    message{}
  };
  for (size_t i = 0; i < messages.size(); ++i) {
    CAF_CHECK_EQUAL(to_string(m1.drop(i)), to_string(messages[i]));
  }
}

CAF_TEST(slice) {
  auto m1 = make_message(1, 2, 3, 4, 5);
  auto m2 = m1.slice(2, 2);
  CAF_CHECK_EQUAL(to_string(m2), to_string(make_message(3, 4)));
}

CAF_TEST(extract1) {
  auto m1 = make_message(1.0, 2.0, 3.0);
  auto m2 = make_message(1, 2, 1.0, 2.0, 3.0);
  auto m3 = make_message(1.0, 1, 2, 2.0, 3.0);
  auto m4 = make_message(1.0, 2.0, 1, 2, 3.0);
  auto m5 = make_message(1.0, 2.0, 3.0, 1, 2);
  auto m6 = make_message(1, 2, 1.0, 2.0, 3.0, 1, 2);
  auto m7 = make_message(1.0, 1, 2, 3, 4, 2.0, 3.0);
  message_handler f{
    [](int, int) { },
    [](float, float) { }
  };
  auto m1s = to_string(m1);
  CAF_CHECK_EQUAL(to_string(m2.extract(f)), m1s);
  CAF_CHECK_EQUAL(to_string(m3.extract(f)), m1s);
  CAF_CHECK_EQUAL(to_string(m4.extract(f)), m1s);
  CAF_CHECK_EQUAL(to_string(m5.extract(f)), m1s);
  CAF_CHECK_EQUAL(to_string(m6.extract(f)), m1s);
  CAF_CHECK_EQUAL(to_string(m7.extract(f)), m1s);
}

CAF_TEST(extract2) {
  auto m1 = make_message(1);
  CAF_CHECK(m1.extract([](int) {}).empty());
  auto m2 = make_message(1.0, 2, 3, 4.0);
  auto m3 = m2.extract({
    [](int, int) { },
    [](double, double) { }
  });
  // check for false positives through collapsing
  CAF_CHECK_EQUAL(to_string(m3), to_string(make_message(1.0, 4.0)));
}

CAF_TEST(extract_opts) {
  auto f = [](std::vector<std::string> xs, std::vector<std::string> remainder) {
    std::string filename;
    size_t log_level = 0;
    auto res = message_builder(xs.begin(), xs.end()).extract_opts({
      {"version,v", "print version"},
      {"log-level,l", "set the log level", log_level},
      {"file,f", "set output file", filename},
      {"whatever", "do whatever"}
    });
    CAF_CHECK_EQUAL(res.opts.count("file"), 1u);
    CAF_CHECK(res.remainder.size() == remainder.size());
    for (size_t i = 0; i < res.remainder.size() && i < remainder.size(); ++i) {
      CAF_CHECK(remainder[i] == res.remainder.get_as<string>(i));
    }
    CAF_CHECK_EQUAL(filename, "hello.txt");
    CAF_CHECK_EQUAL(log_level, 5u);
  };
  f({"--file=hello.txt", "-l", "5"}, {});
  f({"-f", "hello.txt", "--log-level=5"}, {});
  f({"-f", "hello.txt", "-l", "5"}, {});
  f({"-f", "hello.txt", "-l5"}, {});
  f({"-fhello.txt", "-l", "5"}, {});
  f({"-l5", "-fhello.txt"}, {});
  // on remainder
  f({"--file=hello.txt", "-l", "5", "--", "a"}, {"a"});
  f({"--file=hello.txt", "-l", "5", "--", "a", "b"}, {"a", "b"});
  f({"--file=hello.txt", "-l", "5", "--", "aa", "bb"}, {"aa", "bb"});
  f({"--file=hello.txt", "-l", "5", "--", "-a", "--bb"}, {"-a", "--bb"});
  f({"--file=hello.txt", "-l", "5", "--", "-a1", "--bb=10"},
    {"-a1", "--bb=10"});
  f({"--file=hello.txt", "-l", "5", "--", "-a 1", "--b=10"},
    {"-a 1", "--b=10"});
  // multiple remainders
  f({"--file=hello.txt", "-l", "5", "--", "a", "--"}, {"a", "--"});
  f({"--file=hello.txt", "-l", "5", "--", "a", "--", "--"}, {"a", "--", "--"});
  f({"--file=hello.txt", "-l", "5", "--", "a", "--", "b"}, {"a", "--", "b"});
  f({"--file=hello.txt", "-l", "5", "--", "aa", "--", "bb"},
    {"aa", "--", "bb"});
  f({"--file=hello.txt", "-l", "5", "--", "aa", "--", "--", "bb"},
    {"aa", "--", "--", "bb"});
  f({"--file=hello.txt", "-l", "5", "--", "--", "--", "-a1", "--bb=10"},
    {"--", "--", "-a1", "--bb=10"});
  CAF_MESSAGE("ensure that failed parsing doesn't consume input");
  auto msg = make_message("-f", "42", "-b", "1337");
  auto foo = 0;
  auto bar = 0;
  auto r = msg.extract_opts({
    {"foo,f", "foo desc", foo}
  });
  CAF_CHECK(r.opts.count("foo") > 0);
  CAF_CHECK_EQUAL(foo, 42);
  CAF_CHECK_EQUAL(bar, 0);
  CAF_CHECK(!r.error.empty()); // -b is an unknown option
  CAF_CHECK(!r.remainder.empty()
            && to_string(r.remainder) == to_string(make_message("-b", "1337")));
  r = r.remainder.extract_opts({
    {"bar,b", "bar desc", bar}
  });
  CAF_CHECK(r.opts.count("bar") > 0);
  CAF_CHECK_EQUAL(bar, 1337);
  CAF_CHECK(r.error.empty());
}

CAF_TEST(type_token) {
  auto m1 = make_message(get_atom::value);
  CAF_CHECK_EQUAL(m1.type_token(), make_type_token<get_atom>());
}

CAF_TEST(concat) {
  auto m1 = make_message(get_atom::value);
  auto m2 = make_message(uint32_t{1});
  auto m3 = message::concat(m1, m2);
  CAF_CHECK_EQUAL(to_string(m3), to_string(m1 + m2));
  CAF_CHECK_EQUAL(to_string(m3), "('get', 1)");
  auto m4 = make_message(get_atom::value, uint32_t{1},
                         get_atom::value, uint32_t{1});
  CAF_CHECK_EQUAL(to_string(message::concat(m3, message{}, m1, m2)), to_string(m4));
}

namespace {

struct s1 {
  int value[3] = {10, 20, 30};
};

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, s1& x) {
  return f(x.value);
}

struct s2 {
  int value[4][2] = {{1, 10}, {2, 20}, {3, 30}, {4, 40}};
};

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, s2& x) {
  return f(x.value);
}

struct s3 {
  std::array<int, 4> value;
  s3() {
    std::iota(value.begin(), value.end(), 1);
  }
};

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, s3& x) {
  return f(x.value);
}

template <class... Ts>
std::string msg_as_string(Ts&&... xs) {
  return to_string(make_message(std::forward<Ts>(xs)...));
}

} // namespace <anonymous>

CAF_TEST(compare_custom_types) {
  s2 tmp;
  tmp.value[0][1] = 100;
  CAF_CHECK_NOT_EQUAL(to_string(make_message(s2{})),
                      to_string(make_message(tmp)));
}

CAF_TEST(empty_to_string) {
  message msg;
  CAF_CHECK(to_string(msg), "<empty-message>");
}

CAF_TEST(integers_to_string) {
  using ivec = vector<int>;
  CAF_CHECK_EQUAL(msg_as_string(1, 2, 3), "(1, 2, 3)");
  CAF_CHECK_EQUAL(msg_as_string(ivec{1, 2, 3}), "([1, 2, 3])");
  CAF_CHECK_EQUAL(msg_as_string(ivec{1, 2}, 3, 4, ivec{5, 6, 7}),
                  "([1, 2], 3, 4, [5, 6, 7])");
}

CAF_TEST(strings_to_string) {
  using svec = vector<string>;
  auto msg1 = make_message("one", "two", "three");
  CAF_CHECK_EQUAL(to_string(msg1), R"__(("one", "two", "three"))__");
  auto msg2 = make_message(svec{"one", "two", "three"});
  CAF_CHECK_EQUAL(to_string(msg2), R"__((["one", "two", "three"]))__");
  auto msg3 = make_message(svec{"one", "two"}, "three", "four",
                           svec{"five", "six", "seven"});
  CAF_CHECK(to_string(msg3) ==
          R"__((["one", "two"], "three", "four", ["five", "six", "seven"]))__");
  auto msg4 = make_message(R"(this is a "test")");
  CAF_CHECK_EQUAL(to_string(msg4), "(\"this is a \\\"test\\\"\")");
}

CAF_TEST(maps_to_string) {
  map<int, int> m1{{1, 10}, {2, 20}, {3, 30}};
  auto msg1 = make_message(move(m1));
  CAF_CHECK_EQUAL(to_string(msg1), "([(1, 10), (2, 20), (3, 30)])");
}

CAF_TEST(tuples_to_string) {
  auto msg1 = make_message(make_tuple(1, 2, 3), 4, 5);
  CAF_CHECK_EQUAL(to_string(msg1), "((1, 2, 3), 4, 5)");
  auto msg2 = make_message(make_tuple(string{"one"}, 2, uint32_t{3}), 4, true);
  CAF_CHECK_EQUAL(to_string(msg2), "((\"one\", 2, 3), 4, true)");
}

CAF_TEST(arrays_to_string) {
  CAF_CHECK_EQUAL(msg_as_string(s1{}), "((10, 20, 30))");
  auto msg2 = make_message(s2{});
  s2 tmp;
  tmp.value[0][1] = 100;
  CAF_CHECK_EQUAL(to_string(msg2), "(((1, 10), (2, 20), (3, 30), (4, 40)))");
  CAF_CHECK_EQUAL(msg_as_string(s3{}), "((1, 2, 3, 4))");
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE constructor_attach
#include "caf/test/unit_test.hpp"

#include "caf/all.hpp"

using namespace caf;

namespace {

using die_atom = atom_constant<atom("die")>;
using done_atom = atom_constant<atom("done")>;

class testee : public event_based_actor {
public:
  testee(actor_config& cfg, actor buddy) : event_based_actor(cfg) {
    attach_functor([=](const error& reason) {
      send(buddy, done_atom::value, reason);
    });
  }

  behavior make_behavior() override {
    return {
      [=](die_atom) {
        quit(exit_reason::user_shutdown);
      }
    };
  }
};

class spawner : public event_based_actor {
public:
  spawner(actor_config& cfg)
      : event_based_actor(cfg),
        downs_(0),
        testee_(spawn<testee, monitored>(this)) {
    set_down_handler([=](down_msg& msg) {
      CAF_CHECK_EQUAL(msg.reason, exit_reason::user_shutdown);
      CAF_CHECK_EQUAL(msg.source, testee_.address());
      if (++downs_ == 2)
        quit(msg.reason);
    });
  }

  behavior make_behavior() override {
    return {
      [=](done_atom, const error& reason) {
        CAF_CHECK_EQUAL(reason, exit_reason::user_shutdown);
        if (++downs_ == 2) {
          quit(reason);
        }
      },
      [=](die_atom x) {
        return delegate(testee_, x);
      }
    };
  }

  void on_exit() override {
    destroy(testee_);
  }

private:
  int downs_;
  actor testee_;
};

} // namespace <anonymous>

CAF_TEST(constructor_attach) {
  actor_system_config cfg;
  actor_system system{cfg};
  anon_send(system.spawn<spawner>(), die_atom::value);
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE detached_actors
#include "caf/test/unit_test.hpp"

#include "caf/all.hpp"

using namespace caf;

using std::endl;

namespace {

struct fixture {
  actor_system_config cfg;
  actor_system sys;
  scoped_actor self;

  fixture() : sys(cfg), self(sys, true) {
    // nop
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(detached_actors, fixture)

CAF_TEST(shutdown) {
  CAF_MESSAGE("does sys shut down after spawning a detached actor?");
  sys.spawn<detached>([] {});
}

CAF_TEST(shutdown_with_delayed_send) {
  CAF_MESSAGE("does sys shut down after spawning a detached actor that used "
              "delayed_send?");
  auto f = [](event_based_actor* self) -> behavior {
    self->delayed_send(self, std::chrono::nanoseconds(1), ok_atom::value);
    return {
      [=](ok_atom) {
        self->quit();
      }
    };
  };
  sys.spawn<detached>(f);
}

CAF_TEST(shutdown_with_unhandled_delayed_send) {
  CAF_MESSAGE("does sys shut down after spawning a detached actor that used "
              "delayed_send but didn't bother waiting for it?");
  auto f = [](event_based_actor* self) {
    self->delayed_send(self, std::chrono::nanoseconds(1), ok_atom::value);
  };
  sys.spawn<detached>(f);
}

CAF_TEST(shutdown_with_after) {
  CAF_MESSAGE("does sys shut down after spawning a detached actor that used "
              "after()?");
  auto f = [](event_based_actor* self) -> behavior {
    return {
      after(std::chrono::nanoseconds(1)) >> [=] {
        self->quit();
      }
    };
  };
  sys.spawn<detached>(f);
}

CAF_TEST(shutdown_delayed_send_loop) {
  CAF_MESSAGE("does sys shut down after spawning a detached actor that used "
              "a delayed send loop and was interrupted via exit message?");
  auto f = [](event_based_actor* self) -> behavior {
    self->send(self, std::chrono::milliseconds(1), ok_atom::value);
    return {
      [=](ok_atom) {
        self->send(self, std::chrono::milliseconds(1), ok_atom::value);
      }
    };
  };
  auto a = sys.spawn<detached>(f);
  auto g = detail::make_scope_guard([&] {
    self->send_exit(a, exit_reason::user_shutdown);
  });
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE extract
#include "caf/test/unit_test.hpp"

#include <string>
#include <vector>

#include "caf/all.hpp"

using namespace caf;

using std::string;

CAF_TEST(type_sequences) {
  auto _64 = uint64_t{64};
  std::string str = "str";
  auto msg = make_message(1.0, 2.f, str, 42, _64);
  auto df = [](double, float) { };
  auto fs = [](float, const string&) { };
  auto iu = [](int, uint64_t) { };
  CAF_CHECK_EQUAL(to_string(msg.extract(df)),
                  to_string(make_message(str, 42,  _64)));
  CAF_CHECK_EQUAL(to_string(msg.extract(fs)),
                  to_string(make_message(1.0, 42,  _64)));
  CAF_CHECK_EQUAL(to_string(msg.extract(iu)),
                  to_string(make_message(1.0, 2.f, str)));
}

CAF_TEST(cli_args) {
  std::vector<string> args{"-n", "-v", "5", "--out-file=/dev/null"};
  int verbosity = 0;
  string output_file;
  string input_file;
  auto res = message_builder(args.begin(), args.end()).extract_opts({
    {"no-colors,n", "disable colors"},
    {"out-file,o", "redirect output", output_file},
    {"in-file,i", "read from file", input_file},
    {"verbosity,v", "1-5", verbosity}
  });
  CAF_CHECK_EQUAL(res.remainder.size(), 0u);
  CAF_CHECK(res.remainder.empty());
  CAF_CHECK_EQUAL(res.opts.count("no-colors"), 1u);
  CAF_CHECK_EQUAL(res.opts.count("verbosity"), 1u);
  CAF_CHECK_EQUAL(res.opts.count("out-file"), 1u);
  CAF_CHECK_EQUAL(res.opts.count("in-file"), 0u);
  CAF_CHECK_EQUAL(output_file, "/dev/null");
  CAF_CHECK_EQUAL(input_file, "");
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE function_view
#include "caf/test/unit_test.hpp"

#include <string>
#include <vector>

#include "caf/all.hpp"

using namespace caf;

namespace {

using calculator = typed_actor<replies_to<int, int>::with<int>>;

calculator::behavior_type adder() {
  return {
    [](int x, int y) {
      return x + y;
    }
  };
}

calculator::behavior_type multiplier() {
  return {
    [](int x, int y) {
      return x * y;
    }
  };
}

calculator::behavior_type divider() {
  return {
    [](int x, int y) -> optional<int> {
      if (y == 0)
        return none;
      return x / y;
    }
  };
}

using doubler = typed_actor<replies_to<int>::with<int, int>>;

doubler::behavior_type simple_doubler() {
  return {
    [](int x) {
      return std::make_tuple(x, x);
    }
  };
}

using cell = typed_actor<reacts_to<put_atom, int>,
                         replies_to<get_atom>::with<int>>;

struct cell_state {
  int value = 0;
};

cell::behavior_type
simple_cell(cell::stateful_pointer<cell_state> self) {
  return {
    [=](put_atom, int val) {
      self->state.value = val;
    },
    [=](get_atom) {
      return self->state.value;
    }
  };
}

struct fixture {
  fixture() : system(cfg) {
    // nop
  }

  actor_system_config cfg;
  actor_system system;
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(function_view_tests, fixture)

CAF_TEST(empty_function_fiew) {
  function_view<calculator> f;
  CAF_CHECK_EQUAL(f(10, 20), sec::bad_function_call);
}

CAF_TEST(single_res_function_view) {
  auto f = make_function_view(system.spawn(adder));
  CAF_CHECK_EQUAL(f(3, 4), 7);
  CAF_CHECK(f != nullptr);
  CAF_CHECK(nullptr != f);
  function_view<calculator> g;
  g = std::move(f);
  CAF_CHECK(f == nullptr);
  CAF_CHECK(nullptr == f);
  CAF_CHECK(g != nullptr);
  CAF_CHECK(nullptr != g);
  CAF_CHECK_EQUAL(g(10, 20), 30);
  g.assign(system.spawn(multiplier));
  CAF_CHECK_EQUAL(g(10, 20), 200);
  g.assign(system.spawn(divider));
  CAF_CHECK(!g(1, 0));
  g.assign(system.spawn(divider));
  CAF_CHECK_EQUAL(g(4, 2), 2);
}

CAF_TEST(tuple_res_function_view) {
  auto f = make_function_view(system.spawn(simple_doubler));
  CAF_CHECK_EQUAL(f(10), std::make_tuple(10, 10));
}

CAF_TEST(cell_function_view) {
  auto f = make_function_view(system.spawn(simple_cell));
  CAF_CHECK_EQUAL(f(get_atom::value), 0);
  f(put_atom::value, 1024);
  CAF_CHECK_EQUAL(f(get_atom::value), 1024);
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE config_option
#include "caf/test/unit_test.hpp"

#include "caf/config_option.hpp"
#include "caf/actor_system_config.hpp"

// turn off several flags for overflows / sign conversion
#ifdef CAF_CLANG
#pragma clang diagnostic ignored "-Wsign-conversion"
#pragma clang diagnostic ignored "-Wfloat-equal"
#pragma clang diagnostic ignored "-Wconstant-conversion"
#elif defined(CAF_GCC)
#pragma GCC diagnostic ignored "-Woverflow"
#endif

using namespace caf;

namespace {

constexpr const char* category = "category";
constexpr const char* name = "name";
constexpr const char* explanation = "explanation";
constexpr size_t line = 0;

template<class T>
constexpr T zero() { return 0; }

template<class T, class U, class V> 
constexpr T overflow() {
  // +2 is necessary as after an overflow unsigned integral numbers 
  // must differ from zero() in the tests
  return static_cast<V>(std::numeric_limits<U>::max()) + 2;
}

template <class T, class U> 
std::tuple<T, std::string> run_config_option(const T& init_value, 
                                             const U& test_value) {
  std::stringstream ostr;
  T output_value = init_value;
  auto cv = config_value(test_value);
  auto co = make_config_option(output_value, category, name, explanation);
  auto f = co->to_sink(); 
  f(line, cv, static_cast<std::ostream&>(ostr));
  return std::make_tuple(output_value, ostr.str());
}

// only works with an integral types and double 
template <class T, class U> 
void check_num_general_usage() {
  // check positive numbers
  std::string error_str;
  U test_value = 5;
  T result;
  std::tie(result, error_str) = run_config_option(zero<T>(), test_value); 
  CAF_CHECK_EQUAL(result, static_cast<T>(test_value));
  CAF_CHECK(error_str.empty());
  // check negative numbers
  test_value = -5;
  std::tie(result, error_str) = run_config_option(zero<T>(), test_value); 
  if (std::numeric_limits<T>::is_signed) {
    CAF_CHECK_EQUAL(result, static_cast<T>(test_value));
    CAF_CHECK(error_str.empty());
  } else {
    CAF_CHECK_EQUAL(result, zero<T>());
    CAF_CHECK(!error_str.empty());
  }
  // check vector<T>
  test_value = 5;
  std::vector<T> vec_result;
  std::tie(vec_result, error_str) = 
           run_config_option(std::vector<T>{}, test_value);
  CAF_CHECK(!vec_result.empty());
  if (!vec_result.empty()) {
    CAF_CHECK_EQUAL(*vec_result.begin(), static_cast<T>(test_value));
  }
}

// only works with an integral types (no doubles)
template <class T, class U> 
void check_num_boundary_usage() {
  std::string error_str;
  T result;
  U boundary_check = overflow<U,T,U>();
  std::tie(result, error_str) = run_config_option(zero<T>(), boundary_check); 
  T tmp = overflow<T, T, U>();
  CAF_CHECK_NOT_EQUAL(result, tmp);
  CAF_CHECK_EQUAL(result, zero<T>());
  CAF_CHECK(!error_str.empty());
}

// only works with an integral types (no doubles)
template <class T, class U> 
void check_num_general_and_boundary_usage() {
  check_num_general_usage<T, U>();
  check_num_boundary_usage<T, U>();
}

// intended for atoms, strings, and bools 
template <class T> 
void check_non_num_general_usage(const T& init_value, const T& test_value) {
  // general check
  std::string error_str;
  T result;
  std::tie(result, error_str) = run_config_option(init_value, test_value);
  CAF_CHECK_EQUAL(result, test_value);
  // vector<T> check
  std::vector<T> vec_result;
  std::tie(vec_result, error_str) = 
           run_config_option(std::vector<T>{}, test_value);
  CAF_CHECK(!vec_result.empty());
  if (!vec_result.empty()) {
    CAF_CHECK_EQUAL(*vec_result.begin(), test_value);
  }
}

void check_non_num_general_usage(bool init_value, bool test_value) {
  // general check
  std::string error_str;
  bool result;
  std::tie(result, error_str) = run_config_option(init_value, test_value);
  CAF_CHECK_EQUAL(result, test_value);
  // vector<T> check
  // emplace_back() in class cli_arg do not support <bool> until C++14
}

}

CAF_TEST(type_bool) {
  check_non_num_general_usage(false, true);
}

CAF_TEST(type_int8_t) {
  check_num_general_and_boundary_usage<int8_t, int64_t>();
}

CAF_TEST(type_uint8_t) {
  check_num_general_and_boundary_usage<uint8_t, int64_t>();
}

CAF_TEST(type_int16_t) {
  check_num_general_and_boundary_usage<int16_t, int64_t>();
}

CAF_TEST(type_uint16_t) {
  check_num_general_and_boundary_usage<uint16_t, int64_t>();
}

CAF_TEST(type_int32_t) {
  check_num_general_and_boundary_usage<int32_t, int64_t>();
}

CAF_TEST(type_uint32_t) {
  check_num_general_and_boundary_usage<uint32_t, int64_t>();
}

CAF_TEST(type_uint64_t) {
  check_num_general_usage<uint64_t, int64_t>();
}

CAF_TEST(type_int64_t) {
  check_num_general_usage<int64_t, int64_t>();
}

CAF_TEST(type_float) {
  check_num_general_usage<float, double>();
  // check boundaries
  std::string error_str;
  float result;
  float init_value = 0;
  // *2 is required as +2 does not change the variable at this size anymore
  double boundary_check = static_cast<double>(
                                      std::numeric_limits<float>::max()) * 2;
  std::tie(result, error_str) = run_config_option(init_value, boundary_check); 
  float float_inf = std::numeric_limits<float>::infinity();
  // Unit test does not compare inf values correct until now
  bool tmp = float_inf == result;
  CAF_CHECK_NOT_EQUAL(tmp, true);
  CAF_CHECK_EQUAL(result, init_value);
  CAF_CHECK_EQUAL(error_str.empty(), false);
}

CAF_TEST(type_double) {
  check_num_general_usage<double, double>();
}

CAF_TEST(type_string) {
  check_non_num_general_usage<std::string>("", "test string");
}

CAF_TEST(type_atom) {
  // TODO: in class cli_arg std::istringstream do not support atom_value
  // check_non_num_general_usage<atom_value>(atom(""), atom("test atom"));
}

template <class T>
std::string v(const T& x) {
  config_option::type_name_visitor v;
  return v(x);
}

CAF_TEST(type_names) {
  CAF_CHECK_EQUAL(v(true),             "a boolean");
  CAF_CHECK_EQUAL(v(atom("")),         "an atom_value");
  CAF_CHECK_EQUAL(v(std::string{}),    "a string");
  CAF_CHECK_EQUAL(v(zero<float>()),    "a float");
  CAF_CHECK_EQUAL(v(zero<double>()),   "a double");
  CAF_CHECK_EQUAL(v(zero<int8_t>()),   "an 8-bit integer");
  CAF_CHECK_EQUAL(v(zero<uint8_t>()),  "an 8-bit unsigned integer");
  CAF_CHECK_EQUAL(v(zero<int16_t>()),  "a 16-bit integer");
  CAF_CHECK_EQUAL(v(zero<uint16_t>()), "a 16-bit unsigned integer");
  CAF_CHECK_EQUAL(v(zero<int32_t>()),  "a 32-bit integer");
  CAF_CHECK_EQUAL(v(zero<uint32_t>()), "a 32-bit unsigned integer");
  CAF_CHECK_EQUAL(v(zero<int64_t>()),  "a 64-bit integer");
  CAF_CHECK_EQUAL(v(zero<uint64_t>()), "a 64-bit unsigned integer");
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE composable_behaviors
#include "caf/test/unit_test.hpp"

#include "caf/all.hpp"

#define ERROR_HANDLER                                                          \
  [&](error& err) { CAF_FAIL(system.render(err)); }

using namespace std;
using namespace caf;

namespace {

// -- composable behaviors using primitive data types --------------------------

using i3_actor = typed_actor<replies_to<int, int, int>::with<int>>;

using d_actor = typed_actor<replies_to<double>::with<double, double>>;

using foo_actor = i3_actor::extend_with<d_actor>;

class foo_actor_state : public composable_behavior<foo_actor> {
public:
  result<int> operator()(int x, int y, int z) override {
    return x + y + z;
  }

  result<double, double> operator()(double x) override {
    return {x, x};
  }
};

class i3_actor_state : public composable_behavior<i3_actor> {
public:
  result<int> operator()(int x, int y, int z) override {
    return x + y + z;
  }
};

class d_actor_state : public composable_behavior<d_actor> {
public:
  result<double, double> operator()(double x) override {
    return {x, x};
  }
};

class i3_actor_state2 : public composable_behavior<i3_actor> {
public:
  result<int> operator()(int x, int y, int z) override {
    return x * (y * z);
  }
};

// checks whether CAF resolves "diamonds" properly by inheriting
// from two behaviors that both implement i3_actor
struct foo_actor_state2
    : composed_behavior<i3_actor_state2, i3_actor_state, d_actor_state> {
  result<int> operator()(int x, int y, int z) override {
    return x - y - z;
  }
};

// -- composable behaviors using param<T> arguments ----------------------------

std::atomic<long> counting_strings_created;
std::atomic<long> counting_strings_moved;
std::atomic<long> counting_strings_destroyed;

// counts how many instances where created
struct counting_string {
public:
  counting_string() {
    ++counting_strings_created;
  }

  counting_string(const char* cstr) : str_(cstr) {
    ++counting_strings_created;
  }

  counting_string(const counting_string& x) : str_(x.str_) {
    ++counting_strings_created;
  }

  counting_string(counting_string&& x) : str_(std::move(x.str_)) {
    ++counting_strings_created;
    ++counting_strings_moved;
  }

  ~counting_string() {
    ++counting_strings_destroyed;
  }

  counting_string& operator=(const char* cstr) {
    str_ = cstr;
    return *this;
  }

  const std::string& str() const {
    return str_;
  }

  template <class Inspector>
  friend typename Inspector::result_type inspect(Inspector& f,
                                                 counting_string& x) {
    return f(x.str_);
  }

private:
  std::string str_;
};

bool operator==(const counting_string& x, const counting_string& y) {
  return x.str() == y.str();
}

bool operator==(const counting_string& x, const char* y) {
  return x.str() == y;
}

std::string to_string(const counting_string& ref) {
  return ref.str();
}

} // namespace <anonymous>

namespace std {

template <>
struct hash<counting_string> {
  inline size_t operator()(const counting_string& ref) const {
    hash<string> f;
    return f(ref.str());
  }
};

} // namespace std

namespace {

using add_atom = atom_constant<atom("add")>;
using get_name_atom = atom_constant<atom("getName")>;
using ping_atom = atom_constant<atom("ping")>;
using pong_atom = atom_constant<atom("pong")>;

// "base" interface
using named_actor =
  typed_actor<replies_to<get_name_atom>::with<counting_string>,
              replies_to<ping_atom>::with<pong_atom>>;

// a simple dictionary
using dict =
  named_actor::extend<replies_to<get_atom, counting_string>
                      ::with<counting_string>,
                      replies_to<put_atom, counting_string, counting_string>
                      ::with<void>>;

class dict_state : public composable_behavior<dict> {
public:
  result<counting_string> operator()(get_name_atom) override {
    return "dictionary";
  }

  result<pong_atom> operator()(ping_atom) override {
    return pong_atom::value;
  }

  result<counting_string> operator()(get_atom,
                                     param<counting_string> key) override {
    auto i = values_.find(key.get());
    if (i == values_.end())
      return "";
    return i->second;
  }

  result<void> operator()(put_atom, param<counting_string> key,
                          param<counting_string> value) override {
    if (values_.count(key.get()) != 0)
      return unit;
    values_.emplace(key.move(), value.move());
    return unit;
  }

protected:
  std::unordered_map<counting_string, counting_string> values_;
};

using delayed_testee_actor = typed_actor<reacts_to<int>,
                                         replies_to<bool>::with<int>,
                                         reacts_to<std::string>>;

class delayed_testee : public composable_behavior<delayed_testee_actor> {
public:
  result<void> operator()(int x) override {
    CAF_CHECK_EQUAL(x, 42);
    self->delayed_anon_send(self, std::chrono::milliseconds(10), true);
    return unit;
  }

  result<int> operator()(bool x) override {
    CAF_CHECK_EQUAL(x, true);
    self->delayed_send(self, std::chrono::milliseconds(10), "hello");
    return 0;
  }

  result<void> operator()(param<std::string> x) override {
    CAF_CHECK_EQUAL(x.get(), "hello");
    return unit;
  }
};

struct fixture {
  fixture() : system(cfg) {
    // nop
  }

  actor_system_config cfg;
  actor_system system;
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(composable_behaviors_tests, fixture)

CAF_TEST(composition) {
  // test foo_foo_actor_state
  auto f1 = make_function_view(system.spawn<foo_actor_state>());
  CAF_CHECK_EQUAL(f1(1, 2, 4), 7);
  CAF_CHECK_EQUAL(f1(42.0), std::make_tuple(42.0, 42.0));
  // test on-the-fly composition of i3_actor_state and d_actor_state
  f1.assign(system.spawn<composed_behavior<i3_actor_state, d_actor_state>>());
  CAF_CHECK_EQUAL(f1(1, 2, 4), 7);
  CAF_CHECK_EQUAL(f1(42.0), std::make_tuple(42.0, 42.0));
  // test on-the-fly composition of i3_actor_state2 and d_actor_state
  f1.assign(system.spawn<composed_behavior<i3_actor_state2, d_actor_state>>());
  CAF_CHECK_EQUAL(f1(1, 2, 4), 8);
  CAF_CHECK_EQUAL(f1(42.0), std::make_tuple(42.0, 42.0));
  // test foo_actor_state2
  f1.assign(system.spawn<foo_actor_state2>());
  CAF_CHECK_EQUAL(f1(1, 2, 4), -5);
  CAF_CHECK_EQUAL(f1(42.0), std::make_tuple(42.0, 42.0));
}

CAF_TEST(param_detaching) {
  auto dict = actor_cast<actor>(system.spawn<dict_state>());
  scoped_actor self{system};
  // this ping-pong makes sure that dict has cleaned up all state related
  // to a test before moving to the second test; otherwise, reference counts
  // can diverge from what we expect
  auto ping_pong = [&] {
    self->request(dict, infinite, ping_atom::value).receive(
      [](pong_atom) {
        // nop
      },
      [&](error& err) {
        CAF_FAIL("error: " << system.render(err));
      }
    );
  };
  // Using CAF is the key to success!
  counting_string key = "CAF";
  counting_string value = "success";
  CAF_CHECK_EQUAL(counting_strings_created.load(), 2);
  CAF_CHECK_EQUAL(counting_strings_moved.load(), 0);
  CAF_CHECK_EQUAL(counting_strings_destroyed.load(), 0);
  // wrap two strings into messages
  auto put_msg = make_message(put_atom::value, key, value);
  auto get_msg = make_message(get_atom::value, key);
  CAF_CHECK_EQUAL(counting_strings_created.load(), 5);
  CAF_CHECK_EQUAL(counting_strings_moved.load(), 0);
  CAF_CHECK_EQUAL(counting_strings_destroyed.load(), 0);
  // send put message to dictionary
  self->request(dict, infinite, put_msg).receive(
    [&] {
      ping_pong();
      // the handler of put_atom calls .move() on key and value,
      // both causing to detach + move into the map
      CAF_CHECK_EQUAL(counting_strings_created.load(), 9);
      CAF_CHECK_EQUAL(counting_strings_moved.load(), 2);
      CAF_CHECK_EQUAL(counting_strings_destroyed.load(), 2);
    },
    ERROR_HANDLER
  );
  // send put message to dictionary again
  self->request(dict, infinite, put_msg).receive(
    [&] {
      ping_pong();
      // the handler checks whether key already exists -> no copies
      CAF_CHECK_EQUAL(counting_strings_created.load(), 9);
      CAF_CHECK_EQUAL(counting_strings_moved.load(), 2);
      CAF_CHECK_EQUAL(counting_strings_destroyed.load(), 2);
    },
    ERROR_HANDLER
  );
  // alter our initial put, this time moving it to the dictionary
  put_msg.get_mutable_as<counting_string>(1) = "neverlord";
  put_msg.get_mutable_as<counting_string>(2) = "CAF";
  // send put message to dictionary
  self->request(dict, infinite, std::move(put_msg)).receive(
    [&] {
      ping_pong();
      // the handler of put_atom calls .move() on key and value,
      // but no detaching occurs this time (unique access) -> move into the map
      CAF_CHECK_EQUAL(counting_strings_created.load(), 11);
      CAF_CHECK_EQUAL(counting_strings_moved.load(), 4);
      CAF_CHECK_EQUAL(counting_strings_destroyed.load(), 4);
    },
    ERROR_HANDLER
  );
  // finally, check for original key
  self->request(dict, infinite, std::move(get_msg)).receive(
    [&](const counting_string& str) {
      ping_pong();
      // we receive a copy of the value, which is copied out of the map and
      // then moved into the result message;
      // the string from our get_msg is destroyed
      CAF_CHECK_EQUAL(counting_strings_created.load(), 13);
      CAF_CHECK_EQUAL(counting_strings_moved.load(), 5);
      CAF_CHECK_EQUAL(counting_strings_destroyed.load(), 6);
      CAF_CHECK_EQUAL(str, "success");
    },
    ERROR_HANDLER
  );
  // temporary of our handler is destroyed
  CAF_CHECK_EQUAL(counting_strings_destroyed.load(), 7);
  self->send_exit(dict, exit_reason::kill);
  self->await_all_other_actors_done();
  // only `key` and `value` from this scope remain
  CAF_CHECK_EQUAL(counting_strings_destroyed.load(), 11);
}

CAF_TEST(delayed_sends) {
  scoped_actor self{system};
  auto testee = self->spawn<delayed_testee>();
  self->send(testee, 42);
}

CAF_TEST_FIXTURE_SCOPE_END()

CAF_TEST(dynamic_spawning) {
  using impl = composable_behavior_based_actor<foo_actor_state>;
  actor_system_config cfg;
  cfg.add_actor_type<impl>("foo_actor");
  actor_system sys{cfg};
  auto sr = sys.spawn<foo_actor>("foo_actor", make_message());
  CAF_REQUIRE(sr);
  auto f1 = make_function_view(std::move(*sr));
  CAF_CHECK_EQUAL(f1(1, 2, 4), 7);
  CAF_CHECK_EQUAL(f1(42.0), std::make_tuple(42.0, 42.0));
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE message_lifetime
#include "caf/test/unit_test.hpp"

#include <atomic>
#include <iostream>

#include "caf/all.hpp"

using namespace caf;

namespace {

class testee : public event_based_actor {
public:
  testee(actor_config& cfg) : event_based_actor(cfg) {
    // nop
  }

  ~testee() override {
    // nop
  }

  behavior make_behavior() override {
    // reflecting a message increases its reference count by one
    set_default_handler(reflect_and_quit);
    return {
      [] {
        // nop
      }
    };
  }
};

class tester : public event_based_actor {
public:
  tester(actor_config& cfg, actor aut)
      : event_based_actor(cfg),
        aut_(std::move(aut)),
        msg_(make_message(1, 2, 3)) {
    set_down_handler([=](down_msg& dm) {
      CAF_CHECK_EQUAL(dm.reason, exit_reason::normal);
      CAF_CHECK_EQUAL(dm.source, aut_.address());
      quit();
    });
  }

  behavior make_behavior() override {
    monitor(aut_);
    send(aut_, msg_);
    return {
      [=](int a, int b, int c) {
        CAF_CHECK_EQUAL(a, 1);
        CAF_CHECK_EQUAL(b, 2);
        CAF_CHECK_EQUAL(c, 3);
      }
    };
  }

private:
  actor aut_;
  message msg_;
};

struct fixture {
  fixture() : system(cfg) {
    // nop
  }

  template <spawn_options Os>
  void test_message_lifetime() {
    // put some preassure on the scheduler (check for thread safety)
    for (size_t i = 0; i < 100; ++i)
      system.spawn<tester>(system.spawn<testee, Os>());
  }

  actor_system_config cfg;
  actor_system system;
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(message_lifetime_tests, fixture)

CAF_TEST(message_lifetime_in_scoped_actor) {
  auto msg = make_message(1, 2, 3);
  scoped_actor self{system};
  self->send(self, msg);
  self->receive(
    [&](int a, int b, int c) {
      CAF_CHECK_EQUAL(a, 1);
      CAF_CHECK_EQUAL(b, 2);
      CAF_CHECK_EQUAL(c, 3);
      CAF_CHECK_EQUAL(msg.cvals()->get_reference_count(), 2u);
    }
  );
  CAF_CHECK_EQUAL(msg.cvals()->get_reference_count(), 1u);
  msg = make_message(42);
  self->send(self, msg);
  CAF_CHECK_EQUAL(msg.cvals()->get_reference_count(), 2u);
  self->receive(
    [&](int& value) {
      CAF_CHECK_NOT_EQUAL(&value, msg.at(0));
      value = 10;
    }
  );
  CAF_CHECK_EQUAL(msg.get_as<int>(0), 42);
}

CAF_TEST(message_lifetime_no_spawn_options) {
  test_message_lifetime<no_spawn_options>();
}

CAF_TEST(message_lifetime_priority_aware) {
  test_message_lifetime<priority_aware>();
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE sequencer
#include "caf/test/unit_test.hpp"

#include "caf/all.hpp"

#define ERROR_HANDLER                                                          \
  [&](error& err) { CAF_FAIL(system.render(err)); }

using namespace caf;

namespace {

behavior testee(event_based_actor* self) {
  return {
    [](int v) {
      return 2 * v;
    },
    [=] {
      self->quit();
    }
  };
}

using first_stage = typed_actor<replies_to<int>::with<double, double>>;
using second_stage = typed_actor<replies_to<double, double>::with<double>>;

first_stage::behavior_type typed_first_stage() {
  return [](int i) {
    return std::make_tuple(i * 2.0, i * 4.0);
  };
}

second_stage::behavior_type typed_second_stage() {
  return [](double x, double y) {
    return x * y;
  };
}

struct fixture {
  fixture() : system(cfg), self(system, true) {
    // nop
  }

  template <class Actor>
  static bool exited(const Actor& handle) {
    auto ptr = actor_cast<abstract_actor*>(handle);
    auto dptr = dynamic_cast<monitorable_actor*>(ptr);
    CAF_REQUIRE(dptr != nullptr);
    return dptr->getf(abstract_actor::is_terminated_flag);
  }

  actor_system_config cfg;
  actor_system system;
  scoped_actor self;
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(sequencer_tests, fixture)

CAF_TEST(identity) {
  actor_system_config cfg_g;
  actor_system system_of_g{cfg_g};
  actor_system_config cfg_f;
  actor_system system_of_f{cfg_f};
  auto g = system_of_g.spawn(typed_first_stage);
  auto f = system_of_f.spawn(typed_second_stage);
  CAF_CHECK_EQUAL(system_of_g.registry().running(), 1u);
  auto h = f * g;
  CAF_CHECK_EQUAL(system_of_g.registry().running(), 1u);
  CAF_CHECK_EQUAL(&h->home_system(), &g->home_system());
  CAF_CHECK_EQUAL(h->node(), g->node());
  CAF_CHECK_NOT_EQUAL(h->id(), g->id());
  CAF_CHECK_NOT_EQUAL(h.address(), g.address());
  CAF_CHECK_EQUAL(h->message_types(), g->home_system().message_types(h));
}

// spawned dead if `g` is already dead upon spawning
CAF_TEST(lifetime_1a) {
  auto g = system.spawn(testee);
  auto f = system.spawn(testee);
  anon_send_exit(g, exit_reason::kill);
  self->wait_for(g);
  auto h = f * g;
  CAF_CHECK(exited(h));
}

// spawned dead if `f` is already dead upon spawning
CAF_TEST(lifetime_1b) {
  auto g = system.spawn(testee);
  auto f = system.spawn(testee);
  anon_send_exit(f, exit_reason::kill);
  self->wait_for(f);
  auto h = f * g;
  CAF_CHECK(exited(h));
}

// `f.g` exits when `g` exits
CAF_TEST(lifetime_2a) {
  auto g = system.spawn(testee);
  auto f = system.spawn(testee);
  auto h = f * g;
  self->monitor(h);
  anon_send(g, message{});
}

// `f.g` exits when `f` exits
CAF_TEST(lifetime_2b) {
  auto g = system.spawn(testee);
  auto f = system.spawn(testee);
  auto h = f * g;
  self->monitor(h);
  anon_send(f, message{});
}

CAF_TEST(request_response_promise) {
  auto g = system.spawn(testee);
  auto f = system.spawn(testee);
  auto h = f * g;
  anon_send_exit(h, exit_reason::kill);
  CAF_CHECK(exited(h));
  self->request(h, infinite, 1).receive(
    [](int) {
      CAF_CHECK(false);
    },
    [](error err) {
      CAF_CHECK_EQUAL(err.code(), static_cast<uint8_t>(sec::request_receiver_down));
    }
  );
}

// single composition of distinct actors
CAF_TEST(dot_composition_1) {
  auto first = system.spawn(typed_first_stage);
  auto second = system.spawn(typed_second_stage);
  auto first_then_second = second * first;
  self->request(first_then_second, infinite, 42).receive(
    [](double res) {
      CAF_CHECK_EQUAL(res, (42 * 2.0) * (42 * 4.0));
    },
    ERROR_HANDLER
  );
}

// multiple self composition
CAF_TEST(dot_composition_2) {
  auto dbl_actor = system.spawn(testee);
  auto dbl_x4_actor = dbl_actor * dbl_actor
                      * dbl_actor * dbl_actor;
  self->request(dbl_x4_actor, infinite, 1).receive(
    [](int v) {
      CAF_CHECK_EQUAL(v, 16);
    },
    ERROR_HANDLER
  );
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE simple_timeout
#include "caf/test/unit_test.hpp"

#include <chrono>
#include <memory>

#include "caf/all.hpp"

using namespace caf;

namespace {

using ms = std::chrono::milliseconds;

using reset_atom = atom_constant<atom("reset")>;
using timer = typed_actor<reacts_to<reset_atom>>;

struct timer_state {
  bool had_reset = false;
};

timer::behavior_type timer_impl(timer::stateful_pointer<timer_state> self) {
  self->delayed_send(self, ms(100), reset_atom::value);
  return {
    [=](reset_atom) {
      CAF_MESSAGE("timer reset");
      self->state.had_reset = true;
    },
    after(ms(600)) >> [=] {
      CAF_MESSAGE("timer expired");
      CAF_REQUIRE(self->state.had_reset);
      self->quit();
    }
  };
}

timer::behavior_type timer_impl2(timer::pointer self) {
  auto had_reset = std::make_shared<bool>(false);
  self->delayed_anon_send(self, ms(100), reset_atom::value);
  return {
    [=](reset_atom) {
      CAF_MESSAGE("timer reset");
      *had_reset = true;
    },
    after(ms(600)) >> [=] {
      CAF_MESSAGE("timer expired");
      CAF_REQUIRE(*had_reset);
      self->quit();
    }
  };
}

struct config : actor_system_config {
  config() {
    scheduler_policy = atom("testing");
  }
};

struct fixture {
  config cfg;
  actor_system system;
  scoped_actor self;
  scheduler::test_coordinator& sched;

  fixture()
      : system(cfg),
        self(system),
        sched(dynamic_cast<scheduler::test_coordinator&>(system.scheduler())) {
    CAF_REQUIRE(sched.jobs.empty());
  }

  ~fixture() {
    sched.run_dispatch_loop();
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(simple_timeout_tests, fixture)

CAF_TEST(duration_conversion) {
  duration d1{time_unit::milliseconds, 100};
  std::chrono::milliseconds d2{100};
  duration d3{d2};
  CAF_CHECK_EQUAL(d1.count, static_cast<uint64_t>(d2.count()));
  CAF_CHECK_EQUAL(d1, d3);
}

CAF_TEST(single_timeout) {
  system.spawn(timer_impl);
}

CAF_TEST(single_anon_timeout) {
  system.spawn(timer_impl2);
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE serialization
#include "caf/test/unit_test.hpp"

#include <new>
#include <set>
#include <list>
#include <stack>
#include <tuple>
#include <locale>
#include <memory>
#include <string>
#include <limits>
#include <vector>
#include <cstring>
#include <sstream>
#include <cstdint>
#include <cstring>
#include <cassert>
#include <iterator>
#include <typeinfo>
#include <iostream>
#include <stdexcept>
#include <algorithm>
#include <functional>
#include <type_traits>

#include "caf/message.hpp"
#include "caf/streambuf.hpp"
#include "caf/serializer.hpp"
#include "caf/ref_counted.hpp"
#include "caf/deserializer.hpp"
#include "caf/actor_system.hpp"
#include "caf/proxy_registry.hpp"
#include "caf/message_handler.hpp"
#include "caf/event_based_actor.hpp"
#include "caf/primitive_variant.hpp"
#include "caf/binary_serializer.hpp"
#include "caf/binary_deserializer.hpp"
#include "caf/actor_system_config.hpp"
#include "caf/make_type_erased_view.hpp"
#include "caf/make_type_erased_tuple_view.hpp"

#include "caf/detail/ieee_754.hpp"
#include "caf/detail/int_list.hpp"
#include "caf/detail/safe_equal.hpp"
#include "caf/detail/type_traits.hpp"
#include "caf/detail/enum_to_string.hpp"
#include "caf/detail/get_mac_addresses.hpp"

using namespace std;
using namespace caf;
using caf::detail::type_erased_value_impl;

namespace {

using strmap = map<string, u16string>;

struct raw_struct {
  string str;
};

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, raw_struct& x) {
  return f(x.str);
}

bool operator==(const raw_struct& lhs, const raw_struct& rhs) {
  return lhs.str == rhs.str;
}

enum class test_enum : uint32_t {
  a,
  b,
  c
};

const char* test_enum_strings[] = { "a", "b", "c" };

std::string to_string(test_enum x) {
  return detail::enum_to_string(x, test_enum_strings);
}

struct test_array {
  int value[4];
  int value2[2][4];
};

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, test_array& x) {
  return f(x.value, x.value2);
}

struct test_empty_non_pod {
  test_empty_non_pod() = default;
  test_empty_non_pod(const test_empty_non_pod&) = default;
  test_empty_non_pod& operator=(const test_empty_non_pod&) = default;
  virtual void foo() {
    // nop
  }
  virtual ~test_empty_non_pod() {
    // nop
  }
};

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, test_empty_non_pod&) {
  return f();
}

class config : public actor_system_config {
public:
  config() {
    add_message_type<test_enum>("test_enum");
    add_message_type<raw_struct>("raw_struct");
    add_message_type<test_array>("test_array");
    add_message_type<test_empty_non_pod>("test_empty_non_pod");
    add_message_type<std::vector<bool>>("bool_vector");
  }
};

struct fixture {
  int32_t i32 = -345;
  int64_t i64 = -1234567890123456789ll;
  float f32 = 3.45f;
  double f64 = 54.3;
  duration dur = duration{time_unit::seconds, 123};
  timestamp ts = timestamp{timestamp::duration{1478715821 * 1000000000ll}};
  test_enum te = test_enum::b;
  string str = "Lorem ipsum dolor sit amet.";
  raw_struct rs;
  test_array ta {
    {0, 1, 2, 3},
    {
      {0, 1, 2, 3},
      {4, 5, 6, 7}
    },
  };
  int ra[3] = {1, 2, 3};

  config cfg;
  actor_system system;
  scoped_execution_unit context;
  message msg;

  template <class T, class... Ts>
  vector<char> serialize(T& x, Ts&... xs) {
    vector<char> buf;
    binary_serializer bs{&context, buf};
    bs(x, xs...);
    return buf;
  }

  template <class T, class... Ts>
  void deserialize(const vector<char>& buf, T& x, Ts&... xs) {
    binary_deserializer bd{&context, buf};
    bd(x, xs...);
  }

  // serializes `x` and then deserializes and returns the serialized value
  template <class T>
  T roundtrip(T x) {
    T result;
    deserialize(serialize(x), result);
    return result;
  }

  // converts `x` to a message, serialize it, then deserializes it, and
  // finally returns unboxed value
  template <class T>
  T msg_roundtrip(const T& x) {
    message result;
    auto tmp = make_message(x);
    deserialize(serialize(tmp), result);
    CAF_REQUIRE(result.match_elements<T>());
    return result.get_as<T>(0);
  }

  fixture()
      : system(cfg),
        context(&system) {
    rs.str.assign(string(str.rbegin(), str.rend()));
    msg = make_message(i32, i64, dur, ts, te, str, rs);
  }
};

struct is_message {
  explicit is_message(message& msgref) : msg(msgref) {
    // nop
  }

  message& msg;

  template <class T, class... Ts>
  bool equal(T&& v, Ts&&... vs) {
    bool ok = false;
    // work around for gcc 4.8.4 bug
    auto tup = tie(v, vs...);
    message_handler impl {
      [&](T const& u, Ts const&... us) {
        ok = tup == tie(u, us...);
      }
    };
    impl(msg);
    return ok;
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(serialization_tests, fixture)

CAF_TEST(ieee_754_conversion) {
  // check conversion of float
  float f1 = 3.1415925f;         // float value
  auto p1 = caf::detail::pack754(f1); // packet value
  CAF_CHECK_EQUAL(p1, static_cast<decltype(p1)>(0x40490FDA));
  auto u1 = caf::detail::unpack754(p1); // unpacked value
  CAF_CHECK_EQUAL(f1, u1);
  // check conversion of double
  double f2 = 3.14159265358979311600;  // double value
  auto p2 = caf::detail::pack754(f2); // packet value
  CAF_CHECK_EQUAL(p2, static_cast<decltype(p2)>(0x400921FB54442D18));
  auto u2 = caf::detail::unpack754(p2); // unpacked value
  CAF_CHECK_EQUAL(f2, u2);
}

CAF_TEST(i32_values) {
  auto buf = serialize(i32);
  int32_t x;
  deserialize(buf, x);
  CAF_CHECK_EQUAL(i32, x);
}

CAF_TEST(i64_values) {
  auto buf = serialize(i64);
  int64_t x;
  deserialize(buf, x);
  CAF_CHECK_EQUAL(i64, x);
}

CAF_TEST(float_values) {
  auto buf = serialize(f32);
  float x;
  deserialize(buf, x);
  CAF_CHECK_EQUAL(f32, x);
}

CAF_TEST(double_values) {
  auto buf = serialize(f64);
  double x;
  deserialize(buf, x);
  CAF_CHECK_EQUAL(f64, x);
}

CAF_TEST(duration_values) {
  auto buf = serialize(dur);
  duration x;
  deserialize(buf, x);
  CAF_CHECK_EQUAL(dur, x);
}

CAF_TEST(timestamp_values) {
  auto buf = serialize(ts);
  timestamp x;
  deserialize(buf, x);
  CAF_CHECK_EQUAL(ts, x);
}

CAF_TEST(enum_classes) {
  auto buf = serialize(te);
  test_enum x;
  deserialize(buf, x);
  CAF_CHECK_EQUAL(te, x);
}

CAF_TEST(strings) {
  auto buf = serialize(str);
  string x;
  deserialize(buf, x);
  CAF_CHECK_EQUAL(str, x);
}

CAF_TEST(custom_struct) {
  auto buf = serialize(rs);
  raw_struct x;
  deserialize(buf, x);
  CAF_CHECK_EQUAL(rs, x);
}

CAF_TEST(atoms) {
  auto foo = atom("foo");
  CAF_CHECK_EQUAL(foo, roundtrip(foo));
  CAF_CHECK_EQUAL(foo, msg_roundtrip(foo));
  using bar_atom = atom_constant<atom("bar")>;
  CAF_CHECK_EQUAL(bar_atom::value, roundtrip(atom("bar")));
  CAF_CHECK_EQUAL(bar_atom::value, msg_roundtrip(atom("bar")));
}

CAF_TEST(raw_arrays) {
  auto buf = serialize(ra);
  int x[3];
  deserialize(buf, x);
  for (auto i = 0; i < 3; ++i)
    CAF_CHECK_EQUAL(ra[i], x[i]);
}

CAF_TEST(arrays) {
  auto buf = serialize(ta);
  test_array x;
  deserialize(buf, x);
  for (auto i = 0; i < 4; ++i)
    CAF_CHECK_EQUAL(ta.value[i], x.value[i]);
  for (auto i = 0; i < 2; ++i)
    for (auto j = 0; j < 4; ++j)
      CAF_CHECK_EQUAL(ta.value2[i][j], x.value2[i][j]);
}

CAF_TEST(empty_non_pods) {
  test_empty_non_pod x;
  auto buf = serialize(x);
  CAF_REQUIRE(buf.empty());
  deserialize(buf, x);
}

std::string hexstr(const std::vector<char>& buf) {
  using namespace std;
  ostringstream oss;
  oss << hex;
  oss.fill('0');
  for (auto& c : buf) {
    oss.width(2);
    oss << int{c};
  }
  return oss.str();
}

CAF_TEST(messages) {
  // serialize original message which uses tuple_vals internally and
  // deserialize into a message which uses type_erased_value pointers
  message x;
  auto buf1 = serialize(msg);
  deserialize(buf1, x);
  CAF_CHECK_EQUAL(to_string(msg), to_string(x));
  CAF_CHECK(is_message(x).equal(i32, i64, dur, ts, te, str, rs));
  // serialize fully dynamic message again (do another roundtrip)
  message y;
  auto buf2 = serialize(x);
  CAF_CHECK_EQUAL(buf1, buf2);
  deserialize(buf2, y);
  CAF_CHECK_EQUAL(to_string(msg), to_string(y));
  CAF_CHECK(is_message(y).equal(i32, i64, dur, ts, te, str, rs));
}

CAF_TEST(multiple_messages) {
  auto m = make_message(rs, te);
  auto buf = serialize(te, m, msg);
  test_enum t;
  message m1;
  message m2;
  deserialize(buf, t, m1, m2);
  CAF_CHECK_EQUAL(std::make_tuple(t, to_string(m1), to_string(m2)),
                  std::make_tuple(te, to_string(m), to_string(msg)));
  CAF_CHECK(is_message(m1).equal(rs, te));
  CAF_CHECK(is_message(m2).equal(i32, i64, dur, ts, te, str, rs));
}


CAF_TEST(type_erased_value) {
  auto buf = serialize(str);
  type_erased_value_ptr ptr{new type_erased_value_impl<std::string>};
  binary_deserializer bd{&context, buf.data(), buf.size()};
  ptr->load(bd);
  CAF_CHECK_EQUAL(str, *reinterpret_cast<const std::string*>(ptr->get()));
}

CAF_TEST(type_erased_view) {
  auto str_view = make_type_erased_view(str);
  auto buf = serialize(str_view);
  std::string res;
  deserialize(buf, res);
  CAF_CHECK_EQUAL(str, res);
}

CAF_TEST(type_erased_tuple) {
  auto tview = make_type_erased_tuple_view(str, i32);
  CAF_CHECK_EQUAL(to_string(tview), deep_to_string(std::make_tuple(str, i32)));
  auto buf = serialize(tview);
  CAF_REQUIRE(!buf.empty());
  std::string tmp1;
  int32_t tmp2;
  deserialize(buf, tmp1, tmp2);
  CAF_CHECK_EQUAL(tmp1, str);
  CAF_CHECK_EQUAL(tmp2, i32);
  deserialize(buf, tview);
  CAF_CHECK_EQUAL(to_string(tview), deep_to_string(std::make_tuple(str, i32)));
}

CAF_TEST(streambuf_serialization) {
  auto data = std::string{"The quick brown fox jumps over the lazy dog"};
  std::vector<char> buf;
  // First, we check the standard use case in CAF where stream serializers own
  // their stream buffers.
  stream_serializer<vectorbuf> bs{vectorbuf{buf}};
  auto e = bs(data);
  CAF_REQUIRE_EQUAL(e, none);
  stream_deserializer<charbuf> bd{charbuf{buf}};
  std::string target;
  e = bd(target);
  CAF_REQUIRE_EQUAL(e, none);
  CAF_CHECK_EQUAL(data, target);
  // Second, we test another use case where the serializers only keep
  // references of the stream buffers.
  buf.clear();
  target.clear();
  vectorbuf vb{buf};
  stream_serializer<vectorbuf&> vs{vb};
  e = vs(data);
  CAF_REQUIRE_EQUAL(e, none);
  charbuf cb{buf};
  stream_deserializer<charbuf&> vd{cb};
  e = vd(target);
  CAF_REQUIRE_EQUAL(e, none);
  CAF_CHECK(data == target);
}

CAF_TEST(byte_sequence_optimization) {
  std::vector<uint8_t> data(42);
  std::fill(data.begin(), data.end(), 0x2a);
  std::vector<uint8_t> buf;
  using streambuf_type = containerbuf<std::vector<uint8_t>>;
  streambuf_type cb{buf};
  stream_serializer<streambuf_type&> bs{cb};
  auto e = bs(data);
  CAF_REQUIRE(!e);
  data.clear();
  streambuf_type cb2{buf};
  stream_deserializer<streambuf_type&> bd{cb2};
  e = bd(data);
  CAF_REQUIRE(!e);
  CAF_CHECK_EQUAL(data.size(), 42u);
  CAF_CHECK(std::all_of(data.begin(), data.end(),
                        [](uint8_t c) { return c == 0x2a; }));
}

CAF_TEST(long_sequences) {
  std::vector<char> data;
  binary_serializer sink{nullptr, data};
  size_t n = 12345678900u;
  sink.begin_sequence(n);
  sink.end_sequence();
  binary_deserializer source{nullptr, data};
  size_t m = 0;
  source.begin_sequence(m);
  source.end_sequence();
  CAF_CHECK_EQUAL(n, m);
}

// -- our vector<bool> serialization packs into an uint64_t. Hence, the
// critical sizes to test are 0, 1, 63, 64, and 65.

CAF_TEST(bool_vector_size_0) {
  std::vector<bool> xs;
  CAF_CHECK_EQUAL(deep_to_string(xs), "[]");
  CAF_CHECK_EQUAL(xs, roundtrip(xs));
  CAF_CHECK_EQUAL(xs, msg_roundtrip(xs));
}

CAF_TEST(bool_vector_size_1) {
  std::vector<bool> xs{true};
  CAF_CHECK_EQUAL(deep_to_string(xs), "[1]");
  CAF_CHECK_EQUAL(xs, roundtrip(xs));
  CAF_CHECK_EQUAL(xs, msg_roundtrip(xs));
}

CAF_TEST(bool_vector_size_63) {
  std::vector<bool> xs;
  for (int i = 0; i < 63; ++i)
    xs.push_back(i % 3 == 0);
  CAF_CHECK_EQUAL(deep_to_string(xs),
                  "[1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, "
                  "0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, "
                  "1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, "
                  "0, 1, 0, 0]");
  CAF_CHECK_EQUAL(xs, roundtrip(xs));
  CAF_CHECK_EQUAL(xs, msg_roundtrip(xs));
}

CAF_TEST(bool_vector_size_64) {
  std::vector<bool> xs;
  for (int i = 0; i < 64; ++i)
    xs.push_back(i % 5 == 0);
  CAF_CHECK_EQUAL(deep_to_string(xs),
                  "[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, "
                  "0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, "
                  "0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, "
                  "0, 1, 0, 0, 0]");
  CAF_CHECK_EQUAL(xs, roundtrip(xs));
  CAF_CHECK_EQUAL(xs, msg_roundtrip(xs));
}

CAF_TEST(bool_vector_size_65) {
  std::vector<bool> xs;
  for (int i = 0; i < 65; ++i)
    xs.push_back(!(i % 7 == 0));
  CAF_CHECK_EQUAL(deep_to_string(xs),
                  "[0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, "
                  "1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, "
                  "1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, "
                  "1, 1, 1, 1, 0, 1]");
  CAF_CHECK_EQUAL(xs, roundtrip(xs));
  CAF_CHECK_EQUAL(xs, msg_roundtrip(xs));
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE blocking_actor
#include "caf/test/unit_test.hpp"

#include "caf/all.hpp"

using namespace caf;

namespace {

struct fixture {
  actor_system_config cfg;
  actor_system system;
  scoped_actor self;

  fixture() : system(cfg), self(system) {
    // nop
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(blocking_actor_tests, fixture)

CAF_TEST(catch_all) {
  self->send(self, 42);
  self->receive(
    [](float) {
      CAF_FAIL("received unexpected float");
    },
    others >> [](message_view& x) -> result<message> {
      CAF_CHECK_EQUAL(to_string(x.content()), "(42)");
      return sec::unexpected_message;
    }
  );
  self->receive(
    [](const error& err) {
      CAF_CHECK_EQUAL(err, sec::unexpected_message);
    }
  );
}

CAF_TEST(behavior_ref) {
  behavior bhvr{
    [](int i) {
      CAF_CHECK_EQUAL(i, 42);
    }
  };
  self->send(self, 42);
  self->receive(bhvr);
}

CAF_TEST(timeout_in_scoped_actor) {
  bool timeout_called = false;
  scoped_actor self{system};
  self->receive(
    after(std::chrono::milliseconds(20)) >> [&] {
      timeout_called = true;
    }
  );
  CAF_CHECK(timeout_called);
}

// -- scoped_actors using skip -------------------------------------------------

using msg_t = int; 
// send_order_t contains messages which are send to an actor in the same order
// as in vector
using send_order_t = std::vector<msg_t>;
// sequence_t contains a number of messages for processing by an actor with
// the information to skip the current message for later processing
using sequence_t = std::vector<std::pair<msg_t, bool>>;
using check_order_t = std::pair<send_order_t, sequence_t>;

behavior check_order_behavior_factory(local_actor* self,
                                      sequence_t::const_iterator* seq_it_ptr) {
  return {
    [=](int i) -> result<void> {
      auto& seq_it = *seq_it_ptr;
      CAF_CHECK_EQUAL(i, seq_it->first);
      if (seq_it->second) {
        CAF_MESSAGE("current: " << i << "; awaiting: " << seq_it->first
                                << "; inbox size: " << self->mailbox().count()
                                << " SKIPPED");
        ++seq_it;
        return skip(); 
      } else {
        CAF_MESSAGE("current: " << i << "; awaiting: " << seq_it->first
                                << "; inbox size: " << self->mailbox().count()
                                << " OK");
        ++seq_it;
        return unit; 
      }
    }
  };
}

void check_order_event_based_actor(const check_order_t& corder) {
  actor_system_config cfg;
  actor_system system{cfg};
  auto& send_order = corder.first;
  auto& sequence = corder.second;
  auto seq_it = sequence.cbegin();
  {
    auto tmp = system.spawn(
      [&](event_based_actor* self) {
        self->set_default_handler(skip);
        for(auto i : send_order) {
          self->send(self, i);
        }
        self->become(
          check_order_behavior_factory(self, &seq_it));
      }
    );

  }
  system.await_all_actors_done();
}

void check_order_scoped_actor(const check_order_t& corder) {
  actor_system_config cfg;
  actor_system system{cfg};
  auto& send_order = corder.first;
  auto& sequence = corder.second;
  auto seq_it = begin(sequence);
  scoped_actor self{system};
  auto check_order_behavior =
    check_order_behavior_factory(actor_cast<local_actor*>(self), &seq_it);
  for(auto i : send_order) {
    self->send(self, i);
  }
  while (seq_it != end(sequence)) {
    self->receive(check_order_behavior);
  }
}

CAF_TEST(skip_message) {
  check_order_t a = {
    {0, 1, 2, 3}, //recv_order = 0,1,2,3
    {{0, false}, {1, false}, {2, false}, {3, false}}
  };
  check_order_t b = {
    {3, 2, 1, 0}, //recv_order = 0,1,2,3
    {{3, true}, {2, true}, {1, true}, {0, false},
    {3, true}, {2, true}, {1, false},
    {3, true}, {2, false},
    {3, false}}    
  };
  check_order_t c = {
    {1, 0, 2}, //recv_order = 0,1,2
    {{1, true}, {0, false}, 
    {1, false}, 
    {2, false}}    
  };
  check_order_t d = {
    {3, 1, 2, 0}, //recv_order = 0,1,2,3
    {{3, true}, {1, true}, {2, true}, {0, false},
    {3, true}, {1, false},
    {3, true}, {2, false},
    {3, false}}
  };
  check_order_event_based_actor(a);
  check_order_event_based_actor(b);
  check_order_event_based_actor(c);
  check_order_event_based_actor(d);
  check_order_scoped_actor(a);
  check_order_scoped_actor(b);
  check_order_scoped_actor(c);
  check_order_scoped_actor(d);
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE dynamic_spawn
#include "caf/test/unit_test.hpp"

#include <stack>
#include <atomic>
#include <chrono>
#include <iostream>
#include <functional>

#include "caf/all.hpp"

using namespace std;
using namespace caf;

namespace {

std::atomic<long> s_max_actor_instances;
std::atomic<long> s_actor_instances;

using a_atom = atom_constant<atom("a")>;
using b_atom = atom_constant<atom("b")>;
using c_atom = atom_constant<atom("c")>;
using abc_atom = atom_constant<atom("abc")>;
using name_atom = atom_constant<atom("name")>;

void inc_actor_instances() {
  long v1 = ++s_actor_instances;
  long v2 = s_max_actor_instances.load();
  while (v1 > v2) {
    s_max_actor_instances.compare_exchange_strong(v2, v1);
  }
}

void dec_actor_instances() {
  --s_actor_instances;
}

class event_testee : public event_based_actor {
public:
  event_testee(actor_config& cfg) : event_based_actor(cfg) {
    inc_actor_instances();
    wait4string.assign(
      [=](const std::string&) {
        become(wait4int);
      },
      [=](get_atom) {
        return "wait4string";
      }
    );
    wait4float.assign(
      [=](float) {
        become(wait4string);
      },
      [=](get_atom) {
        return "wait4float";
      }
    );
    wait4int.assign(
      [=](int) {
        become(wait4float);
      },
      [=](get_atom) {
        return "wait4int";
      }
    );
  }

  ~event_testee() override {
    dec_actor_instances();
  }

  behavior make_behavior() override {
    return wait4int;
  }

  behavior wait4string;
  behavior wait4float;
  behavior wait4int;
};

// quits after 5 timeouts
actor spawn_event_testee2(scoped_actor& parent) {
  struct impl : event_based_actor {
    actor parent;
    impl(actor_config& cfg, actor parent_actor)
        : event_based_actor(cfg),
          parent(std::move(parent_actor)) {
      inc_actor_instances();
    }
    ~impl() override {
      dec_actor_instances();
    }
    behavior wait4timeout(int remaining) {
      return {
        after(chrono::milliseconds(1)) >> [=] {
          CAF_MESSAGE("remaining: " << to_string(remaining));
          if (remaining == 1) {
            send(parent, ok_atom::value);
            quit();
          }
          else become(wait4timeout(remaining - 1));
        }
      };
    }
    behavior make_behavior() override {
      return wait4timeout(5);
    }
  };
  return parent->spawn<impl>(parent);
}

class testee_actor : public blocking_actor {
public:
  testee_actor(actor_config& cfg) : blocking_actor(cfg) {
    inc_actor_instances();
  }

  ~testee_actor() override {
    dec_actor_instances();
  }

  void act() override {
    bool running = true;
    receive_while(running) (
      [&](int) {
        wait4float();
      },
      [&](get_atom) {
        return "wait4int";
      },
      [&](exit_msg& em) {
        if (em.reason) {
          fail_state(std::move(em.reason));
          running = false;
        }
      }
    );
  }

private:
  void wait4string() {
    bool string_received = false;
    do_receive (
      [&](const string&) {
        string_received = true;
      },
      [&](get_atom) {
        return "wait4string";
      }
    )
    .until([&] { return string_received; });
  }

  void wait4float() {
    bool float_received = false;
    do_receive (
      [&](float) {
        float_received = true;
      },
      [&](get_atom) {
        return "wait4float";
      }
    )
    .until([&] { return float_received; });
    wait4string();
  }
};

// self->receives one timeout and quits
class testee1 : public event_based_actor {
public:
  testee1(actor_config& cfg) : event_based_actor(cfg) {
    inc_actor_instances();
  }

  ~testee1() override {
    dec_actor_instances();
  }

  behavior make_behavior() override {
    return {
      after(chrono::milliseconds(10)) >> [=] {
        unbecome();
      }
    };
  }
};

class echo_actor : public event_based_actor {
public:
  echo_actor(actor_config& cfg) : event_based_actor(cfg) {
    inc_actor_instances();
  }

  ~echo_actor() override {
    dec_actor_instances();
  }

  behavior make_behavior() override {
    set_default_handler(reflect);
    return {
      [] {
        // nop
      }
    };
  }
};

class simple_mirror : public event_based_actor {
public:
  simple_mirror(actor_config& cfg) : event_based_actor(cfg) {
    inc_actor_instances();
  }

  ~simple_mirror() override {
    dec_actor_instances();
  }

  behavior make_behavior() override {
    set_default_handler(reflect);
    return {
      [] {
        // nop
      }
    };
  }
};

behavior high_priority_testee(event_based_actor* self) {
  self->send(self, b_atom::value);
  self->send<message_priority::high>(self, a_atom::value);
  // 'a' must be self->received before 'b'
  return {
    [=](b_atom) {
      CAF_ERROR("received 'b' before 'a'");
      self->quit();
    },
    [=](a_atom) {
      CAF_MESSAGE("received \"a\" atom");
      self->become (
        [=](b_atom) {
          CAF_MESSAGE("received \"b\" atom, about to quit");
          self->quit();
        }
      );
    }
  };
}

behavior master(event_based_actor* self) {
  return (
    [=](ok_atom) {
      CAF_MESSAGE("master: received done");
      self->quit(exit_reason::user_shutdown);
    }
  );
}

behavior slave(event_based_actor* self, const actor& master) {
  self->link_to(master);
  self->set_exit_handler([=](exit_msg& msg) {
    CAF_MESSAGE("slave: received exit message");
    self->quit(msg.reason);
  });
  return {
    [] {
      // nop
    }
  };
}

class counting_actor : public event_based_actor {
public:
  counting_actor(actor_config& cfg) : event_based_actor(cfg) {
    inc_actor_instances();
  }

  ~counting_actor() override {
    dec_actor_instances();
  }

  behavior make_behavior() override {
    for (int i = 0; i < 100; ++i) {
      send(this, ok_atom::value);
    }
    CAF_CHECK_EQUAL(mailbox().count(), 100u);
    for (int i = 0; i < 100; ++i) {
      send(this, ok_atom::value);
    }
    CAF_CHECK_EQUAL(mailbox().count(), 200u);
    return {};
  }
};

struct fixture {
  actor_system_config cfg;
  // put inside a union to control ctor/dtor timing
  union { actor_system system; };

  fixture() {
    new (&system) actor_system(cfg);
  }

  ~fixture() {
    system.~actor_system();
    // destructor of actor_system must make sure all
    // destructors of all actors have been run
    CAF_CHECK_EQUAL(s_actor_instances.load(), 0);
    CAF_MESSAGE("max. # of actor instances: " << s_max_actor_instances.load());
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(atom_tests, fixture)

CAF_TEST(priorities) {
  system.spawn<priority_aware>(high_priority_testee);
}

CAF_TEST(count_mailbox) {
  system.spawn<counting_actor>();
}

CAF_TEST(detached_actors_and_schedulued_actors) {
  scoped_actor self{system};
  // check whether detached actors and scheduled actors interact w/o errors
  auto m = system.spawn<detached>(master);
  system.spawn(slave, m);
  system.spawn(slave, m);
  self->send(m, ok_atom::value);
}

CAF_TEST(self_receive_with_zero_timeout) {
  scoped_actor self{system};
  self->receive(
    [&] {
      CAF_ERROR("Unexpected message");
    },
    after(chrono::seconds(0)) >> [] { /* mailbox empty */ }
  );
}

CAF_TEST(mirror) {
  scoped_actor self{system};
  auto mirror = self->spawn<simple_mirror>();
  self->send(mirror, "hello mirror");
  self->receive (
    [](const std::string& msg) {
      CAF_CHECK_EQUAL(msg, "hello mirror");
    }
  );
}

CAF_TEST(detached_mirror) {
  scoped_actor self{system};
  auto mirror = self->spawn<simple_mirror, detached>();
  self->send(mirror, "hello mirror");
  self->receive (
    [](const std::string& msg) {
      CAF_CHECK_EQUAL(msg, "hello mirror");
    }
  );
}

CAF_TEST(priority_aware_mirror) {
  scoped_actor self{system};
  auto mirror = self->spawn<simple_mirror, priority_aware>();
  CAF_MESSAGE("spawned mirror");
  self->send(mirror, "hello mirror");
  self->receive (
    [](const std::string& msg) {
      CAF_CHECK_EQUAL(msg, "hello mirror");
    }
  );
}

CAF_TEST(send_to_self) {
  scoped_actor self{system};
  self->send(self, 1, 2, 3, true);
  self->receive(
    [](int a, int b, int c, bool d) {
      CAF_CHECK_EQUAL(a, 1);
      CAF_CHECK_EQUAL(b, 2);
      CAF_CHECK_EQUAL(c, 3);
      CAF_CHECK_EQUAL(d, true);
    }
  );
  self->send(self, message{});
  self->receive([] {});
}

CAF_TEST(echo_actor_messaging) {
  scoped_actor self{system};
  auto mecho = system.spawn<echo_actor>();
  self->send(mecho, "hello echo");
  self->receive(
    [](const std::string& arg) {
      CAF_CHECK_EQUAL(arg, "hello echo");
    }
  );
}

CAF_TEST(delayed_send) {
  scoped_actor self{system};
  self->delayed_send(self, chrono::milliseconds(1), 1, 2, 3);
  self->receive(
    [](int a, int b, int c) {
      CAF_CHECK_EQUAL(a, 1);
      CAF_CHECK_EQUAL(b, 2);
      CAF_CHECK_EQUAL(c, 3);
    }
  );
}

CAF_TEST(delayed_spawn) {
  scoped_actor self{system};
  self->receive(after(chrono::milliseconds(1)) >> [] { });
  system.spawn<testee1>();
}

CAF_TEST(spawn_event_testee2_test) {
  scoped_actor self{system};
  spawn_event_testee2(self);
  self->receive(
    [](ok_atom) {
      CAF_MESSAGE("Received 'ok'");
    }
  );
}

CAF_TEST(function_spawn) {
  scoped_actor self{system};
  auto f = [](const string& name) -> behavior {
    return (
      [name](get_atom) {
        return std::make_tuple(name_atom::value, name);
      }
    );
  };
  auto a1 = system.spawn(f, "alice");
  auto a2 = system.spawn(f, "bob");
  self->send(a1, get_atom::value);
  self->receive (
    [&](name_atom, const string& name) {
      CAF_CHECK_EQUAL(name, "alice");
    }
  );
  self->send(a2, get_atom::value);
  self->receive (
    [&](name_atom, const string& name) {
      CAF_CHECK_EQUAL(name, "bob");
    }
  );
  self->send_exit(a1, exit_reason::user_shutdown);
  self->send_exit(a2, exit_reason::user_shutdown);
}

using typed_testee = typed_actor<replies_to<abc_atom>::with<std::string>>;

typed_testee::behavior_type testee() {
  return {
    [](abc_atom) {
      CAF_MESSAGE("received 'abc'");
      return "abc";
    }
  };
}

CAF_TEST(typed_await) {
  scoped_actor self{system};
  auto f = make_function_view(system.spawn(testee));
  CAF_CHECK_EQUAL(f(abc_atom::value), "abc");
}

// tests attach_functor() inside of an actor's constructor
CAF_TEST(constructor_attach) {
  class testee : public event_based_actor {
  public:
    testee(actor_config& cfg, actor buddy)
        : event_based_actor(cfg),
          buddy_(buddy) {
      attach_functor([=](const error& reason) {
        send(buddy, ok_atom::value, reason);
      });
    }

    behavior make_behavior() override {
      return {
        [] {
          // nop
        }
      };
    }

    void on_exit() override {
      destroy(buddy_);
    }

  private:
    actor buddy_;
  };
  class spawner : public event_based_actor {
  public:
    spawner(actor_config& cfg)
        : event_based_actor(cfg),
          downs_(0),
          testee_(spawn<testee, monitored>(this)) {
      set_down_handler([=](down_msg& msg) {
        CAF_CHECK_EQUAL(msg.reason, exit_reason::user_shutdown);
        if (++downs_ == 2)
          quit(msg.reason);
      });
      set_exit_handler([=](exit_msg& msg) {
        send_exit(testee_, std::move(msg.reason));
      });
    }

    behavior make_behavior() override {
      return {
        [=](ok_atom, const error& reason) {
          CAF_CHECK_EQUAL(reason, exit_reason::user_shutdown);
          if (++downs_ == 2)
            quit(reason);
        }
      };
    }

    void on_exit() override {
      CAF_MESSAGE("spawner::on_exit()");
      destroy(testee_);
    }

  private:
    int downs_;
    actor testee_;
  };
  anon_send_exit(system.spawn<spawner>(), exit_reason::user_shutdown);
}

CAF_TEST(kill_the_immortal) {
  auto wannabe_immortal = system.spawn([](event_based_actor* self) -> behavior {
    self->set_exit_handler([](local_actor*, exit_msg&) {
      // nop
    });
    return {
      [] {
        // nop
      }
    };
  });
  scoped_actor self{system};
  self->send_exit(wannabe_immortal, exit_reason::kill);
  self->wait_for(wannabe_immortal);
}

CAF_TEST(move_only_argument) {
  using unique_int = std::unique_ptr<int>;
  unique_int uptr{new int(42)};
  auto impl = [](event_based_actor* self, unique_int ptr) -> behavior {
    auto i = *ptr;
    return {
      [=](float) {
        self->quit();
        return i;
      }
    };
  };
  auto f = make_function_view(system.spawn(impl, std::move(uptr)));
  CAF_CHECK_EQUAL(to_string(f(1.f)), "(42)");
  /*
  auto testee = system.spawn(f, std::move(uptr));
  scoped_actor self{system};
  self->request(testee, infinite, 1.f).receive(
    [](int i) {
      CAF_CHECK_EQUAL(i, 42);
    },
    ERROR_HANDLER
  );
  */
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#define CAF_SUITE unit
#include "caf/test/unit_test.hpp"

#include "caf/actor_system.hpp"
#include "caf/actor_system_config.hpp"
#include "caf/atom.hpp"
#include "caf/event_based_actor.hpp"
#include "caf/scoped_actor.hpp"
#include "caf/unit.hpp"

using namespace caf;

using unit_res_atom = atom_constant<atom("unitRes")>;
using void_res_atom = atom_constant<atom("voidRes")>;
using unit_raw_atom = atom_constant<atom("unitRaw")>;
using void_raw_atom = atom_constant<atom("voidRaw")>;

behavior testee(event_based_actor*) {
  return {
    [] (unit_res_atom) -> result<unit_t> { return unit; },
    [] (void_res_atom) -> result<void>   { return {}; },
    [] (unit_raw_atom) -> unit_t         { return unit; },
    [] (void_raw_atom) -> void           { }
  };
}

CAF_TEST(unit_results) {
  actor_system_config cfg;
  actor_system sys{cfg};
  scoped_actor self{sys};
  auto aut = sys.spawn(testee);
  atom_value as[] = {unit_res_atom::value, void_res_atom::value,
                     unit_raw_atom::value, void_raw_atom::value};
  for (auto a : as) {
    self->request(aut, infinite, a).receive(
      [&] {
        CAF_MESSAGE("actor under test correctly replied to " << to_string(a));
      },
      [&] (const error&) {
        CAF_FAIL("actor under test failed at input " << to_string(a));
      }
    );
  }
}

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <set>
#include <map>
#include <string>
#include <numeric>
#include <fstream>
#include <iostream>
#include <iterator>
#include <unordered_set>

#define CAF_SUITE multi_lane_streaming
#include "caf/test/dsl.hpp"

#include "caf/random_topic_scatterer.hpp"

#include "caf/detail/pull5_gatherer.hpp"
#include "caf/detail/push5_scatterer.hpp"

using std::cout;
using std::endl;
using std::vector;
using std::string;

using namespace caf;

namespace {

using key_type = string;

using value_type = string;

using filter_type = std::vector<key_type>;

using element_type = std::pair<key_type, value_type>;

struct process_t {
  void operator()(unit_t&, downstream<element_type>& out, element_type x) {
    out.push(std::move(x));
  }
};

constexpr process_t process_fun = process_t{};

struct cleanup_t {
  void operator()(unit_t&) {
    // nop
  }
};

constexpr cleanup_t cleanup_fun = cleanup_t{};

struct selected_t {
  template <class T>
  bool operator()(const std::vector<string>& filter, const T& x) {
    for (auto& prefix : filter)
      if (get<0>(x).compare(0, prefix.size(), prefix.c_str()) == 0)
        return true;
    return false;
  }
};

struct stream_splitter_state {
  using stage_impl = stream_stage_impl<
    process_t, cleanup_t, random_gatherer,
    random_topic_scatterer<element_type, std::vector<key_type>, selected_t>>;
  intrusive_ptr<stage_impl> stage;
  static const char* name;
};

const char* stream_splitter_state::name = "stream_splitter";

behavior stream_splitter(stateful_actor<stream_splitter_state>* self) {
  stream_id id{self->ctrl(),
               self->new_request_id(message_priority::normal).integer_value()};
  using impl = stream_splitter_state::stage_impl;
  self->state.stage = make_counted<impl>(self, id, process_fun, cleanup_fun);
  self->state.stage->in().continuous(true);
  // Force the splitter to collect credit until reaching 3 in order
  // to receive only full batches from upstream (simplifies testing).
  // Restrict maximum credit per path to 5 (simplifies testing).
  self->state.stage->in().min_credit_assignment(3);
  self->state.stage->in().max_credit(5);
  self->streams().emplace(id, self->state.stage);
  return {
    [=](join_atom, filter_type filter) -> stream<element_type> {
      auto sid = self->streams().begin()->first;
      auto hdl = self->current_sender();
      if (!self->add_sink<element_type>(
            self->state.stage, sid, nullptr, hdl, no_stages, make_message_id(),
            stream_priority::normal, std::make_tuple()))
        return none;
      self->drop_current_message_id();
      self->state.stage->out().set_filter(sid, hdl, std::move(filter));
      return sid;
    },
    [=](const stream<element_type>& in) {
      auto& mgr = self->state.stage;
      if (!self->add_source(mgr, in.id(), none)) {
        CAF_FAIL("serve_as_stage failed");
      }
      self->streams().emplace(in.id(), mgr);
    }
  };
}

struct storage_state {
  static const char* name;
  std::vector<element_type> buf;
};

const char* storage_state::name = "storage";

behavior storage(stateful_actor<storage_state>* self,
                 actor source, filter_type filter) {
  self->send(self * source, join_atom::value, std::move(filter));
  return {
    [=](stream<element_type>& in) {
      return self->make_sink(
        // input stream
        in,
        // initialize state
        [](unit_t&) {
          // nop
        },
        // processing step
        [=](unit_t&, element_type x) {
          self->state.buf.emplace_back(std::move(x));
        },
        // cleanup and produce void "result"
        [](unit_t&) {
          CAF_LOG_INFO("storage done");
        },
        policy::arg<detail::pull5_gatherer, terminal_stream_scatterer>::value
      );
    },
    [=](get_atom) {
      return self->state.buf;
    }
  };
}

struct nores_streamer_state {
  static const char* name;
};

const char* nores_streamer_state::name = "nores_streamer";

void nores_streamer(stateful_actor<nores_streamer_state>* self,
                             const actor& dest) {
  CAF_LOG_INFO("nores_streamer initialized");
  using buf = std::deque<element_type>;
  self->make_source(
    // destination of the stream
    dest,
    // initialize state
    [&](buf& xs) {
      xs = buf{{"key1", "a"}, {"key2", "a"}, {"key1", "b"}, {"key2", "b"},
               {"key1", "c"}, {"key2", "c"}, {"key1", "d"}, {"key2", "d"}};
    },
    // get next element
    [=](buf& xs, downstream<element_type>& out, size_t num) {
      auto n = std::min(num, xs.size());
      for (size_t i = 0; i < n; ++i)
        out.push(xs[i]);
      xs.erase(xs.begin(), xs.begin() + static_cast<ptrdiff_t>(n));
    },
    // check whether we reached the end
    [=](const buf& xs) {
      return xs.empty();
    },
    // handle result of the stream
    [=](expected<void>) {
      // nop
    });
}

struct config : actor_system_config {
public:
  config() {
    add_message_type<element_type>("element_type");
  }
};

using fixture = test_coordinator_fixture<config>;

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(multi_lane_streaming, fixture)

CAF_TEST(fork_setup) {
  using batch = std::vector<element_type>;
  auto splitter = sys.spawn(stream_splitter);
  sched.run();
  CAF_MESSAGE("spawn first sink");
  auto d1 = sys.spawn(storage, splitter, filter_type{"key1"});
  sched.run_once();
  expect((atom_value, filter_type),
         from(d1).to(splitter).with(join_atom::value, filter_type{"key1"}));
  expect((stream_msg::open),
         from(_).to(d1).with(_, splitter, _, _, _, false));
  expect((stream_msg::ack_open),
         from(d1).to(splitter).with(_, _, 5, _, false));
  CAF_MESSAGE("spawn second sink");
  auto d2 = sys.spawn(storage, splitter, filter_type{"key2"});
  sched.run_once();
  expect((atom_value, filter_type),
         from(d2).to(splitter).with(join_atom::value, filter_type{"key2"}));
  expect((stream_msg::open),
         from(_).to(d2).with(_, splitter, _, _, _, false));
  expect((stream_msg::ack_open),
         from(d2).to(splitter).with(_, _, 5, _, false));
  CAF_MESSAGE("spawn source");
  auto src = sys.spawn(nores_streamer, splitter);
  sched.run_once();
  // Handshake between src and splitter.
  expect((stream_msg::open),
         from(_).to(splitter).with(_, src, _, _, _, false));
  expect((stream_msg::ack_open),
         from(splitter).to(src).with(_, _, 5, _, false));
  // First batch.
  expect((stream_msg::batch),
         from(src).to(splitter)
         .with(5,
               batch{{"key1", "a"},
                     {"key2", "a"},
                     {"key1", "b"},
                     {"key2", "b"},
                     {"key1", "c"}},
               0));
  expect((stream_msg::batch),
         from(splitter).to(d2)
         .with(2, batch{{"key2", "a"}, {"key2", "b"}}, 0));
  expect((stream_msg::batch),
         from(splitter).to(d1)
         .with(3, batch{{"key1", "a"}, {"key1", "b"}, {"key1", "c"}}, 0));
  expect((stream_msg::ack_batch), from(d2).to(splitter).with(2, 0));
  expect((stream_msg::ack_batch), from(d1).to(splitter).with(3, 0));
  expect((stream_msg::ack_batch), from(splitter).to(src).with(5, 0));
  // Second batch.
  expect((stream_msg::batch),
         from(src).to(splitter)
         .with(3, batch{{"key2", "c"}, {"key1", "d"}, {"key2", "d"}}, 1));
  expect((stream_msg::batch),
         from(splitter).to(d1).with(1, batch{{"key1", "d"}}, 1));
  expect((stream_msg::batch),
         from(splitter).to(d2).with(2, batch{{"key2", "c"}, {"key2", "d"}}, 1));
  expect((stream_msg::ack_batch), from(d1).to(splitter).with(1, 1));
  expect((stream_msg::ack_batch), from(d2).to(splitter).with(2, 1));
  expect((stream_msg::ack_batch), from(splitter).to(src).with(3, 1));
  // Source is done, splitter remains open.
  expect((stream_msg::close), from(src).to(splitter).with());
  CAF_REQUIRE(!sched.has_job());
  CAF_MESSAGE("check content of storages");
  self->send(d1, get_atom::value);
  sched.run_once();
  self->receive(
    [](const batch& xs) {
      batch ys{{"key1", "a"}, {"key1", "b"}, {"key1", "c"}, {"key1", "d"}};
      CAF_REQUIRE_EQUAL(xs, ys);
    }
  );
  self->send(d2, get_atom::value);
  sched.run_once();
  self->receive(
    [](const batch& xs) {
      batch ys{{"key2", "a"}, {"key2", "b"}, {"key2", "c"}, {"key2", "d"}};
      CAF_REQUIRE_EQUAL(xs, ys);
    }
  );
  CAF_MESSAGE("spawn a second source");
  auto src2 = sys.spawn(nores_streamer, splitter);
  sched.run_once();
  // Handshake between src2 and splitter.
  expect((stream_msg::open),
         from(_).to(splitter).with(_, src2, _, _, _, false));
  expect((stream_msg::ack_open),
         from(splitter).to(src2).with(_, _, 5, _, false));
  // First batch.
  expect((stream_msg::batch),
         from(src2).to(splitter)
         .with(5,
               batch{{"key1", "a"},
                     {"key2", "a"},
                     {"key1", "b"},
                     {"key2", "b"},
                     {"key1", "c"}},
               0));
  expect((stream_msg::batch),
         from(splitter).to(d2)
         .with(2, batch{{"key2", "a"}, {"key2", "b"}}, 2));
  expect((stream_msg::batch),
         from(splitter).to(d1)
         .with(3, batch{{"key1", "a"}, {"key1", "b"}, {"key1", "c"}}, 2));
  expect((stream_msg::ack_batch), from(d2).to(splitter).with(2, 2));
  expect((stream_msg::ack_batch), from(d1).to(splitter).with(3, 2));
  expect((stream_msg::ack_batch), from(splitter).to(src2).with(5, 0));
  // Second batch.
  expect((stream_msg::batch),
         from(src2).to(splitter)
         .with(3, batch{{"key2", "c"}, {"key1", "d"}, {"key2", "d"}}, 1));
  expect((stream_msg::batch),
         from(splitter).to(d1).with(1, batch{{"key1", "d"}}, 3));
  expect((stream_msg::batch),
         from(splitter).to(d2).with(2, batch{{"key2", "c"}, {"key2", "d"}}, 3));
  expect((stream_msg::ack_batch), from(d1).to(splitter).with(1, 3));
  expect((stream_msg::ack_batch), from(d2).to(splitter).with(2, 3));
  expect((stream_msg::ack_batch), from(splitter).to(src2).with(3, 1));
  // Source is done, splitter remains open.
  expect((stream_msg::close), from(src2).to(splitter).with());
  CAF_REQUIRE(!sched.has_job());
  CAF_MESSAGE("check content of storages again");
  self->send(d1, get_atom::value);
  sched.run_once();
  self->receive(
    [](const batch& xs) {
      batch ys0{{"key1", "a"}, {"key1", "b"}, {"key1", "c"}, {"key1", "d"}};
      auto ys = ys0;
      ys.insert(ys.end(), ys0.begin(), ys0.end()); // all elements twice
      CAF_REQUIRE_EQUAL(xs, ys);
    }
  );
  self->send(d2, get_atom::value);
  sched.run_once();
  self->receive(
    [](const batch& xs) {
      batch ys0{{"key2", "a"}, {"key2", "b"}, {"key2", "c"}, {"key2", "d"}};
      auto ys = ys0;
      ys.insert(ys.end(), ys0.begin(), ys0.end()); // all elements twice
      CAF_REQUIRE_EQUAL(xs, ys);
    }
  );
  CAF_MESSAGE("shutdown");
  anon_send_exit(splitter, exit_reason::kill);
  sched.run();
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE actor_clock
#include "caf/test/dsl.hpp"

#include <chrono>
#include <memory>

#include "caf/all.hpp"
#include "caf/detail/test_actor_clock.hpp"
#include "caf/raw_event_based_actor.hpp"

using namespace caf;

namespace {

using std::chrono::seconds;

struct testee_state {
  uint32_t timeout_id = 41;
};

behavior testee(stateful_actor<testee_state, raw_event_based_actor>* self,
                detail::test_actor_clock* t) {
  return {
    [=](ok_atom) {
      auto n = t->now() + seconds(10);
      self->state.timeout_id += 1;
      t->set_receive_timeout(n, self, self->state.timeout_id);
    },
    [=](add_atom) {
      auto n = t->now() + seconds(10);
      self->state.timeout_id += 1;
      auto mid = make_message_id(self->state.timeout_id).response_id();
      t->set_request_timeout(n, self, mid);
    },
    [](const timeout_msg&) {
      // nop
    },
    [](const error&) {
      // nop
    },
    [](const std::string&) {
      // nop
    },
    [=](group& grp) {
      self->join(grp);
    },
    [=](exit_msg& x) {
      self->quit(x.reason);
    }
  };
}

struct fixture : test_coordinator_fixture<> {
  detail::test_actor_clock t;
  actor aut;

  fixture() : aut(sys.spawn<lazy_init>(testee, &t)) {
    // nop
  }
};

struct tid {
  uint32_t value;
};

inline bool operator==(const timeout_msg& x, const tid& y) {
  return x.timeout_id == y.value;
}

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(timer_tests, fixture)

CAF_TEST(single_receive_timeout) {
  // Have AUT call t.set_receive_timeout().
  self->send(aut, ok_atom::value);
  expect((ok_atom), from(self).to(aut).with(_));
  CAF_CHECK_EQUAL(t.schedule().size(), 1u);
  CAF_CHECK_EQUAL(t.actor_lookup().size(), 1u);
  // Advance time to send timeout message.
  t.advance_time(seconds(10));
  CAF_CHECK_EQUAL(t.schedule().size(), 0u);
  CAF_CHECK_EQUAL(t.actor_lookup().size(), 0u);
  // Have AUT receive the timeout.
  expect((timeout_msg), from(aut).to(aut).with(tid{42}));
}

CAF_TEST(override_receive_timeout) {
  // Have AUT call t.set_receive_timeout().
  self->send(aut, ok_atom::value);
  expect((ok_atom), from(self).to(aut).with(_));
  CAF_CHECK_EQUAL(t.schedule().size(), 1u);
  CAF_CHECK_EQUAL(t.actor_lookup().size(), 1u);
  // Have AUT call t.set_timeout() again.
  self->send(aut, ok_atom::value);
  expect((ok_atom), from(self).to(aut).with(_));
  CAF_CHECK_EQUAL(t.schedule().size(), 1u);
  CAF_CHECK_EQUAL(t.actor_lookup().size(), 1u);
  // Advance time to send timeout message.
  t.advance_time(seconds(10));
  CAF_CHECK_EQUAL(t.schedule().size(), 0u);
  CAF_CHECK_EQUAL(t.actor_lookup().size(), 0u);
  // Have AUT receive the timeout.
  expect((timeout_msg), from(aut).to(aut).with(tid{43}));
}

CAF_TEST(single_request_timeout) {
  // Have AUT call t.set_request_timeout().
  self->send(aut, add_atom::value);
  expect((add_atom), from(self).to(aut).with(_));
  CAF_CHECK_EQUAL(t.schedule().size(), 1u);
  CAF_CHECK_EQUAL(t.actor_lookup().size(), 1u);
  // Advance time to send timeout message.
  t.advance_time(seconds(10));
  CAF_CHECK_EQUAL(t.schedule().size(), 0u);
  CAF_CHECK_EQUAL(t.actor_lookup().size(), 0u);
  // Have AUT receive the timeout.
  expect((error), from(aut).to(aut).with(sec::request_timeout));
}

CAF_TEST(mixed_receive_and_request_timeouts) {
  // Have AUT call t.set_receive_timeout().
  self->send(aut, ok_atom::value);
  expect((ok_atom), from(self).to(aut).with(_));
  CAF_CHECK_EQUAL(t.schedule().size(), 1u);
  CAF_CHECK_EQUAL(t.actor_lookup().size(), 1u);
  // Cause the request timeout to arrive later.
  t.advance_time(seconds(5));
  // Have AUT call t.set_request_timeout().
  self->send(aut, add_atom::value);
  expect((add_atom), from(self).to(aut).with(_));
  CAF_CHECK_EQUAL(t.schedule().size(), 2u);
  CAF_CHECK_EQUAL(t.actor_lookup().size(), 2u);
  // Advance time to send receive timeout message.
  t.advance_time(seconds(5));
  CAF_CHECK_EQUAL(t.schedule().size(), 1u);
  CAF_CHECK_EQUAL(t.actor_lookup().size(), 1u);
  // Have AUT receive the timeout.
  expect((timeout_msg), from(aut).to(aut).with(tid{42}));
  // Advance time to send request timeout message.
  t.advance_time(seconds(10));
  CAF_CHECK_EQUAL(t.schedule().size(), 0u);
  CAF_CHECK_EQUAL(t.actor_lookup().size(), 0u);
  // Have AUT receive the timeout.
  expect((error), from(aut).to(aut).with(sec::request_timeout));
}

CAF_TEST(delay_actor_message) {
  // Schedule a message for now + 10s.
  auto n = t.now() + seconds(10);
  auto autptr = actor_cast<strong_actor_ptr>(aut);
  t.schedule_message(n, autptr,
                     make_mailbox_element(autptr, make_message_id(),
                                          no_stages, "foo"));
  CAF_CHECK_EQUAL(t.schedule().size(), 1u);
  CAF_CHECK_EQUAL(t.actor_lookup().size(), 0u);
  // Advance time to send the message.
  t.advance_time(seconds(10));
  CAF_CHECK_EQUAL(t.schedule().size(), 0u);
  CAF_CHECK_EQUAL(t.actor_lookup().size(), 0u);
  // Have AUT receive the message.
  expect((std::string), from(aut).to(aut).with("foo"));
}

CAF_TEST(delay_group_message) {
  // Have AUT join the group.
  auto grp = sys.groups().anonymous();
  self->send(aut, grp);
  expect((group), from(self).to(aut).with(_));
  // Schedule a message for now + 10s.
  auto n = t.now() + seconds(10);
  auto autptr = actor_cast<strong_actor_ptr>(aut);
  t.schedule_message(n, std::move(grp), autptr, make_message("foo"));
  CAF_CHECK_EQUAL(t.schedule().size(), 1u);
  CAF_CHECK_EQUAL(t.actor_lookup().size(), 0u);
  // Advance time to send the message.
  t.advance_time(seconds(10));
  CAF_CHECK_EQUAL(t.schedule().size(), 0u);
  CAF_CHECK_EQUAL(t.actor_lookup().size(), 0u);
  // Have AUT receive the message.
  expect((std::string), from(aut).to(aut).with("foo"));
  // Kill AUT (necessary because the group keeps a reference around).
  self->send_exit(aut, exit_reason::kill);
  expect((exit_msg), from(self).to(aut).with(_));
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <utility>

#include "caf/config.hpp"

#define CAF_SUITE request_response
#include "caf/test/dsl.hpp"

#include "caf/all.hpp"

#define ERROR_HANDLER                                                          \
  [&](error& err) { CAF_FAIL(system.render(err)); }

using namespace std;
using namespace caf;

using std::chrono::milliseconds;

namespace {

using f_atom = atom_constant<atom("f")>;
using i_atom = atom_constant<atom("i")>;
using idle_atom = atom_constant<atom("idle")>;
using error_atom = atom_constant<atom("error")>;
using request_atom = atom_constant<atom("request")>;
using response_atom = atom_constant<atom("response")>;
using go_atom = atom_constant<atom("go")>;
using gogo_atom = atom_constant<atom("gogo")>;
using gogogo_atom = atom_constant<atom("gogogo")>;
using no_way_atom = atom_constant<atom("NoWay")>;
using hi_there_atom = atom_constant<atom("HiThere")>;

struct sync_mirror : event_based_actor {
  sync_mirror(actor_config& cfg) : event_based_actor(cfg) {
    // nop
  }

  behavior make_behavior() override {
    set_default_handler(reflect);
    return {
      [] {
        // nop
      }
    };
  }
};

// replies to 'f' with 0.0f and to 'i' with 0
struct float_or_int : event_based_actor {
  float_or_int(actor_config& cfg) : event_based_actor(cfg) {
    // nop
  }

  behavior make_behavior() override {
    return {
      [](f_atom) {
        return 0.0f;
      },
      [](i_atom) {
        return 0;
      }
    };
  }
};

class popular_actor : public event_based_actor { // popular actors have a buddy
public:
  explicit popular_actor(actor_config& cfg, actor  buddy_arg)
      : event_based_actor(cfg),
        buddy_(std::move(buddy_arg)) {
    // don't pollute unit test output with (provoked) warnings
    set_default_handler(drop);
  }

  inline const actor& buddy() const {
    return buddy_;
  }

private:
  actor buddy_;
};

/******************************************************************************\
 *                                test case 1:                                *
 *                                                                            *
 *                  A                  B                  C                   *
 *                  |                  |                  |                   *
 *                  | --(delegate)---> |                  |                   *
 *                  |                  | --(forward)----> |                   *
 *                  |                  X                  |---\               *
 *                  |                                     |   |               *
 *                  |                                     |<--/               *
 *                  | <-------------(reply)-------------- |                   *
 *                  X                                     X                   *
\******************************************************************************/

class A : public popular_actor {
public:
  explicit A(actor_config& cfg, const actor& buddy_arg)
      : popular_actor(cfg, buddy_arg) {
    // nop
  }

  behavior make_behavior() override {
    return {
      [=](go_atom, const actor& next) {
        return delegate(next, gogo_atom::value);
      }
    };
  }
};

class B : public popular_actor {
public:
  explicit B(actor_config& cfg, const actor& buddy_arg)
      : popular_actor(cfg, buddy_arg) {
    // nop
  }

  behavior make_behavior() override {
    return {
      [=](gogo_atom x) {
        CAF_MESSAGE("forward message to buddy");
        quit();
        return delegate(buddy(), x);
      }
    };
  }
};

class C : public event_based_actor {
public:
  C(actor_config& cfg) : event_based_actor(cfg) {
    // don't pollute unit test output with (provoked) warnings
    set_default_handler(drop);
  }

  behavior make_behavior() override {
    return {
      [=](gogo_atom) -> atom_value {
        CAF_MESSAGE("received `gogo_atom`, about to quit");
        quit();
        return ok_atom::value;
      }
    };
  }
};

/******************************************************************************\
 *                                test case 2:                                *
 *                                                                            *
 *                  A                  D                  C                   *
 *                  |                  |                  |                   *
 *                  | ---(request)---> |                  |                   *
 *                  |                  | ---(request)---> |                   *
 *                  |                  |                  |---\               *
 *                  |                  |                  |   |               *
 *                  |                  |                  |<--/               *
 *                  |                  | <---(reply)----- |                   *
 *                  | <---(reply)----- |                                      *
 *                  X                  X                                      *
\******************************************************************************/

class D : public popular_actor {
public:
  explicit D(actor_config& cfg, const actor& buddy_arg)
      : popular_actor(cfg, buddy_arg) {
    // nop
  }

  behavior make_behavior() override {
    return {
      [=](gogo_atom gogo) -> response_promise {
        auto rp = make_response_promise();
        request(buddy(), infinite, gogo).then(
          [=](ok_atom ok) mutable {
            rp.deliver(ok);
            quit();
          }
        );
        return rp;
      }
    };
  }
};

/******************************************************************************\
 *                                test case 3:                                *
 *                                                                            *
 *                Client            Server              Worker                *
 *                  |                  |                  |                   *
 *                  |                  | <---(idle)------ |                   *
 *                  | ---(request)---> |                  |                   *
 *                  |                  | ---(request)---> |                   *
 *                  |                  |                  |---\               *
 *                  |                  X                  |   |               *
 *                  |                                     |<--/               *
 *                  | <------------(response)------------ |                   *
 *                  X                                                         *
\******************************************************************************/

behavior server(event_based_actor* self) {
  return {
    [=](idle_atom, actor worker) {
      self->become(
        keep_behavior,
        [=](request_atom task) {
          self->unbecome(); // await next idle message
          return self->delegate(worker, task);
        },
        [](idle_atom) {
          return skip();
        }
      );
    },
    [](request_atom) {
      return skip();
    }
  };
}

struct fixture {
  actor_system_config cfg;
  actor_system system;
  scoped_actor self;
  fixture() : system(cfg), self(system) {
    // nop
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(request_response_tests1, fixture)

CAF_TEST(test_void_res) {
  using testee_a = typed_actor<replies_to<int, int>::with<void>>;
  auto buddy = system.spawn([]() -> testee_a::behavior_type {
    return [](int, int) {
      // nop
    };
  });
  self->request(buddy, infinite, 1, 2).receive(
    [] {
      CAF_MESSAGE("received void res");
    },
    ERROR_HANDLER
  );
}

CAF_TEST(pending_quit) {
  auto mirror = system.spawn([](event_based_actor* ptr) -> behavior {
    ptr->set_default_handler(reflect);
    return {
      [] {
        // nop
      }
    };
  });
  system.spawn([mirror](event_based_actor* ptr) {
    ptr->request(mirror, infinite, 42).then(
      [](int) {
        CAF_ERROR("received result, should've been terminated already");
      },
      [](const error& err) {
        CAF_CHECK_EQUAL(err, sec::request_receiver_down);
      }
    );
    ptr->quit();
  });
}

CAF_TEST(request_float_or_int) {
  int invocations = 0;
  auto foi = self->spawn<float_or_int, linked>();
  self->send(foi, i_atom::value);
  self->receive(
    [](int i) {
      CAF_CHECK_EQUAL(i, 0);
    }
  );
  self->request(foi, infinite, i_atom::value).receive(
    [&](int i) {
      CAF_CHECK_EQUAL(i, 0);
      ++invocations;
    },
    [&](const error& err) {
      CAF_ERROR("Error: " << self->system().render(err));
    }
  );
  self->request(foi, infinite, f_atom::value).receive(
    [&](float f) {
      CAF_CHECK_EQUAL(f, 0.f);
      ++invocations;
    },
    [&](const error& err) {
      CAF_ERROR("Error: " << self->system().render(err));
    }
  );
  CAF_CHECK_EQUAL(invocations, 2);
  CAF_MESSAGE("trigger sync failure");
  self->request(foi, infinite, f_atom::value).receive(
    [&](int) {
      CAF_FAIL("int handler called");
    },
    [&](error& err) {
      CAF_MESSAGE("error received");
      CAF_CHECK_EQUAL(err, sec::unexpected_response);
    }
  );
}

CAF_TEST(request_to_mirror) {
  auto mirror = system.spawn<sync_mirror>();
  self->request(mirror, infinite, 42).receive(
    [&](int value) {
      CAF_CHECK_EQUAL(value, 42);
    },
    ERROR_HANDLER
  );
}

CAF_TEST(request_to_a_fwd2_b_fwd2_c) {
  self->request(self->spawn<A, monitored>(self), infinite,
                go_atom::value, self->spawn<B>(self->spawn<C>())).receive(
    [](ok_atom) {
      CAF_MESSAGE("received 'ok'");
    },
    ERROR_HANDLER
  );
}

CAF_TEST(request_to_a_fwd2_d_fwd2_c) {
  self->request(self->spawn<A, monitored>(self), infinite,
                go_atom::value, self->spawn<D>(self->spawn<C>())).receive(
    [](ok_atom) {
      CAF_MESSAGE("received 'ok'");
    },
    ERROR_HANDLER
  );
}

CAF_TEST(request_to_self) {
  self->request(self, milliseconds(50), no_way_atom::value).receive(
    [&] {
      CAF_ERROR("unexpected empty message");
    },
    [&](const error& err) {
      CAF_MESSAGE("err = " << system.render(err));
      CAF_REQUIRE(err == sec::request_timeout);
    }
  );
}

CAF_TEST(invalid_request) {
  self->request(self->spawn<C>(), milliseconds(500),
                hi_there_atom::value).receive(
    [&](hi_there_atom) {
      CAF_ERROR("C did reply to 'HiThere'");
    },
    [&](const error& err) {
      CAF_REQUIRE_EQUAL(err, sec::unexpected_message);
    }
  );
}

CAF_TEST(client_server_worker_user_case) {
  auto serv = self->spawn<linked>(server);                       // server
  auto work = self->spawn<linked>([]() -> behavior {             // worker
    return {
      [](request_atom) {
        return response_atom::value;
      }
    };
  });
  // first 'idle', then 'request'
  anon_send(serv, idle_atom::value, work);
  self->request(serv, infinite, request_atom::value).receive(
    [&](response_atom) {
      CAF_MESSAGE("received 'response'");
      CAF_CHECK_EQUAL(self->current_sender(), work);
    },
    [&](const error& err) {
      CAF_ERROR("error: " << self->system().render(err));
    }
  );
  // first 'request', then 'idle'
  auto handle = self->request(serv, infinite, request_atom::value);
  send_as(work, serv, idle_atom::value, work);
  handle.receive(
    [&](response_atom) {
      CAF_CHECK_EQUAL(self->current_sender(), work.address());
    },
    [&](const error& err) {
      CAF_ERROR("error: " << self->system().render(err));
    }
  );
}

behavior request_no_then_A(event_based_actor*) {
  return [=](int number) {
    CAF_MESSAGE("got " << number);
  };
}

behavior request_no_then_B(event_based_actor* self) {
  return {
    [=](int number) {
      self->request(self->spawn(request_no_then_A), infinite, number);
    }
  };
}

CAF_TEST(request_no_then) {
  anon_send(system.spawn(request_no_then_B), 8);
}

CAF_TEST(async_request) {
  auto foo = system.spawn([](event_based_actor* ptr) -> behavior {
    auto receiver = ptr->spawn<linked>([](event_based_actor* ptr2) -> behavior {
      return {
        [=](int) {
          return ptr2->make_response_promise();
        }
      };
    });
    ptr->request(receiver, infinite, 1).then(
      [=](int) {}
    );
    return {
      [=](int) {
        CAF_MESSAGE("int received");
        ptr->quit(exit_reason::user_shutdown);
      }
    };
  });
  anon_send(foo, 1);
}

CAF_TEST(skip_responses) {
  auto mirror = system.spawn<sync_mirror>();
  auto future = self->request(mirror, infinite, 42);
  self->send(mirror, 42);
  self->receive([](int x) {
    CAF_CHECK_EQUAL(x, 42);
  });
  // second receive must time out
  self->receive(
    [](int) {
      CAF_FAIL("received response message as ordinary message");
    },
    after(std::chrono::milliseconds(20)) >> [] {
      CAF_MESSAGE("second receive timed out as expected");
    }
  );
  future.receive(
    [](int x) {
      CAF_CHECK_EQUAL(x, 42);
    },
    [&](const error& err) {
      CAF_FAIL(system.render(err));
    }
  );
}

CAF_TEST_FIXTURE_SCOPE_END()

CAF_TEST_FIXTURE_SCOPE(request_response_tests2, test_coordinator_fixture<>)

CAF_TEST(request_response_in_test_coordinator) {
  auto mirror = sys.spawn<sync_mirror>();
  sched.run();
  sched.inline_next_enqueue();
  // this block would deadlock without inlining the next enqueue
  self->request(mirror, infinite, 23).receive(
    [](int x) {
      CAF_CHECK_EQUAL(x, 23);

    },
    [&](const error& err) {
      CAF_FAIL("unexpected error: " << sys.render(err));
    }
  );
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE intrusive_ptr
#include "caf/test/unit_test.hpp"

// this test dosn't verify thread-safety of intrusive_ptr
// however, it is thread safe since it uses atomic operations only

#include <vector>
#include <cstddef>

#include "caf/ref_counted.hpp"
#include "caf/make_counted.hpp"
#include "caf/intrusive_ptr.hpp"

using namespace caf;

namespace {

int class0_instances = 0;
int class1_instances = 0;

class class0;
class class1;

using class0ptr = intrusive_ptr<class0>;
using class1ptr = intrusive_ptr<class1>;

class class0 : public ref_counted {
public:
  explicit class0(bool subtype = false) : subtype_(subtype) {
    if (!subtype) {
      ++class0_instances;
    }
  }

  ~class0() override {
    if (!subtype_) {
      --class0_instances;
    }
  }

  bool is_subtype() const {
    return subtype_;
  }

  virtual class0ptr create() const {
    return make_counted<class0>();
  }

private:
  bool subtype_;
};

class class1 : public class0 {
public:
  class1() : class0(true) {
    ++class1_instances;
  }

  ~class1() override {
    --class1_instances;
  }

  class0ptr create() const override {
    return make_counted<class1>();
  }
};

class0ptr get_test_rc() {
  return make_counted<class0>();
}

class0ptr get_test_ptr() {
  return get_test_rc();
}

struct fixture {
  ~fixture() {
    CAF_CHECK_EQUAL(class0_instances, 0);
    CAF_CHECK_EQUAL(class1_instances, 0);
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(atom_tests, fixture)

CAF_TEST(make_counted) {
  auto p = make_counted<class0>();
  CAF_CHECK_EQUAL(class0_instances, 1);
  CAF_CHECK(p->unique());
}

CAF_TEST(reset) {
  class0ptr p;
  p.reset(new class0, false);
  CAF_CHECK_EQUAL(class0_instances, 1);
  CAF_CHECK(p->unique());
}

CAF_TEST(get_test_rc) {
  class0ptr p1;
  p1 = get_test_rc();
  class0ptr p2 = p1;
  CAF_CHECK_EQUAL(class0_instances, 1);
  CAF_CHECK_EQUAL(p1->unique(), false);
}

CAF_TEST(list) {
  std::vector<class0ptr> pl;
  pl.push_back(get_test_ptr());
  pl.push_back(get_test_rc());
  pl.push_back(pl.front()->create());
  CAF_CHECK(pl.front()->unique());
  CAF_CHECK_EQUAL(class0_instances, 3);
}

CAF_TEST(full_test) {
  auto p1 = make_counted<class0>();
  CAF_CHECK_EQUAL(p1->is_subtype(), false);
  CAF_CHECK_EQUAL(p1->unique(), true);
  CAF_CHECK_EQUAL(class0_instances, 1);
  CAF_CHECK_EQUAL(class1_instances, 0);
  p1.reset(new class1, false);
  CAF_CHECK_EQUAL(p1->is_subtype(), true);
  CAF_CHECK_EQUAL(p1->unique(), true);
  CAF_CHECK_EQUAL(class0_instances, 0);
  CAF_CHECK_EQUAL(class1_instances, 1);
  auto p2 = make_counted<class1>();
  p1 = p2;
  CAF_CHECK_EQUAL(p1->unique(), false);
  CAF_CHECK_EQUAL(class0_instances, 0);
  CAF_CHECK_EQUAL(class1_instances, 1);
  CAF_CHECK_EQUAL(p1, static_cast<class0*>(p2.get()));
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#define CAF_SUITE behavior

#include "caf/config.hpp"

#include "caf/test/unit_test.hpp"

#include <functional>

#include "caf/behavior.hpp"
#include "caf/message_handler.hpp"
#include "caf/make_type_erased_tuple_view.hpp"

using namespace caf;
using namespace std;

using hi_atom = atom_constant<atom("hi")>;
using ho_atom = atom_constant<atom("ho")>;

namespace {

class nocopy_fun {
public:
  nocopy_fun() = default;

  nocopy_fun(nocopy_fun&&) = default;

  nocopy_fun& operator=(nocopy_fun&&) = default;

  nocopy_fun(const nocopy_fun&) = delete;

  nocopy_fun& operator=(const nocopy_fun&) = delete;

  int operator()(int x, int y) {
    return x + y;
  }
};

struct fixture {
  message m1 = make_message(1);
  message m2 = make_message(1, 2);
  message m3 = make_message(1, 2, 3);
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(behavior_tests, fixture)

CAF_TEST(default_construct) {
  behavior f;
  CAF_CHECK_EQUAL(f(m1), none);
  CAF_CHECK_EQUAL(f(m2), none);
  CAF_CHECK_EQUAL(f(m3), none);
}

CAF_TEST(nocopy_function_object) {
  behavior f{nocopy_fun{}};
  CAF_CHECK_EQUAL(f(m1), none);
  CAF_CHECK_EQUAL(to_string(f(m2)), "*(3)");
  CAF_CHECK_EQUAL(f(m3), none);
}

CAF_TEST(single_lambda_construct) {
  behavior f{[](int x) { return x + 1; }};
  CAF_CHECK_EQUAL(to_string(f(m1)), "*(2)");
  CAF_CHECK_EQUAL(f(m2), none);
  CAF_CHECK_EQUAL(f(m3), none);
}

CAF_TEST(multiple_lambda_construct) {
  behavior f{
    [](int x) { return x + 1; },
    [](int x, int y) { return x * y; }
  };
  CAF_CHECK_EQUAL(to_string(f(m1)), "*(2)");
  CAF_CHECK_EQUAL(to_string(f(m2)), "*(2)");
  CAF_CHECK_EQUAL(f(m3), none);
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE stateful_actor
#include "caf/test/unit_test.hpp"

#include "caf/all.hpp"

#define ERROR_HANDLER                                                          \
  [&](error& err) { CAF_FAIL(system.render(err)); }

using namespace std;
using namespace caf;

namespace {

using typed_adder_actor = typed_actor<reacts_to<add_atom, int>,
                                      replies_to<get_atom>::with<int>>;

struct counter {
  int value = 0;
  local_actor* self_;
};

behavior adder(stateful_actor<counter>* self) {
  return {
    [=](add_atom, int x) {
      self->state.value += x;
    },
    [=](get_atom) {
      return self->state.value;
    }
  };
}

class adder_class : public stateful_actor<counter> {
public:
  adder_class(actor_config& cfg) : stateful_actor<counter>(cfg) {
    // nop
  }

  behavior make_behavior() override {
    return adder(this);
  }
};

typed_adder_actor::behavior_type
typed_adder(typed_adder_actor::stateful_pointer<counter> self) {
  return {
    [=](add_atom, int x) {
      self->state.value += x;
    },
    [=](get_atom) {
      return self->state.value;
    }
  };
}

class typed_adder_class : public typed_adder_actor::stateful_base<counter> {
public:
  using super = typed_adder_actor::stateful_base<counter>;

  typed_adder_class(actor_config& cfg) : super(cfg) {
    // nop
  }

  behavior_type make_behavior() override {
    return typed_adder(this);
  }
};

struct fixture {
  actor_system_config cfg;
  actor_system system;

  fixture() : system(cfg) {
    // nop
  }

  template <class ActorUnderTest>
  void test_adder(ActorUnderTest aut) {
    scoped_actor self{system};
    self->send(aut, add_atom::value, 7);
    self->send(aut, add_atom::value, 4);
    self->send(aut, add_atom::value, 9);
    self->request(aut, infinite, get_atom::value).receive(
      [](int x) {
        CAF_CHECK_EQUAL(x, 20);
      },
      ERROR_HANDLER
    );
  }

  template <class State>
  void test_name(const char* expected) {
    auto aut = system.spawn([](stateful_actor<State>* self) -> behavior {
      return [=](get_atom) {
        self->quit();
        return self->name();
      };
    });
    scoped_actor self{system};
    self->request(aut, infinite, get_atom::value).receive(
      [&](const string& str) {
        CAF_CHECK_EQUAL(str, expected);
      },
      ERROR_HANDLER
    );
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(dynamic_stateful_actor_tests, fixture)

CAF_TEST(dynamic_stateful_actor) {
  CAF_REQUIRE(monitored + monitored == monitored);
  test_adder(system.spawn(adder));
}

CAF_TEST(typed_stateful_actor) {
  test_adder(system.spawn(typed_adder));
}

CAF_TEST(dynamic_stateful_actor_class) {
  test_adder(system.spawn<adder_class>());
}

CAF_TEST(typed_stateful_actor_class) {
  test_adder(system.spawn<typed_adder_class>());
}

CAF_TEST(no_name) {
  struct state {
    // empty
  };
  test_name<state>("scheduled_actor");
}

CAF_TEST(char_name) {
  struct state {
    const char* name = "testee";
  };
  test_name<state>("testee");
}

CAF_TEST(string_name) {
  struct state {
    string name = "testee2";
  };
  test_name<state>("testee2");
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE actor_factory
#include "caf/test/unit_test.hpp"

#include "caf/all.hpp"

#include "caf/actor_registry.hpp"

using namespace caf;

using std::endl;

namespace {

using down_atom = atom_constant<atom("down")>;

struct fixture {
  actor_system_config cfg;

  void test_spawn(message args, bool expect_fail = false) {
    actor_system system{cfg};
    scoped_actor self{system};
    CAF_MESSAGE("set aut");
    strong_actor_ptr res;
    std::set<std::string> ifs;
    scoped_execution_unit context{&system};
    actor_config actor_cfg{&context};
    auto aut = system.spawn<actor>("test_actor", std::move(args));
    if (expect_fail) {
      CAF_REQUIRE(!aut);
      return;
    }
    CAF_REQUIRE(aut);
    self->wait_for(*aut);
    CAF_MESSAGE("aut done");
  }
};

struct test_actor_no_args : event_based_actor {
  using event_based_actor::event_based_actor;
};

struct test_actor_one_arg : event_based_actor {
  test_actor_one_arg(actor_config& conf, int value) : event_based_actor(conf) {
    CAF_CHECK_EQUAL(value, 42);
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(add_actor_type_tests, fixture)

CAF_TEST(fun_no_args) {
  auto test_actor_one_arg = [] {
    CAF_MESSAGE("inside test_actor");
  };
  cfg.add_actor_type("test_actor", test_actor_one_arg);
  test_spawn(make_message());
  CAF_MESSAGE("test_spawn done");
}

CAF_TEST(fun_no_args_selfptr) {
  auto test_actor_one_arg = [](event_based_actor*) {
    CAF_MESSAGE("inside test_actor");
  };
  cfg.add_actor_type("test_actor", test_actor_one_arg);
  test_spawn(make_message());
}
CAF_TEST(fun_one_arg) {
  auto test_actor_one_arg = [](int i) {
    CAF_CHECK_EQUAL(i, 42);
  };
  cfg.add_actor_type("test_actor", test_actor_one_arg);
  test_spawn(make_message(42));
}

CAF_TEST(fun_one_arg_selfptr) {
  auto test_actor_one_arg = [](event_based_actor*, int i) {
    CAF_CHECK_EQUAL(i, 42);
  };
  cfg.add_actor_type("test_actor", test_actor_one_arg);
  test_spawn(make_message(42));
}

CAF_TEST(class_no_arg_invalid) {
  cfg.add_actor_type<test_actor_no_args>("test_actor");
  test_spawn(make_message(42), true);
}

CAF_TEST(class_no_arg_valid) {
  cfg.add_actor_type<test_actor_no_args>("test_actor");
  test_spawn(make_message());
}

CAF_TEST(class_one_arg_invalid) {
  cfg.add_actor_type<test_actor_one_arg, const int&>("test_actor");
  test_spawn(make_message(), true);
}

CAF_TEST(class_one_arg_valid) {
  cfg.add_actor_type<test_actor_one_arg, const int&>("test_actor");
  test_spawn(make_message(42));
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE streambuf
#include "caf/test/unit_test.hpp"

#include "caf/streambuf.hpp"

using namespace caf;

CAF_TEST(signed_arraybuf) {
  auto data = std::string{"The quick brown fox jumps over the lazy dog"};
  arraybuf<char> ab{data};
  // Let's read some.
  CAF_CHECK_EQUAL(static_cast<size_t>(ab.in_avail()), data.size());
  CAF_CHECK_EQUAL(ab.sgetc(), 'T');
  std::string buf;
  buf.resize(3);
  auto got = ab.sgetn(&buf[0], 3);
  CAF_CHECK_EQUAL(got, 3);
  CAF_CHECK_EQUAL(buf, "The");
  CAF_CHECK_EQUAL(ab.sgetc(), ' ');
  // Exhaust the stream.
  buf.resize(data.size());
  got = ab.sgetn(&buf[0] + 3, static_cast<std::streamsize>(data.size() - 3));
  CAF_CHECK_EQUAL(static_cast<size_t>(got), data.size() - 3);
  CAF_CHECK_EQUAL(data, buf);
  CAF_CHECK_EQUAL(ab.in_avail(), 0);
  // No more.
  auto c = ab.sgetc();
  CAF_CHECK_EQUAL(c, charbuf::traits_type::eof());
  // Reset the stream and write into it.
  ab.pubsetbuf(&data[0], static_cast<std::streamsize>(data.size()));
  CAF_CHECK_EQUAL(static_cast<size_t>(ab.in_avail()), data.size());
  auto put = ab.sputn("One", 3);
  CAF_CHECK_EQUAL(put, 3);
  CAF_CHECK(data.compare(0, 3, "One") == 0);
}

CAF_TEST(unsigned_arraybuf) {
  std::vector<uint8_t> data = {0x0a, 0x0b, 0x0c, 0x0d};
  arraybuf<uint8_t> ab{data};
  decltype(data) buf;
  std::copy(std::istreambuf_iterator<uint8_t>{&ab},
            std::istreambuf_iterator<uint8_t>{},
            std::back_inserter(buf));
  CAF_CHECK_EQUAL(data, buf);
  // Relative positioning.
  using pos = arraybuf<uint8_t>::pos_type;
  CAF_CHECK_EQUAL(ab.pubseekoff(2, std::ios::beg, std::ios::in), pos{2});
  CAF_CHECK_EQUAL(ab.sbumpc(), static_cast<int>(0x0c));
  CAF_CHECK_EQUAL(ab.sgetc(), 0x0d);
  CAF_CHECK_EQUAL(ab.pubseekoff(0, std::ios::cur, std::ios::in), pos{3});
  CAF_CHECK_EQUAL(ab.pubseekoff(-2, std::ios::cur, std::ios::in), pos{1});
  CAF_CHECK_EQUAL(ab.sgetc(), 0x0b);
  CAF_CHECK_EQUAL(ab.pubseekoff(-4, std::ios::end, std::ios::in), pos{0});
  CAF_CHECK_EQUAL(ab.sgetc(), 0x0a);
  // Absolute positioning.
  CAF_CHECK_EQUAL(ab.pubseekpos(1, std::ios::in), pos{1});
  CAF_CHECK_EQUAL(ab.sgetc(), 0x0b);
  CAF_CHECK_EQUAL(ab.pubseekpos(3, std::ios::in), pos{3});
  CAF_CHECK_EQUAL(ab.sbumpc(), 0x0d);
  CAF_CHECK_EQUAL(ab.in_avail(), 0);
}

CAF_TEST(containerbuf) {
  std::string data{
    "Habe nun, ach! Philosophie,\n"
    "Juristerei und Medizin,\n"
    "Und leider auch Theologie\n"
    "Durchaus studiert, mit heißem Bemühn.\n"
    "Da steh ich nun, ich armer Tor!\n"
    "Und bin so klug als wie zuvor"
  };
  // Write some data.
  std::vector<char> buf;
  vectorbuf vb{buf};
  auto put = vb.sputn(data.data(), static_cast<std::streamsize>(data.size()));
  CAF_CHECK_EQUAL(static_cast<size_t>(put), data.size());
  put = vb.sputn(";", 1);
  CAF_CHECK_EQUAL(put, 1);
  std::string target;
  std::copy(buf.begin(), buf.end(), std::back_inserter(target));
  CAF_CHECK_EQUAL(data + ';', target);
  // Check "overflow" on a new stream.
  buf.clear();
  vectorbuf vb2{buf};
  auto chr = vb2.sputc('x');
  CAF_CHECK_EQUAL(chr, 'x');
  // Let's read some data into a stream.
  buf.clear();
  containerbuf<std::string> scb{data};
  std::copy(std::istreambuf_iterator<char>{&scb},
            std::istreambuf_iterator<char>{},
            std::back_inserter(buf));
  CAF_CHECK_EQUAL(buf.size(), data.size());
  CAF_CHECK(std::equal(buf.begin(), buf.end(), data.begin() /*, data.end() */));
  // We're done, nothing to see here, please move along.
  CAF_CHECK_EQUAL(scb.sgetc(), containerbuf<std::string>::traits_type::eof());
  // Let's read again, but now in one big block.
  buf.clear();
  containerbuf<std::string> sib2{data};
  buf.resize(data.size());
  auto got = sib2.sgetn(&buf[0], static_cast<std::streamsize>(buf.size()));
  CAF_CHECK_EQUAL(static_cast<size_t>(got), data.size());
  CAF_CHECK_EQUAL(buf.size(), data.size());
  CAF_CHECK(std::equal(buf.begin(), buf.end(), data.begin() /*, data.end() */));
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE optional
#include "caf/test/unit_test.hpp"

#include "caf/optional.hpp"

using namespace std;
using namespace caf;

namespace {

struct qwertz {
  qwertz(int x, int y) : x_(x), y_(y) {
    // nop
  }
  int x_;
  int y_;
};

bool operator==(const qwertz& lhs, const qwertz& rhs) {
  return lhs.x_ == rhs.x_ && lhs.y_ == rhs.y_;
}

} // namespace <anonymous>

CAF_TEST(empty) {
  optional<int> x;
  optional<int> y;
  CAF_CHECK(x == y);
  CAF_CHECK(!(x != y));
}

CAF_TEST(equality) {
  optional<int> x = 42;
  optional<int> y = 7;
  CAF_CHECK(x != y);
  CAF_CHECK(!(x == y));
}

CAF_TEST(ordering) {
  optional<int> x = 42;
  optional<int> y = 7;
  CAF_CHECK(x > y);
  CAF_CHECK(x >= y);
  CAF_CHECK(y < x);
  CAF_CHECK(y <= x);
  CAF_CHECK(!(y > x));
  CAF_CHECK(!(y >= x));
  CAF_CHECK(!(x < y));
  CAF_CHECK(!(x <= y));
  CAF_CHECK(x < 4711);
  CAF_CHECK(4711 > x);
  CAF_CHECK(4711 >= x);
  CAF_CHECK(!(x > 4711));
  CAF_CHECK(!(x >= 4711));
  CAF_CHECK(!(4211 < x));
  CAF_CHECK(!(4211 <= x));
}

CAF_TEST(custom_type_none) {
  optional<qwertz> x;
  CAF_CHECK(x == none);
}

CAF_TEST(custom_type_engaged) {
  qwertz obj{1, 2};
  optional<qwertz> x = obj;
  CAF_CHECK(x != none);
  CAF_CHECK(obj == x);
  CAF_CHECK(x == obj );
  CAF_CHECK(obj == *x);
  CAF_CHECK(*x == obj);
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#define CAF_SUITE composition
#include "caf/test/dsl.hpp"

using namespace std;
using namespace caf;

namespace {

behavior multiplier(int x) {
  return {
    [=](int y) {
      return x * y;
    },
    [=](int y1, int y2) {
      return x * y1 * y2;
    }
  };
}

behavior adder(int x) {
  return {
    [=](int y) {
      return x + y;
    },
    [=](int y1, int y2) {
      return x + y1 + y2;
    }
  };
}

behavior float_adder(float x) {
  return {
    [=](float y) {
      return x + y;
    }
  };
}

using fixture = test_coordinator_fixture<>;

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(composition_tests, fixture)

CAF_TEST(depth2) {
  auto stage1 = sys.spawn(multiplier, 4);
  auto stage2 = sys.spawn(adder, 10);
  auto testee = stage2 * stage1;
  self->send(testee, 1);
  expect((int), from(self).to(stage1).with(1));
  expect((int), from(self).to(stage2).with(4));
  expect((int), from(stage2).to(self).with(14));
}

CAF_TEST(depth3) {
  auto stage1 = sys.spawn(multiplier, 4);
  auto stage2 = sys.spawn(adder, 10);
  auto testee = stage1 * stage2 * stage1;
  self->send(testee, 1);
  expect((int), from(self).to(stage1).with(1));
  expect((int), from(self).to(stage2).with(4));
  expect((int), from(self).to(stage1).with(14));
  expect((int), from(stage1).to(self).with(56));
}

CAF_TEST(depth2_type_mismatch) {
  auto stage1 = sys.spawn(multiplier, 4);
  auto stage2 = sys.spawn(float_adder, 10);
  auto testee = stage2 * stage1;
  self->send(testee, 1);
  expect((int), from(self).to(stage1).with(1));
  expect((int), from(self).to(stage2).with(4));
  expect((error), from(stage2).to(self).with(sec::unexpected_message));
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_NO_STAGES_HPP
#define CAF_NO_STAGES_HPP

#include "caf/mailbox_element.hpp"

namespace caf {

/// Convenience tag type for producing empty forwarding stacks.
struct no_stages_t {
  constexpr no_stages_t() {
    // nop
  }

  inline operator mailbox_element::forwarding_stack() const {
    return {};
  }
};

/// Convenience tag for producing empty forwarding stacks.
constexpr no_stages_t no_stages = no_stages_t{};

} // namespace caf

#endif // CAF_NO_STAGES_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DATA_PROCESSOR_HPP
#define CAF_DATA_PROCESSOR_HPP

#include <chrono>
#include <string>
#include <cstdint>
#include <cstddef> // size_t
#include <type_traits>
#include <iterator>

#include "caf/fwd.hpp"
#include "caf/atom.hpp"
#include "caf/error.hpp"
#include "caf/timestamp.hpp"
#include "caf/allowed_unsafe_message_type.hpp"

#include "caf/meta/annotation.hpp"
#include "caf/meta/save_callback.hpp"
#include "caf/meta/load_callback.hpp"

#include "caf/detail/type_list.hpp"
#include "caf/detail/apply_args.hpp"
#include "caf/detail/delegate_serialize.hpp"
#include "caf/detail/select_integer_type.hpp"

namespace caf {


/// A data processor translates an object into a format that can be
/// stored or vice versa. A data processor can be either in saving
/// or loading mode.
template <class Derived>
class data_processor {
public:
  // -- member types -----------------------------------------------------------

  /// Return type for `operator()`.
  using result_type = error;

  /// List of builtin types for data processors.
  using builtin_t =
    detail::type_list<
      int8_t,
      uint8_t,
      int16_t,
      uint16_t,
      int32_t,
      uint32_t,
      int64_t,
      uint64_t,
      float,
      double,
      long double,
      std::string,
      std::u16string,
      std::u32string
    >;

  /// List of builtin types for data processors as enum.
  enum builtin {
    i8_v,
    u8_v,
    i16_v,
    u16_v,
    i32_v,
    u32_v,
    i64_v,
    u64_v,
    float_v,
    double_v,
    ldouble_v,
    string8_v,
    string16_v,
    string32_v
  };

  // -- constructors, destructors, and assignment operators --------------------

  data_processor(const data_processor&) = delete;
  data_processor& operator=(const data_processor&) = delete;

  data_processor(execution_unit* ctx = nullptr) : context_(ctx) {
    // nop
  }

  virtual ~data_processor() {
    // nop
  }

  // -- pure virtual functions -------------------------------------------------

  /// Begins processing of an object. Saves the type information
  /// to the underlying storage when in saving mode, otherwise
  /// extracts them and sets both arguments accordingly.
  virtual error begin_object(uint16_t& typenr, std::string& name) = 0;

  /// Ends processing of an object.
  virtual error end_object() = 0;

  /// Begins processing of a sequence. Saves the size
  /// to the underlying storage when in saving mode, otherwise
  /// sets `num` accordingly.
  virtual error begin_sequence(size_t& num) = 0;

  /// Ends processing of a sequence.
  virtual error end_sequence() = 0;

  // -- getter -----------------------------------------------------------------

  /// Returns the actor system associated to this data processor.
  execution_unit* context() {
    return context_;
  }

  // -- apply functions --------------------------------------------------------

  /// Applies this processor to an arithmetic type.
  template <class T>
  typename std::enable_if<std::is_floating_point<T>::value, error>::type
  apply(T& x) {
    static constexpr auto tlindex = detail::tl_index_of<builtin_t, T>::value;
    static_assert(tlindex >= 0, "T not recognized as builtin type");
    return apply_builtin(static_cast<builtin>(tlindex), &x);
  }

  template <class T>
  typename std::enable_if<
    std::is_integral<T>::value
    && !std::is_same<bool, T>::value,
    error
  >::type
  apply(T& x) {
    using type =
      typename detail::select_integer_type<
        static_cast<int>(sizeof(T)) * (std::is_signed<T>::value ? -1 : 1)
      >::type;
    static constexpr auto tlindex = detail::tl_index_of<builtin_t, type>::value;
    static_assert(tlindex >= 0, "T not recognized as builtin type");
    return apply_builtin(static_cast<builtin>(tlindex), &x);
  }

  error apply(std::string& x) {
    return apply_builtin(string8_v, &x);
  }

  error apply(std::u16string& x) {
    return apply_builtin(string16_v, &x);
  }

  error apply(std::u32string& x) {
    return apply_builtin(string32_v, &x);
  }

  template <class D, atom_value V>
  static error apply_atom_constant(D& self, atom_constant<V>&) {
    static_assert(!D::writes_state, "cannot deserialize an atom_constant");
    auto x = V;
    return self.apply(x);
  }

  template <atom_value V>
  error apply(atom_constant<V>& x) {
    return apply_atom_constant(dref(), x);
  }

  /// Serializes enums using the underlying type
  /// if no user-defined serialization is defined.
  template <class T>
  typename std::enable_if<
    std::is_enum<T>::value
    && !detail::has_serialize<T>::value,
    error
  >::type
  apply(T& x) {
    using underlying = typename std::underlying_type<T>::type;
    struct {
      void operator()(T& lhs, underlying& rhs) const {
        lhs = static_cast<T>(rhs);
      }
      void operator()(underlying& lhs, T& rhs) const {
        lhs = static_cast<underlying>(rhs);
      }
    } assign;
    underlying tmp;
    return convert_apply(dref(), x, tmp, assign);
  }

  /// Applies this processor to an empty type.
  template <class T>
  typename std::enable_if<
    std::is_empty<T>::value && !detail::is_inspectable<Derived, T>::value,
    error
  >::type
  apply(T&) {
    return none;
  }

  error apply(bool& x) {
    struct {
      void operator()(bool& lhs, uint8_t& rhs) const {
        lhs = rhs != 0;
      }
      void operator()(uint8_t& lhs, bool& rhs) const {
        lhs = rhs ? 1 : 0;
      }
    } assign;
    uint8_t tmp;
    return convert_apply(dref(), x, tmp, assign);
  }

  // Special case to avoid using 1 byte per bool
  error apply(std::vector<bool>& x) {
    auto len = x.size();
    auto err = begin_sequence(len);
    if (err || len == 0)
      return err;
    struct {
      size_t len;
      void operator()(std::vector<bool>& lhs, std::vector<uint8_t>& rhs) const {
        lhs.resize(len, false);
        size_t cpt = 0;
        for (auto v: rhs) {
          for (int k = 0; k < 8; ++k) {
            lhs[cpt] = ((v & (1 << k)) != 0);
            if (++cpt >= len)
              return;
          }
        }
      }
      void operator()(std::vector<uint8_t>& lhs, std::vector<bool>& rhs) const {
        size_t k = 0;
        lhs.resize((rhs.size() - 1) / 8 + 1, 0);
        for (bool b: rhs) {
          if (b)
            lhs[k / 8] |= (1 << (k % 8));
          ++k;
        }
      }
    } assign;
    assign.len = len;
    std::vector<uint8_t> tmp;
    return convert_apply(dref(), x, tmp, assign);
  }

  template <class T>
  error consume_range(T& xs) {
    for (auto& x : xs) {
      using value_type = typename std::remove_const<
                           typename std::remove_reference<decltype(x)>::type
                         >::type;
      auto e = apply(const_cast<value_type&>(x));
      if (e)
        return e;
    }
    return none;
  }

  /// Converts each element in `xs` to `U` before calling `apply`.
  template <class U, class T>
  error consume_range_c(T& xs) {
    for (U x : xs) {
      auto e = apply(x);
      if (e)
        return e;
    }
    return none;
  }

  template <class T>
  error fill_range(T& xs, size_t num_elements) {
    auto insert_iter = std::inserter(xs, xs.end());
    for (size_t i = 0; i < num_elements; ++i) {
      typename std::remove_const<typename T::value_type>::type x;
      auto err = apply(x);
      if (err)
        return err;
      *insert_iter++ = std::move(x);
    }
    return none;
  }

  /// Loads elements from type `U` before inserting to `xs`.
  template <class U, class T>
  error fill_range_c(T& xs, size_t num_elements) {
    auto insert_iter = std::inserter(xs, xs.end());
    for (size_t i = 0; i < num_elements; ++i) {
      U x;
      auto err = apply(x);
      if (err)
        return err;
      *insert_iter++ = std::move(x);
    }
    return none;
  }
  // Applies this processor as Derived to `xs` in saving mode.
  template <class D, class T>
  static typename std::enable_if<
    D::reads_state && !detail::is_byte_sequence<T>::value,
    error
  >::type
  apply_sequence(D& self, T& xs) {
    auto s = xs.size();
    return error::eval([&] { return self.begin_sequence(s); },
                       [&] { return self.consume_range(xs); },
                       [&] { return self.end_sequence(); });
  }

  // Applies this processor as Derived to `xs` in loading mode.
  template <class D, class T>
  static typename std::enable_if<
    !D::reads_state && !detail::is_byte_sequence<T>::value,
    error
  >::type
  apply_sequence(D& self, T& xs) {
    size_t s;
    return error::eval([&] { return self.begin_sequence(s); },
                       [&] { return self.fill_range(xs, s); },
                       [&] { return self.end_sequence(); });
  }

  // Optimized saving for contiguous byte sequences.
  template <class D, class T>
  static typename std::enable_if<
    D::reads_state && detail::is_byte_sequence<T>::value,
    error
  >::type
  apply_sequence(D& self, T& xs) {
    auto s = xs.size();
    return error::eval([&] { return self.begin_sequence(s); },
                       [&] { return s > 0 ? self.apply_raw(xs.size(), &xs[0])
                                          : none; },
                       [&] { return self.end_sequence(); });
  }

  // Optimized loading for contiguous byte sequences.
  template <class D, class T>
  static typename std::enable_if<
    !D::reads_state && detail::is_byte_sequence<T>::value,
    error
  >::type
  apply_sequence(D& self, T& xs) {
    size_t s;
    return error::eval([&] { return self.begin_sequence(s); },
                       [&] { xs.resize(s);
                             return s > 0 ? self.apply_raw(s, &xs[0])
                                          : none; },
                       [&] { return self.end_sequence(); });
  }

  /// Applies this processor to a sequence of values.
  template <class T>
  typename std::enable_if<
    detail::is_iterable<T>::value
    && !detail::has_serialize<T>::value
    && !detail::is_inspectable<Derived, T>::value,
    error
  >::type
  apply(T& xs) {
    return apply_sequence(dref(), xs);
  }

  /// Applies this processor to an array.
  template <class T, size_t S>
  typename std::enable_if<detail::is_serializable<T>::value, error>::type
  apply(std::array<T, S>& xs) {
    return consume_range(xs);
  }

  /// Applies this processor to an array.
  template <class T, size_t S>
  typename std::enable_if<detail::is_serializable<T>::value, error>::type
  apply(T (&xs) [S]) {
    return consume_range(xs);
  }

  template <class F, class S>
  typename std::enable_if<
    detail::is_serializable<typename std::remove_const<F>::type>::value
    && detail::is_serializable<S>::value,
    error
  >::type
  apply(std::pair<F, S>& xs) {
    using t0 = typename std::remove_const<F>::type;
    // This cast allows the data processor to cope with
    // `pair<const K, V>` value types used by `std::map`.
    return error::eval([&] { return apply(const_cast<t0&>(xs.first)); },
                       [&] { return apply(xs.second); });
  }

  template <class... Ts>
  typename std::enable_if<
    detail::conjunction<
      detail::is_serializable<Ts>::value...
    >::value,
    error
  >::type
  apply(std::tuple<Ts...>& xs) {
    //apply_helper f{*this};
    return detail::apply_args(*this, detail::get_indices(xs), xs);
  }

  template <class T>
  typename std::enable_if<
    !std::is_empty<T>::value
    && detail::has_serialize<T>::value,
    error
  >::type
  apply(T& x) {
    // throws on error
    detail::delegate_serialize(dref(), x);
    return none;
  }

  template <class Rep, class Period>
  typename std::enable_if<std::is_integral<Rep>::value, error>::type
  apply(std::chrono::duration<Rep, Period>& x) {
    using duration_type = std::chrono::duration<Rep, Period>;
    // always save/store durations as int64_t to work around possibly
    // different integer types on different plattforms for standard typedefs
    struct {
      void operator()(duration_type& lhs, Rep& rhs) const {
        duration_type tmp{rhs};
        lhs = tmp;
      }
      void operator()(Rep& lhs, duration_type& rhs) const {
        lhs = rhs.count();
      }
    } assign;
    Rep tmp;
    return convert_apply(dref(), x, tmp, assign);
  }

  template <class Rep, class Period>
  typename std::enable_if<std::is_floating_point<Rep>::value, error>::type
  apply(std::chrono::duration<Rep, Period>& x) {
    using duration_type = std::chrono::duration<Rep, Period>;
    // always save/store floating point durations
    // as doubles for the same reason as above
    struct {
      void operator()(duration_type& lhs, double& rhs) const {
        duration_type tmp{rhs};
        lhs = tmp;
      }
      void operator()(double& lhs, duration_type& rhs) const {
        lhs = rhs.count();
      }
    } assign;
    double tmp;
    return convert_apply(dref(), x, tmp, assign);
  }

  template <class Duration>
  error apply(std::chrono::time_point<std::chrono::system_clock, Duration>& t) {
    if (Derived::reads_state) {
      auto dur = t.time_since_epoch();
      return apply(dur);
    }
    if (Derived::writes_state) {
      Duration dur;
      auto e = apply(dur);
      t = std::chrono::time_point<std::chrono::system_clock, Duration>{dur};
      return e;
    }
  }

  /// Applies this processor to a raw block of data of size `num_bytes`.
  virtual error apply_raw(size_t num_bytes, void* data) = 0;

  template <class T>
  typename std::enable_if<
    detail::is_inspectable<Derived, T>::value
      && !detail::has_serialize<T>::value,
    decltype(inspect(std::declval<Derived&>(), std::declval<T&>()))
  >::type
  apply(T& x) {
    return inspect(dref(), x);
  }

  // -- operator() -------------------------------------------------------------

  inline error operator()() {
    return none;
  }

  template <class F, class... Ts>
  error operator()(meta::save_callback_t<F> x, Ts&&... xs) {
    error e;
    if (Derived::reads_state)
      e = x.fun();
    return e ? e : (*this)(std::forward<Ts>(xs)...);
  }

  template <class F, class... Ts>
  error operator()(meta::load_callback_t<F> x, Ts&&... xs) {
    error e;
    if (Derived::writes_state)
      e = x.fun();
    return e ? e : (*this)(std::forward<Ts>(xs)...);
  }

  template <class... Ts>
  error operator()(const meta::annotation&, Ts&&... xs) {
    return (*this)(std::forward<Ts>(xs)...);
  }

  template <class T, class... Ts>
  typename std::enable_if<
    is_allowed_unsafe_message_type<T>::value,
    error
  >::type
  operator()(const T&, Ts&&... xs) {
    return (*this)(std::forward<Ts>(xs)...);
  }

  template <class T, class... Ts>
  typename std::enable_if<
    !meta::is_annotation<T>::value
    && !is_allowed_unsafe_message_type<T>::value,
    error
  >::type
  operator()(T&& x, Ts&&... xs) {
    static_assert(Derived::reads_state
                  || (!std::is_rvalue_reference<T&&>::value
                      && !std::is_const<
                             typename std::remove_reference<T>::type
                           >::value),
                  "a loading inspector requires mutable lvalue references");
    auto e = apply(deconst(x));
    return e ? e : (*this)(std::forward<Ts>(xs)...);
  }

protected:
  /// Applies this processor to a single builtin value.
  virtual error apply_builtin(builtin in_out_type, void* in_out) = 0;

private:
  template <class T>
  T& deconst(const T& x) {
    return const_cast<T&>(x);
  }

  template <class D, class T, class U, class F>
  static typename std::enable_if<D::reads_state, error>::type
  convert_apply(D& self, T& x, U& storage, F assign) {
    assign(storage, x);
    return self.apply(storage);
  }

  template <class D, class T, class U, class F>
  static typename std::enable_if<!D::reads_state, error>::type
  convert_apply(D& self, T& x, U& storage, F assign) {
    auto e = self.apply(storage);
    if (e)
      return e;
    assign(x, storage);
    return none;
  }

  // Returns a reference to the derived type.
  Derived& dref() {
    return *static_cast<Derived*>(this);
  }

  execution_unit* context_;
};

} // namespace caf

#endif // CAF_DATA_PROCESSOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TERM_HPP
#define CAF_TERM_HPP

#include <iosfwd>

namespace caf {

/// Terminal color and font face options.
enum class term {
  /// Resets the color to the default color and the font weight to normal.
  reset,
  /// Like `reset` but also prints a newline.
  reset_endl,
  /// Sets the terminal color to black.
  black,
  /// Sets the terminal color to red.
  red,
  /// Sets the terminal color to green.
  green,
  /// Sets the terminal color to yellow.
  yellow,
  /// Sets the terminal color to blue.
  blue,
  /// Sets the terminal color to magenta.
  magenta,
  /// Sets the terminal color to cyan.
  cyan,
  /// Sets the terminal color to white.
  white,
  /// Sets the terminal color to black and the font weight to bold.
  bold_black,
  /// Sets the terminal color to red and the font weight to bold.
  bold_red,
  /// Sets the terminal color to green and the font weight to bold.
  bold_green,
  /// Sets the terminal color to yellow and the font weight to bold.
  bold_yellow,
  /// Sets the terminal color to blue and the font weight to bold.
  bold_blue,
  /// Sets the terminal color to magenta and the font weight to bold.
  bold_magenta,
  /// Sets the terminal color to cyan and the font weight to bold.
  bold_cyan,
  /// Sets the terminal color to white and the font weight to bold.
  bold_white
};

std::ostream& operator<<(std::ostream& out, term x);

} // namespace caf

#endif // CAF_TERM_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DELEGATED_HPP
#define CAF_DELEGATED_HPP

#include <type_traits>

namespace caf {

/// Helper class to indicate that a request has been forwarded.
template <class... Ts>
class delegated {
  // nop
};


template <class... Ts>
inline bool operator==(const delegated<Ts...>&, const delegated<Ts...>&) {
  return true;
}

} // namespace caf

#endif // CAF_DELEGATED_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ABSTRACT_COMPOSABLE_STATE_HPP
#define CAF_ABSTRACT_COMPOSABLE_STATE_HPP

#include <utility>

#include "caf/fwd.hpp"

namespace caf {

/// Marker type that allows CAF to spawn actors from composable states.
class abstract_composable_behavior {
public:
  virtual ~abstract_composable_behavior();

  virtual void init_behavior(message_handler& x) = 0;
};

} // namespace caf

#endif // CAF_ABSTRACT_COMPOSABLE_STATE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_GATHERER_HPP
#define CAF_STREAM_GATHERER_HPP

#include <vector>
#include <cstdint>
#include <utility>

#include "caf/fwd.hpp"

namespace caf {

/// Type-erased policy for receiving data from sources.
class stream_gatherer {
public:
  // -- member types -----------------------------------------------------------

  /// Type of a single path to a data source.
  using path_type = inbound_path;

  /// Pointer to a single path to a data source.
  using path_ptr = path_type*;

  // -- constructors, destructors, and assignment operators --------------------

  stream_gatherer() = default;

  virtual ~stream_gatherer();

  // -- pure virtual memeber functions -----------------------------------------

  /// Adds a path to the edge and emits `ack_open` to the source.
  /// @param sid Stream ID used by the source.
  /// @param x Handle to the source.
  /// @param original_stage Actor that received the stream handshake initially.
  /// @param prio Priority of data on this path.
  /// @param available_credit Maximum credit for granting to the source.
  /// @param redeployable Stores whether the source can re-appear after aborts.
  /// @param result_cb Callback for the listener of the final stream result.
  ///                  The gatherer must ignore the promise when returning
  ///                  `nullptr`, because the previous stage is responsible for
  ///                  it until the gatherer acknowledges the handshake. The
  ///                  callback is invalid if the stream has a next stage.
  /// @returns The added path on success, `nullptr` otherwise.
  virtual path_ptr add_path(const stream_id& sid, strong_actor_ptr x,
                            strong_actor_ptr original_stage,
                            stream_priority prio, long available_credit,
                            bool redeployable, response_promise result_cb) = 0;

  /// Removes a path from the gatherer.
  virtual bool remove_path(const stream_id& sid, const actor_addr& x,
                           error reason, bool silent) = 0;

  /// Removes all paths gracefully.
  virtual void close(message result) = 0;

  /// Removes all paths with an error message.
  virtual void abort(error reason) = 0;

  /// Returns the number of paths managed on this edge.
  virtual long num_paths() const = 0;

  /// Returns `true` if no downstream exists, `false` otherwise.
  virtual bool closed() const = 0;

  /// Returns whether this edge remains open after the last path is removed.
  virtual bool continuous() const = 0;

  /// Sets whether this edge remains open after the last path is removed.
  virtual void continuous(bool value) = 0;

  /// Returns the stored state for `x` if `x` is a known path and associated to
  /// `sid`, otherwise `nullptr`.
  virtual path_ptr find(const stream_id& sid, const actor_addr& x) = 0;

  /// Returns the stored state for `x` if `x` is a known path and associated to
  /// `sid`, otherwise `nullptr`.
  virtual path_ptr path_at(size_t index) = 0;

  /// Returns the point at which an actor stops sending out demand immediately
  /// (waiting for the available credit to first drop below the watermark).
  virtual long high_watermark() const = 0;

  /// Returns the minimum amount of credit required to send a `demand` message.
  virtual long min_credit_assignment() const = 0;

  /// Returns the maximum credit assigned to a single upstream actors.
  virtual long max_credit() const = 0;

  /// Sets the point at which an actor stops sending out demand immediately
  /// (waiting for the available credit to first drop below the watermark).
  virtual void high_watermark(long x) = 0;

  /// Sets the minimum amount of credit required to send a `demand` message.
  virtual void min_credit_assignment(long x) = 0;

  /// Sets the maximum credit assigned to a single upstream actors.
  virtual void max_credit(long x) = 0;

  /// Assigns new credit to all sources.
  virtual void assign_credit(long downstream_capacity) = 0;

  /// Calculates initial credit for `x` after adding it to the gatherer.
  virtual long initial_credit(long downstream_capacity, path_ptr x) = 0;

  // -- convenience functions --------------------------------------------------

  /// Removes a path from the gatherer.
  bool remove_path(const stream_id& sid, const strong_actor_ptr& x,
                   error reason, bool silent);

  /// Convenience function for calling `find(x, actor_cast<actor_addr>(x))`.
  path_ptr find(const stream_id& sid, const strong_actor_ptr& x);
};

} // namespace caf

#endif // CAF_STREAM_GATHERER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DOWNSTREAM_HPP
#define CAF_DOWNSTREAM_HPP

#include <deque>
#include <vector>

#include "caf/make_message.hpp"

namespace caf {

/// Grants access to an output stream buffer.
template <class T>
class downstream {
public:
  // -- member types -----------------------------------------------------------

  /// A queue of items for temporary storage before moving them into chunks.
  using queue_type = std::deque<T>;

  // -- constructors, destructors, and assignment operators --------------------

  downstream(queue_type& q) : buf_(q) {
    // nop
  }

  // -- queue access -----------------------------------------------------------

  template <class... Ts>
  void push(Ts&&... xs) {
    buf_.emplace_back(std::forward<Ts>(xs)...);
  }

  // @private
  queue_type& buf() {
    return buf_;
  }

protected:
  queue_type& buf_;
};

} // namespace caf

#endif // CAF_DOWNSTREAM_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_SOURCE_TRAIT_HPP
#define CAF_STREAM_SOURCE_TRAIT_HPP

#include "caf/detail/type_traits.hpp"

namespace caf {

template <class F>
struct stream_source_trait;

template <class State, class T>
struct stream_source_trait<void (State&, downstream<T>&, size_t)> {
  using output = T;
  using state = State;
};

template <class F>
using stream_source_trait_t =
  stream_source_trait<typename detail::get_callable_trait<F>::fun_sig>;

} // namespace caf

#endif // CAF_STREAM_SOURCE_TRAIT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MONITORABLE_ACTOR_HPP
#define CAF_MONITORABLE_ACTOR_HPP

#include <set>
#include <mutex>
#include <atomic>
#include <memory>
#include <string>
#include <vector>
#include <cstdint>
#include <type_traits>
#include <condition_variable>

#include "caf/type_nr.hpp"
#include "caf/actor_addr.hpp"
#include "caf/actor_cast.hpp"
#include "caf/abstract_actor.hpp"
#include "caf/mailbox_element.hpp"

#include "caf/detail/type_traits.hpp"
#include "caf/detail/functor_attachable.hpp"

namespace caf {

/// Base class for all actor implementations.
class monitorable_actor : public abstract_actor {
public:
  /// Returns an implementation-dependent name for logging purposes, which
  /// is only valid as long as the actor is running. The default
  /// implementation simply returns "actor".
  virtual const char* name() const;

  void attach(attachable_ptr ptr) override;

  size_t detach(const attachable::token& what) override;

  // -- linking and monitoring -------------------------------------------------

  /// Links this actor to `x`.
  void link_to(const actor_addr& x) {
    auto ptr = actor_cast<strong_actor_ptr>(x);
    if (ptr && ptr->get() != this)
      add_link(ptr->get());
  }

  /// Links this actor to `x`.
  template <class ActorHandle>
  void link_to(const ActorHandle& x) {
    auto ptr = actor_cast<abstract_actor*>(x);
    if (ptr && ptr != this)
      add_link(ptr);
  }

  /// Unlinks this actor from `x`.
  void unlink_from(const actor_addr& x);

  /// Links this actor to `x`.
  template <class ActorHandle>
  void unlink_from(const ActorHandle& x) {
    auto ptr = actor_cast<abstract_actor*>(x);
    if (ptr && ptr != this)
      remove_link(ptr);
  }

  /// @cond PRIVATE

  /// Called by the runtime system to perform cleanup actions for this actor.
  /// Subtypes should always call this member function when overriding it.
  /// This member function is thread-safe, and if the actor has already exited
  /// upon invocation, nothing is done. The return value of this member
  /// function is ignored by scheduled actors.
  virtual bool cleanup(error&& reason, execution_unit* host);

  void add_link(abstract_actor* x) override;

  void remove_link(abstract_actor* x) override;

  bool add_backlink(abstract_actor* x) override;

  bool remove_backlink(abstract_actor* x) override;

  /// @endcond

protected:
  /// Allows subclasses to add additional cleanup code to the
  /// critical secion in `cleanup`. This member function is
  /// called inside of a critical section.
  virtual void on_cleanup();

  /// Sends a response message if `what` is a request.
  void bounce(mailbox_element_ptr& what);

  /// Sends a response message if `what` is a request.
  void bounce(mailbox_element_ptr& what, const error& err);

  /// Creates a new actor instance.
  explicit monitorable_actor(actor_config& cfg);

  /****************************************************************************
   *                 here be dragons: end of public interface                 *
   ****************************************************************************/

  // precondition: `mtx_` is acquired
  inline void attach_impl(attachable_ptr& ptr) {
    ptr->next.swap(attachables_head_);
    attachables_head_.swap(ptr);
  }

  // precondition: `mtx_` is acquired
  size_t detach_impl(const attachable::token& what, bool stop_on_hit = false,
                     bool dry_run = false);

  // handles only `exit_msg` and `sys_atom` messages;
  // returns true if the message is handled
  bool handle_system_message(mailbox_element& x, execution_unit* ctx,
                             bool trap_exit);

  // handles `exit_msg`, `sys_atom` messages, and additionally `down_msg`
  // with `down_msg_handler`; returns true if the message is handled
  template <class F>
  bool handle_system_message(mailbox_element& x, execution_unit* context,
                             bool trap_exit, F& down_msg_handler) {
    auto& content = x.content();
    if (content.type_token() == make_type_token<down_msg>()) {
      if (content.shared()) {
        auto vptr = content.copy(0);
        down_msg_handler(vptr->get_mutable_as<down_msg>());
      } else {
        down_msg_handler(content.get_mutable_as<down_msg>(0));
      }
      return true;
    }
    return handle_system_message(x, context, trap_exit);
  }

  // is protected by `mtx_` in actors that are not scheduled, but
  // can be accessed without lock for event-based and blocking actors
  error fail_state_;

  // only used in blocking and thread-mapped actors
  mutable std::condition_variable cv_;

  // attached functors that are executed on cleanup (monitors, links, etc)
  attachable_ptr attachables_head_;

 /// @endcond
};

} // namespace caf

#endif // CAF_MONITORABLE_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ACTOR_OSTREAM_HPP
#define CAF_ACTOR_OSTREAM_HPP

#include "caf/actor.hpp"
#include "caf/deep_to_string.hpp"
#include "caf/typed_actor_pointer.hpp"

namespace caf {

/// Provides support for thread-safe output operations on character streams. The
/// stream operates on a per-actor basis and will print only complete lines or
/// when explicitly forced to flush its buffer. The stream will convert *any*
/// operation to a message received by a printer actor. This actor is a sequence
/// point that ensures output appears never interleaved.
class actor_ostream {
public:
  using fun_type = actor_ostream& (*)(actor_ostream&);

  actor_ostream(actor_ostream&&) = default;
  actor_ostream(const actor_ostream&) = default;
  actor_ostream& operator=(actor_ostream&&) = default;
  actor_ostream& operator=(const actor_ostream&) = default;

  /// Open redirection file in append mode.
  static constexpr int append = 0x01;

  explicit actor_ostream(local_actor* self);

  explicit actor_ostream(scoped_actor& self);

  template <class... Sigs>
  explicit actor_ostream(const typed_actor_pointer<Sigs...>& ptr)
      : actor_ostream(ptr.internal_ptr()) {
    // nop
  }

  /// Writes `arg` to the buffer allocated for the calling actor.
  actor_ostream& write(std::string arg);

  /// Flushes the buffer allocated for the calling actor.
  actor_ostream& flush();

  /// Redirects all further output from `self` to `file_name`.
  static void redirect(abstract_actor* self, std::string fn, int flags = 0);

  /// Redirects all further output from any actor that did not
  /// redirect its output to `fname`.
  static void redirect_all(actor_system& sys, std::string fn, int flags = 0);

  /// Writes `arg` to the buffer allocated for the calling actor.
  inline actor_ostream& operator<<(const char* arg) {
    return write(arg);
  }

  /// Writes `arg` to the buffer allocated for the calling actor.
  inline actor_ostream& operator<<(std::string arg) {
    return write(std::move(arg));
  }

  /// Writes `to_string(arg)` to the buffer allocated for the calling actor,
  /// calling either `std::to_string` or `caf::to_string` depending on
  /// the argument.
  template <class T>
  inline actor_ostream& operator<<(const T& arg) {
    return write(deep_to_string(arg));
  }

  /// Apply `f` to `*this`.
  inline actor_ostream& operator<<(actor_ostream::fun_type f) {
    return f(*this);
  }

private:
  void init(abstract_actor*);

  actor_id self_;
  actor printer_;
};

/// Convenience factory function for creating an actor output stream.
actor_ostream aout(local_actor* self);

/// Convenience factory function for creating an actor output stream.
actor_ostream aout(scoped_actor& self);

/// Convenience factory function for creating an actor output stream.
template <class... Sigs>
actor_ostream aout(const typed_actor_pointer<Sigs...>& ptr) {
  return actor_ostream{ptr};
}

} // namespace caf

namespace std {
// provide convenience overlaods for aout; implemented in logging.cpp
caf::actor_ostream& endl(caf::actor_ostream& o);
caf::actor_ostream& flush(caf::actor_ostream& o);
} // namespace std

#endif // CAF_ACTOR_OSTREAM_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_THREAD_HOOK_HPP
#define CAF_THREAD_HOOK_HPP

namespace caf {

/// Interface to define thread hooks.
class thread_hook {
public:
  virtual ~thread_hook() {
    // nop
  }

  /// Called by the actor system once before starting any threads.
  virtual void init(actor_system&) = 0;

  /// Called whenever the actor system has started a new thread.
  /// To access a reference to the started thread use `std::this_thread`.
  /// @warning must the thread-safe
  virtual void thread_started() = 0;

  /// Called whenever a thread is about to quit.
  /// To access a reference to the terminating thread use `std::this_thread`.
  /// @warning must the thread-safe
  virtual void thread_terminates() = 0;
};

} // namespace caf

#endif // CAF_THREAD_HOOK_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_COMPOSED_TYPE_HPP
#define CAF_COMPOSED_TYPE_HPP

#include "caf/fwd.hpp"
#include "caf/replies_to.hpp"

#include "caf/detail/type_list.hpp"

namespace caf {

/// Computes the type for f*g (actor composition).
///
/// ~~~
/// let output_type x = case x of Stream y -> y ; Single y -> y
///
/// let propagate_stream from to = case from of
///                                  Stream _ -> Stream (output_type to)
///                                  Single _ -> to
/// let composed_type f g =
///   [(fst x, propagate_stream (snd x) (snd y)) | x <- g, y <- f,
///                                                output_type (snd x) == fst y]
/// ~~~
///
/// This class implements the list comprehension above in a
/// single shot with worst case n*m template instantiations using an
/// inner and outer loop, where n is the size
/// of Xs and m the size of Ys. Zs is a helper that models the
/// "inner loop variable" for generating the cross product of Xs and Ys.
/// The helper function propagate_stream is integrated into the loop with
/// four cases for the matching case. Rs collects the results.

template <class Xs, class Ys, class Zs, class Rs>
struct composed_type;

// end of outer loop over Xs
template <class Ys, class Zs, class... Rs>
struct composed_type<detail::type_list<>, Ys, Zs, detail::type_list<Rs...>> {
  using type = typed_actor<Rs...>;
};

// end of inner loop Ys (Zs)
template <class X, class... Xs, class Ys, class Rs>
struct composed_type<detail::type_list<X, Xs...>, Ys, detail::type_list<>, Rs>
    : composed_type<detail::type_list<Xs...>, Ys, Ys, Rs> {};

// case #1
template <class... In, class... Out, class... Xs, class Ys,
          class... MapsTo, class... Zs, class... Rs>
struct composed_type<detail::type_list<typed_mpi<detail::type_list<In...>,
                                            output_tuple<Out...>>, Xs...>,
                     Ys,
                     detail::type_list<typed_mpi<detail::type_list<Out...>,
                                            output_tuple<MapsTo...>>, Zs...>,
                     detail::type_list<Rs...>>
    : composed_type<detail::type_list<Xs...>, Ys, Ys,
                    detail::type_list<Rs..., typed_mpi<detail::type_list<In...>,
                                                  output_tuple<MapsTo...>>>> {};

// case #2
template <class... In, class... Out, class... Xs, class Ys,
          class... MapsTo, class... Zs, class... Rs>
struct composed_type<detail::type_list<typed_mpi<detail::type_list<In...>,
                                                 output_tuple<Out...>>, Xs...>,
                     Ys,
                     detail::type_list<typed_mpi<detail::type_list<Out...>,
                                                 output_stream<MapsTo...>>,
                                       Zs...>,
                     detail::type_list<Rs...>>
    : composed_type<detail::type_list<Xs...>, Ys, Ys,
                    detail::type_list<Rs...,
                                      typed_mpi<detail::type_list<In...>,
                                                output_stream<MapsTo...>>>> {};

// case #3
template <class... In, class... Out, class... Xs, class Ys,
          class... MapsTo, class... Zs, class... Rs>
struct composed_type<detail::type_list<typed_mpi<detail::type_list<In...>,
                                            output_stream<Out...>>, Xs...>,
                     Ys,
                     detail::type_list<typed_mpi<detail::type_list<Out...>,
                                            output_tuple<MapsTo...>>, Zs...>,
                     detail::type_list<Rs...>>
    : composed_type<detail::type_list<Xs...>, Ys, Ys,
                    detail::type_list<Rs...,
                                      typed_mpi<detail::type_list<In...>,
                                                output_stream<MapsTo...>>>> {};

// case #4
template <class... In, class... Out, class... Xs, class Ys,
          class... MapsTo, class... Zs, class... Rs>
struct composed_type<detail::type_list<typed_mpi<detail::type_list<In...>,
                                            output_stream<Out...>>, Xs...>,
                     Ys,
                     detail::type_list<typed_mpi<detail::type_list<Out...>,
                                            output_stream<MapsTo...>>, Zs...>,
                     detail::type_list<Rs...>>
    : composed_type<detail::type_list<Xs...>, Ys, Ys,
                    detail::type_list<Rs...,
                                      typed_mpi<detail::type_list<In...>,
                                                output_stream<MapsTo...>>>> {};

// default case (recurse over Zs)
template <class In, class Out, class... Xs, class Ys,
          class Unrelated, class MapsTo, class... Zs, class Rs>
struct composed_type<detail::type_list<typed_mpi<In, Out>, Xs...>,
                     Ys,
                     detail::type_list<typed_mpi<Unrelated, MapsTo>, Zs...>,
                     Rs>
    : composed_type<detail::type_list<typed_mpi<In, Out>, Xs...>,
                    Ys, detail::type_list<Zs...>, Rs> {};

/// Convenience type alias.
/// @relates composed_type
template <class F, class G>
using composed_type_t =
  typename composed_type<G, F, F, detail::type_list<>>::type;

} // namespace caf

#endif // CAF_COMPOSED_TYPE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_META_LOAD_CALLBACK_HPP
#define CAF_META_LOAD_CALLBACK_HPP

#include "caf/meta/annotation.hpp"

namespace caf {
namespace meta {

template <class F>
struct load_callback_t : annotation {
  load_callback_t(F&& f) : fun(f) {
    // nop
  }

  load_callback_t(load_callback_t&&) = default;

  load_callback_t(const load_callback_t&) = default;

  F fun;
};

/// Returns an annotation that allows inspectors to call
/// user-defined code after performing load operations.
template <class F>
load_callback_t<F> load_callback(F fun) {
  return {std::move(fun)};
}

} // namespace meta
} // namespace caf

#endif // CAF_META_LOAD_CALLBACK_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_META_HEX_FORMATTED_HPP
#define CAF_META_HEX_FORMATTED_HPP

#include "caf/meta/annotation.hpp"

namespace caf {
namespace meta {

struct hex_formatted_t : annotation {
  constexpr hex_formatted_t() {
    // nop
  }
};

/// Advises the inspector to format the following data field in hex format.
constexpr hex_formatted_t hex_formatted() {
  return {};
}

} // namespace meta
} // namespace caf

#endif // CAF_META_HEX_FORMATTED_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_META_OMITTABLE_IF_NONE_HPP
#define CAF_META_OMITTABLE_IF_NONE_HPP

#include "caf/meta/annotation.hpp"

namespace caf {
namespace meta {

struct omittable_if_none_t : annotation {
  constexpr omittable_if_none_t() {
    // nop
  }
};

/// Allows an inspector to omit the following data field if it is empty.
constexpr omittable_if_none_t omittable_if_none() {
  return {};
}

} // namespace meta
} // namespace caf

#endif // CAF_META_OMITTABLE_IF_NONE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_META_ANNOTATION_HPP
#define CAF_META_ANNOTATION_HPP

#include <type_traits>

namespace caf {
namespace meta {

/// Type tag for all meta annotations in CAF.
struct annotation {
  constexpr annotation() {
    // nop
  }
};

template <class T>
struct is_annotation {
  static constexpr bool value = std::is_base_of<annotation, T>::value;
};

template <class T>
struct is_annotation<T&> : is_annotation<T> {};

template <class T>
struct is_annotation<const T&> : is_annotation<T> {};

template <class T>
struct is_annotation<T&&> : is_annotation<T> {};

} // namespace meta
} // namespace caf

#endif // CAF_META_ANNOTATION_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_META_SAVE_CALLBACK_HPP
#define CAF_META_SAVE_CALLBACK_HPP

#include "caf/meta/annotation.hpp"

namespace caf {
namespace meta {

template <class F>
struct save_callback_t : annotation {
  save_callback_t(F&& f) : fun(f) {
    // nop
  }

  save_callback_t(save_callback_t&&) = default;

  save_callback_t(const save_callback_t&) = default;

  F fun;
};

/// Returns an annotation that allows inspectors to call
/// user-defined code after performing save operations.
template <class F>
save_callback_t<F> save_callback(F fun) {
  return {std::move(fun)};
}

} // namespace meta
} // namespace caf

#endif // CAF_META_SAVE_CALLBACK_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_META_OMITTABLE_HPP
#define CAF_META_OMITTABLE_HPP

#include "caf/meta/annotation.hpp"

namespace caf {
namespace meta {

struct omittable_t : annotation {
  constexpr omittable_t() {
    // nop
  }
};

/// Allows an inspector to omit the following data field
/// unconditionally when producing human-friendly output.
constexpr omittable_t omittable() {
  return {};
}

} // namespace meta
} // namespace caf

#endif // CAF_META_OMITTABLE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_META_TYPE_NAME_HPP
#define CAF_META_TYPE_NAME_HPP

#include "caf/meta/annotation.hpp"

namespace caf {
namespace meta {

struct type_name_t : annotation {
  constexpr type_name_t(const char* cstr) : value(cstr) {
    // nop
  }

  const char* value;
};

/// Returns a type name annotation.
type_name_t constexpr type_name(const char* cstr) {
  return {cstr};
}
} // namespace meta
} // namespace caf

#endif // CAF_META_TYPE_NAME_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_META_OMITTABLE_IF_EMPTY_HPP
#define CAF_META_OMITTABLE_IF_EMPTY_HPP

#include "caf/meta/annotation.hpp"

namespace caf {
namespace meta {

struct omittable_if_empty_t : annotation {
  constexpr omittable_if_empty_t() {
    // nop
  }
};

/// Allows an inspector to omit the following data field if it is empty.
constexpr omittable_if_empty_t omittable_if_empty() {
  return {};
}

} // namespace meta
} // namespace caf

#endif // CAF_META_OMITTABLE_IF_EMPTY_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_INDEX_MAPPING_HPP
#define CAF_INDEX_MAPPING_HPP

#include <tuple>
#include <string>
#include <functional>

#include "caf/meta/type_name.hpp"

namespace caf {

/// Marker for representing placeholders at runtime.
struct index_mapping {
  int value;

  explicit index_mapping(int x) : value(x) {
    // nop
  }

  template <class T,
            class E = typename std::enable_if<
                        std::is_placeholder<T>::value != 0
                      >::type>
  index_mapping(T) : value(std::is_placeholder<T>::value) {
    // nop
  }
};

inline bool operator==(const index_mapping& x, const index_mapping& y) {
  return x.value == y.value;
}

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, index_mapping& x) {
  return f(meta::type_name("index_mapping"), x.value);
}

} // namespace caf

#endif // CAF_INDEX_MAPPING_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_RESULT_HPP
#define CAF_RESULT_HPP

#include "caf/fwd.hpp"
#include "caf/none.hpp"
#include "caf/skip.hpp"
#include "caf/error.hpp"
#include "caf/expected.hpp"
#include "caf/message.hpp"
#include "caf/delegated.hpp"

#include "caf/detail/type_list.hpp"

namespace caf {

enum result_runtime_type {
  rt_value,
  rt_error,
  rt_delegated,
  rt_skip
};

template <class... Ts>
class result {
public:
  result(Ts... xs) : flag(rt_value), value(make_message(std::move(xs)...)) {
    // nop
  }

  template <class U, class... Us>
  result(U x, Us... xs) : flag(rt_value) {
    init(std::move(x), std::move(xs)...);
  }

  template <class E, class = enable_if_has_make_error_t<E>>
  result(E x) : flag(rt_error), err(make_error(x)) {
    // nop
  }

  result(error x) : flag(rt_error), err(std::move(x)) {
    // nop
  }

  template <
    class T,
    class = typename std::enable_if<
      sizeof...(Ts) == 1
      && std::is_convertible<
           T,
           detail::tl_head_t<detail::type_list<Ts...>>
         >::value
    >::type
  >
  result(expected<T> x) {
    if (x) {
      flag = rt_value;
      init(std::move(*x));
    } else {
      flag = rt_error;
      err = std::move(x.error());
    }
  }

  result(skip_t) : flag(rt_skip) {
    // nop
  }

  result(delegated<Ts...>) : flag(rt_delegated) {
    // nop
  }

  result(const typed_response_promise<Ts...>&) : flag(rt_delegated) {
    // nop
  }

  result(const response_promise&) : flag(rt_delegated) {
    // nop
  }

  result_runtime_type flag;
  message value;
  error err;

private:
  void init(Ts... xs) {
    value = make_message(std::move(xs)...);
  }
};

template <>
struct result<void> {
public:
  result() : flag(rt_value) {
    // nop
  }

  result(const unit_t&) : flag(rt_value) {
    // nop
  }

  template <class E, class = enable_if_has_make_error_t<E>>
  result(E x) : flag(rt_error), err(make_error(x)) {
    // nop
  }

  result(error x) : flag(rt_error), err(std::move(x)) {
    // nop
  }

  result(expected<void> x) {
    if (x) {
      flag = rt_value;
    } else {
      flag = rt_error;
      err = std::move(x.error());
    }
  }

  result(skip_t) : flag(rt_skip) {
    // nop
  }

  result(delegated<void>) : flag(rt_delegated) {
    // nop
  }

  result(const typed_response_promise<void>&) : flag(rt_delegated) {
    // nop
  }

  result(const response_promise&) : flag(rt_delegated) {
    // nop
  }

  result_runtime_type flag;
  message value;
  error err;
};

template <>
struct result<unit_t> : result<void> {

  using super = result<void>;

  using super::super;
};

template <class T>
struct is_result : std::false_type {};

template <class... Ts>
struct is_result<result<Ts...>> : std::true_type {};

} // namespace caf

#endif // CAF_RESULT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_COMPOSABLE_STATE_HPP
#define CAF_COMPOSABLE_STATE_HPP

#include "caf/param.hpp"
#include "caf/behavior.hpp"
#include "caf/replies_to.hpp"
#include "caf/typed_actor.hpp"
#include "caf/typed_actor_pointer.hpp"
#include "caf/abstract_composable_behavior.hpp"

namespace caf {

/// Generates an interface class that provides `operator()`. The signature
/// of the apply operator is derived from the typed message passing interface
/// `MPI`.
template <class MPI>
class composable_behavior_base;

template <class... Xs, class... Ys>
class composable_behavior_base<typed_mpi<detail::type_list<Xs...>,
                                         output_tuple<Ys...>>> {
public:
  virtual ~composable_behavior_base() noexcept {
    // nop
  }

  virtual result<Ys...> operator()(param_t<Xs>...) = 0;

  // C++14 and later
# if __cplusplus > 201103L
  auto make_callback() {
    return [=](param_t<Xs>... xs) { return (*this)(std::move(xs)...); };
  }
# else
  // C++11
  std::function<result<Ys...> (param_t<Xs>...)> make_callback() {
    return [=](param_t<Xs>... xs) { return (*this)(std::move(xs)...); };
  }
# endif
};

/// Base type for composable actor states.
template <class TypedActor>
class composable_behavior;

template <class... Clauses>
class composable_behavior<typed_actor<Clauses...>>
  : virtual public abstract_composable_behavior,
    public composable_behavior_base<Clauses>... {
public:
  using signatures = detail::type_list<Clauses...>;

  using handle_type =
    typename detail::tl_apply<
      signatures,
      typed_actor
    >::type;

  using actor_base = typename handle_type::base;

  using broker_base = typename handle_type::broker_base;

  using behavior_type = typename handle_type::behavior_type;

  composable_behavior() : self(nullptr) {
    // nop
  }

  template <class SelfPointer>
  unit_t init_selfptr(SelfPointer x) {
    CAF_ASSERT(x != nullptr);
    self = x;
    return unit;
  }

  void init_behavior(message_handler& x) override {
    init_behavior_impl(x);
  }

  unit_t init_behavior_impl(message_handler& x) {
    if (x)
      x = x.or_else(composable_behavior_base<Clauses>::make_callback()...);
    else
      x.assign(composable_behavior_base<Clauses>::make_callback()...);
    return unit;
  }

  typed_actor_pointer<Clauses...> self;
};

} // namespace caf

#endif // CAF_COMPOSABLE_STATE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_VARIANT_HPP
#define CAF_VARIANT_HPP

#include <type_traits>

#include "caf/config.hpp"
#include "caf/fwd.hpp"
#include "caf/static_visitor.hpp"

#include "caf/meta/omittable.hpp"

#include "caf/detail/type_list.hpp"
#include "caf/detail/type_traits.hpp"
#include "caf/detail/variant_data.hpp"

#define CAF_VARIANT_CASE(n)                                                    \
  case n:                                                                      \
    return f(std::forward<Us>(xs)...,                                          \
             x.get(std::integral_constant<int, (n <= max_type_id ? n : 0)>()))

#define CAF_VARIANT_DISPATCH_CASE(n)                                           \
  case n:                                                                      \
    return next.template apply_impl<Result>(                                   \
      std::forward<Variant>(next), std::forward<Visitor>(f),                   \
      std::forward<Us>(xs)...,                                                 \
      x.get(std::integral_constant<int, (n <= max_type_id ? n : 0)>()))

#define CAF_VARIANT_ASSIGN_CASE(n)                                             \
  case n: {                                                                    \
    using tmp_t = typename detail::tl_at<                                      \
                    detail::type_list<Ts...>,                                  \
                    (n < sizeof...(Ts) ? n : 0)                                \
                  >::type;                                                     \
    x.x = tmp_t{};                                                             \
    return f(get<tmp_t>(x.x));                                                 \
  }

namespace caf {

constexpr size_t variant_npos = static_cast<size_t>(-1);

struct variant_marker_t {};

constexpr variant_marker_t variant_marker = variant_marker_t{};

template <class T>
struct is_variant : std::false_type {};

template <class... Ts>
struct is_variant<variant<Ts...>> : std::true_type {};

template <class... Ts>
struct is_variant<variant<Ts...>&> : std::true_type {};

template <class... Ts>
struct is_variant<const variant<Ts...>&> : std::true_type {};

template <class... Ts>
struct is_variant<const variant<Ts...>&&> : std::true_type {};

template <class T>
struct variant_assign_helper {
  using result_type = void;
  T& lhs;
  variant_assign_helper(T& lhs_ref) : lhs(lhs_ref) { }
  template <class U>
  void operator()(const U& rhs) const {
    lhs = rhs;
  }
};

template <class T>
struct variant_move_helper {
  using result_type = void;
  T& lhs;
  variant_move_helper(T& lhs_ref) : lhs(lhs_ref) { }
  template <class U>
  void operator()(U& rhs) const {
    lhs = std::move(rhs);
  }
};

template <bool Valid, class F, class... Ts>
struct variant_visit_result_impl {
  using type =
    decltype((std::declval<F&>())(std::declval<typename Ts::type0&>()...));
};

template <class F, class... Ts>
struct variant_visit_result_impl<false, F, Ts...> {};

template <class F, class... Ts>
struct variant_visit_result
    : variant_visit_result_impl<
        detail::conjunction<is_variant<Ts>::value...>::value, F, Ts...> {};

template <class F, class... Ts>
using variant_visit_result_t =
  typename variant_visit_result<detail::decay_t<F>,
                                detail::decay_t<Ts>...>::type;

template <class T, class U,
          bool Enable = std::is_integral<T>::value
                        && std::is_integral<U>::value
                        && !std::is_same<T, bool>::value>
struct is_equal_int_type {
  static constexpr bool value = sizeof(T) == sizeof(U)
                                && std::is_signed<T>::value
                                   == std::is_signed<U>::value;
};

template <class T, typename U>
struct is_equal_int_type<T, U, false> : std::false_type { };

/// Compares `T` to `U` und evaluates to `true_type` if either
/// `T == U or if T and U are both integral types of the
/// same size and signedness. This works around the issue that
/// `uint8_t != unsigned char on some compilers.
template <class T, typename U>
struct is_same_ish
    : std::conditional<
        std::is_same<T, U>::value,
        std::true_type,
        is_equal_int_type<T, U>
      >::type { };

/// A variant represents always a valid value of one of the types `Ts...`.
template <class... Ts>
class variant {
public:
  using types = detail::type_list<Ts...>;

  static constexpr int max_type_id = sizeof...(Ts) - 1;

  static_assert(sizeof...(Ts) <= 20, "Too many template arguments given.");

  static_assert(sizeof...(Ts) > 0, "No template argument given.");

  static_assert(!detail::tl_exists<types, std::is_reference>::value,
                "Cannot create a variant of references");

  using type0 = typename detail::tl_at<types, 0>::type;

  variant& operator=(const variant& other) {
    variant_assign_helper<variant> helper{*this};
    other.template apply<void>(helper);
    return *this;
  }

  variant& operator=(variant&& other) {
    variant_move_helper<variant> helper{*this};
    other.template apply<void>(helper);
    return *this;
  }

  variant() : type_(variant_npos) {
    // Never empty ...
    set(typename detail::tl_head<types>::type());
    // ... unless an exception was thrown above.
    type_ = 0;
  }

  template <class U>
  variant(U&& arg) : type_(variant_npos) {
    set(std::forward<U>(arg));
  }

  template <class U>
  variant& operator=(U&& arg) {
    set(std::forward<U>(arg));
    return *this;
  }

  variant(const variant& other) : type_(variant_npos) {
    variant_assign_helper<variant> helper{*this};
    other.template apply<void>(helper);
  }

  variant(variant&& other) : type_(variant_npos) {
    variant_move_helper<variant> helper{*this};
    other.template apply<void>(helper);
  }

  ~variant() {
    destroy_data();
  }

  constexpr size_t index() const {
    return static_cast<size_t>(type_);
  }

  bool valueless_by_exception() const {
    return index() == variant_npos;
  }

  /// @cond PRIVATE
  template <int Pos>
  bool is(std::integral_constant<int, Pos>) const {
    return type_ == Pos;
  }

  template <class T>
  bool is() const {
    using namespace detail;
    int_token<tl_index_where<type_list<Ts...>,
                             tbind<is_same_ish, T>::template type>::value>
      token;
    return is(token);
  }

  template <int Pos>
  const typename detail::tl_at<types, Pos>::type&
  get(std::integral_constant<int, Pos> token) const {
    return data_.get(token);
  }

  template <int Pos>
  typename detail::tl_at<types, Pos>::type&
  get(std::integral_constant<int, Pos> token) {
    return data_.get(token);
  }

  template <class Result, class Visitor, class... Variants>
  Result apply(Visitor&& visitor, Variants&&... xs) const {
    return apply_impl<Result>(*this, std::forward<Visitor>(visitor),
                              std::forward<Variants>(xs)..., variant_marker);
  }

  template <class Result, class Visitor, class... Variants>
  Result apply(Visitor&& visitor, Variants&&... xs) {
    return apply_impl<Result>(*this, std::forward<Visitor>(visitor),
                              std::forward<Variants>(xs)..., variant_marker);
  }

  template <class Result, class Self, class Visitor, class... Us>
  static Result apply_impl(Self& x, Visitor&& f, variant_marker_t, Us&&... xs) {
    switch (x.type_) {
      default: CAF_RAISE_ERROR("invalid type found");
      CAF_VARIANT_CASE(0);
      CAF_VARIANT_CASE(1);
      CAF_VARIANT_CASE(2);
      CAF_VARIANT_CASE(3);
      CAF_VARIANT_CASE(4);
      CAF_VARIANT_CASE(5);
      CAF_VARIANT_CASE(6);
      CAF_VARIANT_CASE(7);
      CAF_VARIANT_CASE(8);
      CAF_VARIANT_CASE(9);
      CAF_VARIANT_CASE(10);
      CAF_VARIANT_CASE(11);
      CAF_VARIANT_CASE(12);
      CAF_VARIANT_CASE(13);
      CAF_VARIANT_CASE(14);
      CAF_VARIANT_CASE(15);
      CAF_VARIANT_CASE(16);
      CAF_VARIANT_CASE(17);
      CAF_VARIANT_CASE(18);
      CAF_VARIANT_CASE(19);
    }
  }

  template <class Result, class Self, class Visitor, class Variant, class... Us>
  static detail::enable_if_t<is_variant<Variant>::value, Result>
  apply_impl(Self& x, Visitor&& f, Variant&& next, Us&&... xs) {
    switch (x.type_) {
      default: CAF_RAISE_ERROR("invalid type found");
      CAF_VARIANT_DISPATCH_CASE(0);
      CAF_VARIANT_DISPATCH_CASE(1);
      CAF_VARIANT_DISPATCH_CASE(2);
      CAF_VARIANT_DISPATCH_CASE(3);
      CAF_VARIANT_DISPATCH_CASE(4);
      CAF_VARIANT_DISPATCH_CASE(5);
      CAF_VARIANT_DISPATCH_CASE(6);
      CAF_VARIANT_DISPATCH_CASE(7);
      CAF_VARIANT_DISPATCH_CASE(8);
      CAF_VARIANT_DISPATCH_CASE(9);
      CAF_VARIANT_DISPATCH_CASE(10);
      CAF_VARIANT_DISPATCH_CASE(11);
      CAF_VARIANT_DISPATCH_CASE(12);
      CAF_VARIANT_DISPATCH_CASE(13);
      CAF_VARIANT_DISPATCH_CASE(14);
      CAF_VARIANT_DISPATCH_CASE(15);
      CAF_VARIANT_DISPATCH_CASE(16);
      CAF_VARIANT_DISPATCH_CASE(17);
      CAF_VARIANT_DISPATCH_CASE(18);
      CAF_VARIANT_DISPATCH_CASE(19);
    }
  }
  /// @endcond

private:
  inline void destroy_data() {
    if (type_ == variant_npos) return; // nothing to do
    detail::variant_data_destructor f;
    apply<void>(f);
  }

  template <class U>
  void set(U&& arg) {
    using type = typename std::decay<U>::type;
    static constexpr int type_id =
      detail::tl_index_where<
        types,
        detail::tbind<is_same_ish, type>::template type
      >::value;
    static_assert(type_id >= 0, "invalid type for variant");
    std::integral_constant<int, type_id> token;
    if (type_ != type_id) {
      destroy_data();
      type_ = type_id;
      auto& ref = data_.get(token);
      new (&ref) type (std::forward<U>(arg));
    } else {
       data_.get(token) = std::forward<U>(arg);
    }
  }

  template <class... Us>
  void set(const variant<Us...>& other) {
    using namespace detail;
    static_assert(tl_subset_of<type_list<Us...>, types>::value,
                  "cannot set variant of type A to variant of type B "
                  "unless the element types of A are a strict subset of "
                  "the element types of B");
    variant_assign_helper<variant> helper{*this};
    other.template apply<void>(helper);
  }

  template <class... Us>
  void set(variant<Us...>& other) {
    set(const_cast<const variant<Us...>&>(other));
  }

  template <class... Us>
  void set(variant<Us...>&& other) {
    using namespace detail;
    static_assert(tl_subset_of<type_list<Us...>, types>::value,
                  "cannot set variant of type A to variant of type B "
                  "unless the element types of A are a strict subset of "
                  "the element types of B");
    variant_move_helper<variant> helper{*this};
    other.template apply<void>(helper);
  }

  size_t type_;
  detail::variant_data<typename lift_void<Ts>::type...> data_;
};

/// @relates variant
template <class T, class... Us>
T& get(variant<Us...>& value) {
  using namespace detail;
  int_token<tl_index_where<type_list<Us...>,
                           tbind<is_same_ish, T>::template type>::value> token;
  // silence compiler error about "binding to unrelated types" such as
  // 'signed char' to 'char' (which is obvious bullshit)
  return reinterpret_cast<T&>(value.get(token));
}

/// @relates variant
template <class T, class... Us>
const T& get(const variant<Us...>& value) {
  // compiler implicitly restores const because of the return type
  return get<T>(const_cast<variant<Us...>&>(value));
}

/// @relates variant
template <class T, class... Us>
T* get_if(variant<Us...>* value) {
  using namespace detail;
  int_token<tl_index_where<type_list<Us...>,
                           tbind<is_same_ish, T>::template type>::value> token;
  if (value->is(token))
    return &get<T>(*value);
  return nullptr;
}

/// @relates variant
template <class T, class... Us>
const T* get_if(const variant<Us...>* value) {
  // compiler implicitly restores const because of the return type
  return get_if<T>(const_cast<variant<Us...>*>(value));
}

/// @relates variant
template <class Visitor, class Variant, class... Variants,
          class Result = variant_visit_result_t<Visitor, Variant, Variants...>>
detail::enable_if_t<is_variant<Variant>::value, Result>
visit(Visitor&& f, Variant&& x, Variants&&... xs) {
  return x.template apply<Result>(std::forward<Visitor>(f),
                                  std::forward<Variants>(xs)...);
}

template <class T, class... Ts>
bool holds_alternative(const variant<Ts...>& data) {
  return data.template is<T>();
}

/// @relates variant
template <class T>
struct variant_compare_helper {
  using result_type = bool;
  const T& lhs;
  variant_compare_helper(const T& lhs_ref) : lhs(lhs_ref) {
    // nop
  }
  template <class U>
  bool operator()(const U& rhs) const {
    auto ptr = get_if<U>(&lhs);
    return ptr ? *ptr == rhs : false;
  }
};

/// @relates variant
template <class... Ts>
bool operator==(const variant<Ts...>& x, const variant<Ts...>& y) {
  variant_compare_helper<variant<Ts...>> f{x};
  return visit(f, y);
}

/// @relates variant
template <class T, class... Ts>
bool operator==(const T& x, const variant<Ts...>& y) {
  variant_compare_helper<variant<Ts...>> f{y};
  return f(x);
}

/// @relates variant
template <class T, class... Ts>
bool operator==(const variant<Ts...>& x, const T& y) {
  return y == x;
}

/// @relates variant
template <class T>
struct variant_reader {
  size_t& type_tag;
  T& x;
};

/// @relates variant
template <class Inspector, class... Ts>
typename Inspector::result_type
inspect(Inspector& f, variant_reader<variant<Ts...>>& x) {
  return x.x.template apply<typename Inspector::result_type>(f);
}

/// @relates variant
template <class Inspector, class... Ts>
typename std::enable_if<Inspector::reads_state,
                        typename Inspector::result_type>::type
inspect(Inspector& f, variant<Ts...>& x) {
  auto type_tag = x.index();
  variant_reader<variant<Ts...>> helper{type_tag, x};
  return f(meta::omittable(), type_tag, helper);
}

/// @relates variant
template <class T>
struct variant_writer {
  size_t& type_tag;
  T& x;
};

/// @relates variant
template <class Inspector, class... Ts>
typename Inspector::result_type
inspect(Inspector& f, variant_writer<variant<Ts...>>& x) {
  switch (x.type_tag) {
    default: CAF_RAISE_ERROR("invalid type found");
    CAF_VARIANT_ASSIGN_CASE(0);
    CAF_VARIANT_ASSIGN_CASE(1);
    CAF_VARIANT_ASSIGN_CASE(2);
    CAF_VARIANT_ASSIGN_CASE(3);
    CAF_VARIANT_ASSIGN_CASE(4);
    CAF_VARIANT_ASSIGN_CASE(5);
    CAF_VARIANT_ASSIGN_CASE(6);
    CAF_VARIANT_ASSIGN_CASE(7);
    CAF_VARIANT_ASSIGN_CASE(8);
    CAF_VARIANT_ASSIGN_CASE(9);
    CAF_VARIANT_ASSIGN_CASE(10);
    CAF_VARIANT_ASSIGN_CASE(11);
    CAF_VARIANT_ASSIGN_CASE(12);
    CAF_VARIANT_ASSIGN_CASE(13);
    CAF_VARIANT_ASSIGN_CASE(14);
    CAF_VARIANT_ASSIGN_CASE(15);
    CAF_VARIANT_ASSIGN_CASE(16);
    CAF_VARIANT_ASSIGN_CASE(17);
    CAF_VARIANT_ASSIGN_CASE(18);
    CAF_VARIANT_ASSIGN_CASE(19);
  }
}

/// @relates variant
template <class Inspector, class... Ts>
typename std::enable_if<Inspector::writes_state,
                        typename Inspector::result_type>::type
inspect(Inspector& f, variant<Ts...>& x) {
  size_t type_tag;
  variant_writer<variant<Ts...>> helper{type_tag, x};
  return f(meta::omittable(), type_tag, helper);
}

} // namespace caf

#endif // CAF_VARIANT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MESSAGE_ID_HPP
#define CAF_MESSAGE_ID_HPP

#include <string>
#include <cstdint>
#include <functional>

#include "caf/config.hpp"
#include "caf/error.hpp"
#include "caf/message_priority.hpp"

#include "caf/meta/type_name.hpp"

#include "caf/detail/comparable.hpp"
#include "caf/detail/type_traits.hpp"

namespace caf {

struct invalid_message_id_t {
  constexpr invalid_message_id_t() {
    // nop
  }
};

constexpr invalid_message_id_t invalid_message_id = invalid_message_id_t{};

struct make_message_id_t;

/// Denotes whether a message is asynchronous or synchronous
/// @note Asynchronous messages always have an invalid message id.
class message_id : detail::comparable<message_id> {
public:
  // -- friends ---------------------------------------------------------------

  friend struct make_message_id_t;

  // -- constants -------------------------------------------------------------

  static constexpr uint64_t response_flag_mask = 0x8000000000000000;
  static constexpr uint64_t answered_flag_mask = 0x4000000000000000;
  static constexpr uint64_t high_prioity_flag_mask = 0x2000000000000000;
  static constexpr uint64_t request_id_mask = 0x1FFFFFFFFFFFFFFF;

  constexpr message_id() : value_(0) {
    // nop
  }

  constexpr message_id(invalid_message_id_t) : value_(0) {
    // nop
  }

  message_id(message_id&&) = default;
  message_id(const message_id&) = default;
  message_id& operator=(message_id&&) = default;
  message_id& operator=(const message_id&) = default;

  inline message_id& operator++() {
    ++value_;
    return *this;
  }

  inline bool is_async() const {
    return value_ == 0 || value_ == high_prioity_flag_mask;
  }

  inline bool is_response() const {
    return (value_ & response_flag_mask) != 0;
  }

  inline bool is_answered() const {
    return (value_ & answered_flag_mask) != 0;
  }

  inline bool is_high_priority() const {
    return (value_ & high_prioity_flag_mask) != 0;
  }

  inline bool valid() const {
    return (value_ & request_id_mask) != 0;
  }

  inline bool is_request() const {
    return valid() && !is_response();
  }

  inline message_id response_id() const {
    return message_id{is_request() ? value_ | response_flag_mask : 0};
  }

  inline message_id request_id() const {
    return message_id(value_ & request_id_mask);
  }

  inline message_id with_high_priority() const {
    return message_id(value_ | high_prioity_flag_mask);
  }

  inline message_id with_normal_priority() const {
    return message_id(value_ & ~high_prioity_flag_mask);
  }

  inline void mark_as_answered() {
    value_ |= answered_flag_mask;
  }

  inline uint64_t integer_value() const {
    return value_;
  }

  long compare(const message_id& other) const {
    return (value_ == other.value_) ? 0
                                      : (value_ < other.value_ ? -1 : 1);
  }

  template <class Inspector>
  friend typename Inspector::result_type inspect(Inspector& f, message_id& x) {
    return f(meta::type_name("message_id"), x.value_);
  }

  // -- deprecated functions ---------------------------------------------------

  template <class... Ts>
  static message_id make(Ts&&... xs)
  CAF_DEPRECATED_MSG("use make_message_id instead");

private:
  constexpr message_id(uint64_t value) : value_(value) {
    // nop
  }

  uint64_t value_;
};

// -- make_message_id ----------------------------------------------------------

/// Utility class for generating a `message_id` from integer values or
/// priorities.
struct make_message_id_t {
  constexpr make_message_id_t() {
    // nop
  }

  constexpr message_id operator()(uint64_t value = 0) const {
    return value;
  }

  constexpr message_id operator()(message_priority p) const {
    return p == message_priority::high ? message_id::high_prioity_flag_mask
                                       : 0u;
  }
};

/// Generates a `message_id` from integer values or priorities.
constexpr make_message_id_t make_message_id = make_message_id_t{};

// -- deprecated functions -----------------------------------------------------

template <class... Ts>
message_id message_id::make(Ts&&... xs) {
  return make_message_id(std::forward<Ts>(xs)...);
}

} // namespace caf

namespace std {

template <>
struct hash<caf::message_id> {
  inline size_t operator()(caf::message_id x) const {
    hash<uint64_t> f;
    return f(x.integer_value());
  }
};

} // namespace std

#endif // CAF_MESSAGE_ID_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IS_TYPED_ACTOR_HPP
#define CAF_IS_TYPED_ACTOR_HPP

#include "caf/fwd.hpp"

namespace caf {

/**
 * Evaluates to true if `T` is a `typed_actor<...>`.
 */
template <class T>
struct is_typed_actor : std::false_type { };

template <class... Ts>
struct is_typed_actor<typed_actor<Ts...>> : std::true_type { };

} // namespace caf

#endif //CAF_IS_TYPED_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

// This file is partially included in the manual, do not modify
// without updating the references in the *.tex files!
// Manual references: lines 31-51 (Error.tex)

#ifndef CAF_EXIT_REASON_HPP
#define CAF_EXIT_REASON_HPP

#include "caf/error.hpp"

namespace caf {

/// This error category represents fail conditions for actors.
enum class exit_reason : uint8_t {
  /// Indicates that an actor finished execution without error.
  normal = 0,
  /// Indicates that an actor died because of an unhandled exception.
  unhandled_exception,
  /// Indicates that the exit reason for this actor is unknown, i.e.,
  /// the actor has been terminated and no longer exists.
  unknown,
  /// Indicates that an actor pool unexpectedly ran out of workers.
  out_of_workers,
  /// Indicates that an actor was forced to shutdown by a user-generated event.
  user_shutdown,
  /// Indicates that an actor was killed unconditionally.
  kill,
  /// Indicates that an actor finishied execution because a connection
  /// to a remote link was closed unexpectedly.
  remote_link_unreachable,
  /// Indicates that an actor was killed because it became unreachable.
  unreachable
};

/// Returns a string representation of given exit reason.
std::string to_string(exit_reason x);

/// @relates exit_reason
error make_error(exit_reason);

} // namespace caf

#endif // CAF_EXIT_REASON_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STATEFUL_ACTOR_HPP
#define CAF_STATEFUL_ACTOR_HPP

#include <new>
#include <type_traits>

#include "caf/fwd.hpp"
#include "caf/sec.hpp"

#include "caf/logger.hpp"

#include "caf/detail/type_traits.hpp"

namespace caf {

/// An event-based actor with managed state. The state is constructed
/// before `make_behavior` will get called and destroyed after the
/// actor called `quit`. This state management brakes cycles and
/// allows actors to automatically release ressources as soon
/// as possible.
template <class State, class Base = event_based_actor>
class stateful_actor : public Base {
public:
  template <class... Ts>
  explicit stateful_actor(actor_config& cfg, Ts&&... xs)
      : Base(cfg, std::forward<Ts>(xs)...),
        state(state_) {
    if (detail::is_serializable<State>::value)
      this->setf(Base::is_serializable_flag);
    cr_state(this);
  }

  ~stateful_actor() override {
    // nop
  }

  /// Destroys the state of this actor (no further overriding allowed).
  void on_exit() final {
    CAF_LOG_TRACE("");
    state_.~State();
  }

  const char* name() const final {
    return get_name(state_);
  }

  error save_state(serializer& sink, unsigned int version) override {
    return serialize_state(&sink, state, version);
  }

  error load_state(deserializer& source, unsigned int version) override {
    return serialize_state(&source, state, version);
  }

  /// A reference to the actor's state.
  State& state;

  /// @cond PRIVATE

  void initialize() override {
    Base::initialize();
  }

  /// @endcond

private:
  template <class Inspector, class T>
  auto serialize_state(Inspector* f, T& x, unsigned int)
  -> decltype(inspect(*f, x)) {
    return inspect(*f, x);
  }

  template <class T>
  error serialize_state(void*, T&, unsigned int) {
    return sec::invalid_argument;
  }

  template <class T>
  typename std::enable_if<std::is_constructible<State, T>::value>::type
  cr_state(T arg) {
    new (&state_) State(arg);
  }

  template <class T>
  typename std::enable_if<!std::is_constructible<State, T>::value>::type
  cr_state(T) {
    new (&state_) State();
  }

  static const char* unbox_str(const char* str) {
    return str;
  }

  template <class U>
  static const char* unbox_str(const U& str) {
    return str.c_str();
  }

  template <class U>
  typename std::enable_if<detail::has_name<U>::value, const char*>::type
  get_name(const U& st) const {
    return unbox_str(st.name);
  }

  template <class U>
  typename std::enable_if<!detail::has_name<U>::value, const char*>::type
  get_name(const U&) const {
    return Base::name();
  }

  union { State state_; };
};

} // namespace caf

#endif // CAF_STATEFUL_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_REMOTE_ACTOR_REGISTRY_HPP
#define CAF_REMOTE_ACTOR_REGISTRY_HPP

#include <utility>
#include <functional>
#include <unordered_map>

#include "caf/fwd.hpp"
#include "caf/node_id.hpp"
#include "caf/actor_addr.hpp"
#include "caf/actor_cast.hpp"
#include "caf/actor_proxy.hpp"
#include "caf/exit_reason.hpp"

namespace caf {

/// Groups a (distributed) set of actors and allows actors
/// in the same namespace to exchange messages.
class proxy_registry {
public:
  /// Responsible for creating proxy actors.
  class backend {
  public:
    virtual ~backend();

    /// Creates a new proxy instance.
    virtual strong_actor_ptr make_proxy(node_id, actor_id) = 0;

    virtual execution_unit* registry_context() = 0;
  };

  proxy_registry(actor_system& sys, backend& be);

  proxy_registry(const proxy_registry&) = delete;
  proxy_registry& operator=(const proxy_registry&) = delete;

  ~proxy_registry();

  void serialize(serializer& sink, const actor_addr& addr) const;

  void serialize(deserializer& source, actor_addr& addr);

  /// Writes an actor address to `sink` and adds the actor
  /// to the list of known actors for a later deserialization.
  void write(serializer* sink, const actor_addr& ptr) const;

  /// Reads an actor address from `source,` creating
  /// addresses for remote actors on the fly if needed.
  actor_addr read(deserializer* source);

  /// A map that stores all proxies for known remote actors.
  using proxy_map = std::map<actor_id, strong_actor_ptr>;

  /// Returns the number of proxies for `node`.
  size_t count_proxies(const node_id& node);

  /// Returns the proxy instance identified by `node` and `aid`.
  strong_actor_ptr get(const node_id& node, actor_id aid);

  /// Returns the proxy instance identified by `node` and `aid`
  /// or creates a new (default) proxy instance.
  strong_actor_ptr get_or_put(const node_id& nid, actor_id aid);

  /// Returns all known proxies.
  std::vector<strong_actor_ptr> get_all(const node_id& node);

  /// Deletes all proxies for `node`.
  void erase(const node_id& nid);

  /// Deletes the proxy with id `aid` for `nid`.
  void erase(const node_id& nid, actor_id aid,
             error rsn = exit_reason::remote_link_unreachable);

  /// Queries whether there are any proxies left.
  bool empty() const;

  /// Deletes all proxies.
  void clear();

  inline actor_system& system() {
    return system_;
  }

  inline size_t size() const {
    return proxies_.size();
  }

private:
  void kill_proxy(strong_actor_ptr&, error);

  actor_system& system_;
  backend& backend_;
  std::unordered_map<node_id, proxy_map> proxies_;
};

} // namespace caf

#endif
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STRING_ALGORITHMS_HPP
#define CAF_STRING_ALGORITHMS_HPP

#include <cmath>     // fabs
#include <string>
#include <vector>
#include <limits>
#include <sstream>
#include <algorithm>
#include <type_traits>

#include "caf/config.hpp"
#include "caf/detail/type_traits.hpp"

namespace caf {

// provide boost::split compatible interface

inline std::string is_any_of(std::string arg) {
  return arg;
}

constexpr bool token_compress_on = false;

template <class Container, class Delim>
void split(Container& result, const std::string& str, const Delim& delims,
           bool keep_all = true) {
  size_t pos = 0;
  size_t prev = 0;
  while ((pos = str.find_first_of(delims, prev)) != std::string::npos) {
    if (pos > prev) {
      auto substr = str.substr(prev, pos - prev);
      if (!substr.empty() || keep_all) {
        result.push_back(std::move(substr));
      }
    }
    prev = pos + 1;
  }
  if (prev < str.size()) {
    result.push_back(str.substr(prev, std::string::npos));
  }
}

template <class Iterator>
class iterator_range {
public:
  using iterator = Iterator;

  iterator_range(iterator first, iterator last) : begin_(first), end_(last) {
    // nop
  }

  iterator begin() const {
    return begin_;
  }

  iterator end() const {
    return end_;
  }

private:
  iterator begin_;
  iterator end_;
};


template <class Container>
std::string join(const Container& c, const std::string& glue) {
  auto begin = c.begin();
  auto end = c.end();
  bool first = true;
  std::ostringstream oss;
  for ( ; begin != end; ++begin) {
    if (first)
      first = false;
    else
      oss << glue;
    oss << *begin;
  }
  return oss.str();
}

// end of recursion
inline void splice(std::string&, const std::string&) {
  // nop
}

template <class T, class... Ts>
void splice(std::string& str, const std::string& glue, T&& arg, Ts&&... xs) {
  str += glue;
  str += std::forward<T>(arg);
  splice(str, glue, std::forward<Ts>(xs)...);
}

template <ptrdiff_t WhatSize, ptrdiff_t WithSize>
void replace_all(std::string& str,
                 const char (&what)[WhatSize],
                 const char (&with)[WithSize]) {
  // end(what) - 1 points to the null-terminator
  auto next = [&](std::string::iterator pos) -> std::string::iterator {
    return std::search(pos, str.end(), std::begin(what), std::end(what) - 1);
  };
  auto i = next(std::begin(str));
  while (i != std::end(str)) {
    auto before = std::distance(std::begin(str), i);
    CAF_ASSERT(before >= 0);
    str.replace(i, i + WhatSize - 1, with);
    // i became invalidated -> use new iterator pointing
    // to the first character after the replaced text
    i = next(str.begin() + before + (WithSize - 1));
  }
}

template<size_t S>
bool starts_with(const std::string& str, const char (&prefix)[S]) {
  return str.compare(0, S - 1, prefix) == 0;
}

template <size_t S>
bool ends_with(const std::string& str, const char (&suffix)[S]) {
  auto n = str.size();
  auto m = S - 1;
  if (n >= m)
    return str.compare(n - m, m, suffix) == 0;
  return false;
}

template <class T>
typename std::enable_if<
  std::is_arithmetic<T>::value,
  std::string
>::type
convert_to_str(T value) {
  return std::to_string(value);
}

inline std::string convert_to_str(std::string value) {
  return value;
}

} // namespace caf

#endif // CAF_STRING_ALGORITHMS_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_LOCKS_HPP
#define CAF_LOCKS_HPP

#include <mutex>

namespace caf {

template <class Lockable>
using unique_lock = std::unique_lock<Lockable>;

template <class SharedLockable>
class shared_lock {
public:
  using lockable = SharedLockable;

  explicit shared_lock(lockable& arg) : lockable_(&arg) {
    lockable_->lock_shared();
  }

  ~shared_lock() {
    unlock();
  }

  bool owns_lock() const {
    return lockable_ != nullptr;
  }

  void unlock() {
    if (lockable_) {
      lockable_->unlock_shared();
      lockable_ = nullptr;
    }
  }

  lockable* release() {
    auto result = lockable_;
    lockable_ = nullptr;
    return result;
  }

private:
  lockable* lockable_;
};

template <class SharedLockable>
using upgrade_lock = shared_lock<SharedLockable>;

template <class UpgradeLockable>
class upgrade_to_unique_lock {
public:
  using lockable = UpgradeLockable;

  template <class LockType>
  explicit upgrade_to_unique_lock(LockType& other) {
    lockable_ = other.release();
    if (lockable_) lockable_->unlock_upgrade_and_lock();
  }

  ~upgrade_to_unique_lock() {
    unlock();
  }

  bool owns_lock() const {
    return lockable_ != nullptr;
  }

  void unlock() {
    if (lockable_) {
      lockable_->unlock();
      lockable_ = nullptr;
    }
  }

private:
  lockable* lockable_;
};

} // namespace caf

#endif // CAF_LOCKS_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_GROUP_MODULE_HPP
#define CAF_GROUP_MODULE_HPP

#include <string>
#include <memory>

#include "caf/fwd.hpp"
#include "caf/actor_addr.hpp"
#include "caf/attachable.hpp"
#include "caf/ref_counted.hpp"
#include "caf/abstract_channel.hpp"

namespace caf {

/// Interface for user-defined multicast implementations.
class group_module {
public:
  // -- constructors, destructors, and assignment operators --------------------

  group_module(actor_system& sys, std::string mname);

  virtual ~group_module();

  // -- pure virtual member functions ------------------------------------------

  /// Stops all groups from this module.
  virtual void stop() = 0;

  /// Returns a pointer to the group associated with the name `group_name`.
  /// @threadsafe
  virtual expected<group> get(const std::string& group_name) = 0;

  /// Loads a group of this module from `source` and stores it in `storage`.
  virtual error load(deserializer& source, group& storage) = 0;

  // -- observers --------------------------------------------------------------

  /// Returns the hosting actor system.
  inline actor_system& system() const {
    return system_;
  }

  /// Returns the name of this module implementation.
  inline const std::string& name() const {
    return name_;
  }

private:
  actor_system& system_;
  std::string name_;
};

} // namespace caf

#endif // CAF_GROUP_MODULE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TIMESTAMP_HPP
#define CAF_TIMESTAMP_HPP

#include <chrono>
#include <string>
#include <cstdint>

namespace caf {

/// A portable timestamp with nanosecond resolution anchored at the UNIX epoch.
using timestamp = std::chrono::time_point<
  std::chrono::system_clock,
  std::chrono::duration<int64_t, std::nano>
>;

/// Convenience function for returning a `timestamp` representing
/// the current system time.
timestamp make_timestamp();

/// Converts the time-since-epoch of `x` to a `string`.
std::string timestamp_to_string(const timestamp& x);

/// Appends the time-since-epoch of `y` to `x`.
void append_timestamp_to_string(std::string& x, const timestamp& y);

} // namespace caf

#endif // CAF_TIMESTAMP_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OUTBOUND_PATH_HPP
#define CAF_OUTBOUND_PATH_HPP

#include <deque>
#include <vector>
#include <cstdint>
#include <cstddef>

#include "caf/fwd.hpp"
#include "caf/stream_id.hpp"
#include "caf/stream_msg.hpp"
#include "caf/stream_aborter.hpp"
#include "caf/actor_control_block.hpp"

#include "caf/meta/type_name.hpp"

namespace caf {

/// State for a single path to a sink on a `stream_scatterer`.
class outbound_path {
public:
  /// Stream aborter flag to monitor a path.
  static constexpr const auto aborter_type = stream_aborter::sink_aborter;

  /// Message type for propagating graceful shutdowns.
  using regular_shutdown = stream_msg::close;

  /// Message type for propagating errors.
  using irregular_shutdown = stream_msg::forced_close;

  /// Stores information about the initiator of the steam.
  struct client_data {
    strong_actor_ptr hdl;
    message_id mid;
  };

  /// Pointer to the parent actor.
  local_actor* self;

  /// Stream ID used by the sink.
  stream_id sid;

  /// Handle to the sink.
  strong_actor_ptr hdl;

  /// Next expected batch ID.
  int64_t next_batch_id;

  /// Currently available credit for this path.
  long open_credit;

  /// Stores whether the downstream actor is failsafe, i.e., allows the runtime
  /// to redeploy it on failure. If this field is set to `false` then
  /// `unacknowledged_batches` is unused.
  bool redeployable;

  /// Next expected batch ID to be acknowledged. Actors can receive a more
  /// advanced batch ID in an ACK message, since CAF uses accumulative ACKs.
  int64_t next_ack_id;

  /// Caches batches until receiving an ACK.
  std::deque<std::pair<int64_t, stream_msg::batch>> unacknowledged_batches;

  /// Caches the initiator of the stream (client) with the original request ID
  /// until the stream handshake is either confirmed or aborted. Once
  /// confirmed, the next stage takes responsibility for answering to the
  /// client.
  client_data cd;

  /// Stores whether an error occurred during stream processing.
  error shutdown_reason;

  /// Constructs a path for given handle and stream ID.
  outbound_path(local_actor* selfptr, const stream_id& id,
                strong_actor_ptr ptr);

  ~outbound_path();

  /// Sets `open_credit` to `initial_credit` and clears `cached_handshake`.
  void handle_ack_open(long initial_credit);

  void emit_open(strong_actor_ptr origin,
                 mailbox_element::forwarding_stack stages, message_id mid,
                 message handshake_data, stream_priority prio,
                 bool is_redeployable);

  /// Emits a `stream_msg::batch` on this path, decrements `open_credit` by
  /// `xs_size` and increments `next_batch_id` by 1.
  void emit_batch(long xs_size, message xs);

  static void emit_irregular_shutdown(local_actor* self, const stream_id& sid,
                                      const strong_actor_ptr& hdl,
                                      error reason);
};

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, outbound_path& x) {
  return f(meta::type_name("outbound_path"), x.hdl, x.sid, x.next_batch_id,
           x.open_credit, x.redeployable, x.unacknowledged_batches);
}

} // namespace caf

#endif // CAF_OUTBOUND_PATH_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_EXECUTION_UNIT_HPP
#define CAF_EXECUTION_UNIT_HPP

#include "caf/fwd.hpp"

#include "caf/config.hpp"

namespace caf {

/// Identifies an execution unit, e.g., a worker thread of the scheduler. By
/// querying its execution unit, an actor can access other context information.
class execution_unit {
public:
  explicit execution_unit(actor_system* sys);

  execution_unit(execution_unit&&) = delete;
  execution_unit(const execution_unit&) = delete;

  virtual ~execution_unit();

  /// Enqueues `ptr` to the job list of the execution unit.
  /// @warning Must only be called from a {@link resumable} currently
  ///          executed by this execution unit.
  virtual void exec_later(resumable* ptr) = 0;

  /// Returns the enclosing actor system.
  /// @warning Must be set before the execution unit calls `resume` on an actor.
  actor_system& system() const {
    CAF_ASSERT(system_ != nullptr);
    return *system_;
  }

  /// Returns a pointer to the proxy factory currently associated to this unit.
  proxy_registry* proxy_registry_ptr() {
    return proxies_;
  }

  /// Associated a new proxy factory to this unit.
  void proxy_registry_ptr(proxy_registry* ptr) {
    proxies_ = ptr;
  }

protected:
  actor_system* system_;
  proxy_registry* proxies_;
};

} // namespace caf

#endif // CAF_EXECUTION_UNIT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ACTOR_POOL_HPP
#define CAF_ACTOR_POOL_HPP

#include <vector>
#include <functional>

#include "caf/locks.hpp"
#include "caf/actor.hpp"
#include "caf/execution_unit.hpp"
#include "caf/mailbox_element.hpp"
#include "caf/monitorable_actor.hpp"

#include "caf/detail/split_join.hpp"
#include "caf/detail/shared_spinlock.hpp"

namespace caf {

/// An actor poool is a lightweight abstraction for a set of workers.
/// The pool itself is an actor, meaning that it can be passed
/// around in an actor system to hide the actual set of workers.
///
/// After construction, new workers can be added via `{'SYS', 'PUT', actor}`
/// messages, e.g., `send(my_pool, sys_atom::value, put_atom::value, worker)`.
/// `{'SYS', 'DELETE', actor}` messages remove a specific worker from the set,
/// `{'SYS', 'DELETE'}` removes all workers, and `{'SYS', 'GET'}` returns a
/// `vector<actor>` containing all workers.
///
/// Note that the pool *always*  sends exit messages to all of its workers
/// when forced to quit. The pool monitors all of its workers. Messages queued
/// up in a worker's mailbox are lost, i.e., the pool itself does not buffer
/// and resend messages. Advanced caching or resend strategies can be
/// implemented in a policy.
///
/// It is worth mentioning that the pool is *not* an event-based actor.
/// Neither does it live in its own thread. Messages are dispatched immediately
/// during the enqueue operation. Any user-defined policy thus has to dispatch
/// messages with as little overhead as possible, because the dispatching
/// runs in the context of the sender.
/// @experimental
class actor_pool : public monitorable_actor {
public:
  using uplock = upgrade_lock<detail::shared_spinlock>;
  using actor_vec = std::vector<actor>;
  using factory = std::function<actor ()>;
  using policy = std::function<void (actor_system&, uplock&, const actor_vec&,
                                     mailbox_element_ptr&, execution_unit*)>;

  /// Returns a simple round robin dispatching policy.
  static policy round_robin();

  /// Returns a broadcast dispatching policy.
  static policy broadcast();

  /// Returns a random dispatching policy.
  static policy random();

  /// Returns a split/join dispatching policy. The function object `sf`
  /// distributes a work item to all workers (split step) and the function
  /// object `jf` joins individual results into a single one with `init`
  /// as initial value of the operation.
  /// @tparam T Result type of the join step.
  /// @tparam Join Function object with signature `void (T&, message&)`.
  /// @tparam Split Function object with signature
  ///               `void (vector<pair<actor, message>>&, message&)`. The first
  ///               argument is a mapping from actors (workers) to tasks
  ///               (messages). The second argument is the input message.
  ///               The default split policy broadcasts the work item to all
  ///               workers.
  template <class T, class Join, class Split = detail::nop_split>
  static policy split_join(Join jf, Split sf = Split(), T init = T()) {
    using impl = detail::split_join<T, Split, Join>;
    return impl{std::move(init), std::move(sf), std::move(jf)};
  }

  ~actor_pool() override;

  /// Returns an actor pool without workers using the dispatch policy `pol`.
  static actor make(execution_unit* eu, policy pol);

  /// Returns an actor pool with `n` workers created by the factory
  /// function `fac` using the dispatch policy `pol`.
  static actor make(execution_unit* eu, size_t num_workers, const factory& fac, policy pol);

  void enqueue(mailbox_element_ptr what, execution_unit* eu) override;

  actor_pool(actor_config& cfg);

protected:
  void on_cleanup() override;

private:
  bool filter(upgrade_lock<detail::shared_spinlock>&,
              const strong_actor_ptr& sender, message_id mid,
              message_view& mv, execution_unit* eu);

  // call without workers_mtx_ held
  void quit(execution_unit* host);

  detail::shared_spinlock workers_mtx_;
  std::vector<actor> workers_;
  policy policy_;
  exit_reason planned_reason_;
};

} // namespace caf

#endif // CAF_ACTOR_POOL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2014                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPTIONAL_HPP
#define CAF_OPTIONAL_HPP

#include <new>
#include <utility>

#include "caf/none.hpp"
#include "caf/unit.hpp"
#include "caf/config.hpp"
#include "caf/deep_to_string.hpp"

#include "caf/detail/safe_equal.hpp"
#include "caf/detail/scope_guard.hpp"

namespace caf {

/// A C++17 compatible `optional` implementation.
template <class T>
class optional {
 public:
  /// Typdef for `T`.
  using type = T;

  /// Creates an instance without value.
  optional(const none_t& = none) : m_valid(false) {
    // nop
  }

  /// Creates an valid instance from `value`.
  template <class U,
            class E = typename std::enable_if<
                        std::is_convertible<U, T>::value
                      >::type>
  optional(U x) : m_valid(false) {
    cr(std::move(x));
  }

  optional(const optional& other) : m_valid(false) {
    if (other.m_valid) {
      cr(other.m_value);
    }
  }

  optional(optional&& other)
  noexcept(std::is_nothrow_move_constructible<T>::value)
    : m_valid(false) {
    if (other.m_valid) {
      cr(std::move(other.m_value));
    }
  }

  ~optional() {
    destroy();
  }

  optional& operator=(const optional& other) {
    if (m_valid) {
      if (other.m_valid) m_value = other.m_value;
      else destroy();
    }
    else if (other.m_valid) {
      cr(other.m_value);
    }
    return *this;
  }

  optional& operator=(optional&& other)
  noexcept(std::is_nothrow_destructible<T>::value &&
           std::is_nothrow_move_assignable<T>::value) {
    if (m_valid) {
      if (other.m_valid) m_value = std::move(other.m_value);
      else destroy();
    }
    else if (other.m_valid) {
      cr(std::move(other.m_value));
    }
    return *this;
  }

  /// Checks whether this object contains a value.
  explicit operator bool() const {
    return m_valid;
  }

  /// Checks whether this object does not contain a value.
  bool operator!() const {
    return !m_valid;
  }

  /// Returns the value.
  T& operator*() {
    CAF_ASSERT(m_valid);
    return m_value;
  }

  /// Returns the value.
  const T& operator*() const {
    CAF_ASSERT(m_valid);
    return m_value;
  }

  /// Returns the value.
  const T* operator->() const {
    CAF_ASSERT(m_valid);
    return &m_value;
  }

  /// Returns the value.
  T* operator->() {
    CAF_ASSERT(m_valid);
    return &m_value;
  }

  /// Returns the value.
  T& value() {
    CAF_ASSERT(m_valid);
    return m_value;
  }

  /// Returns the value.
  const T& value() const {
    CAF_ASSERT(m_valid);
    return m_value;
  }

  /// Returns the value if `m_valid`, otherwise returns `default_value`.
  const T& value_or(const T& default_value) const {
    return m_valid ? value() : default_value;
  }

 private:
  void destroy() {
    if (m_valid) {
      m_value.~T();
      m_valid = false;
    }
  }

  template <class V>
  void cr(V&& x) {
    CAF_ASSERT(!m_valid);
    m_valid = true;
    new (&m_value) T(std::forward<V>(x));
  }

  bool m_valid;
  union { T m_value; };
};

/// Template specialization to allow `optional` to hold a reference
/// rather than an actual value with minimal overhead.
template <class T>
class optional<T&> {
 public:
  using type = T;

  optional(const none_t& = none) : m_value(nullptr) {
    // nop
  }

  optional(T& x) : m_value(&x) {
    // nop
  }

  optional(T* x) : m_value(x) {
    // nop
  }

  optional(const optional& other) = default;

  optional& operator=(const optional& other) = default;

  explicit operator bool() const {
    return m_value != nullptr;
  }

  bool operator!() const {
    return !m_value;
  }

  T& operator*() {
    CAF_ASSERT(m_value);
    return *m_value;
  }

  const T& operator*() const {
    CAF_ASSERT(m_value);
    return *m_value;
  }

  T* operator->() {
    CAF_ASSERT(m_value);
    return m_value;
  }

  const T* operator->() const {
    CAF_ASSERT(m_value);
    return m_value;
  }

  T& value() {
    CAF_ASSERT(m_value);
    return *m_value;
  }

  const T& value() const {
    CAF_ASSERT(m_value);
    return *m_value;
  }

  const T& value_or(const T& default_value) const {
    if (m_value)
      return value();
    return default_value;
  }

 private:
  T* m_value;
};

template <>
class optional<void> {
 public:
  using type = unit_t;

  optional(none_t = none) : m_value(false) {
    // nop
  }

  optional(unit_t) : m_value(true) {
    // nop
  }

  optional(const optional& other) = default;

  optional& operator=(const optional& other) = default;

  explicit operator bool() const {
    return m_value;
  }

  bool operator!() const {
    return !m_value;
  }

 private:
  bool m_value;
};

template <class Inspector, class T>
typename std::enable_if<Inspector::reads_state,
                        typename Inspector::result_type>::type
inspect(Inspector& f, optional<T>& x) {
  return x ? f(true, *x) : f(false);
}

template <class T>
struct optional_inspect_helper {
  bool& enabled;
  T& storage;
  template <class Inspector>
  friend typename Inspector::result_type inspect(Inspector& f,
                                                 optional_inspect_helper& x) {
    return x.enabled ? f(x.storage) : f();
  }
};

template <class Inspector, class T>
typename std::enable_if<Inspector::writes_state,
                        typename Inspector::result_type>::type
inspect(Inspector& f, optional<T>& x) {
  bool flag;
  typename optional<T>::type tmp;
  optional_inspect_helper<T> helper{flag, tmp};
  auto guard = detail::make_scope_guard([&] {
    if (flag)
      x = std::move(tmp);
    else
      x = none;
  });
  return f(flag, helper);
}


/// @relates optional
template <class T>
std::string to_string(const optional<T>& x) {
  return x ? "*" + deep_to_string(*x) : "none";
}

// -- [X.Y.8] comparison with optional ----------------------------------------

/// @relates optional
template <class T>
bool operator==(const optional<T>& lhs, const optional<T>& rhs) {
  return static_cast<bool>(lhs) == static_cast<bool>(rhs)
      && (!lhs || *lhs == *rhs);
}

/// @relates optional
template <class T>
bool operator!=(const optional<T>& lhs, const optional<T>& rhs) {
  return !(lhs == rhs);
}

/// @relates optional
template <class T>
bool operator<(const optional<T>& lhs, const optional<T>& rhs) {
  return static_cast<bool>(rhs) && (!lhs || *lhs < *rhs);
}

/// @relates optional
template <class T>
bool operator<=(const optional<T>& lhs, const optional<T>& rhs) {
  return !(rhs < lhs);
}

/// @relates optional
template <class T>
bool operator>=(const optional<T>& lhs, const optional<T>& rhs) {
  return !(lhs < rhs);
}

/// @relates optional
template <class T>
bool operator>(const optional<T>& lhs, const optional<T>& rhs) {
  return rhs < lhs;
}

// -- [X.Y.9] comparison with none_t (aka. nullopt_t) -------------------------

/// @relates optional
template <class T>
bool operator==(const optional<T>& lhs, none_t) {
  return !lhs;
}

/// @relates optional
template <class T>
bool operator==(none_t, const optional<T>& rhs) {
  return !rhs;
}

/// @relates optional
template <class T>
bool operator!=(const optional<T>& lhs, none_t) {
  return static_cast<bool>(lhs);
}

/// @relates optional
template <class T>
bool operator!=(none_t, const optional<T>& rhs) {
  return static_cast<bool>(rhs);
}

/// @relates optional
template <class T>
bool operator<(const optional<T>&, none_t) {
  return false;
}

/// @relates optional
template <class T>
bool operator<(none_t, const optional<T>& rhs) {
  return static_cast<bool>(rhs);
}

/// @relates optional
template <class T>
bool operator<=(const optional<T>& lhs, none_t) {
  return !lhs;
}

/// @relates optional
template <class T>
bool operator<=(none_t, const optional<T>&) {
  return true;
}

/// @relates optional
template <class T>
bool operator>(const optional<T>& lhs, none_t) {
  return static_cast<bool>(lhs);
}

/// @relates optional
template <class T>
bool operator>(none_t, const optional<T>&) {
  return false;
}

/// @relates optional
template <class T>
bool operator>=(const optional<T>&, none_t) {
  return true;
}

/// @relates optional
template <class T>
bool operator>=(none_t, const optional<T>&) {
  return true;
}

// -- [X.Y.10] comparison with value type ------------------------------------

/// @relates optional
template <class T>
bool operator==(const optional<T>& lhs, const T& rhs) {
  return lhs && *lhs == rhs;
}

/// @relates optional
template <class T>
bool operator==(const T& lhs, const optional<T>& rhs) {
  return rhs && lhs == *rhs;
}

/// @relates optional
template <class T>
bool operator!=(const optional<T>& lhs, const T& rhs) {
  return !lhs || !(*lhs == rhs);
}

/// @relates optional
template <class T>
bool operator!=(const T& lhs, const optional<T>& rhs) {
  return !rhs || !(lhs == *rhs);
}

/// @relates optional
template <class T>
bool operator<(const optional<T>& lhs, const T& rhs) {
  return !lhs || *lhs < rhs;
}

/// @relates optional
template <class T>
bool operator<(const T& lhs, const optional<T>& rhs) {
  return rhs && lhs < *rhs;
}

/// @relates optional
template <class T>
bool operator<=(const optional<T>& lhs, const T& rhs) {
  return !lhs || !(rhs < *lhs);
}

/// @relates optional
template <class T>
bool operator<=(const T& lhs, const optional<T>& rhs) {
  return rhs && !(rhs < lhs);
}

/// @relates optional
template <class T>
bool operator>(const optional<T>& lhs, const T& rhs) {
  return lhs && rhs < *lhs;
}

/// @relates optional
template <class T>
bool operator>(const T& lhs, const optional<T>& rhs) {
  return !rhs || *rhs < lhs;
}

/// @relates optional
template <class T>
bool operator>=(const optional<T>& lhs, const T& rhs) {
  return lhs && !(*lhs < rhs);
}

/// @relates optional
template <class T>
bool operator>=(const T& lhs, const optional<T>& rhs) {
  return !rhs || !(lhs < *rhs);
}

} // namespace caf

#endif // CAF_OPTIONAL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DEDUCE_MPI_HPP
#define CAF_DEDUCE_MPI_HPP

#include <type_traits>

#include "caf/fwd.hpp"
#include "caf/param.hpp"
#include "caf/expected.hpp"
#include "caf/optional.hpp"
#include "caf/replies_to.hpp"
#include "caf/stream_result.hpp"

#include "caf/detail/implicit_conversions.hpp"

namespace caf {

namespace detail {

// dmi = deduce_mpi_implementation
template <class T>
struct dmi;

// case #1: function returning a single value
template <class Y, class... Xs>
struct dmi<Y (Xs...)> {
  using type = typed_mpi<type_list<typename param_decay<Xs>::type...>,
                         output_tuple<implicit_conversions_t<Y>>>;
};

// case #2a: function returning a result<...>
template <class... Ys, class... Xs>
struct dmi<result<Ys...> (Xs...)> {
  using type = typed_mpi<type_list<typename param_decay<Xs>::type...>,
                         output_tuple<implicit_conversions_t<Ys>...>>;
};

// case #2b: function returning a stream_result<...>
template <class Y, class... Xs>
struct dmi<stream_result<Y> (Xs...)> {
  using type = typed_mpi<type_list<typename param_decay<Xs>::type...>,
                         output_tuple<implicit_conversions_t<Y>>>;
};

// case #2c: function returning a std::tuple<...>
template <class... Ys, class... Xs>
struct dmi<std::tuple<Ys...> (Xs...)> {
  using type = typed_mpi<type_list<typename param_decay<Xs>::type...>,
                         output_tuple<implicit_conversions_t<Ys>...>>;
};

// case #2d: function returning a std::tuple<...>
template <class... Ys, class... Xs>
struct dmi<delegated<Ys...> (Xs...)> {
  using type = typed_mpi<type_list<typename param_decay<Xs>::type...>,
                         output_tuple<implicit_conversions_t<Ys>...>>;
};

// case #2d: function returning a typed_response_promise<...>
template <class... Ys, class... Xs>
struct dmi<typed_response_promise<Ys...> (Xs...)> {
  using type = typed_mpi<type_list<typename param_decay<Xs>::type...>,
                         output_tuple<implicit_conversions_t<Ys>...>>;
};

// case #3: function returning an optional<>
template <class Y, class... Xs>
struct dmi<optional<Y> (Xs...)> : dmi<Y (Xs...)> {};

// case #4: function returning an expected<>
template <class Y, class... Xs>
struct dmi<expected<Y> (Xs...)> : dmi<Y (Xs...)> {};

// case #5: function returning an annotated_stream<>
template <class Y, class... Ys, class... Xs>
struct dmi<annotated_stream<Y, Ys...> (Xs...)> : dmi<Y (Xs...)> {
  using type =
    typed_mpi<type_list<typename param_decay<Xs>::type...>,
              output_tuple<stream<Y>, strip_and_convert_t<Ys>...>>;
};

// -- dmfou = deduce_mpi_function_object_unboxing

template <class T, bool isClass = std::is_class<T>::value>
struct dmfou;

// case #1: const member function pointer
template <class C, class Result, class... Ts>
struct dmfou<Result (C::*)(Ts...) const, false> : dmi<Result (Ts...)> {};

// case #2: member function pointer
template <class C, class Result, class... Ts>
struct dmfou<Result (C::*)(Ts...), false> : dmi<Result (Ts...)> {};

// case #3: good ol' function
template <class Result, class... Ts>
struct dmfou<Result(Ts...), false> : dmi<Result (Ts...)> {};

template <class T>
struct dmfou<T, true> : dmfou<decltype(&T::operator()), false> {};

// this specialization leaves timeout definitions untouched,
// later stages such as interface_mismatch need to deal with them later
template <class T>
struct dmfou<timeout_definition<T>, true> {
  using type = timeout_definition<T>;
};

template <class T>
struct dmfou<trivial_match_case<T>, true> : dmfou<T> {};

} // namespace detail

/// Deduces the message passing interface from a function object.
template <class T>
using deduce_mpi_t = typename detail::dmfou<typename param_decay<T>::type>::type;

} // namespace caf

#endif // CAF_DEDUCE_MPI_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MIXIN_BUFFERED_SCATTERER_HPP
#define CAF_MIXIN_BUFFERED_SCATTERER_HPP

#include <deque>
#include <vector>
#include <cstddef>
#include <iterator>

#include "caf/sec.hpp"
#include "caf/stream_edge_impl.hpp"
#include "caf/actor_control_block.hpp"
#include "caf/stream_scatterer_impl.hpp"

namespace caf {

/// Mixin for streams with any number of downstreams. `Subtype` must provide a
/// member function `buf()` returning a queue with `std::deque`-like interface.
template <class T>
class buffered_scatterer : public stream_scatterer_impl {
public:
  using super = stream_scatterer_impl;

  using value_type = T;

  using buffer_type = std::deque<value_type>;

  using chunk_type = std::vector<value_type>;

  buffered_scatterer(local_actor* selfptr) : super(selfptr) {
    // nop
  }

  template <class T0, class... Ts>
  void push(T0&& x, Ts&&... xs) {
    buf_.emplace_back(std::forward<T0>(x), std::forward<Ts>(xs)...);
  }

  /// @pre `n <= buf_.size()`
  static chunk_type get_chunk(buffer_type& buf, long n) {
    CAF_LOG_TRACE(CAF_ARG(buf) << CAF_ARG(n));
    chunk_type xs;
    if (n > 0) {
      xs.reserve(static_cast<size_t>(n));
      if (static_cast<size_t>(n) < buf.size()) {
        auto first = buf.begin();
        auto last = first + static_cast<ptrdiff_t>(n);
        std::move(first, last, std::back_inserter(xs));
        buf.erase(first, last);
      } else {
        std::move(buf.begin(), buf.end(), std::back_inserter(xs));
        buf.clear();
      }
    }
    return xs;
  }

  chunk_type get_chunk(long n) {
    return get_chunk(buf_, n);
  }

  long buffered() const override {
    return static_cast<long>(buf_.size());
  }

  buffer_type& buf() {
    return buf_;
  }

  const buffer_type& buf() const {
    return buf_;
  }

protected:
  buffer_type buf_;
};

} // namespace caf

#endif // CAF_MIXIN_BUFFERED_SCATTERER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_GROUP_MANAGER_HPP
#define CAF_GROUP_MANAGER_HPP

#include <map>
#include <mutex>
#include <thread>
#include <unordered_map>

#include "caf/fwd.hpp"
#include "caf/optional.hpp"
#include "caf/expected.hpp"
#include "caf/group_module.hpp"
#include "caf/abstract_group.hpp"
#include "caf/detail/shared_spinlock.hpp"

namespace caf {

class group_manager {
public:
  // -- friends ----------------------------------------------------------------

  friend class actor_system;

  // -- member types -----------------------------------------------------------

  using modules_map = std::unordered_map<std::string,
                                         std::unique_ptr<group_module>>;

  // -- constructors, destructors, and assignment operators --------------------

  ~group_manager();

  // -- observers --------------------------------------------------------------

  /// Get a handle to the group associated with given URI scheme.
  /// @threadsafe
  /// @experimental
  expected<group> get(std::string group_uri) const;

  /// Get a handle to the group associated with
  /// `identifier` from the module `mod_name`.
  /// @threadsafe
  expected<group> get(const std::string& module_name,
                      const std::string& group_identifier) const;

  /// Get a pointer to the group associated with
  /// `identifier` from the module `local`.
  /// @threadsafe
  group get_local(const std::string& group_identifier) const;

  /// Returns an anonymous group.
  /// Each calls to this member function returns a new instance
  /// of an anonymous group. Anonymous groups can be used whenever
  /// a set of actors wants to communicate using an exclusive channel.
  group anonymous() const;

  /// Returns the module named `name` if it exists, otherwise `none`.
  optional<group_module&> get_module(const std::string& x) const;

private:
  // -- constructors, destructors, and assignment operators --------------------

  group_manager(actor_system& sys);

  // -- member functions required by actor_system ------------------------------

  void init(actor_system_config& cfg);

  void start();

  void stop();

  // -- data members -----------------------------------------------------------

  modules_map mmap_;
  actor_system& system_;
};

} // namespace caf

#endif // CAF_GROUP_MANAGER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TERMINAL_STREAM_SCATTERER_HPP
#define CAF_TERMINAL_STREAM_SCATTERER_HPP

#include "caf/stream_scatterer.hpp"

namespace caf {

/// Special-purpose scatterer for sinks that terminate a stream. A terminal
/// stream scatterer generates credit without downstream actors.
class terminal_stream_scatterer : public stream_scatterer {
public:
  terminal_stream_scatterer() = default;

  ~terminal_stream_scatterer() override;

  path_ptr add_path(const stream_id& sid, strong_actor_ptr origin,
                    strong_actor_ptr sink_ptr,
                    mailbox_element::forwarding_stack stages,
                    message_id handshake_mid, message handshake_data,
                    stream_priority prio, bool redeployable) override;

  path_ptr confirm_path(const stream_id& sid, const actor_addr& from,
                        strong_actor_ptr to, long initial_demand,
                        bool redeployable) override;

  bool remove_path(const stream_id& sid, const actor_addr& x,
                           error reason, bool silent) override;

  bool paths_clean() const override;

  void close() override;

  void abort(error reason) override;

  long num_paths() const override;

  bool closed() const override;

  bool continuous() const override;

  void continuous(bool value) override;

  path_type* path_at(size_t index) override;

  void emit_batches() override;

  path_type* find(const stream_id& sid, const actor_addr& x) override;

  long credit() const override;

  long buffered() const override;

  long min_batch_size() const override;

  long max_batch_size() const override;

  long min_buffer_size() const override;

  duration max_batch_delay() const override;

  void min_batch_size(long x) override;

  void max_batch_size(long x) override;

  void min_buffer_size(long x) override;

  void max_batch_delay(duration x) override;
};

} // namespace caf

#endif // CAF_TERMINAL_STREAM_SCATTERER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_INTERFACE_MISMATCH_HPP
#define CAF_INTERFACE_MISMATCH_HPP

#include "caf/fwd.hpp"
#include "caf/replies_to.hpp"

#include "caf/detail/type_list.hpp"

namespace caf {

namespace detail {

// imi = interface_mismatch_implementation
// Precondition: Pos == 0 && len(Xs) == len(Ys) && len(Zs) == 0
// Iterate over Xs to find a match in Ys; Zs is used as temporary storage
// to iterate over Ys. On a match, the element is removed from Xs and Ys and
// Zs are prepended to Ys again for next iteration.
// Evaluates to:
// * len(Xs) if interface check succeeds
// * Pos on a mismatch (incremented per iteration to reflect position in Xs)
template <int Pos, class Xs, class Ys, class Zs>
struct imi;

// end of recursion: success (consumed both lists)
template <int Pos>
struct imi<Pos, type_list<>, type_list<>, type_list<>> {
  static constexpr int value = Pos;
  using xs = type_list<>;
  using ys = type_list<>;
};

// end of recursion: success (consumed both lists, except the timeout)
template <int Pos, class X>
struct imi<Pos, type_list<timeout_definition<X>>, type_list<>, type_list<>> {
  static constexpr int value = Pos + 1; // count timeout def. as consumed
  using xs = type_list<>;
  using ys = type_list<>;
};

// end of recursion: failure (consumed all Xs but not all Ys)
template <int Pos, class Yin, class Yout, class... Ys>
struct imi<Pos, type_list<>, type_list<typed_mpi<Yin, Yout>, Ys...>, type_list<>> {
  static constexpr int value = -1;
  using xs = type_list<>;
  using ys = type_list<typed_mpi<Yin, Yout>, Ys...>;
};

// end of recursion: failure (consumed all Ys but not all Xs)
template <int Pos, class Xin, class Xout, class... Xs>
struct imi<Pos, type_list<typed_mpi<Xin, Xout>, Xs...>, type_list<>, type_list<>> {
  static constexpr int value = -2;
  using xs = type_list<typed_mpi<Xin, Xout>, Xs...>;
  using ys = type_list<>;
};

// end of recursion: failure (consumed all Ys except timeout but not all Xs)
template <int Pos, class X, class Y, class... Ys>
struct imi<Pos, type_list<timeout_definition<X>>,
           type_list<Y, Ys...>, type_list<>> {
  static constexpr int value = -2;
  using xs = type_list<>;
  using ys = type_list<Y, Ys...>;
};

// case #1: exact match
template <int Pos, class In, class Out, class... Xs, class... Ys, class... Zs>
struct imi<Pos,
           type_list<typed_mpi<In, Out>, Xs...>,
           type_list<typed_mpi<In, Out>, Ys...>,
           type_list<Zs...>>
    : imi<Pos + 1, type_list<Xs...>, type_list<Zs..., Ys...>, type_list<>> {};

// case #2: match with skip_t
template <int Pos, class In, class... Xs, class Out, class... Ys, class... Zs>
struct imi<Pos,
           type_list<typed_mpi<In, output_tuple<skip_t>>, Xs...>,
           type_list<typed_mpi<In, Out>, Ys...>,
           type_list<Zs...>>
    : imi<Pos + 1, type_list<Xs...>, type_list<Zs..., Ys...>, type_list<>> {};

// case #3: no match at position
template <int Pos, class Xin, class Xout, class... Xs,
          class Yin, class Yout, class... Ys, class... Zs>
struct imi<Pos,
           type_list<typed_mpi<Xin, Xout>, Xs...>,
           type_list<typed_mpi<Yin, Yout>, Ys...>,
           type_list<Zs...>>
    : imi<Pos,
          type_list<typed_mpi<Xin, Xout>, Xs...>,
          type_list<Ys...>,
          type_list<Zs..., typed_mpi<Yin, Yout>>> {};

// case #4: no match (error)
template <int Pos, class X, class... Xs, class... Zs>
struct imi<Pos, type_list<X, Xs...>, type_list<>, type_list<Zs...>> {
  static constexpr int value = Pos;
  using xs = type_list<X, Xs...>;
  using ys = type_list<Zs...>;
};

} // namespace detail

/// Scans two typed MPI lists for compatibility, returning the index of the
/// first mismatch. Returns the number of elements on a match.
/// @pre len(Found) == len(Expected)
template <class Found, class Expected>
using interface_mismatch_t = detail::imi<0, Found, Expected,
                                         detail::type_list<>>;

} // namespace caf

#endif // CAF_INTERFACE_MISMATCH_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ACTOR_REGISTRY_HPP
#define CAF_ACTOR_REGISTRY_HPP

#include <mutex>
#include <thread>
#include <atomic>
#include <cstdint>
#include <unordered_map>
#include <condition_variable>

#include "caf/fwd.hpp"
#include "caf/actor.hpp"
#include "caf/actor_cast.hpp"
#include "caf/abstract_actor.hpp"
#include "caf/actor_control_block.hpp"

#include "caf/detail/shared_spinlock.hpp"

namespace caf {

/// A registry is used to associate actors to IDs or atoms (names). This
/// allows a middleman to lookup actor handles after receiving actor IDs
/// via the network and enables developers to use well-known names to
/// identify important actors independent from their ID at runtime.
/// Note that the registry does *not* contain all actors of an actor system.
/// The middleman registers actors as needed.
class actor_registry {
public:
  friend class actor_system;

  ~actor_registry();

  /// Returns the local actor associated to `key`.
  template<class T = strong_actor_ptr>
  T get(actor_id key) const {
      return actor_cast<T>(get_impl(key));
  }

  /// Associates a local actor with its ID.
  template<class T>
  void put(actor_id key, const T& val) {
      put_impl(key, actor_cast<strong_actor_ptr>(val));
  }

  /// Removes an actor from this registry,
  /// leaving `reason` for future reference.
  void erase(actor_id key);

  /// Increases running-actors-count by one.
  void inc_running();

  /// Decreases running-actors-count by one.
  void dec_running();

  /// Returns the number of currently running actors.
  size_t running() const;

  /// Blocks the caller until running-actors-count becomes `expected`
  /// (must be either 0 or 1).
  void await_running_count_equal(size_t expected) const;

  /// Returns the actor associated with `key` or `invalid_actor`.
  template<class T = strong_actor_ptr>
  T get(atom_value key) const {
      return actor_cast<T>(get_impl(key));
  }

  /// Associates given actor to `key`.
  template<class T>
  void put(atom_value key, const T& value) {
      // using reference here and before to allow putting a scoped_actor without calling .ptr()
      put_impl(key, actor_cast<strong_actor_ptr>(value));
  }

  /// Removes a name mapping.
  void erase(atom_value key);

  using name_map = std::unordered_map<atom_value, strong_actor_ptr>;

  name_map named_actors() const;

private:
  // Starts this component.
  void start();

  // Stops this component.
  void stop();

  /// Returns the local actor associated to `key`.
  strong_actor_ptr get_impl(actor_id key) const;

  /// Associates a local actor with its ID.
  void put_impl(actor_id key, strong_actor_ptr val);

  /// Returns the actor associated with `key` or `invalid_actor`.
  strong_actor_ptr get_impl(atom_value key) const;

  /// Associates given actor to `key`.
  void put_impl(atom_value key, strong_actor_ptr value);

  using entries = std::unordered_map<actor_id, strong_actor_ptr>;

  actor_registry(actor_system& sys);

  std::atomic<size_t> running_;
  mutable std::mutex running_mtx_;
  mutable std::condition_variable running_cv_;

  mutable detail::shared_spinlock instances_mtx_;
  entries entries_;

  name_map named_entries_;
  mutable detail::shared_spinlock named_entries_mtx_;

  actor_system& system_;
};

} // namespace caf

#endif // CAF_ACTOR_REGISTRY_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ALL_HPP
#define CAF_ALL_HPP

#include "caf/config.hpp"

#include "caf/sec.hpp"
#include "caf/atom.hpp"
#include "caf/send.hpp"
#include "caf/skip.hpp"
#include "caf/unit.hpp"
#include "caf/term.hpp"
#include "caf/actor.hpp"
#include "caf/after.hpp"
#include "caf/error.hpp"
#include "caf/group.hpp"
#include "caf/extend.hpp"
#include "caf/logger.hpp"
#include "caf/others.hpp"
#include "caf/result.hpp"
#include "caf/stream.hpp"
#include "caf/message.hpp"
#include "caf/node_id.hpp"
#include "caf/behavior.hpp"
#include "caf/duration.hpp"
#include "caf/expected.hpp"
#include "caf/exec_main.hpp"
#include "caf/resumable.hpp"
#include "caf/streambuf.hpp"
#include "caf/to_string.hpp"
#include "caf/actor_addr.hpp"
#include "caf/actor_pool.hpp"
#include "caf/attachable.hpp"
#include "caf/message_id.hpp"
#include "caf/replies_to.hpp"
#include "caf/serializer.hpp"
#include "caf/actor_clock.hpp"
#include "caf/actor_proxy.hpp"
#include "caf/exit_reason.hpp"
#include "caf/local_actor.hpp"
#include "caf/ref_counted.hpp"
#include "caf/thread_hook.hpp"
#include "caf/typed_actor.hpp"
#include "caf/actor_system.hpp"
#include "caf/deserializer.hpp"
#include "caf/scoped_actor.hpp"
#include "caf/actor_ostream.hpp"
#include "caf/function_view.hpp"
#include "caf/index_mapping.hpp"
#include "caf/spawn_options.hpp"
#include "caf/abstract_actor.hpp"
#include "caf/abstract_group.hpp"
#include "caf/blocking_actor.hpp"
#include "caf/deep_to_string.hpp"
#include "caf/execution_unit.hpp"
#include "caf/memory_managed.hpp"
#include "caf/stateful_actor.hpp"
#include "caf/typed_behavior.hpp"
#include "caf/proxy_registry.hpp"
#include "caf/behavior_policy.hpp"
#include "caf/message_builder.hpp"
#include "caf/message_handler.hpp"
#include "caf/response_handle.hpp"
#include "caf/fused_scatterer.hpp"
#include "caf/random_gatherer.hpp"
#include "caf/system_messages.hpp"
#include "caf/abstract_channel.hpp"
#include "caf/may_have_timeout.hpp"
#include "caf/message_priority.hpp"
#include "caf/typed_actor_view.hpp"
#include "caf/binary_serializer.hpp"
#include "caf/composed_behavior.hpp"
#include "caf/event_based_actor.hpp"
#include "caf/primitive_variant.hpp"
#include "caf/timeout_definition.hpp"
#include "caf/broadcast_scatterer.hpp"
#include "caf/actor_system_config.hpp"
#include "caf/binary_deserializer.hpp"
#include "caf/composable_behavior.hpp"
#include "caf/typed_actor_pointer.hpp"
#include "caf/scoped_execution_unit.hpp"
#include "caf/typed_response_promise.hpp"
#include "caf/random_topic_scatterer.hpp"
#include "caf/broadcast_topic_scatterer.hpp"
#include "caf/typed_event_based_actor.hpp"
#include "caf/abstract_composable_behavior.hpp"

#include "caf/decorator/sequencer.hpp"

#include "caf/meta/type_name.hpp"
#include "caf/meta/annotation.hpp"
#include "caf/meta/save_callback.hpp"
#include "caf/meta/load_callback.hpp"
#include "caf/meta/omittable_if_empty.hpp"

#include "caf/scheduler/test_coordinator.hpp"
#include "caf/scheduler/abstract_coordinator.hpp"

///
/// @mainpage CAF
///
/// @section Intro Introduction
///
/// This library provides an implementation of the actor model for C++.
/// It uses a network transparent messaging system to ease development
/// of both concurrent and distributed software.
///
/// `libcaf` uses a thread pool to schedule actors by default.
/// A scheduled actor should not call blocking functions.
/// Individual actors can be spawned (created) with a special flag to run in
/// an own thread if one needs to make use of blocking APIs.
///
/// Writing applications in `libcaf` requires a minimum of gluecode and
/// each context <i>is</i> an actor. Scoped actors allow actor interaction
/// from the context of threads such as main.
///
/// @section GettingStarted Getting Started
///
/// To build `libcaf,` you need `GCC >= 4.8 or <tt>Clang >= 3.2</tt>,
/// and `CMake`.
///
/// The usual build steps on Linux and macOS are:
///
///- `./configure
///- `make
///- `make install (as root, optionally)
///
/// Please run the unit tests as well to verify that `libcaf`
/// works properly.
///
///- `make test
///
/// Please submit a bug report that includes (a) your compiler version,
/// (b) your OS, and (c) the output of the unit tests if an error occurs:
/// https://github.com/actor-framework/actor-framework/issues
///
/// Please read the <b>Manual</b> for an introduction to `libcaf`.
/// It is available online on Read The Docs at
/// https://actor-framework.readthedocs.io or as PDF at
/// http://www.actor-framework.org/pdf/manual.pdf
///
/// @section IntroHelloWorld Hello World Example
///
/// @include hello_world.cpp
///
/// @section IntroMoreExamples More Examples
///
/// The {@link math_actor.cpp Math Actor Example} shows the usage
/// of {@link receive_loop} and {@link caf::arg_match arg_match}.
/// The {@link dining_philosophers.cpp Dining Philosophers Example}
/// introduces event-based actors covers various features of CAF.
///
/// @namespace caf
/// Root namespace of libcaf.
///
/// @namespace caf::mixin
/// Contains mixin classes implementing several actor traits.
///
/// @namespace caf::exit_reason
/// Contains all predefined exit reasons.
///
/// @namespace caf::policy
/// Contains policies encapsulating characteristics or algorithms.
///
/// @namespace caf::io
/// Contains all IO-related classes and functions.
///
/// @namespace caf::io::network
/// Contains classes and functions used for network abstraction.
///
/// @namespace caf::io::basp
/// Contains all classes and functions for the Binary Actor Sytem Protocol.
///
/// @defgroup MessageHandling Message Handling
///
/// This is the beating heart of CAF, since actor programming is
/// a message oriented programming paradigm.
///
/// A message in CAF is a n-tuple of values (with size >= 1).
/// You can use almost every type in a messages as long as it is announced,
/// i.e., known by the type system of CAF.
///
/// @defgroup BlockingAPI Blocking API
///
/// Blocking functions to receive messages.
///
/// The blocking API of CAF is intended to be used for migrating
/// previously threaded applications. When writing new code, you should
/// consider the nonblocking API based on `become` and `unbecome` first.
///
/// @section Send Sending Messages
///
/// The function `send` can be used to send a message to an actor.
/// The first argument is the receiver of the message followed by any number
/// of values:
///
/// ~~
/// // spawn some actors
/// actor_system_config cfg;
/// actor_system system{cfg};
/// auto a1 = system.spawn(...);
/// auto a2 = system.spawn(...);
/// auto a3 = system.spawn(...);
///
/// // an actor executed in the current thread
/// scoped_actor self{system};
///
/// // define an atom for message annotation
/// using hello_atom = atom_constant<atom("hello")>;
/// using compute_atom = atom_constant<atom("compute")>;
/// using result_atom = atom_constant<atom("result")>;
///
/// // send a message to a1
/// self->send(a1, hello_atom::value, "hello a1!");
///
/// // send a message to a1, a2, and a3
/// auto msg = make_message(compute_atom::value, 1, 2, 3);
/// self->send(a1, msg);
/// self->send(a2, msg);
/// self->send(a3, msg);
/// ~~
///
/// @section Receive Receive messages
///
/// The function `receive` takes a `behavior` as argument. The behavior
/// is a list of { callback } rules where the callback argument types
/// define a pattern for matching messages.
///
/// ~~
/// {
///   [](hello_atom, const std::string& msg) {
///     cout << "received hello message: " << msg << endl;
///   },
///   [](compute_atom, int i0, int i1, int i2) {
///     // send our result back to the sender of this messages
///     return make_message(result_atom::value, i0 + i1 + i2);
///   }
/// }
/// ~~
///
/// Blocking actors such as the scoped actor can call their receive member
/// to handle incoming messages.
///
/// ~~
/// self->receive(
///  [](result_atom, int i) {
///    cout << "result is: " << i << endl;
///  }
/// );
/// ~~
///
/// Please read the manual for further details about pattern matching.
///
/// @section Atoms Atoms
///
/// Atoms are a nice way to add semantic informations to a message.
/// Assuming an actor wants to provide a "math sevice" for integers. It
/// could provide operations such as addition, subtraction, etc.
/// This operations all have two operands. Thus, the actor does not know
/// what operation the sender of a message wanted by receiving just two integers.
///
/// Example actor:
/// ~~
/// using plus_atom = atom_constant<atom("plus")>;
/// using minus_atom = atom_constant<atom("minus")>;
/// behavior math_actor() {
///   return {
///     [](plus_atom, int a, int b) {
///       return make_message(atom("result"), a + b);
///     },
///     [](minus_atom, int a, int b) {
///       return make_message(atom("result"), a - b);
///     }
///   };
/// }
/// ~~
///
/// @section ReceiveLoops Receive Loops
///
/// The previous examples used `receive` to create a behavior on-the-fly.
/// This is inefficient in a loop since the argument passed to receive
/// is created in each iteration again. It's possible to store the behavior
/// in a variable and pass that variable to receive. This fixes the issue
/// of re-creation each iteration but rips apart definition and usage.
///
/// There are three convenience functions implementing receive loops to
/// declare behavior where it belongs without unnecessary
/// copies: `receive_while,` `receive_for` and `do_receive`.
///
/// `receive_while` creates a functor evaluating a lambda expression.
/// The loop continues until the given lambda returns `false`. A simple example:
///
/// ~~
/// size_t received = 0;
/// receive_while([&] { return received < 10; }) (
///   [&](int) {
///     ++received;
///   }
/// );
/// // ...
/// ~~
///
/// `receive_for` is a simple ranged-based loop:
///
/// ~~
/// std::vector<int> results;
/// size_t i = 0;
/// receive_for(i, 10) (
///   [&](int value) {
///     results.push_back(value);
///   }
/// );
/// ~~
///
/// `do_receive` returns a functor providing the function `until` that
/// takes a lambda expression. The loop continues until the given lambda
/// returns true. Example:
///
/// ~~
/// size_t received = 0;
/// do_receive (
///   [&](int) {
///     ++received;
///   }
/// ).until([&] { return received >= 10; });
/// // ...
/// ~~
///
/// @section FutureSend Sending Delayed Messages
///
/// The function `delayed_send` provides a simple way to delay a message.
/// This is particularly useful for recurring events, e.g., periodical polling.
/// Usage example:
///
/// ~~
/// scoped_actor self{...};
///
/// self->delayed_send(self, std::chrono::seconds(1), poll_atom::value);
/// bool running = true;
/// self->receive_while([&](){ return running; }) (
///   // ...
///   [&](poll_atom) {
///     // ... poll something ...
///     // and do it again after 1sec
///     self->delayed_send(self, std::chrono::seconds(1), poll_atom::value);
///   }
/// );
/// ~~
///
/// See also the {@link dancing_kirby.cpp dancing kirby example}.
///
/// @defgroup ImplicitConversion Implicit Type Conversions
///
/// The message passing of `libcaf` prohibits pointers in messages because
/// it enforces network transparent messaging.
/// Unfortunately, string literals in `C++` have the type `const char*,
/// resp. `const char[]. Since `libcaf` is a user-friendly library,
/// it silently converts string literals and C-strings to `std::string` objects.
/// It also converts unicode literals to the corresponding STL container.
///
/// A few examples:
/// ~~
/// // sends an std::string containing "hello actor!" to itself
/// send(self, "hello actor!");
///
/// const char* cstring = "cstring";
/// // sends an std::string containing "cstring" to itself
/// send(self, cstring);
///
/// // sends an std::u16string containing the UTF16 string "hello unicode world!"
/// send(self, u"hello unicode world!");
///
/// // x has the type caf::tuple<std::string, std::string>
/// auto x = make_message("hello", "tuple");
/// ~~
///
/// @defgroup ActorCreation Creating Actors

// examples

/// A trivial example program.
/// @example hello_world.cpp

/// A simple example for a delayed_send based application.
/// @example dancing_kirby.cpp

/// An event-based "Dining Philosophers" implementation.
/// @example dining_philosophers.cpp

#endif // CAF_ALL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_INVOKE_MESSAGE_RESULT_HPP
#define CAF_INVOKE_MESSAGE_RESULT_HPP

namespace caf {

enum invoke_message_result {
  im_success,
  im_skipped,
  im_dropped
};

inline std::string to_string(invoke_message_result x) {
  return x == im_success ? "im_success"
                         : (x == im_skipped ? "im_skipped" : "im_dropped" );
}

} // namespace caf

#endif // CAF_INVOKE_MESSAGE_RESULT_HPP

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ACTOR_CONTROL_BLOCK_HPP
#define CAF_ACTOR_CONTROL_BLOCK_HPP

#include <atomic>

#include "caf/fwd.hpp"
#include "caf/error.hpp"
#include "caf/node_id.hpp"
#include "caf/intrusive_ptr.hpp"
#include "caf/weak_intrusive_ptr.hpp"

#include "caf/meta/type_name.hpp"
#include "caf/meta/save_callback.hpp"
#include "caf/meta/load_callback.hpp"
#include "caf/meta/omittable_if_none.hpp"

namespace caf {

/// Actors are always allocated with a control block that stores its identity
/// as well as strong and weak reference counts to it. Unlike
/// "common" weak pointer designs, the goal is not to allocate the data
/// separately. Instead, the only goal is to break cycles. For
/// example, linking two actors automatically creates a cycle when using
/// strong reference counts only.
///
/// When allocating a new actor, CAF will always embed the user-defined
/// actor in an `actor_storage` with the control block prefixing the
/// actual actor type, as shown below.
///
///     +----------------------------------------+
///     |            actor_storage<T>            |
///     +----------------------------------------+
///     | +-----------------+------------------+ |
///     | |  control block  |  actor data (T)  | |
///     | +-----------------+------------------+ |
///     | | ref count       | mailbox          | |
///     | | weak ref count  | .                | |
///     | | actor ID        | .                | |
///     | | node ID         | .                | |
///     | +-----------------+------------------+ |
///     +----------------------------------------+
///
/// Actors start with a strong reference count of 1. This count is transferred
/// to the first `actor` or `typed_actor` handle used to store the actor.
/// Actors will also start with a weak reference count of 1. This count
/// is decremenated once the strong reference count drops to 0.
///
/// The data block is destructed by calling the destructor of `T` when the
/// last strong reference expires. The storage itself is destroyed when
/// the last weak reference expires.
class actor_control_block {
public:
  using data_destructor = void (*)(abstract_actor*);
  using block_destructor = void (*)(actor_control_block*);

  actor_control_block(actor_id x, node_id& y, actor_system* sys,
                      data_destructor ddtor, block_destructor bdtor)
      : strong_refs(1),
        weak_refs(1),
        aid(x),
        nid(std::move(y)),
        home_system(sys),
        data_dtor(ddtor),
        block_dtor(bdtor) {
    // nop
  }

  actor_control_block(const actor_control_block&) = delete;
  actor_control_block& operator=(const actor_control_block&) = delete;

  std::atomic<size_t> strong_refs;
  std::atomic<size_t> weak_refs;
  const actor_id aid;
  const node_id nid;
  actor_system* const home_system;
  const data_destructor data_dtor;
  const block_destructor block_dtor;

  static_assert(sizeof(std::atomic<size_t>) == sizeof(void*),
                "std::atomic not lockfree on this platform");

  static_assert(sizeof(intrusive_ptr<node_id::data>) == sizeof(void*),
                "intrusive_ptr<T> and T* have different size");

  static_assert(sizeof(node_id) == sizeof(void*),
                "sizeof(node_id) != sizeof(size_t)");

  static_assert(sizeof(data_destructor) == sizeof(void*),
                "functiion pointer and regular pointers have different size");

  /// Returns a pointer to the actual actor instance.
  inline abstract_actor* get() {
    // this pointer arithmetic is compile-time checked in actor_storage's ctor
    return reinterpret_cast<abstract_actor*>(
      reinterpret_cast<intptr_t>(this) + CAF_CACHE_LINE_SIZE);
  }

  /// Returns a pointer to the control block that stores
  /// identity and reference counts for this actor.
  static actor_control_block* from(const abstract_actor* ptr) {
    // this pointer arithmetic is compile-time checked in actor_storage's ctor
    return reinterpret_cast<actor_control_block*>(
          reinterpret_cast<intptr_t>(ptr) - CAF_CACHE_LINE_SIZE);
  }

  /// @cond PRIVATE

  actor_addr address();

  inline actor_id id() const noexcept {
    return aid;
  }

  inline const node_id& node() const noexcept {
    return nid;
  }

  void enqueue(strong_actor_ptr sender, message_id mid,
               message content, execution_unit* host);

  void enqueue(mailbox_element_ptr what, execution_unit* host);

  /// @endcond
};

/// @relates actor_control_block
bool intrusive_ptr_upgrade_weak(actor_control_block* x);

/// @relates actor_control_block
inline void intrusive_ptr_add_weak_ref(actor_control_block* x) {
  x->weak_refs.fetch_add(1, std::memory_order_relaxed);
}

/// @relates actor_control_block
void intrusive_ptr_release_weak(actor_control_block* x);

/// @relates actor_control_block
inline void intrusive_ptr_add_ref(actor_control_block* x) {
  x->strong_refs.fetch_add(1, std::memory_order_relaxed);
}

/// @relates actor_control_block
void intrusive_ptr_release(actor_control_block* x);

/// @relates abstract_actor
/// @relates actor_control_block
using strong_actor_ptr = intrusive_ptr<actor_control_block>;

/// @relates strong_actor_ptr
bool operator==(const strong_actor_ptr&, const abstract_actor*);

/// @relates strong_actor_ptr
bool operator==(const abstract_actor*, const strong_actor_ptr&);

/// @relates strong_actor_ptr
inline bool operator!=(const strong_actor_ptr& x, const abstract_actor* y) {
  return !(x == y);
}

/// @relates strong_actor_ptr
inline bool operator!=(const abstract_actor* x, const strong_actor_ptr& y) {
  return !(x == y);
}

/// @relates abstract_actor
/// @relates actor_control_block
using weak_actor_ptr = weak_intrusive_ptr<actor_control_block>;

error load_actor(strong_actor_ptr& storage, execution_unit*,
                 actor_id aid, const node_id& nid);

error save_actor(strong_actor_ptr& storage, execution_unit*,
                 actor_id aid, const node_id& nid);

template <class Inspector>
auto context_of(Inspector* f) -> decltype(f->context()) {
  return f->context();
}

inline execution_unit* context_of(void*) {
  return nullptr;
}

std::string to_string(const strong_actor_ptr& x);

void append_to_string(std::string& x, const strong_actor_ptr& y);

std::string to_string(const weak_actor_ptr& x);

void append_to_string(std::string& x, const weak_actor_ptr& y);

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, strong_actor_ptr& x) {
  actor_id aid = 0;
  node_id nid;
  if (x) {
    aid = x->aid;
    nid = x->nid;
  }
  auto load = [&] { return load_actor(x, context_of(&f), aid, nid); };
  auto save = [&] { return save_actor(x, context_of(&f), aid, nid); };
  return f(meta::type_name("actor"), aid,
           meta::omittable_if_none(), nid,
           meta::load_callback(load), meta::save_callback(save));
}

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, weak_actor_ptr& x) {
  // inspect as strong pointer, then write back to weak pointer on save
  auto tmp = x.lock();
  auto load = [&]() -> error { x.reset(tmp.get()); return none; };
  return f(tmp, meta::load_callback(load));
}

} // namespace caf

// allow actor pointers to be used in hash maps
namespace std {

template <>
struct hash<caf::strong_actor_ptr> {
  inline size_t operator()(const caf::strong_actor_ptr& ptr) const {
    return ptr ? static_cast<size_t>(ptr->id()) : 0;
  }
};

template <>
struct hash<caf::weak_actor_ptr> {
  inline size_t operator()(const caf::weak_actor_ptr& ptr) const {
    return ptr ? static_cast<size_t>(ptr->id()) : 0;
  }
};

} // namespace std

#endif // CAF_ACTOR_CONTROL_BLOCK_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://openresult.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_RESULT_TRAIT_HPP
#define CAF_STREAM_RESULT_TRAIT_HPP

#include "caf/unit.hpp"
#include "caf/behavior.hpp"

#include "caf/detail/type_traits.hpp"

namespace caf {

template <class F>
struct stream_result_trait;

template <class T>
struct stream_result_trait<void (expected<T>)> {
  using type = T;
  template <class OnResult>
  static behavior make_result_handler(OnResult f) {
    return {
      [=](T& res) {
        f(std::move(res));
      },
      [=](error& err) {
        f(std::move(err));
      }
    };
  }
};

template <>
struct stream_result_trait<void (expected<void>)> {
  using type = void;
  template <class OnResult>
  static behavior make_result_handler(OnResult f) {
    return {
      [=]() {
        f(unit);
      },
      [=](error& err) {
        f(std::move(err));
      }
    };
  }
};

template <class F>
using stream_result_trait_t =
  stream_result_trait<typename detail::get_callable_trait<F>::fun_sig>;

} // namespace caf

#endif // CAF_STREAM_RESULT_TRAIT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DEFAULT_ATTACHABLE_HPP
#define CAF_DEFAULT_ATTACHABLE_HPP

#include "caf/actor_addr.hpp"
#include "caf/attachable.hpp"

namespace caf {

class default_attachable : public attachable {
public:
  enum observe_type {
    monitor,
    link
  };

  struct observe_token {
    actor_addr observer;
    observe_type type;
    static constexpr size_t token_type = attachable::token::observer;
  };

  void actor_exited(const error& rsn, execution_unit* host) override;

  bool matches(const token& what) override;

  inline static attachable_ptr make_monitor(actor_addr observed,
                                            actor_addr observer) {
    return attachable_ptr{new default_attachable(std::move(observed),
                                                 std::move(observer), monitor)};
  }

  inline static attachable_ptr make_link(actor_addr observed,
                                         actor_addr observer) {
    return attachable_ptr{new default_attachable(std::move(observed),
                                                 std::move(observer), link)};
  }

  class predicate {
  public:
    inline predicate(actor_addr observer, observe_type type)
        : observer_(std::move(observer)),
          type_(type) {
      // nop
    }

    inline bool operator()(const attachable_ptr& ptr) const {
      return ptr->matches(observe_token{observer_, type_});
    }

  private:
    actor_addr observer_;
    observe_type type_;
  };

private:
  default_attachable(actor_addr observed, actor_addr observer, observe_type type);
  actor_addr observed_;
  actor_addr observer_;
  observe_type type_;
};

} // namespace caf


#endif // CAF_DEFAULT_ATTACHABLE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_INTRUSIVE_PTR_HPP
#define CAF_INTRUSIVE_PTR_HPP

#include <string>
#include <cstddef>
#include <cinttypes>
#include <algorithm>
#include <stdexcept>
#include <type_traits>

#include "caf/detail/comparable.hpp"

namespace caf {

/// An intrusive, reference counting smart pointer implementation.
/// @relates ref_counted
template <class T>
class intrusive_ptr {
public:
  using pointer = T*;
  using const_pointer = const T*;
  using element_type = T;
  using reference = T&;
  using const_reference = const T&;

  // tell actor_cast which semantic this type uses
  static constexpr bool has_weak_ptr_semantics = false;

  constexpr intrusive_ptr() noexcept : ptr_(nullptr) {
    // nop
  }

  intrusive_ptr(pointer raw_ptr, bool add_ref = true) noexcept {
    set_ptr(raw_ptr, add_ref);
  }

  intrusive_ptr(intrusive_ptr&& other) noexcept : ptr_(other.detach()) {
    // nop
  }

  intrusive_ptr(const intrusive_ptr& other) noexcept {
    set_ptr(other.get(), true);
  }

  template <class Y>
  intrusive_ptr(intrusive_ptr<Y> other) noexcept : ptr_(other.detach()) {
    static_assert(std::is_convertible<Y*, T*>::value,
                  "Y* is not assignable to T*");
  }

  ~intrusive_ptr() {
    if (ptr_)
      intrusive_ptr_release(ptr_);
  }

  void swap(intrusive_ptr& other) noexcept {
    std::swap(ptr_, other.ptr_);
  }

  /// Returns the raw pointer without modifying reference
  /// count and sets this to `nullptr`.
  pointer detach() noexcept {
    auto result = ptr_;
    if (result)
      ptr_ = nullptr;
    return result;
  }

  /// Returns the raw pointer without modifying reference
  /// count and sets this to `nullptr`.
  pointer release() noexcept {
    return detach();
  }

  void reset(pointer new_value = nullptr, bool add_ref = true) noexcept {
    auto old = ptr_;
    set_ptr(new_value, add_ref);
    if (old)
      intrusive_ptr_release(old);
  }

  intrusive_ptr& operator=(pointer ptr) noexcept {
    reset(ptr);
    return *this;
  }

  intrusive_ptr& operator=(intrusive_ptr other) noexcept {
    swap(other);
    return *this;
  }

  pointer get() const noexcept {
    return ptr_;
  }

  pointer operator->() const noexcept {
    return ptr_;
  }

  reference operator*() const noexcept {
    return *ptr_;
  }

  bool operator!() const noexcept {
    return !ptr_;
  }

  explicit operator bool() const noexcept {
    return ptr_ != nullptr;
  }

  ptrdiff_t compare(const_pointer ptr) const noexcept {
    return static_cast<ptrdiff_t>(get() - ptr);
  }

  ptrdiff_t compare(const intrusive_ptr& other) const noexcept {
    return compare(other.get());
  }

  ptrdiff_t compare(std::nullptr_t) const noexcept {
    return reinterpret_cast<ptrdiff_t>(get());
  }

  template <class C>
  intrusive_ptr<C> downcast() const noexcept {
    return (ptr_) ? dynamic_cast<C*>(get()) : nullptr;
  }

  template <class C>
  intrusive_ptr<C> upcast() const noexcept {
    return (ptr_) ? static_cast<C*>(get()) : nullptr;
  }

private:
  void set_ptr(pointer raw_ptr, bool add_ref) noexcept {
    ptr_ = raw_ptr;
    if (raw_ptr && add_ref)
      intrusive_ptr_add_ref(raw_ptr);
  }

  pointer ptr_;
};

// -- comparison to nullptr ----------------------------------------------------

/// @relates intrusive_ptr
template <class T>
bool operator==(const intrusive_ptr<T>& x, std::nullptr_t) {
  return !x;
}

/// @relates intrusive_ptr
template <class T>
bool operator==(std::nullptr_t, const intrusive_ptr<T>& x) {
  return !x;
}

/// @relates intrusive_ptr
template <class T>
bool operator!=(const intrusive_ptr<T>& x, std::nullptr_t) {
  return static_cast<bool>(x);
}

/// @relates intrusive_ptr
template <class T>
bool operator!=(std::nullptr_t, const intrusive_ptr<T>& x) {
  return static_cast<bool>(x);
}

// -- comparison to raw pointer ------------------------------------------------

/// @relates intrusive_ptr
template <class T>
bool operator==(const intrusive_ptr<T>& x, const T* y) {
  return x.get() == y;
}

/// @relates intrusive_ptr
template <class T>
bool operator==(const T* x, const intrusive_ptr<T>& y) {
  return x == y.get();
}

/// @relates intrusive_ptr
template <class T>
bool operator!=(const intrusive_ptr<T>& x, const T* y) {
  return x.get() != y;
}

/// @relates intrusive_ptr
template <class T>
bool operator!=(const T* x, const intrusive_ptr<T>& y) {
  return x != y.get();
}

// -- comparison to intrusive_pointer ------------------------------------------

/// @relates intrusive_ptr
template <class T, class U>
bool operator==(const intrusive_ptr<T>& x, const intrusive_ptr<U>& y) {
  return x.get() == y.get();
}

/// @relates intrusive_ptr
template <class T, class U>
bool operator!=(const intrusive_ptr<T>& x, const intrusive_ptr<U>& y) {
  return x.get() != y.get();
}

/// @relates intrusive_ptr
template <class T>
bool operator<(const intrusive_ptr<T>& x, const intrusive_ptr<T>& y) {
  return x.get() < y.get();
}

/// @relates intrusive_ptr
template <class T>
bool operator<(const intrusive_ptr<T>& x, const T* y) {
  return x.get() < y;
}
/// @relates intrusive_ptr
template <class T>
bool operator<(const T* x, const intrusive_ptr<T>& y) {
  return x < y.get();
}

template <class T>
std::string to_string(const intrusive_ptr<T>& x) {
  auto v = reinterpret_cast<uintptr_t>(x.get());
  // we convert to hex representation, i.e.,
  // one byte takes two characters + null terminator + "0x" prefix
  char buf[sizeof(v) * 2 + 3];
  sprintf(buf, "%" PRIxPTR, v);
  return buf;
}

} // namespace caf

#endif // CAF_INTRUSIVE_PTR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ABSTRACT_CHANNEL_HPP
#define CAF_ABSTRACT_CHANNEL_HPP

#include <atomic>

#include "caf/fwd.hpp"
#include "caf/message_id.hpp"

namespace caf {

/// Interface for all message receivers. * This interface describes an
/// entity that can receive messages and is implemented by {@link actor}
/// and {@link group}.
class abstract_channel {
public:
  friend class abstract_actor;
  friend class abstract_group;

  virtual ~abstract_channel();

  /// Enqueues a new message without forwarding stack to the channel.
  virtual void enqueue(strong_actor_ptr sender, message_id mid, message content,
                       execution_unit* host = nullptr) = 0;

  static constexpr int is_abstract_actor_flag       = 0x01000000;

  static constexpr int is_abstract_group_flag       = 0x02000000;

  static constexpr int is_actor_bind_decorator_flag = 0x04000000;

  static constexpr int is_actor_dot_decorator_flag  = 0x08000000;

  static constexpr int is_actor_decorator_mask      = 0x0C000000;

  static constexpr int is_hidden_flag               = 0x10000000;

  inline bool is_abstract_actor() const {
    return static_cast<bool>(flags() & is_abstract_actor_flag);
  }

  inline bool is_abstract_group() const {
    return static_cast<bool>(flags() & is_abstract_group_flag);
  }

  inline bool is_actor_decorator() const {
    return static_cast<bool>(flags() & is_actor_decorator_mask);
  }

protected:
  // note: *both* operations use relaxed memory order, this is because
  // only the actor itself is granted write access while all access
  // from other actors or threads is always read-only; further, only
  // flags that are considered constant after an actor has launched are
  // read by others, i.e., there is no acquire/release semantic between
  // setting and reading flags
  inline int flags() const {
    return flags_.load(std::memory_order_relaxed);
  }

  inline void flags(int new_value) {
    flags_.store(new_value, std::memory_order_relaxed);
  }

private:
  // can only be called from abstract_actor and abstract_group
  abstract_channel(int fs);

  // Accumulates several state and type flags. Subtypes may use only the
  // first 20 bits, i.e., the bitmask 0xFFF00000 is reserved for
  // channel-related flags.
  std::atomic<int> flags_;
};

} // namespace caf

#endif // CAF_ABSTRACT_CHANNEL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_MSG_VISITOR_HPP
#define CAF_STREAM_MSG_VISITOR_HPP

#include <utility>
#include <unordered_map>

#include "caf/fwd.hpp"
#include "caf/stream_msg.hpp"
#include "caf/intrusive_ptr.hpp"
#include "caf/stream_manager.hpp"
#include "caf/scheduled_actor.hpp"

namespace caf {

class stream_msg_visitor {
public:
  using map_type = std::unordered_map<stream_id, intrusive_ptr<stream_manager>>;
  using iterator = typename map_type::iterator;
  using result_type = bool;

  stream_msg_visitor(scheduled_actor* self, const stream_msg& msg,
                     behavior* bhvr);

  result_type operator()(stream_msg::open& x);

  result_type operator()(stream_msg::ack_open& x);

  result_type operator()(stream_msg::batch& x);

  result_type operator()(stream_msg::ack_batch& x);

  result_type operator()(stream_msg::close& x);

  result_type operator()(stream_msg::drop& x);

  result_type operator()(stream_msg::forced_close& x);

  result_type operator()(stream_msg::forced_drop& x);

private:
  // Invokes `f` on the stream manager. On error calls `abort` on the manager
  // and removes it from the streams map.
  template <class F>
  bool invoke(F f) {
    auto e = self_->streams().end();
    auto i = self_->streams().find(sid_);
    if (i == e)
      return false;
    auto err = f(i->second);
    if (err != none) {
      i->second->abort(std::move(err));
      self_->streams().erase(i);
    } else if (i->second->done()) {
      CAF_LOG_DEBUG("manager reported done, remove from streams");
      i->second->close();
      self_->streams().erase(i);
    }
    return true;
  }

  scheduled_actor* self_;
  const stream_id& sid_;
  const actor_addr& sender_;
  behavior* bhvr_;
};

} // namespace caf

#endif // CAF_STREAM_MSG_VISITOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ILLEGAL_MESSAGE_ELEMENT_HPP
#define CAF_ILLEGAL_MESSAGE_ELEMENT_HPP

#include <type_traits>

namespace caf {

/// Marker class identifying classes in CAF that are not allowed
/// to be used as message element.
struct illegal_message_element {
  // no members (marker class)
};

template <class T>
struct is_illegal_message_element
  : std::is_base_of<illegal_message_element, T> { };

} // namespace caf

#endif // CAF_ILLEGAL_MESSAGE_ELEMENT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAMBUF_HPP
#define CAF_STREAMBUF_HPP

#include <algorithm>
#include <cstddef>
#include <cstring>
#include <limits>
#include <streambuf>
#include <type_traits>
#include <vector>

#include "caf/config.hpp"
#include "caf/detail/type_traits.hpp"

namespace caf {

/// The base class for all stream buffer implementations.
template <class CharT = char, class Traits = std::char_traits<CharT>>
class stream_buffer : public std::basic_streambuf<CharT, Traits> {
protected:
  /// The standard only defines pbump(int), which can overflow on 64-bit
  /// architectures. All stream buffer implementations should therefore use
  /// these function instead. For a detailed discussion, see:
  /// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=47921
  template <class T = int>
  typename std::enable_if<sizeof(T) == 4>::type
  safe_pbump(std::streamsize n) {
    while (n > std::numeric_limits<int>::max()) {
      this->pbump(std::numeric_limits<int>::max());
      n -= std::numeric_limits<int>::max();
    }
    this->pbump(static_cast<int>(n));
  }

  template <class T = int>
  typename std::enable_if<sizeof(T) == 8>::type
  safe_pbump(std::streamsize n) {
    this->pbump(static_cast<int>(n));
  }

  // As above, but for the get area.
  template <class T = int>
  typename std::enable_if<sizeof(T) == 4>::type
  safe_gbump(std::streamsize n) {
    while (n > std::numeric_limits<int>::max()) {
      this->gbump(std::numeric_limits<int>::max());
      n -= std::numeric_limits<int>::max();
    }
    this->gbump(static_cast<int>(n));
  }

  template <class T = int>
  typename std::enable_if<sizeof(T) == 8>::type
  safe_gbump(std::streamsize n) {
    this->gbump(static_cast<int>(n));
  }
};

/// A streambuffer abstraction over a fixed array of bytes. This streambuffer
/// cannot overflow/underflow. Once it has reached its end, attempts to read
/// characters will return `trait_type::eof`.
template <class CharT = char, class Traits = std::char_traits<CharT>>
class arraybuf : public stream_buffer<CharT, Traits> {
public:
  using base = std::basic_streambuf<CharT, Traits>;
  using char_type = typename base::char_type;
  using traits_type = typename base::traits_type;
  using int_type = typename base::int_type;
  using pos_type = typename base::pos_type;
  using off_type = typename base::off_type;

  /// Constructs an array streambuffer from a container.
  /// @param c A contiguous container.
  /// @pre `c.data()` must point to a contiguous sequence of characters having
  ///      length `c.size()`.
  template <
    class Container,
    class = typename std::enable_if<
      detail::has_data_member<Container>::value
      && detail::has_size_member<Container>::value
    >::type
  >
  arraybuf(Container& c)
    : arraybuf(const_cast<char_type*>(c.data()), c.size()) {
    // nop
  }

  /// Constructs an array streambuffer from a raw character sequence.
  /// @param data A pointer to the first character.
  /// @param size The length of the character sequence.
  arraybuf(char_type* data, size_t size) {
    setbuf(data, static_cast<std::streamsize>(size));
  }

  // There exists a bug in libstdc++ version < 5: the implementation does not
  // provide  the necessary move constructors, so we have to roll our own :-/.
  // See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54316 for details.
  // TODO: remove after having raised the minimum GCC version to 5.
  arraybuf(arraybuf&& other) {
    this->setg(other.eback(), other.gptr(), other.egptr());
    this->setp(other.pptr(), other.epptr());
    other.setg(nullptr, nullptr, nullptr);
    other.setp(nullptr, nullptr);
  }

  // TODO: remove after having raised the minimum GCC version to 5.
  arraybuf& operator=(arraybuf&& other) {
    this->setg(other.eback(), other.gptr(), other.egptr());
    this->setp(other.pptr(), other.epptr());
    other.setg(nullptr, nullptr, nullptr);
    other.setp(nullptr, nullptr);
    return *this;
  }

protected:
  // -- positioning ----------------------------------------------------------

  std::basic_streambuf<char_type, Traits>*
  setbuf(char_type* s, std::streamsize n) override {
    this->setg(s, s, s + n);
    this->setp(s, s + n);
    return this;
  }

  pos_type seekpos(pos_type pos,
                   std::ios_base::openmode which
                     = std::ios_base::in | std::ios_base::out) override {
    auto get = (which & std::ios_base::in) == std::ios_base::in;
    auto put = (which & std::ios_base::out) == std::ios_base::out;
    if (!(get || put))
      return pos_type(off_type(-1)); // nothing to do
    if (get)
      this->setg(this->eback(), this->eback() + pos, this->egptr());
    if (put) {
      this->setp(this->pbase(), this->epptr());
      this->safe_pbump(pos);
    }
    return pos;
  }

  pos_type seekoff(off_type off,
                   std::ios_base::seekdir dir,
                   std::ios_base::openmode which) override {
    auto new_off = pos_type(off_type(-1));
    auto get = (which & std::ios_base::in) == std::ios_base::in;
    auto put = (which & std::ios_base::out) == std::ios_base::out;
    if (!(get || put))
      return new_off; // nothing to do
    if (get) {
      switch (dir) {
        default:
          return pos_type(off_type(-1));
        case std::ios_base::beg:
          new_off = 0;
          break;
        case std::ios_base::cur:
          new_off = this->gptr() - this->eback();
          break;
        case std::ios_base::end:
          new_off = this->egptr() - this->eback();
          break;
      }
      new_off += off;
      this->setg(this->eback(), this->eback() + new_off, this->egptr());
    }
    if (put) {
      switch (dir) {
        default:
          return pos_type(off_type(-1));
        case std::ios_base::beg:
          new_off = 0;
          break;
        case std::ios_base::cur:
          new_off = this->pptr() - this->pbase();
          break;
        case std::ios_base::end:
          new_off = this->egptr() - this->pbase();
          break;
      }
      new_off += off;
      this->setp(this->pbase(), this->epptr());
      this->safe_pbump(new_off);
    }
    return new_off;
  }

  // -- put area -------------------------------------------------------------

  std::streamsize xsputn(const char_type* s, std::streamsize n) override {
    auto available = this->epptr() - this->pptr();
    auto actual = std::min(n, static_cast<std::streamsize>(available));
    std::memcpy(this->pptr(), s,
                static_cast<size_t>(actual) * sizeof(char_type));
    this->safe_pbump(actual);
    return actual;
  }

  // -- get area -------------------------------------------------------------

  std::streamsize xsgetn(char_type* s, std::streamsize n) override {
    auto available = this->egptr() - this->gptr();
    auto actual = std::min(n, static_cast<std::streamsize>(available));
    std::memcpy(s, this->gptr(),
                static_cast<size_t>(actual) * sizeof(char_type));
    this->safe_gbump(actual);
    return actual;
  }
};

/// A streambuffer abstraction over a contiguous container. It supports
/// reading in the same style as `arraybuf`, but is unbounded for output.
template <class Container>
class containerbuf
  : public stream_buffer<
      typename Container::value_type,
      std::char_traits<typename Container::value_type>
    > {
public:
  using base = std::basic_streambuf<
      typename Container::value_type,
      std::char_traits<typename Container::value_type>
    >;
  using char_type = typename base::char_type;
  using traits_type = typename base::traits_type;
  using int_type = typename base::int_type;
  using pos_type = typename base::pos_type;
  using off_type = typename base::off_type;

  /// Constructs a container streambuf.
  /// @param c A contiguous container.
  template <
    class C = Container,
    class = typename std::enable_if<
      detail::has_data_member<C>::value && detail::has_size_member<C>::value
    >::type
  >
  containerbuf(Container& c) : container_(c) {
    this->setg(const_cast<char_type*>(c.data()),
               const_cast<char_type*>(c.data()),
               const_cast<char_type*>(c.data()) + c.size());
  }

  // See note in arraybuf(arraybuf&&).
  // TODO: remove after having raised the minimum GCC version to 5.
  containerbuf(containerbuf&& other)
    : container_(other.container_) {
    this->setg(other.eback(), other.gptr(), other.egptr());
    other.setg(nullptr, nullptr, nullptr);
  }

  // TODO: remove after having raised the minimum GCC version to 5.
  containerbuf& operator=(containerbuf&& other) {
    this->setg(other.eback(), other.gptr(), other.egptr());
    other.setg(nullptr, nullptr, nullptr);
    return *this;
  }

  // Hides base-class implementation to simplify single-character lookup.
  int_type sgetc() {
    if (this->gptr() == this->egptr())
      return traits_type::eof();
    return traits_type::to_int_type(*this->gptr());
  }

  // Hides base-class implementation to simplify single-character insert.
  int_type sputc(char_type c) {
    container_.push_back(c);
    return c;
  }

protected:
  // We can't get obtain more characters on underflow, so we only optimize
  // multi-character sequential reads.
  std::streamsize xsgetn(char_type* s, std::streamsize n) override {
    auto available = this->egptr() - this->gptr();
    auto actual = std::min(n, static_cast<std::streamsize>(available));
    std::memcpy(s, this->gptr(),
                static_cast<size_t>(actual) * sizeof(char_type));
    this->safe_gbump(actual);
    return actual;
  }

  // Should never get called, because there is always space in the buffer.
  // (But just in case, it does the same thing as sputc.)
  int_type overflow(int_type c = traits_type::eof()) final {
    if (!traits_type::eq_int_type(c, traits_type::eof()))
      container_.push_back(traits_type::to_char_type(c));
    return c;
  }

  std::streamsize xsputn(const char_type* s, std::streamsize n) override {
    // TODO: Do a performance analysis whether the current implementation based
    // on copy_n is faster than these two statements:
    // (1) container_.resize(container_.size() + n);
    // (2) std::memcpy(this->pptr(), s, n * sizeof(char_type));
    std::copy_n(s, n, std::back_inserter(container_));
    return n;
  }

private:
  Container& container_;
};

using charbuf = arraybuf<char>;
using vectorbuf = containerbuf<std::vector<char>>;

} // namespace caf

#endif // CAF_STREAMBUF_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_SCOPED_EXECUTION_UNIT_HPP
#define CAF_SCOPED_EXECUTION_UNIT_HPP

#include "caf/execution_unit.hpp"

namespace caf {

/// Identifies an execution unit, e.g., a worker thread of the scheduler. By
/// querying its execution unit, an actor can access other context information.
class scoped_execution_unit : public execution_unit {
public:
  /// @pre `sys != nullptr`
  explicit scoped_execution_unit(actor_system* sys = nullptr);

  /// Delegates the resumable to the scheduler of `system()`.
  void exec_later(resumable* ptr) override;
};

} // namespace caf

#endif // CAF_SCOPED_EXECUTION_UNIT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TYPED_RESPONSE_PROMISE_HPP
#define CAF_TYPED_RESPONSE_PROMISE_HPP

#include "caf/response_promise.hpp"

#include "caf/detail/type_list.hpp"

namespace caf {

/// A response promise can be used to deliver a uniquely identifiable
/// response message from the server (i.e. receiver of the request)
/// to the client (i.e. the sender of the request).
template <class... Ts>
class typed_response_promise {
public:
  /// Constructs an invalid response promise.
  typed_response_promise() = default;

  inline typed_response_promise(strong_actor_ptr self, mailbox_element& src)
      : promise_(std::move(self), src) {
    // nop
  }

  typed_response_promise(typed_response_promise&&) = default;
  typed_response_promise(const typed_response_promise&) = default;
  typed_response_promise& operator=(typed_response_promise&&) = default;
  typed_response_promise& operator=(const typed_response_promise&) = default;

  /// Implicitly convertible to untyped response promise.
  inline operator response_promise& () {
    return promise_;
  }

  /// Satisfies the promise by sending a non-error response message.
  template <class U, class... Us>
  typename std::enable_if<
    (sizeof...(Us) > 0) || !std::is_convertible<U, error>::value,
    typed_response_promise
  >::type
  deliver(U&& x, Us&&... xs) {
    static_assert(
      std::is_same<detail::type_list<Ts...>,
                   detail::type_list<typename std::decay<U>::type,
                                     typename std::decay<Us>::type...>>::value,
      "typed_response_promise: message type mismatched");
    promise_.deliver(std::forward<U>(x), std::forward<Us>(xs)...);
    return *this;
  }

  template <message_priority P = message_priority::normal,
           class Handle = actor, class... Us>
  typed_response_promise delegate(const Handle& dest, Us&&... xs) {
    promise_.template delegate<P>(dest, std::forward<Us>(xs)...);
    return *this;
  }

  /// Satisfies the promise by sending an error response message.
  /// For non-requests, nothing is done.
  inline typed_response_promise deliver(error x) {
    promise_.deliver(std::move(x));
    return *this;
  }

  /// Queries whether this promise is a valid promise that is not satisfied yet.
  inline bool pending() const {
    return promise_.pending();
  }

private:
  response_promise promise_;
};

} // namespace caf

#endif // CAF_TYPED_RESPONSE_PROMISE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TYPED_ACTOR_VIEW_HPP
#define CAF_TYPED_ACTOR_VIEW_HPP

#include "caf/scheduled_actor.hpp"

#include "caf/mixin/sender.hpp"
#include "caf/mixin/requester.hpp"

namespace caf {

struct typed_actor_view_base { };

template <class... Sigs>
class typed_actor_view : public extend<typed_actor_view_base,
                                       typed_actor_view<Sigs...>>::template
                                with<mixin::sender, mixin::requester> {
public:
  /// Stores the template parameter pack.
  using signatures = detail::type_list<Sigs...>;

  typed_actor_view(scheduled_actor* ptr) : self_(ptr) {
    // nop
  }

  typed_actor_view& operator=(scheduled_actor* ptr) {
    self_ = ptr;
    return *this;
  }

  /****************************************************************************
   *                           spawn actors                                   *
   ****************************************************************************/

  template <class T, spawn_options Os = no_spawn_options, class... Ts>
  typename infer_handle_from_class<T>::type
  spawn(Ts&&... xs) {
    return self_->spawn<T, Os>(std::forward<Ts>(xs)...);
  }

  template <class T, spawn_options Os = no_spawn_options>
  infer_handle_from_state_t<T> spawn() {
    return self_->spawn<T, Os>();
  }

  template <spawn_options Os = no_spawn_options, class F, class... Ts>
  typename infer_handle_from_fun<F>::type
  spawn(F fun, Ts&&... xs) {
    return self_->spawn<Os>(std::move(fun), std::forward<Ts>(xs)...);
  }

  /****************************************************************************
   *                      miscellaneous actor operations                      *
   ****************************************************************************/

  execution_unit* context() const {
    return self_->context();
  }

  actor_system& system() const {
    return self_->system();
  }

  void quit(exit_reason reason = exit_reason::normal) {
    self_->quit(reason);
  }

  template <class... Ts>
  typename detail::make_response_promise_helper<Ts...>::type
  make_response_promise() {
    return self_->make_response_promise<Ts...>();
  }

  template <class T>
  void monitor(const T& x) {
    self_->monitor(x);
  }

  template <class T>
  void demonitor(const T& x) {
    self_->demonitor(x);
  }

  response_promise make_response_promise() {
    return self_->make_response_promise();
  }

  template <class... Ts,
            class R =
              typename detail::make_response_promise_helper<
                typename std::decay<Ts>::type...
              >::type>
  R response(Ts&&... xs) {
    return self_->response(std::forward<Ts>(xs)...);
  }

  /// Returns a pointer to the sender of the current message.
  /// @pre `current_mailbox_element() != nullptr`
  inline strong_actor_ptr& current_sender() {
    return self_->current_sender();
  }

  /// Returns a pointer to the currently processed mailbox element.
  inline mailbox_element* current_mailbox_element() {
    return self_->current_mailbox_element();
  }

  /// @private
  actor_control_block* ctrl() const {
    CAF_ASSERT(self_ != nullptr);
    return actor_control_block::from(self_);;
  }

  /// @private
  scheduled_actor* internal_ptr() const {
    return self_;
  }

private:
  scheduled_actor* self_;
};

} // namespace caf

#endif // CAF_TYPED_ACTOR_VIEW_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_LOGGER_HPP
#define CAF_LOGGER_HPP

#include <thread>
#include <fstream>
#include <cstring>
#include <sstream>
#include <iostream>
#include <typeinfo>
#include <type_traits>
#include <unordered_map>

#include "caf/fwd.hpp"
#include "caf/config.hpp"
#include "caf/unifyn.hpp"
#include "caf/type_nr.hpp"
#include "caf/timestamp.hpp"
#include "caf/ref_counted.hpp"
#include "caf/abstract_actor.hpp"
#include "caf/deep_to_string.hpp"

#include "caf/detail/scope_guard.hpp"
#include "caf/detail/shared_spinlock.hpp"
#include "caf/detail/pretty_type_name.hpp"
#include "caf/detail/single_reader_queue.hpp"

/*
 * To enable logging, you have to define CAF_DEBUG. This enables
 * CAF_LOG_ERROR messages. To enable more debugging output, you can
 * define CAF_LOG_LEVEL to:
 * 1: + warning
 * 2: + info
 * 3: + debug
 * 4: + trace (prints for each logged method entry and exit message)
 *
 * Note: this logger emits log4j style output; logs are best viewed
 *       using a log4j viewer, e.g., http://code.google.com/p/otroslogviewer/
 *
 */
namespace caf {

/// Centrally logs events from all actors in an actor system. To enable
/// logging in your application, you need to define `CAF_LOG_LEVEL`. Per
/// default, the logger generates log4j compatible output.
class logger : public ref_counted {
public:
  friend class actor_system;

  /// Encapsulates a single logging event.
  struct event {
    /// Intrusive pointer to the next logging event.
    event* next;
    /// Intrusive pointer to the previous logging event.
    event* prev;
    /// Level/priority of the event.
    int level;
    /// Name of the category (component) logging the event.
    const char* category_name;
    /// Name of the current context as reported by `__PRETTY_FUNCTION__`.
    const char* pretty_fun;
    /// Name of the current file.
    const char* file_name;
    /// Current line in the file.
    int line_number;
    /// User-provided message.
    std::string message;
    /// Thread ID of the caller.
    std::thread::id tid;
    /// Actor ID of the caller.
    actor_id aid;
    /// Timestamp of the event.
    timestamp tstamp;
  };

  /// Internal representation of format string entites.
  enum field_type {
    invalid_field,
    category_field,
    class_name_field,
    date_field,
    file_field,
    line_field,
    message_field,
    method_field,
    newline_field,
    priority_field,
    runtime_field,
    thread_field,
    actor_field,
    percent_sign_field,
    plain_text_field
  };

  /// Represents a single format string field.
  struct field {
    field_type kind;
    const char* first;
    const char* last;
  };

  /// Stores a parsed format string as list of fields.
  using line_format = std::vector<field>;

  /// Enables automagical string conversion for `CAF_ARG`.
  template <class T>
  struct arg_wrapper {
    const char* name;
    const T& value;
    arg_wrapper(const char* x, const T& y) : name(x), value(y) {
      // nop
    }
  };

  /// Used to implement `CAF_ARG`.
  template <class T>
  static arg_wrapper<T> make_arg_wrapper(const char* name, const T& value) {
    return {name, value};
  }

  /// Utility class for building user-defined log messages with `CAF_ARG`.
  class line_builder {
  public:
    line_builder();

    template <class T>
    line_builder& operator<<(const T& x) {
      if (!str_.empty())
        str_ += " ";
      str_ += deep_to_string(x);
      behind_arg_ = false;
      return *this;
    }

    template <class T>
    line_builder& operator<<(const arg_wrapper<T>& x) {
      if (behind_arg_)
        str_ += ", ";
      else if (!str_.empty())
        str_ += " ";
      str_ += x.name;
      str_ += " = ";
      str_ += deep_to_string(x.value);
      behind_arg_ = true;
      return *this;
    }

    line_builder& operator<<(const std::string& str);

    line_builder& operator<<(const char* str);

    std::string get() const;

  private:
    std::string str_;
    bool behind_arg_;
  };

  /// Returns the ID of the actor currently associated to the calling thread.
  actor_id thread_local_aid();

  /// Associates an actor ID to the calling thread and returns the last value.
  actor_id thread_local_aid(actor_id aid);

  /// Writes an entry to the log file.
  void log(event* x);

  ~logger() override;

  /** @cond PRIVATE */

  static void set_current_actor_system(actor_system*);

  static logger* current_logger();

  bool accepts(int level, const char* cname_begin, const char* cname_end);

  template <size_t N>
  bool accepts(int level, const char (&component)[N]) {
    return accepts(level, component, component + N - 1);
  }

  /** @endcond */

  /// Returns the output format used for the log file.
  inline const line_format& file_format() const {
    return file_format_;
  }

  /// Returns the output format used for the console.
  inline const line_format& console_format() const {
    return console_format_;
  }

  /// Renders the prefix (namespace and class) of a fully qualified function.
  static void render_fun_prefix(std::ostream& out, const char* pretty_fun);

  /// Renders the name of a fully qualified function.
  static void render_fun_name(std::ostream& out, const char* pretty_fun);

  /// Renders the difference between `t0` and `tn` in milliseconds.
  static void render_time_diff(std::ostream& out, timestamp t0, timestamp tn);

  /// Renders the date of `x` in ISO 8601 format.
  static void render_date(std::ostream& out, timestamp x);

  /// Renders `x` using the line format `lf` to `out`.
  void render(std::ostream& out, const line_format& lf, const event& x) const;

  /// Parses `format_str` into a format description vector.
  /// @warning The returned vector can have pointers into `format_str`.
  static line_format parse_format(const char* format_str);

  /// Returns a string representation of the joined groups of `x` if `x` is an
  /// actor with the `subscriber` mixin.
  template <class T>
  static typename std::enable_if<
    std::is_base_of<mixin::subscriber_base, T>::value,
    std::string
  >::type
  joined_groups_of(const T& x) {
    return deep_to_string(x.joined_groups());
  }

  /// Returns a string representation of an empty list if `x` is not an actor
  /// with the `subscriber` mixin.
  template <class T>
  static typename std::enable_if<
    !std::is_base_of<mixin::subscriber_base, T>::value,
    const char*
  >::type
  joined_groups_of(const T& x) {
    CAF_IGNORE_UNUSED(x);
    return "[]";
  }

private:
  void handle_event(event& x);

  void log_first_line();

  void log_last_line();

  logger(actor_system& sys);

  void init(actor_system_config& cfg);

  void run();

  void start();

  void stop();

  actor_system& system_;
  int level_;
  bool inline_output_;
  detail::shared_spinlock aids_lock_;
  std::unordered_map<std::thread::id, actor_id> aids_;
  std::thread thread_;
  std::mutex queue_mtx_;
  std::condition_variable queue_cv_;
  detail::single_reader_queue<event> queue_;
  std::thread::id parent_thread_;
  timestamp t0_;
  line_format file_format_;
  line_format console_format_;
  std::fstream file_;
};

std::string to_string(logger::field_type x);

std::string to_string(const logger::field& x);

bool operator==(const logger::field& x, const logger::field& y);

} // namespace caf

#define CAF_VOID_STMT static_cast<void>(0)

#define CAF_CAT(a, b) a##b

#define CAF_LOG_LEVEL_QUIET -1
#define CAF_LOG_LEVEL_ERROR 0
#define CAF_LOG_LEVEL_WARNING 1
#define CAF_LOG_LEVEL_INFO 2
#define CAF_LOG_LEVEL_DEBUG 3
#define CAF_LOG_LEVEL_TRACE 4

#define CAF_ARG(argument) caf::logger::make_arg_wrapper(#argument, argument)

#define CAF_ARG2(argname, argval) caf::logger::make_arg_wrapper(argname, argval)

#ifdef CAF_MSVC
#define CAF_PRETTY_FUN __FUNCSIG__
#else // CAF_MSVC
#define CAF_PRETTY_FUN __PRETTY_FUNCTION__
#endif // CAF_MSVC

#ifndef CAF_LOG_COMPONENT
#define CAF_LOG_COMPONENT "caf"
#endif // CAF_LOG_COMPONENT

#ifndef CAF_LOG_LEVEL

#define CAF_LOG_IMPL(unused1, unused2, unused3)

// placeholder macros when compiling without logging
inline caf::actor_id caf_set_aid_dummy() { return 0; }

#define CAF_PUSH_AID(unused) CAF_VOID_STMT

#define CAF_PUSH_AID_FROM_PTR(unused) CAF_VOID_STMT

#define CAF_SET_AID(unused) caf_set_aid_dummy()

#define CAF_SET_LOGGER_SYS(unused) CAF_VOID_STMT

#define CAF_LOG_TRACE(unused)

#else // CAF_LOG_LEVEL

#define CAF_LOG_IMPL(component, loglvl, message)                               \
  do {                                                                         \
    auto CAF_UNIFYN(caf_logger) = caf::logger::current_logger();               \
    if (CAF_UNIFYN(caf_logger) != nullptr                                      \
        && CAF_UNIFYN(caf_logger)->accepts(loglvl, component))                 \
      CAF_UNIFYN(caf_logger)                                                   \
        ->log(new ::caf::logger::event{                                        \
          nullptr, nullptr, loglvl, component, CAF_PRETTY_FUN, __FILE__,       \
          __LINE__, (::caf::logger::line_builder{} << message).get(),          \
          ::std::this_thread::get_id(),                                        \
          CAF_UNIFYN(caf_logger)->thread_local_aid(),                          \
          ::caf::make_timestamp()});                                           \
  } while (false)

#define CAF_PUSH_AID(aarg)                                                     \
  auto CAF_UNIFYN(caf_tmp_ptr) = caf::logger::current_logger();                \
  caf::actor_id CAF_UNIFYN(caf_aid_tmp) = 0;                                   \
  if (CAF_UNIFYN(caf_tmp_ptr))                                                 \
    CAF_UNIFYN(caf_aid_tmp) = CAF_UNIFYN(caf_tmp_ptr)->thread_local_aid(aarg); \
  auto CAF_UNIFYN(aid_aid_tmp_guard) = caf::detail::make_scope_guard([=] {     \
    auto CAF_UNIFYN(caf_tmp2_ptr) = caf::logger::current_logger();             \
    if (CAF_UNIFYN(caf_tmp2_ptr))                                              \
      CAF_UNIFYN(caf_tmp2_ptr)->thread_local_aid(CAF_UNIFYN(caf_aid_tmp));     \
  })

#define CAF_PUSH_AID_FROM_PTR(some_ptr)                                        \
  auto CAF_UNIFYN(caf_aid_ptr) = some_ptr;                                     \
  CAF_PUSH_AID(CAF_UNIFYN(caf_aid_ptr) ? CAF_UNIFYN(caf_aid_ptr)->id() : 0)

#define CAF_SET_AID(aid_arg)                                                   \
  (caf::logger::current_logger()                                               \
     ? caf::logger::current_logger()->thread_local_aid(aid_arg)                \
     : 0)

#define CAF_SET_LOGGER_SYS(ptr) caf::logger::set_current_actor_system(ptr)

#if CAF_LOG_LEVEL < CAF_LOG_LEVEL_TRACE

#define CAF_LOG_TRACE(unused) CAF_VOID_STMT

#else // CAF_LOG_LEVEL < CAF_LOG_LEVEL_TRACE

#define CAF_LOG_TRACE(entry_message)                                           \
  CAF_LOG_IMPL(CAF_LOG_COMPONENT, CAF_LOG_LEVEL_TRACE,                         \
               "ENTRY" << entry_message);                                      \
  auto CAF_UNIFYN(caf_log_trace_guard_) = ::caf::detail::make_scope_guard(     \
    [=] { CAF_LOG_IMPL(CAF_LOG_COMPONENT, CAF_LOG_LEVEL_TRACE, "EXIT"); })

#endif // CAF_LOG_LEVEL < CAF_LOG_LEVEL_TRACE

#if CAF_LOG_LEVEL >= CAF_LOG_LEVEL_DEBUG
#define CAF_LOG_DEBUG(output)                                                  \
  CAF_LOG_IMPL(CAF_LOG_COMPONENT, CAF_LOG_LEVEL_DEBUG, output)
#endif

#if CAF_LOG_LEVEL >= CAF_LOG_LEVEL_INFO
#define CAF_LOG_INFO(output)                                                   \
  CAF_LOG_IMPL(CAF_LOG_COMPONENT, CAF_LOG_LEVEL_INFO, output)
#endif

#if CAF_LOG_LEVEL >= CAF_LOG_LEVEL_WARNING
#define CAF_LOG_WARNING(output)                                                \
  CAF_LOG_IMPL(CAF_LOG_COMPONENT, CAF_LOG_LEVEL_WARNING, output)
#endif

#define CAF_LOG_ERROR(output)                                                  \
  CAF_LOG_IMPL(CAF_LOG_COMPONENT, CAF_LOG_LEVEL_ERROR, output)

#endif // CAF_LOG_LEVEL

#ifndef CAF_LOG_INFO
#  define CAF_LOG_INFO(output) CAF_VOID_STMT
#endif

#ifndef CAF_LOG_DEBUG
#  define CAF_LOG_DEBUG(output) CAF_VOID_STMT
#endif

#ifndef CAF_LOG_WARNING
#  define CAF_LOG_WARNING(output) CAF_VOID_STMT
#endif

#ifndef CAF_LOG_ERROR
#  define CAF_LOG_ERROR(output) CAF_VOID_STMT
#endif

#ifdef CAF_LOG_LEVEL

#define CAF_LOG_DEBUG_IF(cond, output)                                         \
  if (cond) {                                                                  \
    CAF_LOG_IMPL(CAF_LOG_COMPONENT, CAF_LOG_LEVEL_DEBUG, output);              \
  }                                                                            \
  CAF_VOID_STMT

#define CAF_LOG_INFO_IF(cond, output)                                          \
  if (cond) {                                                                  \
    CAF_LOG_IMPL(CAF_LOG_COMPONENT, CAF_LOG_LEVEL_INFO, output);               \
  }                                                                            \
  CAF_VOID_STMT

#define CAF_LOG_WARNING_IF(cond, output)                                       \
  if (cond) {                                                                  \
    CAF_LOG_IMPL(CAF_LOG_COMPONENT, CAF_LOG_LEVEL_WARNING, output);            \
  }                                                                            \
  CAF_VOID_STMT

#define CAF_LOG_ERROR_IF(cond, output)                                         \
  if (cond) {                                                                  \
    CAF_LOG_IMPL(CAF_LOG_COMPONENT, CAF_LOG_LEVEL_ERROR, output);              \
  }                                                                            \
  CAF_VOID_STMT

#else // CAF_LOG_LEVEL

#define CAF_LOG_DEBUG_IF(unused1, unused2)
#define CAF_LOG_INFO_IF(unused1, unused2)
#define CAF_LOG_WARNING_IF(unused1, unused2)
#define CAF_LOG_ERROR_IF(unused1, unused2)

#endif // CAF_LOG_LEVEL

// -- Standardized CAF events according to SE-0001.

/// The log component responsible for logging control flow events that are
/// crucial for understanding happens-before relations. See RFC SE-0001.
#define CAF_LOG_FLOW_COMPONENT "caf.flow"

#define CAF_LOG_SPAWN_EVENT(ref, ctor_data)                                    \
  CAF_LOG_IMPL(CAF_LOG_FLOW_COMPONENT, CAF_LOG_LEVEL_DEBUG,                    \
               "SPAWN ; ID ="                                                  \
                 << ref.id() << "; NAME =" << ref.name()                       \
                 << "; TYPE =" << ::caf::detail::pretty_type_name(typeid(ref)) \
                 << "; ARGS =" << ctor_data.c_str()                            \
                 << "; NODE =" << ref.node()                                   \
                 << "; GROUPS =" << ::caf::logger::joined_groups_of(ref))

#define CAF_LOG_SEND_EVENT(ptr)                                                \
  CAF_LOG_IMPL(                                                                \
    CAF_LOG_FLOW_COMPONENT, CAF_LOG_LEVEL_DEBUG,                               \
    "SEND ; TO ="                                                              \
      << ::caf::deep_to_string(::caf::strong_actor_ptr{this->ctrl()}).c_str()  \
      << "; FROM =" << ::caf::deep_to_string(ptr->sender).c_str()              \
      << "; STAGES =" << ::caf::deep_to_string(ptr->stages).c_str()            \
      << "; CONTENT =" << ::caf::deep_to_string(ptr->content()).c_str())

#define CAF_LOG_RECEIVE_EVENT(ptr)                                             \
  CAF_LOG_IMPL(CAF_LOG_FLOW_COMPONENT, CAF_LOG_LEVEL_DEBUG,                    \
               "RECEIVE ; FROM ="                                              \
                 << ::caf::deep_to_string(ptr->sender).c_str()                 \
                 << "; STAGES =" << ::caf::deep_to_string(ptr->stages).c_str() \
                 << "; CONTENT ="                                              \
                 << ::caf::deep_to_string(ptr->content()).c_str())

#define CAF_LOG_REJECT_EVENT()                                                 \
  CAF_LOG_IMPL(CAF_LOG_FLOW_COMPONENT, CAF_LOG_LEVEL_DEBUG, "REJECT")

#define CAF_LOG_ACCEPT_EVENT(unblocked)                                        \
  CAF_LOG_IMPL(CAF_LOG_FLOW_COMPONENT, CAF_LOG_LEVEL_DEBUG,                    \
               "ACCEPT ; UNBLOCKED =" << unblocked)

#define CAF_LOG_DROP_EVENT()                                                   \
  CAF_LOG_IMPL(CAF_LOG_FLOW_COMPONENT, CAF_LOG_LEVEL_DEBUG, "DROP")

#define CAF_LOG_SKIP_EVENT()                                                   \
  CAF_LOG_IMPL(CAF_LOG_FLOW_COMPONENT, CAF_LOG_LEVEL_DEBUG, "SKIP")

#define CAF_LOG_FINALIZE_EVENT()                                               \
  CAF_LOG_IMPL(CAF_LOG_FLOW_COMPONENT, CAF_LOG_LEVEL_DEBUG, "FINALIZE")

#define CAF_LOG_TERMINATE_EVENT(thisptr, rsn)                                  \
  CAF_LOG_IMPL(CAF_LOG_FLOW_COMPONENT, CAF_LOG_LEVEL_DEBUG,                    \
               "TERMINATE ; ID =" << thisptr->id()                             \
                 << "; REASON =" << deep_to_string(rsn).c_str()                \
                 << "; NODE =" << thisptr->node())

#endif // CAF_LOGGER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STATIC_VISITOR_HPP
#define CAF_STATIC_VISITOR_HPP

namespace caf {

template <class Result = void>
struct static_visitor {
  using result_type = Result;
};

} // namespace caf

#endif // CAF_STATIC_VISITOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_UNSAFE_ACTOR_HANDLE_INIT_HPP
#define CAF_UNSAFE_ACTOR_HANDLE_INIT_HPP

namespace caf {

/// Tag type to select the unsafe constructor of actor handles.
struct unsafe_actor_handle_init_t { };

static constexpr unsafe_actor_handle_init_t unsafe_actor_handle_init
  = unsafe_actor_handle_init_t{};

} // namespace caf

#endif // CAF_UNSAFE_ACTOR_HANDLE_INIT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_PRIORITY_HPP
#define CAF_PRIORITY_HPP

#include <cstdint>

namespace caf {

enum class message_priority : uint32_t {
  normal,
  high
};

} // namespace caf

#endif // CAF_PRIORITY_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_SINK_IMPL_HPP
#define CAF_STREAM_SINK_IMPL_HPP

#include "caf/sec.hpp"
#include "caf/logger.hpp"
#include "caf/message_id.hpp"
#include "caf/stream_manager.hpp"
#include "caf/stream_sink_trait.hpp"

namespace caf {

template <class Fun, class Finalize, class Gatherer, class Scatterer>
class stream_sink_impl : public stream_manager {
public:
  using super = stream_manager;

  using trait = stream_sink_trait_t<Fun, Finalize>;

  using state_type = typename trait::state;

  using input_type = typename trait::input;

  using output_type = typename trait::output;

  stream_sink_impl(local_actor* self, Fun fun, Finalize fin)
      : fun_(std::move(fun)),
        fin_(std::move(fin)),
        in_(self) {
    // nop
  }

  state_type& state() {
    return state_;
  }

  Gatherer& in() override {
    return in_;
  }

  Scatterer& out() override {
    return out_;
  }

  bool done() const override {
    return in_.closed();
  }

protected:
  error process_batch(message& msg) override {
    CAF_LOG_TRACE(CAF_ARG(msg));
    using vec_type = std::vector<input_type>;
    if (msg.match_elements<vec_type>()) {
      auto& xs = msg.get_as<vec_type>(0);
      for (auto& x : xs)
        fun_(state_, x);
      return none;
    }
    CAF_LOG_ERROR("received unexpected batch type");
    return sec::unexpected_message;
  }

  message make_final_result() override {
    return trait::make_result(state_, fin_);
  }

private:
  state_type state_;
  Fun fun_;
  Finalize fin_;
  Gatherer in_;
  Scatterer out_;
};

} // namespace caf

#endif // CAF_STREAM_SINK_IMPL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_INFER_HANDLE_HPP
#define CAF_INFER_HANDLE_HPP

#include "caf/actor.hpp"
#include "caf/actor_addr.hpp"
#include "caf/stateful_actor.hpp"
#include "caf/typed_behavior.hpp"
#include "caf/abstract_composable_behavior.hpp"

namespace caf {

template <class... Sigs>
class typed_event_based_actor;

namespace io {

template <class... Sigs>
class typed_broker;

} // namespace io

enum class spawn_mode {
  function,
  function_with_selfptr,
  clazz
};

template <spawn_mode X>
using spawn_mode_token = std::integral_constant<spawn_mode, X>;

// default: dynamically typed actor without self pointer
template <class Result,
          class FirstArg,
          bool FirstArgValid =
            std::is_base_of<
              local_actor,
              typename std::remove_pointer<FirstArg>::type
            >::value>
struct infer_handle_from_fun_impl {
  using type = actor;
  using impl = event_based_actor;
  using behavior_type = behavior;
  static constexpr spawn_mode mode = spawn_mode::function;
};

// dynamically typed actor returning a behavior
template <class Impl>
struct infer_handle_from_fun_impl<void, Impl*, true> {
  using type = actor;
  using impl = Impl;
  using behavior_type = behavior;
  static constexpr spawn_mode mode = spawn_mode::function_with_selfptr;
};

// dynamically typed actor with self pointer
template <class Impl>
struct infer_handle_from_fun_impl<behavior, Impl*, true> {
  using type = actor;
  using impl = Impl;
  using behavior_type = behavior;
  static constexpr spawn_mode mode = spawn_mode::function_with_selfptr;
};

// statically typed actor returning a behavior
template <class... Sigs, class Impl>
struct infer_handle_from_fun_impl<typed_behavior<Sigs...>, Impl, false> {
  using type = typed_actor<Sigs...>;
  using impl = typed_event_based_actor<Sigs...>;
  using behavior_type = typed_behavior<Sigs...>;
  static constexpr spawn_mode mode = spawn_mode::function;
};

// statically typed actor with self pointer
template <class... Sigs, class Impl>
struct infer_handle_from_fun_impl<typed_behavior<Sigs...>, Impl*, true> {
  static_assert(std::is_base_of<typed_event_based_actor<Sigs...>, Impl>::value
                || std::is_base_of<io::typed_broker<Sigs...>, Impl>::value,
                "Self pointer does not match the returned behavior type.");
  using type = typed_actor<Sigs...>;
  using impl = Impl;
  using behavior_type = typed_behavior<Sigs...>;
  static constexpr spawn_mode mode = spawn_mode::function_with_selfptr;
};

/// Deduces an actor handle type from a function or function object.
template <class F, class Trait = typename detail::get_callable_trait<F>::type>
struct infer_handle_from_fun {
  using result_type = typename Trait::result_type;
  using arg_types = typename Trait::arg_types;
  using first_arg = typename detail::tl_head<arg_types>::type;
  using delegate = infer_handle_from_fun_impl<result_type, first_arg>;
  using type = typename delegate::type;
  using impl = typename delegate::impl;
  using behavior_type = typename delegate::behavior_type;
  using fun_type = typename Trait::fun_type;
  static constexpr spawn_mode mode = delegate::mode;
};

/// @relates infer_handle_from_fun
template <class T>
using infer_handle_from_fun_t = typename infer_handle_from_fun<T>::type;

/// @relates infer_handle_from_fun
template <class T>
using infer_impl_from_fun_t = typename infer_handle_from_fun<T>::impl;

template <class T>
struct infer_handle_from_behavior {
  using type = actor;
};

template <class... Sigs>
struct infer_handle_from_behavior<typed_behavior<Sigs...>> {
  using type = typed_actor<Sigs...>;
};

/// Deduces `actor` for dynamically typed actors, otherwise `typed_actor<...>`
/// is deduced.
template <class T, bool = std::is_base_of<abstract_actor, T>::value>
struct infer_handle_from_class {
  using type =
    typename infer_handle_from_behavior<
      typename T::behavior_type
    >::type;
  static constexpr spawn_mode mode = spawn_mode::clazz;
};

template <class T>
struct infer_handle_from_class<T, false> {
  // nop; this enables SFINAE for spawn to differentiate between
  // spawns using actor classes or composable states
};

/// @relates infer_handle_from_class
template <class T>
using infer_handle_from_class_t = typename infer_handle_from_class<T>::type;

template <class T, bool = std::is_base_of<abstract_composable_behavior, T>::value>
struct infer_handle_from_state {
  using type = typename T::handle_type;
};

template <class T>
struct infer_handle_from_state<T, false> {
  // nop; this enables SFINAE for spawn to differentiate between
  // spawns using actor classes or composable states
};

/// @relates infer_handle_from_state
template <class T>
using infer_handle_from_state_t = typename infer_handle_from_state<T>::type;

template <class T>
struct is_handle : std::false_type {};

template <>
struct is_handle<actor> : std::true_type {};

template <>
struct is_handle<strong_actor_ptr> : std::true_type {};

template <class... Ts>
struct is_handle<typed_actor<Ts...>> : std::true_type {};

} // namespace caf

#endif // CAF_INFER_HANDLE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MAY_HAVE_TIMEOUT_HPP
#define CAF_MAY_HAVE_TIMEOUT_HPP

namespace caf {

template <class F>
struct timeout_definition;

class behavior;

template <class T>
struct may_have_timeout {
  static constexpr bool value = false;

};

template <>
struct may_have_timeout<behavior> {
  static constexpr bool value = true;

};

template <class F>
struct may_have_timeout<timeout_definition<F>> {
  static constexpr bool value = true;

};

} // namespace caf

#endif // CAF_MAY_HAVE_TIMEOUT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ACTOR_ADDR_HPP
#define CAF_ACTOR_ADDR_HPP

#include <cstddef>
#include <cstdint>
#include <functional>
#include <type_traits>

#include "caf/fwd.hpp"
#include "caf/abstract_actor.hpp"
#include "caf/actor_control_block.hpp"
#include "caf/unsafe_actor_handle_init.hpp"

#include "caf/detail/comparable.hpp"

namespace caf {

/// Stores the address of typed as well as untyped actors.
class actor_addr : detail::comparable<actor_addr>,
                   detail::comparable<actor_addr, weak_actor_ptr>,
                   detail::comparable<actor_addr, strong_actor_ptr>,
                   detail::comparable<actor_addr, abstract_actor*>,
                   detail::comparable<actor_addr, actor_control_block*> {
public:
  // -- friend types that need access to private ctors

  friend class abstract_actor;

  // allow conversion via actor_cast
  template <class, class, int>
  friend class actor_cast_access;

  // tell actor_cast which semantic this type uses
  static constexpr bool has_weak_ptr_semantics = true;

  actor_addr() = default;
  actor_addr(actor_addr&&) = default;
  actor_addr(const actor_addr&) = default;
  actor_addr& operator=(actor_addr&&) = default;
  actor_addr& operator=(const actor_addr&) = default;

  actor_addr(std::nullptr_t);
  actor_addr(const unsafe_actor_handle_init_t&);

  actor_addr& operator=(std::nullptr_t);

  /// Returns the ID of this actor.
  inline actor_id id() const noexcept {
    return ptr_->id();
  }

  /// Returns the origin node of this actor.
  inline node_id node() const noexcept {
    return ptr_->node();
  }

  /// Returns the hosting actor system.
  inline actor_system& home_system() const noexcept {
    return *ptr_->home_system;
  }

  /// Exchange content of `*this` and `other`.
  void swap(actor_addr& other) noexcept;

  inline explicit operator bool() const {
    return static_cast<bool>(ptr_);
  }

  /// @cond PRIVATE

  static intptr_t compare(const actor_control_block* lhs,
                          const actor_control_block* rhs);

  intptr_t compare(const actor_addr& other) const noexcept;

  intptr_t compare(const abstract_actor* other) const noexcept;

  intptr_t compare(const actor_control_block* other) const noexcept;

  inline intptr_t compare(const weak_actor_ptr& other) const noexcept {
    return compare(other.get());
  }

  inline intptr_t compare(const strong_actor_ptr& other) const noexcept {
    return compare(other.get());
  }

  friend inline std::string to_string(const actor_addr& x) {
    return to_string(x.ptr_);
  }

  friend inline void append_to_string(std::string& x, const actor_addr& y) {
    return append_to_string(x, y.ptr_);
  }

  template <class Inspector>
  friend typename Inspector::result_type inspect(Inspector& f, actor_addr& x) {
    return inspect(f, x.ptr_);
  }

  /// Releases the reference held by handle `x`. Using the
  /// handle after invalidating it is undefined behavior.
  friend void destroy(actor_addr& x) {
    x.ptr_.reset();
  }

  actor_addr(actor_control_block*, bool);

  inline actor_control_block* get() const noexcept {
    return ptr_.get();
  }

  /// @endcond

private:
  inline actor_control_block* release() noexcept {
    return ptr_.release();
  }

  inline actor_control_block* get_locked() const noexcept {
    return ptr_.get_locked();
  }

  actor_addr(actor_control_block*);

  weak_actor_ptr ptr_;
};

inline bool operator==(const actor_addr& x, std::nullptr_t) {
  return x.get() == nullptr;
}

inline bool operator==(std::nullptr_t, const actor_addr& x) {
  return x.get() == nullptr;
}

inline bool operator!=(const actor_addr& x, std::nullptr_t) {
  return x.get() != nullptr;
}

inline bool operator!=(std::nullptr_t, const actor_addr& x) {
  return x.get() != nullptr;
}

} // namespace caf

// allow actor_addr to be used in hash maps
namespace std {
template <>
struct hash<caf::actor_addr> {
  inline size_t operator()(const caf::actor_addr& ref) const {
    return static_cast<size_t>(ref.id());
  }
};
} // namespace std

#endif // CAF_ACTOR_ADDR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TYPE_ERASED_VALUE_HPP
#define CAF_TYPE_ERASED_VALUE_HPP

#include <cstdint>
#include <typeinfo>
#include <functional>

#include "caf/fwd.hpp"
#include "caf/error.hpp"
#include "caf/type_nr.hpp"

namespace caf {

/// Represents a single type-erased value.
class type_erased_value {
public:
  // -- member types -----------------------------------------------------------

  using rtti_pair = std::pair<uint16_t, const std::type_info*>;

  // -- constructors, destructors, and assignment operators --------------------

  virtual ~type_erased_value();

  // -- pure virtual modifiers -------------------------------------------------

  /// Returns a mutable pointer to the stored value.
  virtual void* get_mutable() = 0;

  /// Load the content for the stored value from `source`.
  virtual error load(deserializer& source) = 0;

  // -- pure virtual observers -------------------------------------------------

  /// Returns the type number and type information object for the stored value.
  virtual rtti_pair type() const = 0;

  /// Returns a pointer to the stored value.
  virtual const void* get() const = 0;

  /// Saves the content of the stored value to `sink`.
  virtual error save(serializer& sink) const = 0;

  /// Converts the stored value to a string.
  virtual std::string stringify() const = 0;

  /// Returns a copy of the stored value.
  virtual type_erased_value_ptr copy() const = 0;

  // -- observers --------------------------------------------------------------

  /// Checks whether the type of the stored value matches
  /// the type nr and type info object.
  bool matches(uint16_t nr, const std::type_info* ptr) const;

  // -- convenience functions --------------------------------------------------

  /// Returns the type number for the stored value.
  inline uint16_t type_nr() const {
    return type().first;
  }

  /// Checks whether the type of the stored value matches `rtti`.
  inline bool matches(const rtti_pair& rtti) const {
    return matches(rtti.first, rtti.second);
  }

  /// Convenience function for `reinterpret_cast<const T*>(get())`.
  template <class T>
  const T& get_as() const {
    return *reinterpret_cast<const T*>(get());
  }

  /// Convenience function for `reinterpret_cast<T*>(get_mutable())`.
  template <class T>
  T& get_mutable_as() {
    return *reinterpret_cast<T*>(get_mutable());
  }
};

/// @relates type_erased_value_impl
inline error inspect(serializer& f, type_erased_value& x) {
  return x.save(f);
}

/// @relates type_erased_value_impl
inline error inspect(deserializer& f, type_erased_value& x) {
  return x.load(f);
}

/// @relates type_erased_value_impl
inline std::string to_string(const type_erased_value& x) {
  return x.stringify();
}

} // namespace caf

#endif // CAF_TYPE_ERASED_VALUE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IS_MESSAGE_SINK_HPP
#define CAF_IS_MESSAGE_SINK_HPP

#include <type_traits>

#include "caf/fwd.hpp"

namespace caf {

template <class T>
struct is_message_sink : std::false_type { };

template <>
struct is_message_sink<actor> : std::true_type { };

template <>
struct is_message_sink<group> : std::true_type { };

template <class... Ts>
struct is_message_sink<typed_actor<Ts...>> : std::true_type { };

} // namespace caf

#endif // CAF_IS_MESSAGE_SINK_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MAKE_COUNTED_HPP
#define CAF_MAKE_COUNTED_HPP

#include <type_traits>

#include "caf/ref_counted.hpp"
#include "caf/intrusive_ptr.hpp"

#include "caf/detail/type_traits.hpp"

namespace caf {

/// Constructs an object of type `T` in an `intrusive_ptr`.
/// @relates ref_counted
/// @relates intrusive_ptr
template <class T, class... Ts>
intrusive_ptr<T> make_counted(Ts&&... xs) {
  return intrusive_ptr<T>(new T(std::forward<Ts>(xs)...), false);
}

} // namespace caf

#endif // CAF_MAKE_COUNTED_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ABSTRACT_GROUP_HPP
#define CAF_ABSTRACT_GROUP_HPP

#include <string>
#include <memory>

#include "caf/fwd.hpp"
#include "caf/actor_addr.hpp"
#include "caf/attachable.hpp"
#include "caf/ref_counted.hpp"
#include "caf/abstract_channel.hpp"

namespace caf {

/// A multicast group.
class abstract_group : public ref_counted, public abstract_channel {
public:
  // -- member types -----------------------------------------------------------

  friend class local_actor;
  friend class subscription;
  friend class detail::group_manager;

  // -- constructors, destructors, and assignment operators --------------------

  ~abstract_group() override;

  // -- pure virtual member functions ------------------------------------------

  /// Serialize this group to `sink`.
  virtual error save(serializer& sink) const = 0;

  /// Subscribes `who` to this group and returns `true` on success
  /// or `false` if `who` is already subscribed.
  virtual bool subscribe(strong_actor_ptr who) = 0;

  /// Unsubscribes `who` from this group.
  virtual void unsubscribe(const actor_control_block* who) = 0;

  /// Stops any background actors or threads and IO handles.
  virtual void stop() = 0;

  // -- observers --------------------------------------------------------------

  /// Returns the parent module.
  inline group_module& module() const {
    return parent_;
  }

  /// Returns the hosting system.
  inline actor_system& system() const {
    return system_;
  }

  /// Returns a string representation of the group identifier, e.g.,
  /// "224.0.0.1" for IPv4 multicast or a user-defined string for local groups.
  const std::string& identifier() const {
    return identifier_;
  }

protected:
  abstract_group(group_module& mod, std::string id, node_id nid);

  actor_system& system_;
  group_module& parent_;
  std::string identifier_;
  node_id origin_;
};

/// A smart pointer type that manages instances of {@link group}.
/// @relates group
using abstract_group_ptr = intrusive_ptr<abstract_group>;

} // namespace caf

#endif // CAF_ABSTRACT_GROUP_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ATOM_HPP
#define CAF_ATOM_HPP

#include <string>
#include <functional>
#include <type_traits>

#include "caf/detail/atom_val.hpp"

namespace caf {

/// The value type of atoms.
enum class atom_value : uint64_t {
  /// @cond PRIVATE
  dirty_little_hack = 31337
  /// @endcond
};

/// @relates atom_value
std::string to_string(const atom_value& what);

atom_value atom_from_string(const std::string& x);

/// Creates an atom from given string literal.
template <size_t Size>
constexpr atom_value atom(char const (&str)[Size]) {
  // last character is the NULL terminator
  static_assert(Size <= 11, "only 10 characters are allowed");
  return static_cast<atom_value>(detail::atom_val(str));
}

/// Creates an atom from given string literal and return an integer
/// representation of the atom..
template <size_t Size>
constexpr uint64_t atom_uint(char const (&str)[Size]) {
  static_assert(Size <= 11, "only 10 characters are allowed");
  return detail::atom_val(str);
}

/// Converts an atom to its integer representation.
constexpr uint64_t atom_uint(atom_value x) {
  return static_cast<uint64_t>(x);
}

/// Lifts an `atom_value` to a compile-time constant.
template <atom_value V>
struct atom_constant {
  constexpr atom_constant() {
    // nop
  }
  /// Returns the wrapped value.
  constexpr operator atom_value() const {
    return V;
  }
  static constexpr uint64_t uint_value() {
    return static_cast<uint64_t>(V);
  }
  /// Returns an instance *of this constant* (*not* an `atom_value`).
  static const atom_constant value;
};

template <class T>
struct is_atom_constant {
  static constexpr bool value = false;
};

template <atom_value X>
struct is_atom_constant<atom_constant<X>> {
  static constexpr bool value = true;
};

template <atom_value V>
std::string to_string(const atom_constant<V>&) {
  return to_string(V);
}

template <atom_value V>
const atom_constant<V> atom_constant<V>::value = atom_constant<V>{};

/// Used for request operations.
using add_atom = atom_constant<atom("add")>;

/// Used for request operations.
using get_atom = atom_constant<atom("get")>;

/// Used for request operations.
using put_atom = atom_constant<atom("put")>;

/// Used for signalizing updates, e.g., in a key-value store.
using update_atom = atom_constant<atom("update")>;

/// Used for request operations.
using delete_atom = atom_constant<atom("delete")>;

/// Used for response messages.
using ok_atom = atom_constant<atom("ok")>;

/// Used for triggering system-level message handling.
using sys_atom = atom_constant<atom("sys")>;

/// Used for signaling group subscriptions.
using join_atom = atom_constant<atom("join")>;

/// Used for signaling group unsubscriptions.
using leave_atom = atom_constant<atom("leave")>;

/// Used for signaling forwarding paths.
using forward_atom = atom_constant<atom("forward")>;

/// Used for buffer management.
using flush_atom = atom_constant<atom("flush")>;

/// Used for I/O redirection.
using redirect_atom = atom_constant<atom("redirect")>;

/// Used for link requests over network.
using link_atom = atom_constant<atom("link")>;

/// Used for removing networked links.
using unlink_atom = atom_constant<atom("unlink")>;

/// Used for publishing actors at a given port.
using publish_atom = atom_constant<atom("publish")>;

/// Used for publishing actors at a given port.
using publish_udp_atom = atom_constant<atom("pub_udp")>;

/// Used for removing an actor/port mapping.
using unpublish_atom = atom_constant<atom("unpublish")>;

/// Used for removing an actor/port mapping.
using unpublish_udp_atom = atom_constant<atom("unpub_udp")>;

/// Used for signalizing group membership.
using subscribe_atom = atom_constant<atom("subscribe")>;

/// Used for withdrawing group membership.
using unsubscribe_atom = atom_constant<atom("unsubscrib")>;

/// Used for establishing network connections.
using connect_atom = atom_constant<atom("connect")>;

/// Used for contacting a remote UDP endpoint
using contact_atom = atom_constant<atom("contact")>;

/// Used for opening ports or files.
using open_atom = atom_constant<atom("open")>;

/// Used for closing ports or files.
using close_atom = atom_constant<atom("close")>;

/// Used for spawning remote actors.
using spawn_atom = atom_constant<atom("spawn")>;

/// Used for migrating actors to other nodes.
using migrate_atom = atom_constant<atom("migrate")>;

/// Used for triggering periodic operations.
using tick_atom = atom_constant<atom("tick")>;

/// Used for pending out of order messages.
using pending_atom = atom_constant<atom("pending")>;

} // namespace caf

namespace std {

template <>
struct hash<caf::atom_value> {
  size_t operator()(caf::atom_value x) const {
    hash<uint64_t> f;
    return f(static_cast<uint64_t>(x));
  }
};

} // namespace std

#endif // CAF_ATOM_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TYPE_ERASED_TUPLE_HPP
#define CAF_TYPE_ERASED_TUPLE_HPP

#include <tuple>
#include <cstddef>
#include <cstdint>
#include <typeinfo>

#include "caf/fwd.hpp"
#include "caf/type_nr.hpp"
#include "caf/optional.hpp"
#include "caf/type_erased_value.hpp"

#include "caf/detail/try_match.hpp"
#include "caf/detail/apply_args.hpp"
#include "caf/detail/pseudo_tuple.hpp"

namespace caf {

/// Represents a tuple of type-erased values.
class type_erased_tuple {
public:
  // -- member types -----------------------------------------------------------

  using rtti_pair = std::pair<uint16_t, const std::type_info*>;

  // -- constructors, destructors, and assignment operators --------------------

  type_erased_tuple() = default;
  type_erased_tuple(const type_erased_tuple&) = default;

  virtual ~type_erased_tuple();

  // -- pure virtual modifiers -------------------------------------------------

  /// Returns a mutable pointer to the element at position `pos`.
  virtual void* get_mutable(size_t pos) = 0;

  /// Load the content for the element at position `pos` from `source`.
  virtual error load(size_t pos, deserializer& source) = 0;

  // -- modifiers --------------------------------------------------------------

  /// Load the content for the tuple from `source`.
  error load(deserializer& source);

  // -- pure virtual observers -------------------------------------------------

  /// Returns the size of this tuple.
  virtual size_t size() const noexcept = 0;

  /// Returns a type hint for the element types.
  virtual uint32_t type_token() const noexcept = 0;

  /// Returns the type number and `std::type_info` object for
  /// the element at position `pos`.
  virtual rtti_pair type(size_t pos) const noexcept = 0;

  /// Returns the element at position `pos`.
  virtual const void* get(size_t pos) const noexcept = 0;

  /// Returns a string representation of the element at position `pos`.
  virtual std::string stringify(size_t pos) const = 0;

  /// Returns a copy of the element at position `pos`.
  virtual type_erased_value_ptr copy(size_t pos) const = 0;

  /// Saves the element at position `pos` to `sink`.
  virtual error save(size_t pos, serializer& sink) const = 0;

  // -- observers --------------------------------------------------------------

  /// Returns whether multiple references to this tuple exist.
  /// The default implementation returns false.
  virtual bool shared() const noexcept;

  ///  Returns `size() == 0`.
  bool empty() const;

  /// Returns a string representation of the tuple.
  std::string stringify() const;

  /// Saves the content of the tuple to `sink`.
  error save(serializer& sink) const;

  /// Checks whether the type of the stored value at position `pos`
  /// matches type number `n` and run-time type information `p`.
  bool matches(size_t pos, uint16_t nr, const std::type_info* ptr) const  noexcept;

  // -- convenience functions --------------------------------------------------

  /// Returns the type number for the element at position `pos`.
  inline uint16_t type_nr(size_t pos) const noexcept {
    return type(pos).first;
  }

  /// Checks whether the type of the stored value matches `rtti`.
  inline bool matches(size_t pos, const rtti_pair& rtti) const noexcept {
    return matches(pos, rtti.first, rtti.second);
  }

  /// Convenience function for `*reinterpret_cast<const T*>(get())`.
  template <class T>
  const T& get_as(size_t pos) const {
    return *reinterpret_cast<const T*>(get(pos));
  }

  template <class T, size_t Pos>
  struct typed_index {};

  template <class T, size_t Pos>
  static constexpr typed_index<T, Pos> make_typed_index() {
    return {};
  }

  template <class T, size_t Pos>
  const T& get_as(typed_index<T, Pos>) const {
    return *reinterpret_cast<const T*>(get(Pos));
  }

  template <class... Ts, long... Is>
  std::tuple<const Ts&...> get_as_tuple(detail::type_list<Ts...>,
                                        detail::int_list<Is...>) const {
    return std::tuple<const Ts&...>{get_as<Ts>(Is)...};
    //return get_as<Ts>(Is)...;//(make_typed_index<Ts, Is>())...;
  }

  template <class... Ts>
  std::tuple<const Ts&...> get_as_tuple() const {
    return get_as_tuple(detail::type_list<Ts...>{},
                        typename detail::il_range<0, sizeof...(Ts)>::type{});
  }

  /// Convenience function for `*reinterpret_cast<T*>(get_mutable())`.
  template <class T>
  T& get_mutable_as(size_t pos) {
    return *reinterpret_cast<T*>(get_mutable(pos));
  }

  /// Convenience function for moving a value out of the tuple if it is
  /// unshared. Returns a copy otherwise.
  template <class T>
  T move_if_unshared(size_t pos) {
    if (shared())
      return get_as<T>(pos);
    return std::move(get_mutable_as<T>(pos));
  }

  /// Returns `true` if the element at `pos` matches `T`.
  template <class T>
  bool match_element(size_t pos) const noexcept {
    CAF_ASSERT(pos < size());
    auto x = detail::meta_element_factory<T>::create();
    return x.fun(x, *this, pos);
  }

  /// Returns `true` if the pattern `Ts...` matches the content of this tuple.
  template <class... Ts>
  bool match_elements() const noexcept {
    detail::meta_elements<detail::type_list<Ts...>> xs;
    return xs.arr.empty() ? empty()
                          : detail::try_match(*this, &xs.arr[0], sizeof...(Ts));
  }

  template <class F>
  auto apply(F fun)
  -> optional<typename detail::get_callable_trait<F>::result_type> {
    using trait = typename detail::get_callable_trait<F>::type;
    detail::type_list<typename trait::result_type> result_token;
    typename trait::arg_types args_token;
    return apply(fun, result_token, args_token);
  }

private:
  template <class F, class R, class... Ts>
  optional<R> apply(F& fun, detail::type_list<R>,
                    detail::type_list<Ts...> tk) {
    if (!match_elements<Ts...>())
      return none;
    detail::pseudo_tuple<typename std::decay<Ts>::type...> xs{*this};
    return detail::apply_args(fun, detail::get_indices(tk), xs);
  }

  template <class F, class... Ts>
  optional<void> apply(F& fun, detail::type_list<void>,
                       detail::type_list<Ts...> tk) {
    if (!match_elements<Ts...>())
      return none;
    detail::pseudo_tuple<typename std::decay<Ts>::type...> xs{*this};
    detail::apply_args(fun, detail::get_indices(tk), xs);
    return unit;
  }
};

/// @relates type_erased_tuple
template <class Processor>
typename std::enable_if<Processor::reads_state>::type
serialize(Processor& proc, type_erased_tuple& x) {
  x.save(proc);
}

/// @relates type_erased_tuple
template <class Processor>
typename std::enable_if<Processor::writes_state>::type
serialize(Processor& proc, type_erased_tuple& x) {
  x.load(proc);
}

/// @relates type_erased_tuple
inline std::string to_string(const type_erased_tuple& x) {
  return x.stringify();
}

/// @relates type_erased_tuple
/// Dummy objects representing empty tuples.
class empty_type_erased_tuple : public type_erased_tuple {
public:
  empty_type_erased_tuple() = default;

  ~empty_type_erased_tuple() override;

  void* get_mutable(size_t pos) override;

  error load(size_t pos, deserializer& source) override;

  size_t size() const noexcept override;

  uint32_t type_token() const noexcept override;

  rtti_pair type(size_t pos) const noexcept override;

  const void* get(size_t pos) const noexcept override;

  std::string stringify(size_t pos) const override;

  type_erased_value_ptr copy(size_t pos) const override;

  error save(size_t pos, serializer& sink) const override;
};

} // namespace caf

#endif // CAF_TYPE_ERASED_TUPLE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_DESERIALIZER_HPP
#define CAF_STREAM_DESERIALIZER_HPP

#include <limits>
#include <string>
#include <sstream>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <iomanip>
#include <stdexcept>
#include <type_traits>

#include "caf/sec.hpp"
#include "caf/logger.hpp"
#include "caf/deserializer.hpp"

#include "caf/detail/ieee_754.hpp"
#include "caf/detail/network_order.hpp"

namespace caf {

/// Implements the deserializer interface with a binary serialization protocol.
template <class Streambuf>
class stream_deserializer : public deserializer {
  using streambuf_type = typename std::remove_reference<Streambuf>::type;
  using char_type = typename streambuf_type::char_type;
  using streambuf_base = std::basic_streambuf<char_type>;
  using streamsize = std::streamsize;

  static_assert(std::is_base_of<streambuf_base, streambuf_type>::value,
                "Streambuf must inherit from std::streambuf");

public:
  template <class... Ts>
  explicit stream_deserializer(actor_system& sys, Ts&&... xs)
    : deserializer(sys),
      streambuf_(std::forward<Ts>(xs)...) {
  }

  template <class... Ts>
  explicit stream_deserializer(execution_unit* ctx, Ts&&... xs)
    : deserializer(ctx),
      streambuf_(std::forward<Ts>(xs)...) {
  }

  template <
    class S,
    class = typename std::enable_if<
      std::is_same<
        typename std::remove_reference<S>::type,
        typename std::remove_reference<Streambuf>::type
      >::value
    >::type
  >
  explicit stream_deserializer(S&& sb)
    : deserializer(nullptr),
      streambuf_(std::forward<S>(sb)) {
  }

  error begin_object(uint16_t& typenr, std::string& name) override {
    return error::eval([&] { return apply_int(typenr); },
                       [&] { return typenr == 0 ? apply(name) : error{}; });
  }

  error end_object() override {
    return none;
  }

  error begin_sequence(size_t& num_elements) override {
    return varbyte_decode(num_elements);
  }

  error end_sequence() override {
    return none;
  }

  error apply_raw(size_t num_bytes, void* data) override {
    return range_check(streambuf_.sgetn(reinterpret_cast<char_type*>(data),
                                        static_cast<streamsize>(num_bytes)),
                       num_bytes);
  }

protected:
  // Decode an unsigned integral type as variable-byte-encoded byte sequence.
  template <class T>
  error varbyte_decode(T& x) {
    static_assert(std::is_unsigned<T>::value, "T must be an unsigned type");
    auto n = 0;
    x = 0;
    uint8_t low7;
    do {
      auto c = streambuf_.sbumpc();
      using traits = typename streambuf_type::traits_type;
      if (traits::eq_int_type(c, traits::eof()))
        return sec::end_of_stream;
      low7 = static_cast<uint8_t>(traits::to_char_type(c));
      x |= static_cast<T>((low7 & 0x7F)) << (7 * n);
      ++n;
    } while (low7 & 0x80);
    return none;
  }

  error apply_builtin(builtin type, void* val) override {
    CAF_ASSERT(val != nullptr);
    switch (type) {
      default: // i8_v or u8_v
        CAF_ASSERT(type == i8_v || type == u8_v);
        return apply_raw(sizeof(uint8_t), val);
      case i16_v:
      case u16_v:
        return apply_int(*reinterpret_cast<uint16_t*>(val));
      case i32_v:
      case u32_v:
        return apply_int(*reinterpret_cast<uint32_t*>(val));
      case i64_v:
      case u64_v:
        return apply_int(*reinterpret_cast<uint64_t*>(val));
      case float_v:
        return apply_float(*reinterpret_cast<float*>(val));
      case double_v:
        return apply_float(*reinterpret_cast<double*>(val));
      case ldouble_v: {
        // the IEEE-754 conversion does not work for long double
        // => fall back to string serialization (even though it sucks)
        std::string tmp;
        auto e = apply(tmp);
        if (e)
          return e;
        std::istringstream iss{std::move(tmp)};
        iss >> *reinterpret_cast<long double*>(val);
        return none;
      }
      case string8_v: {
        auto& str = *reinterpret_cast<std::string*>(val);
        size_t str_size;
        return error::eval([&] { return begin_sequence(str_size); },
                           [&] { str.resize(str_size);
                                 auto p = &str[0];
                                 auto data = reinterpret_cast<char_type*>(p);
                                 auto s = static_cast<streamsize>(str_size);
                                 return range_check(streambuf_.sgetn(data, s),
                                                    str_size); },
                           [&] { return end_sequence(); });
      }
      case string16_v: {
        auto& str = *reinterpret_cast<std::u16string*>(val);
        str.clear();
        size_t ns;
        return error::eval([&] { return begin_sequence(ns); },
                           [&] { return fill_range_c<uint16_t>(str, ns); },
                           [&] { return end_sequence(); });
      }
      case string32_v: {
        auto& str = *reinterpret_cast<std::u32string*>(val);
        str.clear();
        size_t ns;
        return error::eval([&] { return begin_sequence(ns); },
                           [&] { return fill_range_c<uint32_t>(str, ns); },
                           [&] { return end_sequence(); });
      }
    }
  }

  error range_check(std::streamsize got, size_t need) {
    if (got >= 0 && static_cast<size_t>(got) == need)
      return none;
    CAF_LOG_ERROR("range_check failed");
    return sec::end_of_stream;
  }

  template <class T>
  error apply_int(T& x) {
    T tmp;
    auto e = apply_raw(sizeof(T), &tmp);
    if (e)
      return e;
    x = detail::from_network_order(tmp);
    return none;
  }

  template <class T>
  error apply_float(T& x) {
    typename detail::ieee_754_trait<T>::packed_type tmp = 0;
    auto e = apply_int(tmp);
    if (e)
      return e;
    x = detail::unpack754(tmp);
    return none;
  }

private:
  Streambuf streambuf_;
};

} // namespace caf

#endif // CAF_STREAM_DESERIALIZER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TOPIC_SCATTERER_HPP
#define CAF_TOPIC_SCATTERER_HPP

#include <map>
#include <tuple>
#include <deque>
#include <vector>
#include <functional>

#include "caf/buffered_scatterer.hpp"

#include "caf/meta/type_name.hpp"

namespace caf {

/// A topic scatterer allows stream nodes to fork into multiple lanes, where
/// each lane carries only a subset of the data. For example, the lane
/// mechanism allows you filter key/value pairs before forwarding them to a set
/// of workers.
template <class T, class Filter, class Select>
class topic_scatterer : public buffered_scatterer<T> {
public:
  /// Base type.
  using super = buffered_scatterer<T>;

  struct lane {
    typename super::buffer_type buf;
    typename super::path_ptr_vec paths;
    template <class Inspector>
    friend typename Inspector::result_type inspect(Inspector& f, lane& x) {
      return f(meta::type_name("lane"), x.buf, x.paths);
    }
  };

  /// Identifies a lane inside the downstream.
  using filter_type = Filter;

  using lanes_map = std::map<filter_type, lane>;

  topic_scatterer(local_actor* selfptr) : super(selfptr) {
    // nop
  }

  using super::remove_path;

  bool remove_path(const stream_id& sid, const actor_addr& x,
                   error reason, bool silent) override {
    CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(x)
                  << CAF_ARG(reason) << CAF_ARG(silent));
    auto i = this->iter_find(this->paths_, sid, x);
    if (i != this->paths_.end()) {
      erase_from_lanes(i->get());
      return super::remove_path(i, std::move(reason), silent);
    }
    return false;
  }

  void add_lane(filter_type f) {
    std::sort(f);
    lanes_.emplace(std::move(f), typename super::buffer_type{});
  }

  /// Sets the filter for `x` to `f` and inserts `x` into the appropriate lane.
  /// @pre `x` is not registered on *any* lane
  template <class Handle>
  void set_filter(const stream_id& sid, const Handle& x, filter_type f) {
    CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(x) << CAF_ARG(f));
    auto ptr = super::find(sid, x);
    if (!ptr) {
      CAF_LOG_WARNING("unable to set filter for unknown path");
      return;
    }
    erase_from_lanes(ptr);
    lanes_[std::move(f)].paths.push_back(ptr);
  }

  const lanes_map& lanes() const {
    return lanes_;
  }

  Select& selector() {
    return select_;
  }

  const Select& selector() const {
    return select_;
  }

protected:
  void erase_from_lanes(typename super::path_ptr ptr) {
    for (auto i = lanes_.begin(); i != lanes_.end(); ++i)
      if (erase_from_lane(i->second, ptr)) {
        if (i->second.paths.empty())
          lanes_.erase(i);
        return;
      }
  }

  bool erase_from_lane(lane& l, typename super::path_ptr ptr) {
    auto e = l.paths.end();
    auto i = std::find(l.paths.begin(), e, ptr);
    if (i != e) {
      l.paths.erase(i);
      return true;
    }
    return false;
  }

  /// Spreads the content of `buf_` to `lanes_`.
  void fan_out() {
    for (auto& kvp : lanes_)
      for (auto& x : this->buf_)
        if (selected(kvp.first, x))
          kvp.second.buf.push_back(x);
    this->buf_.clear();
  }

  /// Returns `true` if `x` is selected by `f`, `false` otherwise.
  bool selected(const filter_type& f, const T& x) {
    if (select_(f, x))
      return true;
    return false;
  }

  lanes_map lanes_;
  Select select_;
};

} // namespace caf

#endif // CAF_TOPIC_SCATTERER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TIMEOUT_DEFINITION_HPP
#define CAF_TIMEOUT_DEFINITION_HPP

#include <functional>
#include <type_traits>

#include "caf/duration.hpp"

namespace caf {

namespace detail {

class behavior_impl;

behavior_impl* new_default_behavior(duration d, std::function<void()> fun);

} // namespace detail

template <class F>
struct timeout_definition {
  static constexpr bool may_have_timeout = true;

  duration timeout;

  F handler;

  detail::behavior_impl* as_behavior_impl() const {
    return detail::new_default_behavior(timeout, handler);
  }

  timeout_definition() = default;
  timeout_definition(timeout_definition&&) = default;
  timeout_definition(const timeout_definition&) = default;

  timeout_definition(duration d, F&& f) : timeout(d), handler(std::move(f)) {
    // nop
  }

  template <class U>
  timeout_definition(const timeout_definition<U>& other)
      : timeout(other.timeout),
        handler(other.handler) {
    // nop
  }
};

template <class T>
struct is_timeout_definition : std::false_type {};

template <class T>
struct is_timeout_definition<timeout_definition<T>> : std::true_type {};

using generic_timeout_definition = timeout_definition<std::function<void()>>;

} // namespace caf

#endif // CAF_TIMEOUT_DEFINITION_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_BROADCAST_TOPIC_SCATTERER_HPP
#define CAF_BROADCAST_TOPIC_SCATTERER_HPP

#include <map>
#include <tuple>
#include <deque>
#include <vector>
#include <functional>

#include "caf/topic_scatterer.hpp"

namespace caf {

/// A topic scatterer that delivers data in broadcast fashion to all sinks.
template <class T, class Filter, class Select>
class broadcast_topic_scatterer
    : public topic_scatterer<T, Filter, Select> {
public:
  /// Base type.
  using super = topic_scatterer<T, Filter, Select>;

  broadcast_topic_scatterer(local_actor* selfptr) : super(selfptr) {
    // nop
  }

  long credit() const override {
    // We receive messages until we have exhausted all downstream credit and
    // have filled our buffer to its minimum size.
    return this->min_credit() + this->min_buffer_size();
  }

  void emit_batches() override {
    CAF_LOG_TRACE("");
    this->fan_out();
    for (auto& kvp : this->lanes_) {
      auto& l = kvp.second;
      auto chunk = super::get_chunk(l.buf, super::min_credit(l.paths));
      auto csize = static_cast<long>(chunk.size());
      if (csize == 0)
        continue;
      auto wrapped_chunk = make_message(std::move(chunk));
      for (auto& x : l.paths) {
        CAF_ASSERT(x->open_credit >= csize);
        x->emit_batch(csize, wrapped_chunk);
      }
    }
  }
};

} // namespace caf

#endif // CAF_BROADCAST_TOPIC_SCATTERER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TO_STRING_HPP
#define CAF_TO_STRING_HPP

#include <string>

#include "caf/error.hpp"
#include "caf/deep_to_string.hpp"

#include "caf/detail/type_traits.hpp"
#include "caf/detail/stringification_inspector.hpp"

namespace caf {

template <class T,
          class E = typename std::enable_if<
                      detail::is_inspectable<
                        detail::stringification_inspector,
                        T
                      >::value
                    >::type>
std::string to_string(const T& x) {
  std::string res;
  detail::stringification_inspector f{res};
  inspect(f, const_cast<T&>(x));
  return res;
}

} // namespace caf

#endif // CAF_TO_STRING_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ACTOR_CLOCK
#define CAF_ACTOR_CLOCK

#include <chrono>

#include "caf/fwd.hpp"

namespace caf {

/// A monotonic clock for scheduling timeouts and delayed messages.
class actor_clock {
public:
  // -- member types -----------------------------------------------------------

  /// Underlying clock type.
  using clock_type = std::chrono::steady_clock;

  /// Discrete point in time.
  using time_point = typename clock_type::time_point;

  /// Difference between two points in time.
  using duration_type = typename clock_type::duration;

  // -- constructors, destructors, and assignment operators --------------------

  virtual ~actor_clock();

  // -- observers --------------------------------------------------------------

  /// Returns the current wall-clock time.
  virtual time_point now() const noexcept;

  /// Returns the difference between `t0` and `t1`, allowing the clock to
  /// return any arbitrary value depending on the measurement that took place.
  virtual duration_type difference(atom_value measurement, time_point t0,
                                   time_point t1) const noexcept;

  /// Schedules a `timeout_msg` for `self` at time point `t`, overriding any
  /// previous receive timeout.
  virtual void set_receive_timeout(time_point t, abstract_actor* self,
                                   uint32_t id) = 0;

  /// Schedules a `sec::request_timeout` for `self` at time point `t`.
  virtual void set_request_timeout(time_point t, abstract_actor* self,
                                   message_id id) = 0;

  /// Cancels a pending receive timeout.
  virtual void cancel_receive_timeout(abstract_actor* self) = 0;

  /// Cancels the pending request timeout for `id`.
  virtual void cancel_request_timeout(abstract_actor* self, message_id id) = 0;

  /// Cancels all timeouts for `self`.
  virtual void cancel_timeouts(abstract_actor* self) = 0;

  /// Schedules an arbitrary message to `receiver` for time point `t`.
  virtual void schedule_message(time_point t, strong_actor_ptr receiver,
                                mailbox_element_ptr content) = 0;

  /// Schedules an arbitrary message to `target` for time point `t`.
  virtual void schedule_message(time_point t, group target,
                                strong_actor_ptr sender, message content) = 0;
};

} // namespace caf

#endif // CAF_ACTOR_CLOCK
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_EXPECTED_HPP
#define CAF_EXPECTED_HPP

#include "caf/config.hpp"

#include <new>
#include <memory>
#include <ostream>
#include <type_traits>

#include "caf/unit.hpp"
#include "caf/error.hpp"
#include "caf/unifyn.hpp"

namespace caf {

/// Helper class to construct an `expected<T>` that represents no error.
/// @relates expected
struct no_error_t {};

/// The only instance of ::no_error_t.
/// @relates expected
constexpr no_error_t no_error = no_error_t{};

/// Represents the result of a computation which can either complete
/// successfully with an instance of type `T` or fail with an `error`.
/// @tparam T The type of the result.
template <typename T>
class expected {
public:
  // -- member types -----------------------------------------------------------

  using value_type = T;

  // -- static member variables ------------------------------------------------

  /// Stores whether move construct and move assign never throw.
  static constexpr bool nothrow_move
    = std::is_nothrow_move_constructible<T>::value
      && std::is_nothrow_move_assignable<T>::value;

  /// Stores whether copy construct and copy assign never throw.
  static constexpr bool nothrow_copy
    = std::is_nothrow_copy_constructible<T>::value
      && std::is_nothrow_copy_assignable<T>::value;

  // -- constructors, destructors, and assignment operators --------------------

  template <class U>
  expected(U x,
           typename std::enable_if<std::is_convertible<U, T>::value>::type* = nullptr)
      : engaged_(true) {
    new (&value_) T(std::move(x));
  }

  expected(T&& x) noexcept(nothrow_move) : engaged_(true) {
    new (&value_) T(std::move(x));
  }

  expected(const T& x) noexcept(nothrow_copy) : engaged_(true) {
    new (&value_) T(x);
  }

  expected(caf::error e) noexcept : engaged_(false) {
    new (&error_) caf::error{std::move(e)};
  }

  expected(no_error_t) noexcept : engaged_(false) {
    new (&error_) caf::error{};
  }

  expected(const expected& other) noexcept(nothrow_copy) {
    construct(other);
  }

  template <class Code, class E = enable_if_has_make_error_t<Code>>
  expected(Code code) : engaged_(false) {
    new (&error_) caf::error(make_error(code));
  }

  expected(expected&& other) noexcept(nothrow_move) {
    construct(std::move(other));
  }

  ~expected() {
    destroy();
  }

  expected& operator=(const expected& other) noexcept(nothrow_copy) {
    if (engaged_ && other.engaged_)
      value_ = other.value_;
    else if (!engaged_ && !other.engaged_)
      error_ = other.error_;
    else {
      destroy();
      construct(other);
    }
    return *this;
  }

  expected& operator=(expected&& other) noexcept(nothrow_move) {
    if (engaged_ && other.engaged_)
      value_ = std::move(other.value_);
    else if (!engaged_ && !other.engaged_)
      error_ = std::move(other.error_);
    else {
      destroy();
      construct(std::move(other));
    }
    return *this;
  }

  expected& operator=(const T& x) noexcept(nothrow_copy) {
    if (engaged_) {
      value_ = x;
    } else {
      destroy();
      engaged_ = true;
      new (&value_) T(x);
    }
    return *this;
  }


  expected& operator=(T&& x) noexcept(nothrow_move) {
    if (engaged_) {
      value_ = std::move(x);
    } else {
      destroy();
      engaged_ = true;
      new (&value_) T(std::move(x));
    }
    return *this;
  }

  template <class U>
  typename std::enable_if<std::is_convertible<U, T>::value, expected&>::type
  operator=(U x) {
    return *this = T{std::move(x)};
  }

  expected& operator=(caf::error e) noexcept {
    if (!engaged_)
      error_ = std::move(e);
    else {
      destroy();
      engaged_ = false;
      new (&error_) caf::error(std::move(e));
    }
    return *this;
  }

  template <class Code>
  enable_if_has_make_error_t<Code, expected&> operator=(Code code) {
    return *this = make_error(code);
  }

  // -- modifiers --------------------------------------------------------------

  /// @copydoc cvalue
  T& value() noexcept {
    CAF_ASSERT(engaged_);
    return value_;
  }

  /// @copydoc cvalue
  T& operator*() noexcept {
    return value();
  }

  /// @copydoc cvalue
  T* operator->() noexcept {
    return &value();
  }

  /// @copydoc cerror
  caf::error& error() noexcept {
    CAF_ASSERT(!engaged_);
    return error_;
  }

  // -- observers --------------------------------------------------------------

  /// Returns the contained value.
  /// @pre `engaged() == true`.
  const T& cvalue() const noexcept {
    CAF_ASSERT(engaged_);
    return value_;
  }

  /// @copydoc cvalue
  const T& value() const noexcept {
    CAF_ASSERT(engaged_);
    return value_;
  }

  /// @copydoc cvalue
  const T& operator*() const noexcept {
    return value();
  }

  /// @copydoc cvalue
  const T* operator->() const noexcept {
    return &value();
  }

  /// @copydoc engaged
  explicit operator bool() const noexcept {
    return engaged();
  }

  /// Returns `true` if the object holds a value (is engaged).
  bool engaged() const noexcept {
    return engaged_;
  }

  /// Returns the contained error.
  /// @pre `engaged() == false`.
  const caf::error& cerror() const noexcept {
    CAF_ASSERT(!engaged_);
    return error_;
  }

  /// @copydoc cerror
  const caf::error& error() const noexcept {
    CAF_ASSERT(!engaged_);
    return error_;
  }

private:
  void construct(expected&& other) noexcept(nothrow_move) {
    if (other.engaged_)
      new (&value_) T(std::move(other.value_));
    else
      new (&error_) caf::error(std::move(other.error_));
    engaged_ = other.engaged_;
  }

  void construct(const expected& other) noexcept(nothrow_copy) {
    if (other.engaged_)
      new (&value_) T(other.value_);
    else
      new (&error_) caf::error(other.error_);
    engaged_ = other.engaged_;
  }

  void destroy() {
    if (engaged_)
      value_.~T();
    else
      error_.~error();
  }

  bool engaged_;

  union {
    T value_;
    caf::error error_;
  };
};

/// @relates expected
template <class T>
auto operator==(const expected<T>& x, const expected<T>& y)
-> decltype(*x == *y) {
  return x && y ? *x == *y : (!x && !y ? x.error() == y.error() : false);
}

/// @relates expected
template <class T, class U>
auto operator==(const expected<T>& x, const U& y) -> decltype(*x == y) {
  return x ? *x == y : false;
}

/// @relates expected
template <class T, class U>
auto operator==(const T& x, const expected<U>& y) -> decltype(x == *y) {
  return y == x;
}

/// @relates expected
template <class T>
bool operator==(const expected<T>& x, const error& y) {
  return x ? false : x.error() == y;
}

/// @relates expected
template <class T>
bool operator==(const error& x, const expected<T>& y) {
  return y == x;
}

/// @relates expected
template <class T, class E>
enable_if_has_make_error_t<E, bool> operator==(const expected<T>& x, E y) {
  return x == make_error(y);
}

/// @relates expected
template <class T, class E>
enable_if_has_make_error_t<E, bool> operator==(E x, const expected<T>& y) {
  return y == make_error(x);
}

/// @relates expected
template <class T>
auto operator!=(const expected<T>& x, const expected<T>& y)
-> decltype(*x == *y) {
  return !(x == y);
}

/// @relates expected
template <class T, class U>
auto operator!=(const expected<T>& x, const U& y) -> decltype(*x == y) {
  return !(x == y);
}

/// @relates expected
template <class T, class U>
auto operator!=(const T& x, const expected<U>& y) -> decltype(x == *y) {
  return !(x == y);
}

/// @relates expected
template <class T>
bool operator!=(const expected<T>& x, const error& y) {
  return !(x == y);
}

/// @relates expected
template <class T>
bool operator!=(const error& x, const expected<T>& y) {
  return !(x == y);
}

/// @relates expected
template <class T, class E>
enable_if_has_make_error_t<E, bool> operator!=(const expected<T>& x, E y) {
  return !(x == y);
}

/// @relates expected
template <class T, class E>
enable_if_has_make_error_t<E, bool> operator!=(E x, const expected<T>& y) {
  return !(x == y);
}

/// The pattern `expected<void>` shall be used for functions that may generate
/// an error but would otherwise return `bool`.
template <>
class expected<void> {
public:
  expected() = default;

  expected(unit_t) noexcept {
    // nop
  }

  expected(no_error_t) noexcept {
    // nop
  }

  expected(caf::error e) noexcept : error_(std::move(e)) {
    // nop
  }

  expected(const expected& other)  noexcept : error_(other.error_) {
    // nop
  }

  expected(expected&& other) noexcept : error_(std::move(other.error_)) {
    // nop
  }

  template <class Code, class E = enable_if_has_make_error_t<Code>>
  expected(Code code) : error_(make_error(code)) {
    // nop
  }

  expected& operator=(const expected& other) = default;

  expected& operator=(expected&& other) noexcept {
    error_ = std::move(other.error_);
    return *this;
  }

  explicit operator bool() const {
    return !error_;
  }

  const caf::error& error() const {
    return error_;
  }

private:
  caf::error error_;
};

/// @relates expected
inline bool operator==(const expected<void>& x, const expected<void>& y) {
  return (x && y) || (!x && !y && x.error() == y.error());
}

/// @relates expected
inline bool operator!=(const expected<void>& x, const expected<void>& y) {
  return !(x == y);
}

template <>
class expected<unit_t> : public expected<void> {
public:
  using expected<void>::expected;
};

template <class T>
std::string to_string(const expected<T>& x) {
  if (x)
    return deep_to_string(*x);
  return "!" + to_string(x.error());
}

inline std::string to_string(const expected<void>& x) {
  if (x)
    return "unit";
  return "!" + to_string(x.error());
}

/// @cond PRIVATE
/// Assigns the value of `expr` (which must return an `expected`)
/// to a new variable named `var` or throws a `std::runtime_error` on error.
/// @relates expected
/// @experimental
#define CAF_EXP_THROW(var, expr)                                               \
  auto CAF_UNIFYN(tmp_var_) = expr;                                            \
  if (!CAF_UNIFYN(tmp_var_))                                                  \
    CAF_RAISE_ERROR(to_string(CAF_UNIFYN(tmp_var_).error()));                  \
  auto& var = *CAF_UNIFYN(tmp_var_)
/// @endcond

} // namespace caf

namespace std {

template <class T>
auto operator<<(ostream& oss, const caf::expected<T>& x)
-> decltype(oss << *x) {
  if (x)
    oss << *x;
  else
    oss << "!" << to_string(x.error());
  return oss;
}

} // namespace std

#endif
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_STAGE_TRAIT_HPP
#define CAF_STREAM_STAGE_TRAIT_HPP

#include "caf/fwd.hpp"
#include "caf/detail/type_traits.hpp"

namespace caf {

template <class F>
struct stream_stage_trait;

template <class State, class In, class Out>
struct stream_stage_trait<void (State&, downstream<Out>&, In)> {
  using state = State;
  using input = In;
  using output = Out;
};

template <class F>
using stream_stage_trait_t =
  stream_stage_trait<typename detail::get_callable_trait<F>::fun_sig>;

} // namespace caf

#endif // CAF_STREAM_STAGE_TRAIT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2015                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_NAMED_ACTOR_CONFIG_HPP
#define CAF_NAMED_ACTOR_CONFIG_HPP

#include <cstddef>

#include "caf/atom.hpp"
#include "caf/deep_to_string.hpp"

#include "caf/meta/type_name.hpp"

namespace caf {

/// Stores a flow-control configuration.
struct named_actor_config {
  atom_value strategy;
  size_t low_watermark;
  size_t max_pending;
};

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, named_actor_config& x) {
  return f(meta::type_name("named_actor_config"), x.strategy, x.low_watermark,
           x.max_pending);
}

} // namespace caf

#endif //CAF_NAMED_ACTOR_CONFIG_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_INVALID_STREAM_GATHERER_HPP
#define CAF_INVALID_STREAM_GATHERER_HPP

#include "caf/stream_gatherer.hpp"

namespace caf {

/// Type-erased policy for receiving data from sources.
class invalid_stream_gatherer : public stream_gatherer {
public:
  invalid_stream_gatherer() = default;

  ~invalid_stream_gatherer() override;

  path_ptr add_path(const stream_id& sid, strong_actor_ptr x,
                    strong_actor_ptr original_stage, stream_priority prio,
                    long available_credit, bool redeployable,
                    response_promise result_cb) override;

  bool remove_path(const stream_id& sid, const actor_addr& x, error reason,
                   bool silent) override;

  void close(message reason) override;

  void abort(error reason) override;

  long num_paths() const override;

  bool closed() const override;

  bool continuous() const override;

  void continuous(bool value) override;

  path_ptr path_at(size_t index) override;

  path_ptr find(const stream_id& sid, const actor_addr& x) override;

  long high_watermark() const override;

  long min_credit_assignment() const override;

  long max_credit() const override;

  void high_watermark(long x) override;

  void min_credit_assignment(long x) override;

  void max_credit(long x) override;

  void assign_credit(long downstream_capacity) override;

  long initial_credit(long downstream_capacity, path_type* x) override;
};

} // namespace caf

#endif // CAF_INVALID_STREAM_GATHERER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_SEND_HPP
#define CAF_SEND_HPP

#include "caf/actor.hpp"
#include "caf/message.hpp"
#include "caf/actor_cast.hpp"
#include "caf/actor_addr.hpp"
#include "caf/message_id.hpp"
#include "caf/typed_actor.hpp"
#include "caf/local_actor.hpp"
#include "caf/response_type.hpp"
#include "caf/system_messages.hpp"
#include "caf/is_message_sink.hpp"
#include "caf/message_priority.hpp"
#include "caf/check_typed_input.hpp"

namespace caf {

/// Sends `to` a message under the identity of `from` with priority `prio`.
template <message_priority P = message_priority::normal,
          class Source = actor, class Dest = actor, class... Ts>
void send_as(const Source& src, const Dest& dest, Ts&&... xs) {
  static_assert(sizeof...(Ts) > 0, "no message to send");
  using token = detail::type_list<detail::strip_and_convert_t<Ts>...>;
  static_assert(!statically_typed<Source>() || statically_typed<Dest>(),
                "statically typed actors can only send() to other "
                "statically typed actors; use anon_send() or request() when "
                "communicating with dynamically typed actors");
  static_assert(response_type_unbox<
                  signatures_of_t<Dest>,
                  token
                >::valid,
                "receiver does not accept given message");
  // TODO: this only checks one way, we should check for loops
  static_assert(is_void_response<
                  response_type_unbox_t<
                    signatures_of_t<Dest>,
                    token>
                >::value
                ||  response_type_unbox<
                      signatures_of_t<Source>,
                      response_type_unbox_t<
                        signatures_of_t<Dest>,
                        token>
                    >::valid,
                "this actor does not accept the response message");
  if (dest)
    dest->eq_impl(make_message_id(P), actor_cast<strong_actor_ptr>(src),
                  nullptr, std::forward<Ts>(xs)...);
}

template <class Source, class Dest, class... Ts>
void unsafe_send_as(Source* src, const Dest& dest, Ts&&... xs) {
  actor_cast<abstract_actor*>(dest)->eq_impl(make_message_id(), src->ctrl(),
                                             src->context(),
                                             std::forward<Ts>(xs)...);
}

template <class... Ts>
void unsafe_response(local_actor* self, strong_actor_ptr src,
                     std::vector<strong_actor_ptr> stages, message_id mid,
                     Ts&&... xs) {
  strong_actor_ptr next;
  if (stages.empty()) {
    next = src;
    src = self->ctrl();
    if (mid.is_request())
      mid = mid.response_id();
  } else {
    next = std::move(stages.back());
    stages.pop_back();
  }
  if (next)
    next->enqueue(make_mailbox_element(std::move(src), mid, std::move(stages),
                                       std::forward<Ts>(xs)...),
                  self->context());
}

/// Anonymously sends `dest` a message.
template <message_priority P = message_priority::normal,
          class Dest = actor, class... Ts>
void anon_send(const Dest& dest, Ts&&... xs) {
  static_assert(sizeof...(Ts) > 0, "no message to send");
  using token = detail::type_list<detail::strip_and_convert_t<Ts>...>;
  static_assert(response_type_unbox<signatures_of_t<Dest>, token>::valid,
                "receiver does not accept given message");
  if (dest)
    dest->eq_impl(make_message_id(P), nullptr, nullptr,
                  std::forward<Ts>(xs)...);
}

/// Anonymously sends `dest` an exit message.
template <class Dest>
void anon_send_exit(const Dest& dest, exit_reason reason) {
  CAF_LOG_TRACE(CAF_ARG(dest) << CAF_ARG(reason));
  if (dest)
    dest->enqueue(nullptr, make_message_id(),
                  make_message(exit_msg{dest->address(), reason}), nullptr);
}

/// Anonymously sends `to` an exit message.
inline void anon_send_exit(const actor_addr& to, exit_reason reason) {
  auto ptr = actor_cast<strong_actor_ptr>(to);
  if (ptr)
    anon_send_exit(ptr, reason);
}

/// Anonymously sends `to` an exit message.
inline void anon_send_exit(const weak_actor_ptr& to, exit_reason reason) {
  auto ptr = actor_cast<strong_actor_ptr>(to);
  if (ptr)
    anon_send_exit(ptr, reason);
}

} // namespace caf

#endif // CAF_SEND_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_WEAK_INTRUSIVE_PTR_HPP
#define CAF_WEAK_INTRUSIVE_PTR_HPP

#include <cstddef>
#include <algorithm>
#include <stdexcept>
#include <type_traits>

#include "caf/intrusive_ptr.hpp"
#include "caf/detail/comparable.hpp"

namespace caf {

/// An intrusive, reference counting smart pointer implementation.
/// @relates ref_counted
template <class T>
class weak_intrusive_ptr : detail::comparable<weak_intrusive_ptr<T>>,
                           detail::comparable<weak_intrusive_ptr<T>, const T*>,
                           detail::comparable<weak_intrusive_ptr<T>,
                                              std::nullptr_t> {
public:
  using pointer = T*;
  using const_pointer = const T*;
  using element_type = T;
  using reference = T&;
  using const_reference = const T&;

  // tell actor_cast which semantic this type uses
  static constexpr bool has_weak_ptr_semantics = true;

  constexpr weak_intrusive_ptr() noexcept : ptr_(nullptr) {
    // nop
  }

  weak_intrusive_ptr(pointer raw_ptr, bool add_ref = true) noexcept {
    set_ptr(raw_ptr, add_ref);
  }

  weak_intrusive_ptr(weak_intrusive_ptr&& other) noexcept
      : ptr_(other.detach()) {
    // nop
  }

  weak_intrusive_ptr(const weak_intrusive_ptr& other) noexcept {
    set_ptr(other.get(), true);
  }

  template <class Y>
  weak_intrusive_ptr(weak_intrusive_ptr<Y> other) noexcept
      : ptr_(other.detach()) {
    static_assert(std::is_convertible<Y*, T*>::value,
                  "Y* is not assignable to T*");
  }

  ~weak_intrusive_ptr() {
    if (ptr_)
      intrusive_ptr_release_weak(ptr_);
  }

  void swap(weak_intrusive_ptr& other) noexcept {
    std::swap(ptr_, other.ptr_);
  }

  /// Returns the raw pointer without modifying reference
  /// count and sets this to `nullptr`.
  pointer detach() noexcept {
    auto result = ptr_;
    if (result)
      ptr_ = nullptr;
    return result;
  }

  /// Returns the raw pointer without modifying reference
  /// count and sets this to `nullptr`.
  pointer release() noexcept {
    return detach();
  }

  void reset(pointer new_value = nullptr, bool add_ref = true) {
    auto old = ptr_;
    set_ptr(new_value, add_ref);
    if (old)
      intrusive_ptr_release_weak(old);
  }

  weak_intrusive_ptr& operator=(pointer ptr) noexcept {
    reset(ptr);
    return *this;
  }

  weak_intrusive_ptr& operator=(weak_intrusive_ptr other) noexcept {
    swap(other);
    return *this;
  }

  pointer get() const noexcept {
    return ptr_;
  }

  pointer operator->() const noexcept {
    return ptr_;
  }

  reference operator*() const noexcept {
    return *ptr_;
  }

  bool operator!() const noexcept {
    return !ptr_;
  }

  explicit operator bool() const noexcept {
    return static_cast<bool>(ptr_);
  }

  ptrdiff_t compare(const_pointer ptr) const noexcept {
    return static_cast<ptrdiff_t>(get() - ptr);
  }

  ptrdiff_t compare(const weak_intrusive_ptr& other) const noexcept {
    return compare(other.get());
  }

  ptrdiff_t compare(std::nullptr_t) const noexcept {
    return reinterpret_cast<ptrdiff_t>(get());
  }

  /// Tries to upgrade this weak reference to a strong reference.
  intrusive_ptr<T> lock() const noexcept {
    if (!ptr_ || !intrusive_ptr_upgrade_weak(ptr_))
      return nullptr;
    // reference count already increased by intrusive_ptr_upgrade_weak
    return {ptr_, false};
  }

  /// Tries to upgrade this weak reference to a strong reference.
  /// Returns a pointer with increased strong reference count
  /// on success, `nullptr` otherwise.
  pointer get_locked() const noexcept {
    if (!ptr_ || !intrusive_ptr_upgrade_weak(ptr_))
      return nullptr;
    return ptr_;
  }

private:
  void set_ptr(pointer raw_ptr, bool add_ref) noexcept {
    ptr_ = raw_ptr;
    if (raw_ptr && add_ref)
      intrusive_ptr_add_weak_ref(raw_ptr);
  }

  pointer ptr_;
};

/// @relates weak_intrusive_ptr
template <class X, typename Y>
bool operator==(const weak_intrusive_ptr<X>& lhs,
                const weak_intrusive_ptr<Y>& rhs) {
  return lhs.get() == rhs.get();
}

/// @relates weak_intrusive_ptr
template <class X, typename Y>
bool operator!=(const weak_intrusive_ptr<X>& lhs,
                const weak_intrusive_ptr<Y>& rhs) {
  return !(lhs == rhs);
}

} // namespace caf

#endif // CAF_WEAK_INTRUSIVE_PTR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_SCHEDULER_HPP
#define CAF_SCHEDULER_HPP

#include "caf/scheduler/worker.hpp"
#include "caf/scheduler/coordinator.hpp"
#include "caf/scheduler/abstract_coordinator.hpp"

#endif // CAF_SCHEDULER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MAKE_TYPE_ERASED_TUPLE_HPP
#define CAF_MAKE_TYPE_ERASED_TUPLE_HPP

#include <tuple>
#include <cstddef>
#include <cstdint>
#include <typeinfo>

#include "caf/type_erased_tuple.hpp"

#include "caf/detail/type_erased_tuple_view.hpp"

namespace caf {

/// @relates type_erased_tuple
template <class... Ts>
detail::type_erased_tuple_view<Ts...> make_type_erased_tuple_view(Ts&... xs) {
  return {xs...};
}

} // namespace caf

#endif // CAF_MAKE_TYPE_ERASED_TUPLE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_REPLIES_TO_HPP
#define CAF_REPLIES_TO_HPP

#include <string>

#include "caf/illegal_message_element.hpp"

#include "caf/detail/type_list.hpp"
#include "caf/detail/type_pair.hpp"
#include "caf/detail/type_traits.hpp"

namespace caf {

/// @cond PRIVATE
std::string replies_to_type_name(size_t input_size,
                                 const std::string* input,
                                 size_t output_opt1_size,
                                 const std::string* output_opt1);
/// @endcond

template <class...>
struct output_stream {};

template <class...>
struct output_tuple {};

template <class Input, class Output>
struct typed_mpi {};

/*
<detail::type_list<Is...>,
                 detail::type_list<Ls...>> {
  static_assert(sizeof...(Is) > 0, "template parameter pack Is empty");
  static_assert(sizeof...(Ls) > 0, "template parameter pack Ls empty");
  using input = detail::type_list<Is...>;
  using output = detail::type_list<Ls...>;
  static_assert(!detail::tl_exists<
                  input_types,
                  is_illegal_message_element
                >::value
                && !detail::tl_exists<
                  output_types,
                  is_illegal_message_element
                >::value,
                "interface definition contains an illegal message type");
};
*/

template <class... Is>
struct replies_to {
  template <class... Os>
  using with = typed_mpi<detail::type_list<Is...>, output_tuple<Os...>>;

  /// @private
  template <class... Os>
  using with_stream = typed_mpi<detail::type_list<Is...>, output_stream<Os...>>;
};

template <class... Is>
using reacts_to = typed_mpi<detail::type_list<Is...>, output_tuple<void>>;

} // namespace caf

#endif // CAF_REPLIES_TO_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_INBOUND_PATH_HPP
#define CAF_INBOUND_PATH_HPP

#include <cstddef>
#include <cstdint>

#include "caf/stream_id.hpp"
#include "caf/stream_msg.hpp"
#include "caf/stream_aborter.hpp"
#include "caf/stream_priority.hpp"
#include "caf/actor_control_block.hpp"

#include "caf/meta/type_name.hpp"

namespace caf {

/// State for a path to an upstream actor (source).
class inbound_path {
public:
  /// Stream aborter flag to monitor a path.
  static constexpr const auto aborter_type = stream_aborter::source_aborter;

  /// Message type for propagating graceful shutdowns.
  using regular_shutdown = stream_msg::drop;

  /// Message type for propagating errors.
  using irregular_shutdown = stream_msg::forced_drop;

  /// Pointer to the parent actor.
  local_actor* self;

  /// Stream ID used on this source.
  stream_id sid;

  /// Handle to the source.
  strong_actor_ptr hdl;

  /// Priority of incoming batches from this source.
  stream_priority prio;

  /// ID of the last acknowledged batch ID.
  int64_t last_acked_batch_id;

  /// ID of the last received batch.
  int64_t last_batch_id;

  /// Amount of credit we have signaled upstream.
  long assigned_credit;

  /// Stores whether the source actor is failsafe, i.e., allows the runtime to
  /// redeploy it on failure.
  bool redeployable;

  /// Stores whether an error occurred during stream processing. Configures
  /// whether the destructor sends `close` or `forced_close` messages.
  error shutdown_reason;

  /// Constructs a path for given handle and stream ID.
  inbound_path(local_actor* selfptr, const stream_id& id, strong_actor_ptr ptr);

  ~inbound_path();

  /// Updates `last_batch_id` and `assigned_credit`.
  void handle_batch(long batch_size, int64_t batch_id);

  /// Emits a `stream_msg::ack_batch` on this path and sets `assigned_credit`
  /// to `initial_demand`.
  void emit_ack_open(actor_addr rebind_from, long initial_demand,
                     bool is_redeployable);

  void emit_ack_batch(long new_demand);

  static void emit_irregular_shutdown(local_actor* self, const stream_id& sid,
                                      const strong_actor_ptr& hdl,
                                      error reason);
};

template <class Inspector>
typename Inspector::return_type inspect(Inspector& f, inbound_path& x) {
  return f(meta::type_name("inbound_path"), x.hdl, x.sid, x.prio,
           x.last_acked_batch_id, x.last_batch_id, x.assigned_credit);
}

} // namespace caf

#endif // CAF_INBOUND_PATH_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ACTOR_SYSTEM_CONFIG_HPP
#define CAF_ACTOR_SYSTEM_CONFIG_HPP

#include <atomic>
#include <string>
#include <memory>
#include <typeindex>
#include <functional>
#include <type_traits>
#include <unordered_map>

#include "caf/fwd.hpp"
#include "caf/stream.hpp"
#include "caf/thread_hook.hpp"
#include "caf/config_value.hpp"
#include "caf/config_option.hpp"
#include "caf/actor_factory.hpp"
#include "caf/is_typed_actor.hpp"
#include "caf/type_erased_value.hpp"
#include "caf/named_actor_config.hpp"

#include "caf/detail/safe_equal.hpp"
#include "caf/detail/type_traits.hpp"

namespace caf {

/// Configures an `actor_system` on startup.
class actor_system_config {
public:
  // -- member types -----------------------------------------------------------

  using hook_factory = std::function<io::hook* (actor_system&)>;

  using hook_factory_vector = std::vector<hook_factory>;

  using thread_hooks = std::vector<std::unique_ptr<thread_hook>>;

  template <class K, class V>
  using hash_map = std::unordered_map<K, V>;

  using module_factory = std::function<actor_system::module* (actor_system&)>;

  using module_factory_vector = std::vector<module_factory>;

  using value_factory = std::function<type_erased_value_ptr ()>;

  using value_factory_string_map = hash_map<std::string, value_factory>;

  using value_factory_rtti_map = hash_map<std::type_index, value_factory>;

  using actor_factory_map = hash_map<std::string, actor_factory>;

  using portable_name_map = hash_map<std::type_index, std::string>;

  using error_renderer = std::function<std::string (uint8_t, atom_value,
                                                    const message&)>;

  using error_renderer_map = hash_map<atom_value, error_renderer>;

  using option_ptr = std::unique_ptr<config_option>;

  using option_vector = std::vector<option_ptr>;

  using group_module_factory = std::function<group_module* ()>;

  using group_module_factory_vector = std::vector<group_module_factory>;

  // -- nested classes ---------------------------------------------------------

  using named_actor_config_map = hash_map<std::string, named_actor_config>;

  class opt_group {
  public:
    opt_group(option_vector& xs, const char* category);

    template <class T>
    opt_group& add(T& storage, const char* name, const char* explanation) {
      xs_.emplace_back(make_config_option(storage, cat_, name, explanation));
      return *this;
    }

  private:
    option_vector& xs_;
    const char* cat_;
  };

  // -- constructors, destructors, and assignment operators --------------------

  virtual ~actor_system_config();

  actor_system_config();

  actor_system_config(actor_system_config&&);

  actor_system_config(const actor_system_config&) = delete;
  actor_system_config& operator=(const actor_system_config&) = delete;

  // -- modifiers --------------------------------------------------------------

  /// Parses `args` as tuple of strings containing CLI options
  /// and `ini_stream` as INI formatted input stream.
  actor_system_config& parse(message& args, std::istream& ini);

  /// Parses the CLI options `{argc, argv}` and
  /// `ini_stream` as INI formatted input stream.
  actor_system_config& parse(int argc, char** argv, std::istream& ini);

  /// Parses the CLI options `{argc, argv}` and
  /// tries to open `config_file_name` as INI formatted config file.
  /// The parsers tries to open `caf-application.ini` if `config_file_name`
  /// is `nullptr`.
  actor_system_config& parse(int argc, char** argv,
                             const char* ini_file_cstr = nullptr);

  /// Allows other nodes to spawn actors created by `fun`
  /// dynamically by using `name` as identifier.
  /// @experimental
  actor_system_config& add_actor_factory(std::string name, actor_factory fun);

  /// Allows other nodes to spawn actors of type `T`
  /// dynamically by using `name` as identifier.
  /// @experimental
  template <class T, class... Ts>
  actor_system_config& add_actor_type(std::string name) {
    using handle = typename infer_handle_from_class<T>::type;
    if (!std::is_same<handle, actor>::value)
      add_message_type<handle>(name);
    return add_actor_factory(std::move(name), make_actor_factory<T, Ts...>());
  }

  /// Allows other nodes to spawn actors implemented by function `f`
  /// dynamically by using `name` as identifier.
  /// @experimental
  template <class F>
  actor_system_config& add_actor_type(std::string name, F f) {
    using handle = typename infer_handle_from_fun<F>::type;
    if (!std::is_same<handle, actor>::value)
      add_message_type<handle>(name);
    return add_actor_factory(std::move(name), make_actor_factory(std::move(f)));
  }

  /// Adds message type `T` with runtime type info `name`.
  template <class T>
  actor_system_config& add_message_type(std::string name) {
    static_assert(std::is_empty<T>::value
                  || std::is_same<T, actor>::value // silence add_actor_type err
                  || is_typed_actor<T>::value
                  || (std::is_default_constructible<T>::value
                      && std::is_copy_constructible<T>::value),
                  "T must provide default and copy constructors");
    std::string stream_name = "stream<";
    stream_name += name;
    stream_name += ">";
    add_message_type_impl<stream<T>>(std::move(stream_name));
    std::string vec_name = "std::vector<";
    vec_name += name;
    vec_name += ">";
    add_message_type_impl<std::vector<T>>(std::move(vec_name));
    add_message_type_impl<T>(std::move(name));
    return *this;
  }

  /// Enables the actor system to convert errors of this error category
  /// to human-readable strings via `renderer`.
  actor_system_config& add_error_category(atom_value x,
                                          error_renderer y);

  /// Enables the actor system to convert errors of this error category
  /// to human-readable strings via `to_string(T)`.
  template <class T>
  actor_system_config& add_error_category(atom_value category) {
    auto f = [=](uint8_t val, const std::string& ctx) -> std::string {
      std::string result;
      result = to_string(category);
      result += ": ";
      result += to_string(static_cast<T>(val));
      if (!ctx.empty()) {
        result += " (";
        result += ctx;
        result += ")";
      }
      return result;
    };
    return add_error_category(category, f);
  }

  /// Loads module `T` with optional template parameters `Ts...`.
  template <class T, class... Ts>
  actor_system_config& load() {
    module_factories.push_back([](actor_system& sys) -> actor_system::module* {
      return T::make(sys, detail::type_list<Ts...>{});
    });
    return *this;
  }

  /// Adds a factory for a new hook type to the middleman (if loaded).
  template <class Factory>
  actor_system_config& add_hook_factory(Factory f) {
    hook_factories.push_back(f);
    return *this;
  }

  /// Adds a hook type to the middleman (if loaded).
  template <class Hook>
  actor_system_config& add_hook_type() {
    return add_hook_factory([](actor_system& sys) -> Hook* {
      return new Hook(sys);
    });
  }

  /// Adds a hook type to the scheduler.
  template <class Hook, class... Ts>
  actor_system_config& add_thread_hook(Ts&&... ts) {
    thread_hooks_.emplace_back(new Hook(std::forward<Ts>(ts)...));
    return *this;
  }

  /// Stores whether the help text for this config object was
  /// printed. If set to `true`, the application should not use
  /// this config object to initialize an `actor_system` and
  /// return from `main` immediately.
  bool cli_helptext_printed;

  /// Stores whether this node was started in slave mode.
  bool slave_mode;

  /// Stores the name of this node when started in slave mode.
  std::string slave_name;

  /// Stores credentials for connecting to the bootstrap node
  /// when using the caf-run launcher.
  std::string bootstrap_node;

  /// Stores CLI arguments that were not consumed by CAF.
  message args_remainder;

  /// Sets a config by using its INI name `config_name` to `config_value`.
  actor_system_config& set(const char* cn, config_value cv);

  // -- config parameters of the scheduler -------------------------------------

  atom_value scheduler_policy;
  size_t scheduler_max_threads;
  size_t scheduler_max_throughput;
  bool scheduler_enable_profiling;
  size_t scheduler_profiling_ms_resolution;
  std::string scheduler_profiling_output_file;

  // -- config parameters for work-stealing ------------------------------------

  size_t work_stealing_aggressive_poll_attempts;
  size_t work_stealing_aggressive_steal_interval;
  size_t work_stealing_moderate_poll_attempts;
  size_t work_stealing_moderate_steal_interval;
  size_t work_stealing_moderate_sleep_duration_us;
  size_t work_stealing_relaxed_steal_interval;
  size_t work_stealing_relaxed_sleep_duration_us;

  // -- config parameters for the logger ---------------------------------------

  std::string logger_file_name;
  std::string logger_file_format;
  atom_value logger_console;
  std::string logger_console_format;
  std::string logger_component_filter;
  atom_value logger_verbosity;
  bool logger_inline_output;

  // -- backward compatibility -------------------------------------------------

  std::string& logger_filename CAF_DEPRECATED;
  std::string& logger_filter CAF_DEPRECATED;

  // -- config parameters of the middleman -------------------------------------

  atom_value middleman_network_backend;
  std::string middleman_app_identifier;
  bool middleman_enable_automatic_connections;
  size_t middleman_max_consecutive_reads;
  size_t middleman_heartbeat_interval;
  bool middleman_detach_utility_actors;
  bool middleman_detach_multiplexer;
  bool middleman_enable_tcp;
  bool middleman_enable_udp;
  size_t middleman_cached_udp_buffers;
  size_t middleman_max_pending_msgs;

  // -- config parameters of the OpenCL module ---------------------------------

  std::string opencl_device_ids;

  // -- config parameters of the OpenSSL module ---------------------------------

  std::string openssl_certificate;
  std::string openssl_key;
  std::string openssl_passphrase;
  std::string openssl_capath;
  std::string openssl_cafile;

  // -- factories --------------------------------------------------------------

  value_factory_string_map value_factories_by_name;
  value_factory_rtti_map value_factories_by_rtti;
  actor_factory_map actor_factories;
  module_factory_vector module_factories;
  hook_factory_vector hook_factories;
  group_module_factory_vector group_module_factories;

  // -- hooks ------------------------------------------------------------------

  thread_hooks thread_hooks_;

  // -- run-time type information ----------------------------------------------

  portable_name_map type_names_by_rtti;

  // -- rendering of user-defined types ----------------------------------------

  error_renderer_map error_renderers;

  // -- convenience functions --------------------------------------------------

  template <class F>
  void for_each_option(F f) const {
    const option_vector* all_options[] = { &options_, &custom_options_ };
    for (auto& opt_vec : all_options)
      for (auto& opt : *opt_vec)
        f(*opt);
  }

  // -- utility for caf-run ----------------------------------------------------

  // Config parameter for individual actor types.
  named_actor_config_map named_actor_configs;

  int (*slave_mode_fun)(actor_system&, const actor_system_config&);

protected:
  virtual std::string make_help_text(const std::vector<message::cli_arg>&);

  option_vector custom_options_;

private:
  template <class T>
  void add_message_type_impl(std::string name) {
    type_names_by_rtti.emplace(std::type_index(typeid(T)), name);
    value_factories_by_name.emplace(std::move(name), &make_type_erased_value<T>);
    value_factories_by_rtti.emplace(std::type_index(typeid(T)),
                                     &make_type_erased_value<T>);
  }

  static std::string render_sec(uint8_t, atom_value, const message&);

  static std::string render_exit_reason(uint8_t, atom_value, const message&);

  std::string extract_config_file_name(message& args);

  option_vector options_;
};

} // namespace caf

#endif //CAF_ACTOR_SYSTEM_CONFIG_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MAKE_TYPE_ERASED_VALUE_HPP
#define CAF_MAKE_TYPE_ERASED_VALUE_HPP

#include <cstdint>
#include <typeinfo>
#include <functional>

#include "caf/type_erased_value.hpp"

#include "caf/detail/type_erased_value_impl.hpp"

namespace caf {

/// @relates type_erased_value
/// Creates a type-erased value of type `T` from `xs`.
template <class T, class... Ts>
type_erased_value_ptr make_type_erased_value(Ts&&... xs) {
  type_erased_value_ptr result;
  result.reset(new detail::type_erased_value_impl<T>(std::forward<Ts>(xs)...));
  return result;
}

/// @relates type_erased_value
/// Converts values to type-erased values.
struct type_erased_value_factory {
  template <class T>
  type_erased_value_ptr operator()(T&& x) const {
    return make_type_erased_value<typename std::decay<T>::type>(std::forward<T>(x));
  }
};

} // namespace caf

#endif // CAF_MAKE_TYPE_ERASED_VALUE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_NONE_HPP
#define CAF_NONE_HPP

#include <string>

#include "caf/detail/comparable.hpp"

namespace caf {

/// Represents "nothing", e.g., for clearing an `optional` by assigning `none`.
struct none_t : detail::comparable<none_t> {
  constexpr none_t() {
    // nop
  }
  constexpr explicit operator bool() const {
    return false;
  }

  static constexpr int compare(none_t) {
    return 0;
  }
};

static constexpr none_t none = none_t{};

/// @relates none_t
inline std::string to_string(const none_t&) {
  return "none";
}

} // namespace caf

#endif // CAF_NONE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TEST_COORDINATOR_HPP
#define CAF_TEST_COORDINATOR_HPP

#include "caf/config.hpp"

#include <deque>
#include <chrono>
#include <limits>
#include <cstddef>
#include <algorithm>

#include "caf/scheduled_actor.hpp"
#include "caf/scheduler/abstract_coordinator.hpp"

#include "caf/detail/test_actor_clock.hpp"

namespace caf {
namespace scheduler {

/// A schedule coordinator for testing purposes.
class test_coordinator : public abstract_coordinator {
public:
  using super = abstract_coordinator;

  test_coordinator(actor_system& sys);

  /// A double-ended queue representing our current job queue.
  std::deque<resumable*> jobs;

  /// A clock type using the highest available precision.
  using hrc = std::chrono::high_resolution_clock;

  /// Returns whether at least one job is in the queue.
  inline bool has_job() const {
    return !jobs.empty();
  }

  /// Returns the next element from the job queue as type `T`.
  template <class T = resumable>
  T& next_job() {
    if (jobs.empty())
      CAF_RAISE_ERROR("jobs.empty()");
    return dynamic_cast<T&>(*jobs.front());
  }

  /// Peeks into the mailbox of `next_job<scheduled_actor>()`.
  template <class T>
  const T& peek() {
    auto ptr = next_job<scheduled_actor>().mailbox().peek();
    CAF_ASSERT(ptr != nullptr);
    if (!ptr->content().match_elements<T>())
      CAF_RAISE_ERROR("Mailbox element does not match T.");
    return ptr->content().get_as<T>(0);
  }

  /// Puts `x` at the front of the queue unless it cannot be found in the queue.
  /// Returns `true` if `x` exists in the queue and was put in front, `false`
  /// otherwise.
  template <class Handle>
  bool prioritize(const Handle& x) {
    auto ptr = dynamic_cast<resumable*>(actor_cast<abstract_actor*>(x));
    if (!ptr)
      return false;
    auto b = jobs.begin();
    auto e = jobs.end();
    auto i = std::find(b, e, ptr);
    if (i == e)
      return false;
    if (i == b)
      return true;
    std::rotate(b, i, i + 1);
    return true;

  }

  /// Tries to execute a single event in FIFO order.
  bool try_run_once();

  /// Tries to execute a single event in LIFO order.
  bool try_run_once_lifo();

  /// Executes a single event in FIFO order or fails if no event is available.
  void run_once();

  /// Executes a single event in LIFO order or fails if no event is available.
  void run_once_lifo();

  /// Executes events until the job queue is empty and no pending timeouts are
  /// left. Returns the number of processed events.
  size_t run(size_t max_count = std::numeric_limits<size_t>::max());

  /// Tries to dispatch a single delayed message.
  bool dispatch_once();

  /// Dispatches all pending delayed messages. Returns the number of dispatched
  /// messages.
  size_t dispatch();

  /// Loops until no job or delayed message remains. Returns the total number of
  /// events (first) and dispatched delayed messages (second).
  std::pair<size_t, size_t> run_dispatch_loop();

  template <class F>
  void after_next_enqueue(F f) {
    after_next_enqueue_ = f;
  }

  /// Executes the next enqueued job immediately by using the
  /// `after_next_enqueue` hook.
  void inline_next_enqueue();

  /// Executes all enqueued jobs immediately by using the `after_next_enqueue`
  /// hook.
  void inline_all_enqueues();

  bool detaches_utility_actors() const override;

  detail::test_actor_clock& clock() noexcept override;

protected:
  void start() override;

  void stop() override;

  void enqueue(resumable* ptr) override;

private:
  void inline_all_enqueues_helper();

  /// Allows users to fake time at will.
  detail::test_actor_clock clock_;

  /// User-provided callback for triggering custom code in `enqueue`.
  std::function<void()> after_next_enqueue_;
};

} // namespace scheduler
} // namespace caf

#endif // CAF_TEST_COORDINATOR_HPP

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_SCHEDULER_WORKER_HPP
#define CAF_SCHEDULER_WORKER_HPP

#include <cstddef>

#include "caf/logger.hpp"
#include "caf/resumable.hpp"
#include "caf/execution_unit.hpp"

#include "caf/detail/double_ended_queue.hpp"

namespace caf {
namespace scheduler {

template <class Policy>
class coordinator;

/// Policy-based implementation of the abstract worker base class.
template <class Policy>
class worker : public execution_unit {
public:
  using job_ptr = resumable*;
  using coordinator_ptr = coordinator<Policy>*;
  using policy_data = typename Policy::worker_data;

  worker(size_t worker_id, coordinator_ptr worker_parent, size_t throughput)
      : execution_unit(&worker_parent->system()),
        max_throughput_(throughput),
        id_(worker_id),
        parent_(worker_parent),
        data_(worker_parent) {
    // nop
  }

  void start() {
    CAF_ASSERT(this_thread_.get_id() == std::thread::id{});
    auto this_worker = this;
    this_thread_ = std::thread{[this_worker] {
      this_worker->system().thread_started();
      this_worker->run();
      this_worker->system().thread_terminates();
    }};
  }

  worker(const worker&) = delete;
  worker& operator=(const worker&) = delete;

  /// Enqueues a new job to the worker's queue from an external
  /// source, i.e., from any other thread.
  void external_enqueue(job_ptr job) {
    CAF_ASSERT(job != nullptr);
    policy_.external_enqueue(this, job);
  }

  /// Enqueues a new job to the worker's queue from an internal
  /// source, i.e., a job that is currently executed by this worker.
  /// @warning Must not be called from other threads.
  void exec_later(job_ptr job) override {
    CAF_ASSERT(job != nullptr);
    policy_.internal_enqueue(this, job);
  }

  coordinator_ptr parent() {
    return parent_;
  }

  size_t id() const {
    return id_;
  }

  std::thread& get_thread() {
    return this_thread_;
  }

  actor_id id_of(resumable* ptr) {
    abstract_actor* dptr = ptr != nullptr ? dynamic_cast<abstract_actor*>(ptr)
                               : nullptr;
    return dptr != nullptr ? dptr->id() : 0;
  }

  policy_data& data() {
    return data_;
  }

  size_t max_throughput() {
    return max_throughput_;
  }

private:
  void run() {
    CAF_SET_LOGGER_SYS(&system());
    // scheduling loop
    for (;;) {
      auto job = policy_.dequeue(this);
      CAF_ASSERT(job != nullptr);
      CAF_ASSERT(job->subtype() != resumable::io_actor);
      CAF_PUSH_AID_FROM_PTR(dynamic_cast<abstract_actor*>(job));
      policy_.before_resume(this, job);
      auto res = job->resume(this, max_throughput_);
      policy_.after_resume(this, job);
      switch (res) {
        case resumable::resume_later: {
          // keep reference to this actor, as it remains in the "loop"
          policy_.resume_job_later(this, job);
          break;
        }
        case resumable::done: {
          policy_.after_completion(this, job);
          intrusive_ptr_release(job);
          break;
        }
        case resumable::awaiting_message: {
          // resumable will maybe be enqueued again later, deref it for now
          intrusive_ptr_release(job);
          break;
        }
        case resumable::shutdown_execution_unit: {
          policy_.after_completion(this, job);
          policy_.before_shutdown(this);
          return;
        }
      }
    }
  }
  // number of messages each actor is allowed to consume per resume
  size_t max_throughput_;
  // the worker's thread
  std::thread this_thread_;
  // the worker's ID received from scheduler
  size_t id_;
  // pointer to central coordinator
  coordinator_ptr parent_;
  // policy-specific data
  policy_data data_;
  // instance of our policy object
  Policy policy_;
};

} // namespace scheduler
} // namespace caf

#endif // CAF_SCHEDULER_WORKER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_SCHEDULER_COORDINATOR_HPP
#define CAF_SCHEDULER_COORDINATOR_HPP

#include "caf/config.hpp"

#include <thread>
#include <limits>
#include <memory>
#include <condition_variable>

#include "caf/scheduler/worker.hpp"
#include "caf/scheduler/abstract_coordinator.hpp"

#include "caf/detail/thread_safe_actor_clock.hpp"

namespace caf {
namespace scheduler {

/// Policy-based implementation of the abstract coordinator base class.
template <class Policy>
class coordinator : public abstract_coordinator {
public:
  using super = abstract_coordinator;

  using policy_data = typename Policy::coordinator_data;

  coordinator(actor_system& sys) : super(sys), data_(this) {
    // nop
  }

  using worker_type = worker<Policy>;

  worker_type* worker_by_id(size_t x) {
    return workers_[x].get();
  }

  policy_data& data() {
    return data_;
  }

  static actor_system::module* make(actor_system& sys, detail::type_list<>) {
    return new coordinator(sys);
  }

protected:
  void start() override {
    // initialize workers vector
    auto num = num_workers();
    workers_.reserve(num);
    for (size_t i = 0; i < num; ++i)
      workers_.emplace_back(new worker_type(i, this, max_throughput_));
    // start all workers now that all workers have been initialized
    for (auto& w : workers_)
      w->start();
    // launch thread for dispatching timeouts and delayed messages
    timer_ = std::thread{[&] {
      clock_.run_dispatch_loop();
    }};
    // run remaining startup code
    super::start();
  }

  void stop() override {
    // shutdown workers
    class shutdown_helper : public resumable, public ref_counted {
    public:
      resumable::resume_result resume(execution_unit* ptr, size_t) override {
        CAF_ASSERT(ptr != nullptr);
        std::unique_lock<std::mutex> guard(mtx);
        last_worker = ptr;
        cv.notify_all();
        return resumable::shutdown_execution_unit;
      }
      void intrusive_ptr_add_ref_impl() override {
        intrusive_ptr_add_ref(this);
      }

      void intrusive_ptr_release_impl() override {
        intrusive_ptr_release(this);
      }
      shutdown_helper() : last_worker(nullptr) {
        // nop
      }
      std::mutex mtx;
      std::condition_variable cv;
      execution_unit* last_worker;
    };
    // use a set to keep track of remaining workers
    shutdown_helper sh;
    std::set<worker_type*> alive_workers;
    auto num = num_workers();
    for (size_t i = 0; i < num; ++i) {
      alive_workers.insert(worker_by_id(i));
      sh.ref(); // make sure reference count is high enough
    }
    while (!alive_workers.empty()) {
      (*alive_workers.begin())->external_enqueue(&sh);
      // since jobs can be stolen, we cannot assume that we have
      // actually shut down the worker we've enqueued sh to
      { // lifetime scope of guard
        std::unique_lock<std::mutex> guard(sh.mtx);
        sh.cv.wait(guard, [&] { return sh.last_worker != nullptr; });
      }
      alive_workers.erase(static_cast<worker_type*>(sh.last_worker));
      sh.last_worker = nullptr;
    }
    // shutdown utility actors
    stop_actors();
    // wait until all workers are done
    for (auto& w : workers_) {
      w->get_thread().join();
    }
    // run cleanup code for each resumable
    auto f = &abstract_coordinator::cleanup_and_release;
    for (auto& w : workers_)
      policy_.foreach_resumable(w.get(), f);
    policy_.foreach_central_resumable(this, f);
    // stop timer thread
    clock_.cancel_dispatch_loop();
    timer_.join();
  }

  void enqueue(resumable* ptr) override {
    policy_.central_enqueue(this, ptr);
  }

  detail::thread_safe_actor_clock& clock() noexcept override {
    return clock_;
  }

private:
  /// System-wide clock.
  detail::thread_safe_actor_clock clock_;

  /// Set of workers.
  std::vector<std::unique_ptr<worker_type>> workers_;

  /// Policy-specific data.
  policy_data data_;

  /// The policy object.
  Policy policy_;

  /// Thread for managing timeouts and delayed messages.
  std::thread timer_;
};

} // namespace scheduler
} // namespace caf

#endif // CAF_SCHEDULER_COORDINATOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_SCHEDULER_PROFILED_COORDINATOR_HPP
#define CAF_SCHEDULER_PROFILED_COORDINATOR_HPP

#include "caf/config.hpp"

#if defined(CAF_MACOS) || defined(CAF_IOS)
#include <mach/mach.h>
#elif defined(CAF_WINDOWS)
#include <windows.h>
#include <psapi.h>
#else
#include <sys/resource.h>
#endif

#include <cmath>
#include <mutex>
#include <chrono>
#include <vector>
#include <fstream>
#include <iomanip>
#include <unordered_map>

#include "caf/actor_system_config.hpp"

#include "caf/scheduler/coordinator.hpp"

#include "caf/policy/profiled.hpp"
#include "caf/policy/work_stealing.hpp"

#include "caf/logger.hpp"

namespace caf {
namespace scheduler {

/// A coordinator which keeps fine-grained profiling state about its workers
/// and their jobs.
template <class Policy = policy::profiled<policy::work_stealing>>
class profiled_coordinator : public coordinator<Policy> {
public:
  using super = coordinator<Policy>;
  using clock_type = std::chrono::high_resolution_clock;

  using usec = std::chrono::microseconds;
  using msec = std::chrono::milliseconds;

  class measurement {
  public:
#   if defined(CAF_MACOS) || defined(CAF_IOS)
    static usec to_usec(const ::time_value_t& tv) {
      return std::chrono::seconds(tv.seconds) + usec(tv.microseconds);
    }
#   elif defined(CAF_WINDOWS)
    static usec to_usec(FILETIME const& ft) {
      ULARGE_INTEGER time;
      time.LowPart = ft.dwLowDateTime;
      time.HighPart = ft.dwHighDateTime;

      return std::chrono::seconds(time.QuadPart / 10000000) + usec((time.QuadPart % 10000000) / 10);
    }
#   else
    static usec to_usec(const ::timeval& tv) {
      return std::chrono::seconds(tv.tv_sec) + usec(tv.tv_usec);
    }
#   endif

    static measurement take() {
      auto now = clock_type::now().time_since_epoch();
      measurement m;
      m.runtime = std::chrono::duration_cast<usec>(now);
#     if defined(CAF_MACOS) || defined(CAF_IOS)
      auto tself = ::mach_thread_self();
      ::thread_basic_info info;
      auto count = THREAD_BASIC_INFO_COUNT;
      auto result = ::thread_info(tself, THREAD_BASIC_INFO,
                                  reinterpret_cast<thread_info_t>(&info),
                                  &count);
      if (result == KERN_SUCCESS && (info.flags & TH_FLAGS_IDLE) == 0) {
        m.usr = to_usec(info.user_time);
        m.sys = to_usec(info.system_time);
      }
      ::mach_port_deallocate(mach_task_self(), tself);
#     elif defined(CAF_WINDOWS)
      FILETIME creation_time, exit_time, kernel_time, user_time;
      PROCESS_MEMORY_COUNTERS pmc;

      GetProcessTimes(GetCurrentProcess(), &creation_time, &exit_time,
        &kernel_time, &user_time);

      GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc));

      m.mem = pmc.PeakWorkingSetSize / 1024;
      m.usr = to_usec(user_time);
      m.sys = to_usec(kernel_time);
#     elif defined(CAF_CYGWIN)
      // TODO - decide what to do here instead of zeros
      m.usr = usec::zero();
      m.sys = usec::zero();
      m.mem = 0;
#     else
      ::rusage ru;
      ::getrusage(RUSAGE_THREAD, &ru);
      m.usr = to_usec(ru.ru_utime);
      m.sys = to_usec(ru.ru_stime);
      m.mem = ru.ru_maxrss;
#     endif
      return m;
    }

    measurement& operator+=(const measurement& other) {
      runtime += other.runtime;
      usr += other.usr;
      sys += other.sys;
      mem += other.mem;
      return *this;
    }

    measurement& operator-=(const measurement& other) {
      runtime -= other.runtime;
      usr -= other.usr;
      sys -= other.sys;
      mem -= other.mem;
      return *this;
    }

    friend measurement operator+(const measurement& x, const measurement& y) {
      measurement tmp(x);
      tmp += y;
      return tmp;
    }

    friend measurement operator-(const measurement& x, const measurement& y) {
      measurement tmp(x);
      tmp -= y;
      return tmp;
    }

    friend std::ostream& operator<<(std::ostream& out, const measurement& m) {
      using std::setw;
      out << setw(15) << m.runtime.count()
          << setw(15) << m.usr.count()
          << setw(15) << m.sys.count()
          << m.mem;
      return out;
    }

    usec runtime = usec::zero();
    usec usr = usec::zero();
    usec sys = usec::zero();
    long mem = 0;
  };

  struct worker_state {
    actor_id current;
    measurement job;
    measurement worker;
    clock_type::duration last_flush = clock_type::duration::zero();
  };

  profiled_coordinator(actor_system& sys) : super{sys} {
    // nop
  }

  void init(actor_system_config& cfg) override {
    super::init(cfg);
    file_.open(cfg.scheduler_profiling_output_file);
    if (!file_)
      std::cerr << R"([WARNING] could not open file ")"
                << cfg.scheduler_profiling_output_file
                << R"(" (no profiler output will be generated))"
                << std::endl;
    resolution_ = msec{cfg.scheduler_profiling_ms_resolution};
  }

  void start() override {
    clock_start_ = clock_type::now().time_since_epoch();
    super::start();
    worker_states_.resize(this->num_workers());
    using std::setw;
    file_.flags(std::ios::left);
    file_ << setw(21) << "clock"     // UNIX timestamp in microseconds
          << setw(10) << "type"      // "actor" or "worker"
          << setw(10) << "id"        // ID of the above
          << setw(15) << "time"      // duration of this sample (cumulative)
          << setw(15) << "usr"       // time spent in user mode (cumulative)
          << setw(15) << "sys"       // time spent in kernel model (cumulative)
          << "mem"                   // used memory (cumulative)
          << '\n';
  }

  void stop() override {
    CAF_LOG_TRACE("");
    super::stop();
    auto now = clock_type::now().time_since_epoch();
    auto wallclock = system_start_ + (now - clock_start_);
    for (size_t i = 0; i < worker_states_.size(); ++i) {
      record(wallclock, "worker", i, worker_states_[i].worker);
    }
  }

  void start_measuring(size_t worker, actor_id job) {
    auto& w = worker_states_[worker];
    w.current = job;
    w.job = measurement::take();
  }

  void stop_measuring(size_t worker, actor_id job) {
    auto m = measurement::take();
    auto& w = worker_states_[worker];
    CAF_ASSERT(job == w.current);
    auto delta = m - w.job;
    // It's not possible that the wallclock timer is less than actual CPU time
    // spent. Due to resolution mismatches of the C++ high-resolution clock and
    // the system timers, this may appear to be the case sometimes. We "fix"
    // this by adjusting the wallclock to the sum of user and system time, so
    // that utilization never exceeds 100%.
    if (delta.runtime < delta.usr + delta.sys) {
      delta.runtime = delta.usr + delta.sys;
    }
    w.worker += delta;
    report(job, delta);
    if (m.runtime - w.last_flush >= resolution_) {
      w.last_flush = m.runtime;
      auto wallclock = system_start_ + (m.runtime - clock_start_);
      std::lock_guard<std::mutex> file_guard{file_mtx_};
      record(wallclock, "worker", worker, w.worker);
      w.worker = {};
    }
  }

  void remove_job(actor_id job) {
    std::lock_guard<std::mutex> job_guard{job_mtx_};
    auto j = jobs_.find(job);
    if (j != jobs_.end()) {
      if (job != 0) {
        auto now = clock_type::now().time_since_epoch();
        auto wallclock = system_start_ + (now - clock_start_);
        std::lock_guard<std::mutex> file_guard{file_mtx_};
        record(wallclock, "actor", job, j->second);
      }
      jobs_.erase(j);
    }
  }

  template <class Time, class Label>
  void record(Time t, Label label, size_t rec_id, const measurement& m) {
    using std::setw;
    file_ << setw(21) << t.time_since_epoch().count()
           << setw(10) << label
           << setw(10) << rec_id
           << m
           << '\n';
  }

  void report(const actor_id& job, const measurement& m) {
    std::lock_guard<std::mutex> job_guard{job_mtx_};
    jobs_[job] += m;
    if (m.runtime - last_flush_ >= resolution_) {
      last_flush_ = m.runtime;
      auto now = clock_type::now().time_since_epoch();
      auto wallclock = system_start_ + (now - clock_start_);
      std::lock_guard<std::mutex> file_guard{file_mtx_};
      for (auto& j : jobs_) {
        record(wallclock, "actor", j.first, j.second);
        j.second = {};
      }
    }
  }

  std::mutex job_mtx_;
  std::mutex file_mtx_;
  std::ofstream file_;
  msec resolution_;
  std::chrono::system_clock::time_point system_start_;
  clock_type::duration clock_start_;
  std::vector<worker_state> worker_states_;
  std::unordered_map<actor_id, measurement> jobs_;
  clock_type::duration last_flush_ = clock_type::duration::zero();
};

} // namespace scheduler
} // namespace caf

#endif // CAF_SCHEDULER_PROFILED_COORDINATOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_SCHEDULER_ABSTRACT_COORDINATOR_HPP
#define CAF_SCHEDULER_ABSTRACT_COORDINATOR_HPP

#include <chrono>
#include <atomic>
#include <cstddef>

#include "caf/fwd.hpp"
#include "caf/atom.hpp"
#include "caf/actor.hpp"
#include "caf/message.hpp"
#include "caf/duration.hpp"
#include "caf/actor_addr.hpp"
#include "caf/actor_cast.hpp"
#include "caf/actor_clock.hpp"
#include "caf/actor_system.hpp"

namespace caf {
namespace scheduler {

/// A coordinator creates the workers, manages delayed sends and
/// the central printer instance for {@link aout}. It also forwards
/// sends from detached workers or non-actor threads to randomly
/// chosen workers.
class abstract_coordinator : public actor_system::module {
public:
  enum utility_actor_id : size_t {
    printer_id,
    max_id
  };

  explicit abstract_coordinator(actor_system& sys);

  /// Returns a handle to the central printing actor.
  inline actor printer() const {
    return actor_cast<actor>(utility_actors_[printer_id]);
  }

  /// Returns the number of utility actors.
  inline size_t num_utility_actors() const {
    return utility_actors_.size();
  }

  /// Puts `what` into the queue of a randomly chosen worker.
  virtual void enqueue(resumable* what) = 0;

  inline actor_system& system() {
    return system_;
  }

  inline size_t max_throughput() const {
    return max_throughput_;
  }

  inline size_t num_workers() const {
    return num_workers_;
  }

  /// Returns `true` if this scheduler detaches its utility actors.
  virtual bool detaches_utility_actors() const;

  void start() override;

  void init(actor_system_config& cfg) override;

  id_t id() const override;

  void* subtype_ptr() override;

  static void cleanup_and_release(resumable*);

  virtual actor_clock& clock() noexcept = 0;

protected:
  void stop_actors();

  /// ID of the worker receiving the next enqueue (round-robin dispatch).
  std::atomic<size_t> next_worker_;

  /// Number of messages each actor is allowed to consume per resume.
  size_t max_throughput_;

  /// Configured number of workers.
  size_t num_workers_;

  /// Background workers, e.g., printer.
  std::array<actor, max_id> utility_actors_;

  /// Reference to the host system.
  actor_system& system_;

};

} // namespace scheduler
} // namespace caf

#endif // CAF_SCHEDULER_ABSTRACT_COORDINATOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TYPE_NR_HPP
#define CAF_TYPE_NR_HPP

#include <map>
#include <set>
#include <string>
#include <vector>
#include <cstdint>

#include "caf/fwd.hpp"
#include "caf/atom.hpp"
#include "caf/timestamp.hpp"

#include "caf/detail/type_list.hpp"
#include "caf/detail/squashed_int.hpp"

namespace caf {

/// Compile-time list of all built-in types.
/// @warning Types are sorted by uniform name.
using sorted_builtin_types =
  detail::type_list<
    actor,                              // @actor
    std::vector<actor>,                 // @actorvec
    actor_addr,                         // @addr
    std::vector<actor_addr>,            // @addrvec
    atom_value,                         // @atom
    std::vector<char>,                  // @charbuf
    down_msg,                           // @down
    duration,                           // @duration
    timestamp,                          // @timestamp
    error,                              // @error
    exit_msg,                           // @exit
    group,                              // @group
    group_down_msg,                     // @group_down
    int16_t,                            // @i16
    int32_t,                            // @i32
    int64_t,                            // @i64
    int8_t,                             // @i8
    long double,                        // @ldouble
    message,                            // @message
    message_id,                         // @message_id
    node_id,                            // @node
    std::string,                        // @str
    stream_msg,                         // @stream_msg
    std::map<std::string, std::string>, // @strmap
    strong_actor_ptr,                   // @strong_actor_ptr
    std::set<std::string>,              // @strset
    std::vector<std::string>,           // @strvec
    timeout_msg,                        // @timeout
    uint16_t,                           // @u16
    std::u16string,                     // @u16_str
    uint32_t,                           // @u32
    std::u32string,                     // @u32_str
    uint64_t,                           // @u64
    uint8_t,                            // @u8
    unit_t,                             // @unit
    weak_actor_ptr,                     // @weak_actor_ptr
    bool,                               // bool
    double,                             // double
    float                               // float
  >;

/// Computes the type number for `T`.
template <class T, bool IsIntegral = std::is_integral<T>::value>
struct type_nr {
  static constexpr uint16_t value = static_cast<uint16_t>(
    detail::tl_index_of<sorted_builtin_types, T>::value + 1);
};

template <class T>
struct type_nr<T, true> {
  using type = detail::squashed_int_t<T>;
  static constexpr uint16_t value = static_cast<uint16_t>(
    detail::tl_index_of<sorted_builtin_types, type>::value + 1);
};

template <>
struct type_nr<bool, true> {
  static constexpr uint16_t value = static_cast<uint16_t>(
    detail::tl_index_of<sorted_builtin_types, bool>::value + 1);
};

template <atom_value V>
struct type_nr<atom_constant<V>, false> {
  static constexpr uint16_t value = type_nr<atom_value>::value;
};

/// The number of built-in types.
static constexpr size_t type_nrs = detail::tl_size<sorted_builtin_types>::value
                                   + 1;

/// List of all type names, indexed via `type_nr`.
extern const char* numbered_type_names[];

template <uint32_t R, uint16_t... Is>
struct type_token_helper;

template <uint32_t R>
struct type_token_helper<R> : std::integral_constant<uint32_t, R> {
  // nop
};

template <uint32_t R, uint16_t I, uint16_t... Is>
struct type_token_helper<R, I, Is...> : type_token_helper<(R << 6) | I, Is...> {
  // nop
};

template <class... Ts>
constexpr uint32_t make_type_token() {
  return type_token_helper<0xFFFFFFFF, type_nr<Ts>::value...>::value;
}

constexpr uint32_t add_to_type_token(uint32_t token, uint16_t tnr) {
  return (token << 6) | tnr;
}

template <class T>
struct make_type_token_from_list_helper;

template <class... Ts>
struct make_type_token_from_list_helper<detail::type_list<Ts...>>
    : type_token_helper<0xFFFFFFFF, type_nr<Ts>::value...> {
  // nop
};

template <class T>
constexpr uint32_t make_type_token_from_list() {
  return make_type_token_from_list_helper<T>::value;
}

} // namespace caf

#endif // CAF_TYPE_NR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ACTOR_HPP
#define CAF_ACTOR_HPP

#include <string>
#include <cstddef>
#include <cstdint>
#include <utility>
#include <type_traits>

#include "caf/config.hpp"

#include "caf/fwd.hpp"
#include "caf/message.hpp"
#include "caf/actor_marker.hpp"
#include "caf/abstract_actor.hpp"
#include "caf/actor_control_block.hpp"
#include "caf/unsafe_actor_handle_init.hpp"

#include "caf/detail/comparable.hpp"
#include "caf/detail/type_traits.hpp"

namespace caf {

template <class T>
struct is_convertible_to_actor {
  static constexpr bool value =
      !std::is_base_of<statically_typed_actor_base, T>::value
      && (std::is_base_of<actor_proxy, T>::value
          || std::is_base_of<local_actor, T>::value);
};

template <>
struct is_convertible_to_actor<scoped_actor> : std::true_type {
  // nop
};

template <class T>
struct is_convertible_to_actor<T*> : is_convertible_to_actor<T> {};

/// Identifies an untyped actor. Can be used with derived types
/// of `event_based_actor`, `blocking_actor`, and `actor_proxy`.
class actor : detail::comparable<actor>,
              detail::comparable<actor, actor_addr>,
              detail::comparable<actor, strong_actor_ptr> {
public:
  // -- friend types that need access to private ctors
  friend class local_actor;

  using signatures = none_t;

  // allow conversion via actor_cast
  template <class, class, int>
  friend class actor_cast_access;

  // tell actor_cast which semantic this type uses
  static constexpr bool has_weak_ptr_semantics = false;

  actor() = default;
  actor(actor&&) = default;
  actor(const actor&) = default;
  actor& operator=(actor&&) = default;
  actor& operator=(const actor&) = default;

  actor(std::nullptr_t);

  actor(const scoped_actor&);

  explicit actor(const unsafe_actor_handle_init_t&) CAF_DEPRECATED;

  template <class T,
            class = typename std::enable_if<
                      std::is_base_of<dynamically_typed_actor_base, T>::value
                    >::type>
  actor(T* ptr) : ptr_(ptr->ctrl()) {
    CAF_ASSERT(ptr != nullptr);
  }

  template <class T>
  typename std::enable_if<is_convertible_to_actor<T>::value, actor&>::type
  operator=(intrusive_ptr<T> ptr) {
    actor tmp{std::move(ptr)};
    swap(tmp);
    return *this;
  }

  template <class T>
  typename std::enable_if<is_convertible_to_actor<T>::value, actor&>::type
  operator=(T* ptr) {
    actor tmp{ptr};
    swap(tmp);
    return *this;
  }

  actor& operator=(std::nullptr_t);

  actor& operator=(const scoped_actor& x);

  /// Queries whether this actor handle is valid.
  inline explicit operator bool() const {
    return static_cast<bool>(ptr_);
  }

  /// Queries whether this actor handle is invalid.
  inline bool operator!() const {
    return !ptr_;
  }

  /// Returns the address of the stored actor.
  actor_addr address() const noexcept;

  /// Returns the ID of this actor.
  inline actor_id id() const noexcept {
    return ptr_->id();
  }

  /// Returns the origin node of this actor.
  inline node_id node() const noexcept {
    return ptr_->node();
  }

  /// Returns the hosting actor system.
  inline actor_system& home_system() const noexcept {
    return *ptr_->home_system;
  }

  /// Exchange content of `*this` and `other`.
  void swap(actor& other) noexcept;

  /// Queries whether this object was constructed using
  /// `unsafe_actor_handle_init` or is in moved-from state.
  bool unsafe() const CAF_DEPRECATED {
    return !ptr_;
  }

  /// @cond PRIVATE

  inline abstract_actor* operator->() const noexcept {
    CAF_ASSERT(ptr_);
    return ptr_->get();
  }

  intptr_t compare(const actor&) const noexcept;

  intptr_t compare(const actor_addr&) const noexcept;

  intptr_t compare(const strong_actor_ptr&) const noexcept;

  static actor splice_impl(std::initializer_list<actor> xs);

  actor(actor_control_block*, bool);

  /// @endcond

  friend inline std::string to_string(const actor& x) {
    return to_string(x.ptr_);
  }

  friend inline void append_to_string(std::string& x, const actor& y) {
    return append_to_string(x, y.ptr_);
  }

  template <class Inspector>
  friend typename Inspector::result_type inspect(Inspector& f, actor& x) {
    return inspect(f, x.ptr_);
  }

  /// Releases the reference held by handle `x`. Using the
  /// handle after invalidating it is undefined behavior.
  friend void destroy(actor& x) {
    x.ptr_.reset();
  }

private:
  inline actor_control_block* get() const noexcept {
    return ptr_.get();
  }

  inline actor_control_block* release() noexcept {
    return ptr_.release();
  }

  actor(actor_control_block*);

  strong_actor_ptr ptr_;
};

/// Combine `f` and `g` so that `(f*g)(x) = f(g(x))`.
actor operator*(actor f, actor g);

/// @relates actor
template <class... Ts>
actor splice(const actor& x, const actor& y, const Ts&... zs) {
  return actor::splice_impl({x, y, zs...});
}

/// @relates actor
bool operator==(const actor& lhs, abstract_actor* rhs);

/// @relates actor
bool operator==(abstract_actor* lhs, const actor& rhs);

/// @relates actor
bool operator!=(const actor& lhs, abstract_actor* rhs);

/// @relates actor
bool operator!=(abstract_actor* lhs, const actor& rhs);

} // namespace caf

// allow actor to be used in hash maps
namespace std {
template <>
struct hash<caf::actor> {
  inline size_t operator()(const caf::actor& ref) const {
    return static_cast<size_t>(ref ? ref->id() : 0);
  }
};
} // namespace std

#endif // CAF_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_ID_HPP
#define CAF_STREAM_ID_HPP

#include <cstdint>

#include "caf/actor_addr.hpp"

#include "caf/meta/type_name.hpp"

#include "caf/detail/comparable.hpp"

namespace caf {

class stream_id : detail::comparable<stream_id> {
public:
  stream_id(stream_id&&) = default;
  stream_id(const stream_id&) = default;
  stream_id& operator=(stream_id&&) = default;
  stream_id& operator=(const stream_id&) = default;

  stream_id();

  stream_id(none_t);

  stream_id(actor_addr origin_actor, uint64_t origin_nr);

  stream_id(actor_control_block* origin_actor, uint64_t origin_nr);

  stream_id(const strong_actor_ptr& origin_actor, uint64_t origin_nr);

  int64_t compare(const stream_id& other) const;

  actor_addr origin;
  uint64_t nr;

  inline bool valid() const {
    return origin != nullptr;
  }
};

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, stream_id& x) {
  return f(meta::type_name("stream_id"), x.origin, x.nr);
}

} // namespace caf

namespace std {
template <>
struct hash<caf::stream_id> {
  size_t operator()(const caf::stream_id& x) const {
    auto tmp = reinterpret_cast<ptrdiff_t>(x.origin.get())
               ^ static_cast<ptrdiff_t>(x.nr);
    return static_cast<size_t>(tmp);
  }
};
} // namespace std


#endif // CAF_STREAM_ID_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ABSTRACT_EVENT_BASED_ACTOR_HPP
#define CAF_ABSTRACT_EVENT_BASED_ACTOR_HPP

#include "caf/config.hpp"

#ifndef CAF_NO_EXCEPTIONS
#include <exception>
#endif // CAF_NO_EXCEPTIONS

#include <type_traits>

#include "caf/fwd.hpp"
#include "caf/sec.hpp"
#include "caf/error.hpp"
#include "caf/extend.hpp"
#include "caf/no_stages.hpp"
#include "caf/local_actor.hpp"
#include "caf/actor_marker.hpp"
#include "caf/stream_result.hpp"
#include "caf/response_handle.hpp"
#include "caf/scheduled_actor.hpp"
#include "caf/random_gatherer.hpp"
#include "caf/stream_sink_impl.hpp"
#include "caf/stream_stage_impl.hpp"
#include "caf/stream_source_impl.hpp"
#include "caf/stream_result_trait.hpp"
#include "caf/broadcast_scatterer.hpp"
#include "caf/terminal_stream_scatterer.hpp"

#include "caf/to_string.hpp"

#include "caf/policy/arg.hpp"

#include "caf/mixin/sender.hpp"
#include "caf/mixin/requester.hpp"
#include "caf/mixin/behavior_changer.hpp"

#include "caf/logger.hpp"

namespace caf {

// -- related free functions ---------------------------------------------------

/// @relates scheduled_actor
/// Default handler function that sends the message back to the sender.
result<message> reflect(scheduled_actor*, message_view&);

/// @relates scheduled_actor
/// Default handler function that sends
/// the message back to the sender and then quits.
result<message> reflect_and_quit(scheduled_actor*, message_view&);

/// @relates scheduled_actor
/// Default handler function that prints messages
/// message via `aout` and drops them afterwards.
result<message> print_and_drop(scheduled_actor*, message_view&);

/// @relates scheduled_actor
/// Default handler function that simply drops messages.
result<message> drop(scheduled_actor*, message_view&);

/// A cooperatively scheduled, event-based actor implementation. This is the
/// recommended base class for user-defined actors.
/// @extends local_actor
class scheduled_actor : public local_actor, public resumable {
public:
  // -- member types -----------------------------------------------------------

  /// A reference-counting pointer to a `stream_manager`.
  using stream_manager_ptr = intrusive_ptr<stream_manager>;

  /// A container for associating stream IDs to handlers.
  using streams_map = std::unordered_map<stream_id, stream_manager_ptr>;

  /// The message ID of an outstanding response with its callback.
  using pending_response = std::pair<const message_id, behavior>;

  /// A pointer to a scheduled actor.
  using pointer = scheduled_actor*;

  /// Function object for handling unmatched messages.
  using default_handler =
    std::function<result<message>(pointer, message_view&)>;

  /// Function object for handling error messages.
  using error_handler = std::function<void (pointer, error&)>;

  /// Function object for handling down messages.
  using down_handler = std::function<void (pointer, down_msg&)>;

  /// Function object for handling exit messages.
  using exit_handler = std::function<void (pointer, exit_msg&)>;

# ifndef CAF_NO_EXCEPTIONS
  /// Function object for handling exit messages.
  using exception_handler = std::function<error (pointer, std::exception_ptr&)>;
# endif // CAF_NO_EXCEPTIONS

  // -- nested enums -----------------------------------------------------------

  /// @cond PRIVATE

  /// Categorizes incoming messages.
  enum class message_category {
    /// Denotes an expired and thus obsolete timeout.
    expired_timeout,
    /// Triggers the currently active timeout.
    timeout,
    /// Triggers the current behavior.
    ordinary,
    /// Triggers handlers for system messages such as `exit_msg` or `down_msg`.
    internal
  };

  /// Result of one-shot activations.
  enum class activation_result {
    /// Actor is still alive and handled the activation message.
    success,
    /// Actor handled the activation message and terminated.
    terminated,
    /// Actor skipped the activation message.
    skipped,
    /// Actor dropped the activation message.
    dropped
  };

  /// @endcond

  // -- static helper functions ------------------------------------------------

  static void default_error_handler(pointer ptr, error& x);

  static void default_down_handler(pointer ptr, down_msg& x);

  static void default_exit_handler(pointer ptr, exit_msg& x);

# ifndef CAF_NO_EXCEPTIONS
  static error default_exception_handler(pointer ptr, std::exception_ptr& x);
# endif // CAF_NO_EXCEPTIONS

  // -- constructors and destructors -------------------------------------------

  explicit scheduled_actor(actor_config& cfg);

  ~scheduled_actor() override;

  // -- overridden functions of abstract_actor ---------------------------------

  using abstract_actor::enqueue;

  void enqueue(mailbox_element_ptr ptr, execution_unit* eu) override;

  // -- overridden functions of local_actor ------------------------------------

  const char* name() const override;

  void launch(execution_unit* eu, bool lazy, bool hide) override;

  bool cleanup(error&& fail_state, execution_unit* host) override;

  // -- overridden functions of resumable --------------------------------------

  subtype_t subtype() const override;

  void intrusive_ptr_add_ref_impl() override;

  void intrusive_ptr_release_impl() override;

  resume_result resume(execution_unit*, size_t) override;

  // -- scheduler callbacks ----------------------------------------------------

  /// Returns a factory for proxies created
  /// and managed by this actor or `nullptr`.
  virtual proxy_registry* proxy_registry_ptr();

  // -- state modifiers --------------------------------------------------------

  /// Finishes execution of this actor after any currently running
  /// message handler is done.
  /// This member function clears the behavior stack of the running actor
  /// and invokes `on_exit()`. The actors does not finish execution
  /// if the implementation of `on_exit()` sets a new behavior.
  /// When setting a new behavior in `on_exit()`, one has to make sure
  /// to not produce an infinite recursion.
  ///
  /// If `on_exit()` did not set a new behavior, the actor sends an
  /// exit message to all of its linked actors, sets its state to exited
  /// and finishes execution.
  ///
  /// In case this actor uses the blocking API, this member function unwinds
  /// the stack by throwing an `actor_exited` exception.
  /// @warning This member function throws immediately in thread-based actors
  ///          that do not use the behavior stack, i.e., actors that use
  ///          blocking API calls such as {@link receive()}.
  void quit(error x = error{});

  // -- event handlers ---------------------------------------------------------

  /// Sets a custom handler for unexpected messages.
  inline void set_default_handler(default_handler fun) {
    if (fun)
      default_handler_ = std::move(fun);
    else
      default_handler_ = print_and_drop;
  }

  /// Sets a custom handler for unexpected messages.
  template <class F>
  typename std::enable_if<
    std::is_convertible<
      F,
      std::function<result<message> (type_erased_tuple&)>
    >::value
  >::type
  set_default_handler(F fun) {
    default_handler_ = [=](scheduled_actor*, const type_erased_tuple& xs) {
      return fun(xs);
    };
  }

  /// Sets a custom handler for error messages.
  inline void set_error_handler(error_handler fun) {
    if (fun)
      error_handler_ = std::move(fun);
    else
      error_handler_ = default_error_handler;
  }

  /// Sets a custom handler for error messages.
  template <class T>
  auto set_error_handler(T fun) -> decltype(fun(std::declval<error&>())) {
    set_error_handler([fun](scheduled_actor*, error& x) { fun(x); });
  }

  /// Sets a custom handler for down messages.
  inline void set_down_handler(down_handler fun) {
    if (fun)
      down_handler_ = std::move(fun);
    else
      down_handler_ = default_down_handler;
  }

  /// Sets a custom handler for down messages.
  template <class T>
  auto set_down_handler(T fun) -> decltype(fun(std::declval<down_msg&>())) {
    set_down_handler([fun](scheduled_actor*, down_msg& x) { fun(x); });
  }

  /// Sets a custom handler for error messages.
  inline void set_exit_handler(exit_handler fun) {
    if (fun)
      exit_handler_ = std::move(fun);
    else
      exit_handler_ = default_exit_handler;
  }

  /// Sets a custom handler for exit messages.
  template <class T>
  auto set_exit_handler(T fun) -> decltype(fun(std::declval<exit_msg&>())) {
    set_exit_handler([fun](scheduled_actor*, exit_msg& x) { fun(x); });
  }

# ifndef CAF_NO_EXCEPTIONS
  /// Sets a custom exception handler for this actor. If multiple handlers are
  /// defined, only the functor that was added *last* is being executed.
  inline void set_exception_handler(exception_handler fun) {
    if (fun)
      exception_handler_ = std::move(fun);
    else
      exception_handler_ = default_exception_handler;
  }

  /// Sets a custom exception handler for this actor. If multiple handlers are
  /// defined, only the functor that was added *last* is being executed.
  template <class F>
  typename std::enable_if<
    std::is_convertible<
      F,
      std::function<error (std::exception_ptr&)>
    >::value
  >::type
  set_exception_handler(F f) {
    set_exception_handler([f](scheduled_actor*, std::exception_ptr& x) {
      return f(x);
    });
  }
# endif // CAF_NO_EXCEPTIONS

  // -- stream management ------------------------------------------------------

  /// Returns a new stream ID.
  stream_id make_stream_id() {
    return {ctrl(), new_request_id(message_priority::normal).integer_value()};
  }

  /// Creates a new stream source and starts streaming to `dest`.
  /// @param dest Actor handle to the stream destination.
  /// @param xs User-defined handshake payload.
  /// @param init Function object for initializing the state of the source.
  /// @param getter Function object for generating messages for the stream.
  /// @param pred Predicate returning `true` when the stream is done.
  /// @param res_handler Function object for receiving the stream result.
  /// @param scatterer_type Configures the policy for downstream communication.
  /// @returns A stream object with a pointer to the generated `stream_manager`.
  template <class Handle, class... Ts, class Init, class Getter,
            class ClosedPredicate, class ResHandler,
            class Scatterer = broadcast_scatterer<
              typename stream_source_trait_t<Getter>::output>>
  annotated_stream<typename stream_source_trait_t<Getter>::output, Ts...>
  make_source(const Handle& dest, std::tuple<Ts...> xs, Init init,
              Getter getter, ClosedPredicate pred, ResHandler res_handler,
              policy::arg<Scatterer> scatterer_type = {}) {
    CAF_IGNORE_UNUSED(scatterer_type);
    using type = typename stream_source_trait_t<Getter>::output;
    using state_type = typename stream_source_trait_t<Getter>::state;
    static_assert(std::is_same<
                    void (state_type&),
                    typename detail::get_callable_trait<Init>::fun_sig
                  >::value,
                  "Expected signature `void (State&)` for init function");
    static_assert(std::is_same<
                    void (state_type&, downstream<type>&, size_t),
                    typename detail::get_callable_trait<Getter>::fun_sig
                  >::value,
                  "Expected signature `void (State&, downstream<T>&, size_t)` "
                  "for getter function");
    static_assert(std::is_same<
                    bool (const state_type&),
                    typename detail::get_callable_trait<
                      ClosedPredicate
                    >::fun_sig
                  >::value,
                  "Expected signature `bool (const State&)` for "
                  "closed_predicate function");
    if (!dest) {
      CAF_LOG_ERROR("cannot stream to an invalid actor handle");
      return none;
    }
    // generate new stream ID and manager
    auto sid = make_stream_id();
    using impl = stream_source_impl<Getter, ClosedPredicate, Scatterer>;
    auto ptr = make_counted<impl>(this, std::move(getter), std::move(pred));
    auto mid = new_request_id(message_priority::normal);
    if (!add_sink<type>(ptr, sid, ctrl(), actor_cast<strong_actor_ptr>(dest),
                        no_stages, mid, stream_priority::normal, std::move(xs)))
      return none;
    init(ptr->state());
    this->add_multiplexed_response_handler(
      mid.response_id(),
      stream_result_trait_t<ResHandler>::make_result_handler(res_handler));
    streams_.emplace(sid, ptr);
    return {std::move(sid), std::move(ptr)};
  }

  /// Creates a new stream source and starts streaming to `dest`.
  /// @param dest Actor handle to the stream destination.
  /// @param init Function object for initializing the state of the source.
  /// @param getter Function object for generating messages for the stream.
  /// @param pred Predicate returning `true` when the stream is done.
  /// @param res_handler Function object for receiving the stream result.
  /// @param scatterer_type Configures the policy for downstream communication.
  /// @returns A stream object with a pointer to the generated `stream_manager`.
  template <class Handle, class Init, class Getter, class ClosedPredicate,
            class ResHandler,
            class Scatterer = broadcast_scatterer<
              typename stream_source_trait_t<Getter>::output>>
  stream<typename stream_source_trait_t<Getter>::output>
  make_source(const Handle& dest, Init init, Getter getter,
              ClosedPredicate pred, ResHandler res_handler,
              policy::arg<Scatterer> scatterer_type = {}) {
    return make_source(dest, std::make_tuple(), std::move(init),
                       std::move(getter), std::move(pred),
                       std::move(res_handler), scatterer_type);
  }

  /// Creates a new stream source.
  /// @param xs User-defined handshake payload.
  /// @param init Function object for initializing the state of the source.
  /// @param getter Function object for generating messages for the stream.
  /// @param pred Predicate returning `true` when the stream is done.
  /// @param scatterer_type Configures the policy for downstream communication.
  /// @returns A stream object with a pointer to the generated `stream_manager`.
  template <class Init, class... Ts, class Getter, class ClosedPredicate,
            class Scatterer = broadcast_scatterer<
              typename stream_source_trait_t<Getter>::output>>
  annotated_stream<typename stream_source_trait_t<Getter>::output, Ts...>
  make_source(std::tuple<Ts...> xs, Init init, Getter getter,
              ClosedPredicate pred,
              policy::arg<Scatterer> scatterer_type = {}) {
    CAF_IGNORE_UNUSED(scatterer_type);
    using type = typename stream_source_trait_t<Getter>::output;
    using state_type = typename stream_source_trait_t<Getter>::state;
    static_assert(std::is_same<
                    void (state_type&),
                    typename detail::get_callable_trait<Init>::fun_sig
                  >::value,
                  "Expected signature `void (State&)` for init function");
    static_assert(std::is_same<
                    void (state_type&, downstream<type>&, size_t),
                    typename detail::get_callable_trait<Getter>::fun_sig
                  >::value,
                  "Expected signature `void (State&, downstream<T>&, size_t)` "
                  "for getter function");
    static_assert(std::is_same<
                    bool (const state_type&),
                    typename detail::get_callable_trait<
                      ClosedPredicate
                    >::fun_sig
                  >::value,
                  "Expected signature `bool (const State&)` for "
                  "closed_predicate function");
    auto sid = make_stream_id();
    using impl = stream_source_impl<Getter, ClosedPredicate, Scatterer>;
    auto ptr = make_counted<impl>(this, std::move(getter), std::move(pred));
    auto next = take_current_next_stage();
    if (!add_sink<type>(ptr, sid, current_sender(), std::move(next),
                        take_current_forwarding_stack(), current_message_id(),
                        stream_priority::normal, std::move(xs))) {
      CAF_LOG_ERROR("cannot create stream source without sink");
      auto rp = make_response_promise();
      rp.deliver(sec::no_downstream_stages_defined);
      return none;
    }
    drop_current_message_id();
    init(ptr->state());
    streams_.emplace(sid, ptr);
    return {std::move(sid), std::move(ptr)};
  }

  /// Creates a new stream source.
  /// @param init Function object for initializing the state of the source.
  /// @param getter Function object for generating messages for the stream.
  /// @param pred Predicate returning `true` when the stream is done.
  /// @param scatterer_type Configures the policy for downstream communication.
  /// @returns A stream object with a pointer to the generated `stream_manager`.
  template <class Init, class Getter, class ClosedPredicate,
            class Scatterer = broadcast_scatterer<
              typename stream_source_trait_t<Getter>::output>>
  stream<typename stream_source_trait_t<Getter>::output>
  make_source(Init init, Getter getter, ClosedPredicate pred,
              policy::arg<Scatterer> scatterer_type = {}) {
    return make_source(std::make_tuple(), std::move(init), std::move(getter),
                       std::move(pred), scatterer_type);
  }

  /// Creates a new stream stage.
  /// @pre `current_mailbox_element()` is a `stream_msg::open` handshake
  /// @param in The input of the stage.
  /// @param xs User-defined handshake payload.
  /// @param init Function object for initializing the state of the stage.
  /// @param fun Function object for processing stream elements.
  /// @param cleanup Function object for clearing the stage of the stage.
  /// @param policies Sets the policies for up- and downstream communication.
  /// @returns A stream object with a pointer to the generated `stream_manager`.
  template <class In, class... Ts, class Init, class Fun, class Cleanup,
            class Gatherer = random_gatherer,
            class Scatterer =
              broadcast_scatterer<typename stream_stage_trait_t<Fun>::output>>
  annotated_stream<typename stream_stage_trait_t<Fun>::output, Ts...>
  make_stage(const stream<In>& in, std::tuple<Ts...> xs, Init init, Fun fun,
             Cleanup cleanup, policy::arg<Gatherer, Scatterer> policies = {}) {
    CAF_IGNORE_UNUSED(policies);
    CAF_ASSERT(current_mailbox_element() != nullptr);
    CAF_ASSERT(current_mailbox_element()->content().match_elements<stream_msg>());
    using output_type = typename stream_stage_trait_t<Fun>::output;
    using state_type = typename stream_stage_trait_t<Fun>::state;
    static_assert(std::is_same<
                    void (state_type&),
                    typename detail::get_callable_trait<Init>::fun_sig
                  >::value,
                  "Expected signature `void (State&)` for init function");
    static_assert(std::is_same<
                    void (state_type&, downstream<output_type>&, In),
                    typename detail::get_callable_trait<Fun>::fun_sig
                  >::value,
                  "Expected signature `void (State&, downstream<Out>&, In)` "
                  "for consume function");
    using impl = stream_stage_impl<Fun, Cleanup, Gatherer, Scatterer>;
    auto ptr = make_counted<impl>(this, in.id(), std::move(fun),
                                  std::move(cleanup));
    if (!serve_as_stage<output_type>(ptr, in, std::move(xs))) {
      CAF_LOG_ERROR("installing sink and source to the manager failed");
      return none;
    }
    init(ptr->state());
    return {in.id(), std::move(ptr)};
  }

  /// Creates a new stream stage.
  /// @pre `current_mailbox_element()` is a `stream_msg::open` handshake
  /// @param in The input of the stage.
  /// @param init Function object for initializing the state of the stage.
  /// @param fun Function object for processing stream elements.
  /// @param cleanup Function object for clearing the stage of the stage.
  /// @param policies Sets the policies for up- and downstream communication.
  /// @returns A stream object with a pointer to the generated `stream_manager`.
  template <class In, class Init, class Fun, class Cleanup,
            class Gatherer = random_gatherer,
            class Scatterer =
              broadcast_scatterer<typename stream_stage_trait_t<Fun>::output>>
  stream<typename stream_stage_trait_t<Fun>::output>
  make_stage(const stream<In>& in, Init init, Fun fun, Cleanup cleanup,
             policy::arg<Gatherer, Scatterer> policies = {}) {
    return make_stage(in, std::make_tuple(), std::move(init), std::move(fun),
                      std::move(cleanup), policies);
  }

  /// Creates a new stream sink of type T.
  /// @pre `current_mailbox_element()` is a `stream_msg::open` handshake
  /// @param in The input of the sink.
  /// @param f Callback for initializing the object after successful creation.
  /// @param xs Parameter pack for creating the instance of T.
  /// @returns A stream object with a pointer to the generated `stream_manager`.
  template <class T, class In, class SuccessCallback, class... Ts>
  stream_result<typename T::output_type>
  make_sink_impl(const stream<In>& in, SuccessCallback f, Ts&&... xs) {
    CAF_ASSERT(current_mailbox_element() != nullptr);
    CAF_ASSERT(current_mailbox_element()->content().match_elements<stream_msg>());
    auto& sm = current_mailbox_element()->content().get_as<stream_msg>(0);
    CAF_ASSERT(holds_alternative<stream_msg::open>(sm.content));
    auto& opn = get<stream_msg::open>(sm.content);
    auto sid = in.id();
    auto next = take_current_next_stage();
    auto ptr = make_counted<T>(this, std::forward<Ts>(xs)...);
    auto rp = make_response_promise();
    if (!add_source(ptr, sid, std::move(opn.prev_stage),
                    std::move(opn.original_stage), opn.priority,
                    opn.redeployable, rp)) {
      CAF_LOG_ERROR("cannot create stream stage without source");
      rp.deliver(sec::cannot_add_upstream);
      return none;
    }
    f(*ptr);
    streams_.emplace(in.id(), ptr);
    return {in.id(), std::move(ptr)};
  }

  /// Creates a new stream sink.
  /// @pre `current_mailbox_element()` is a `stream_msg::open` handshake
  /// @param in The input of the sink.
  /// @param init Function object for initializing the state of the stage.
  /// @param fun Function object for processing stream elements.
  /// @param finalize Function object for producing the final result.
  /// @param policies Sets the policies for up- and downstream communication.
  /// @returns A stream object with a pointer to the generated `stream_manager`.
  template <class In, class Init, class Fun, class Finalize,
            class Gatherer = random_gatherer,
            class Scatterer = terminal_stream_scatterer>
  stream_result<typename stream_sink_trait_t<Fun, Finalize>::output>
  make_sink(const stream<In>& in, Init init, Fun fun, Finalize finalize,
            policy::arg<Gatherer, Scatterer> policies = {}) {
    CAF_IGNORE_UNUSED(policies);
    using state_type = typename stream_sink_trait_t<Fun, Finalize>::state;
    static_assert(std::is_same<
                    void (state_type&),
                    typename detail::get_callable_trait<Init>::fun_sig
                  >::value,
                  "Expected signature `void (State&)` for init function");
    static_assert(std::is_same<
                    void (state_type&, In),
                    typename detail::get_callable_trait<Fun>::fun_sig
                  >::value,
                  "Expected signature `void (State&, Input)` "
                  "for consume function");
    using impl = stream_sink_impl<Fun, Finalize, Gatherer, Scatterer>;
    auto initializer = [&](impl& x) {
      init(x.state());
    };
    return make_sink_impl<impl>(in, initializer, std::move(fun),
                                std::move(finalize));
  }

  inline streams_map& streams() {
    return streams_;
  }

  /// Tries to send more data on all downstream paths. Use this function to
  /// manually trigger batches in a source after receiving more data to send.
  void trigger_downstreams();

  /// @cond PRIVATE

  // -- timeout management -----------------------------------------------------

  /// Requests a new timeout and returns its ID.
  uint32_t request_timeout(const duration& d);

  /// Resets the timeout if `timeout_id` is the active timeout.
  void reset_timeout(uint32_t timeout_id);

  /// Returns whether `timeout_id` is currently active.
  bool is_active_timeout(uint32_t tid) const;

  // -- message processing -----------------------------------------------------

  /// Adds a callback for an awaited response.
  void add_awaited_response_handler(message_id response_id, behavior bhvr);

  /// Adds a callback for a multiplexed response.
  void add_multiplexed_response_handler(message_id response_id, behavior bhvr);

  /// Returns the category of `x`.
  message_category categorize(mailbox_element& x);

  /// Tries to consume `x`.
  virtual invoke_message_result consume(mailbox_element& x);

  /// Tries to consume `x`.
  void consume(mailbox_element_ptr x);

  /// Tries to consume one element form the cache using the current behavior.
  bool consume_from_cache();

  /// Activates an actor and runs initialization code if necessary.
  /// @returns `true` if the actor is alive and ready for `reactivate`,
  ///          `false` otherwise.
  bool activate(execution_unit* ctx);

  /// One-shot interface for activating an actor for a single message.
  activation_result activate(execution_unit* ctx, mailbox_element& x);

  /// Interface for activating an actor any
  /// number of additional times after `activate`.
  activation_result reactivate(mailbox_element& x);

  // -- behavior management ----------------------------------------------------

  /// Returns whether `true` if the behavior stack is not empty or
  /// if outstanding responses exist, `false` otherwise.
  inline bool has_behavior() const {
    return !bhvr_stack_.empty()
           || !awaited_responses_.empty()
           || !multiplexed_responses_.empty()
           || !streams_.empty();
  }

  inline behavior& current_behavior() {
    return !awaited_responses_.empty() ? awaited_responses_.front().second
                                        : bhvr_stack_.back();
  }

  /// Installs a new behavior without performing any type checks.
  void do_become(behavior bhvr, bool discard_old);

  /// Performs cleanup code for the actor if it has no active
  /// behavior or was explicitly terminated.
  /// @returns `true` if cleanup code was called, `false` otherwise.
  bool finalize();

  inline detail::behavior_stack& bhvr_stack() {
    return bhvr_stack_;
  }

  template <class T, class... Ts>
  static message make_handshake(const stream_id& sid, std::tuple<Ts...>& xs) {
    stream<T> token{sid};
    auto ys = std::tuple_cat(std::forward_as_tuple(token), std::move(xs));
    return make_message_from_tuple(std::move(ys));
  }

  /// Tries to add a new sink to the stream manager `mgr`.
  /// @param mgr Pointer to the responsible stream manager.
  /// @param sid The ID used for communicating to the sink.
  /// @param origin Handle to the actor that initiated the stream and that will
  ///               receive the stream result (if any).
  /// @param sink_ptr Handle to the new sink.
  /// @param fwd_stack Forwarding stack for the remaining stream participants.
  /// @param prio Priority of the traffic to the sink.
  /// @param handshake_mid Message ID for the stream handshake. If valid, this
  ///                      ID will be used to send the result to the `origin`.
  /// @param data Additional payload for the stream handshake.
  /// @returns `true` if the sink could be added to the manager, `false`
  ///          otherwise.
  template <class T, class... Ts>
  bool add_sink(const stream_manager_ptr& mgr, const stream_id& sid,
                strong_actor_ptr origin, strong_actor_ptr sink_ptr,
                mailbox_element::forwarding_stack fwd_stack,
                message_id handshake_mid, stream_priority prio,
                std::tuple<Ts...> data) {
    CAF_ASSERT(mgr != nullptr);
    if (!sink_ptr || !sid.valid())
      return false;
    return mgr->add_sink(sid, std::move(origin), std::move(sink_ptr),
                         std::move(fwd_stack), handshake_mid,
                         make_handshake<T>(sid, data), prio, false);
  }

  /// Tries to add a new source to the stream manager `mgr`.
  /// @param mgr Pointer to the responsible stream manager.
  /// @param sid The ID used for communicating to the sink.
  /// @param source_ptr Handle to the new source.
  /// @param prio Priority of the traffic from the source.
  /// @param redeployable Configures whether source can re-appear after aborts.
  /// @param result_cb Callback for the listener of the final stream result.
  ///                  Ignored when returning `nullptr`, because the previous
  ///                  stage is responsible for it until this manager
  ///                  acknowledges the handshake.
  /// @returns `true` if the sink could be added to the manager, `false`
  ///          otherwise.
  bool add_source(const stream_manager_ptr& mgr, const stream_id& sid,
                  strong_actor_ptr source_ptr, strong_actor_ptr original_stage,
                  stream_priority prio, bool redeployable,
                  response_promise result_cb);

  /// Adds a new source to the stream manager `mgr` if `current_message()` is a
  /// `stream_msg::open` handshake.
  /// @param mgr Pointer to the responsible stream manager.
  /// @param sid The ID used for communicating to the sink.
  /// @param result_cb Callback for the listener of the final stream result.
  ///                  Ignored when returning `nullptr`, because the previous
  ///                  stage is responsible for it until this manager
  ///                  acknowledges the handshake.
  /// @returns `true` if the sink could be added to the manager, `false`
  ///          otherwise.
  bool add_source(const stream_manager_ptr& mgr, const stream_id& sid,
                  response_promise result_cb);

  /// Adds a pair of source and sink to `mgr` that allows it to serve as a
  /// stage for the stream `in` with the output type `Out`. Returns `false` if
  /// `current_mailbox_element()` is not a `stream_msg::open` handshake or if
  /// adding the sink or source fails, `true` otherwise.
  /// @param mgr Pointer to the responsible stream manager.
  /// @param in The input of the stage.
  /// @param xs User-defined handshake payload.
  /// @returns `true` if the manager added sink and source, `false` otherwise.
  template <class Out, class In, class... Ts>
  bool serve_as_stage(const stream_manager_ptr& mgr, const stream<In>& in,
                      std::tuple<Ts...> xs) {
    CAF_ASSERT(current_mailbox_element() != nullptr);
    if (!current_mailbox_element()->content().match_elements<stream_msg>())
      return false;
    auto& sm = current_mailbox_element()->content().get_as<stream_msg>(0);
    if (!holds_alternative<stream_msg::open>(sm.content))
      return false;
    auto& opn = get<stream_msg::open>(sm.content);
    auto sid = in.id();
    auto next = take_current_next_stage();
    if (!add_sink<Out>(mgr, sid, current_sender(), std::move(next),
                       current_forwarding_stack(), current_message_id(),
                       opn.priority, std::move(xs))) {
      CAF_LOG_ERROR("cannot create stream stage without sink");
      mgr->abort(sec::no_downstream_stages_defined);
      auto rp = make_response_promise();
      rp.deliver(sec::no_downstream_stages_defined);
      return false;
    }
    // Pass `none` instead of a response promise to the source, because the
    // outbound_path is responsible for the "promise" until we receive an ACK
    // from the next stage.
    if (!add_source(mgr, sid, std::move(opn.prev_stage),
                    std::move(opn.original_stage), opn.priority,
                    opn.redeployable, none)) {
      CAF_LOG_ERROR("cannot create stream stage without source");
      auto rp = make_response_promise();
      rp.deliver(sec::cannot_add_upstream);
      return false;
    }
    streams_.emplace(sid, mgr);
    return true;
  }


  template <class T, class... Ts>
  void fwd_stream_handshake(const stream_id& sid, std::tuple<Ts...>& xs,
                            bool ignore_mid = false) {
    auto mptr = current_mailbox_element();
    auto& stages = mptr->stages;
    CAF_ASSERT(!stages.empty());
    CAF_ASSERT(stages.back() != nullptr);
    auto next = std::move(stages.back());
    stages.pop_back();
    stream<T> token{sid};
    auto ys = std::tuple_cat(std::forward_as_tuple(token), std::move(xs));;
    next->enqueue(make_mailbox_element(
                    mptr->sender, ignore_mid ? make_message_id() : mptr->mid,
                    std::move(stages),
                    make<stream_msg::open>(
                      sid, address(), make_message_from_tuple(std::move(ys)),
                      ctrl(), next, stream_priority::normal, false)),
                  context());
    if (!ignore_mid)
      mptr->mid.mark_as_answered();
  }

  /// @endcond

protected:
  /// @cond PRIVATE

  /// Utility function that swaps `f` into a temporary before calling it
  /// and restoring `f` only if it has not been replaced by the user.
  template <class F, class... Ts>
  auto call_handler(F& f, Ts&&... xs)
  -> typename std::enable_if<
       !std::is_same<decltype(f(std::forward<Ts>(xs)...)), void>::value,
       decltype(f(std::forward<Ts>(xs)...))
     >::type {
    using std::swap;
    F g;
    swap(f, g);
    auto res = g(std::forward<Ts>(xs)...);
    if (!f)
      swap(g, f);
    return res;
  }

  template <class F, class... Ts>
  auto call_handler(F& f, Ts&&... xs)
  -> typename std::enable_if<
       std::is_same<decltype(f(std::forward<Ts>(xs)...)), void>::value
     >::type {
    using std::swap;
    F g;
    swap(f, g);
    g(std::forward<Ts>(xs)...);
    if (!f)
      swap(g, f);
  }

  bool handle_stream_msg(mailbox_element& x, behavior* active_behavior);

  // -- Member Variables -------------------------------------------------------

  /// Stores user-defined callbacks for message handling.
  detail::behavior_stack bhvr_stack_;

  /// Identifies the timeout messages we are currently waiting for.
  uint32_t timeout_id_;

  /// Stores callbacks for awaited responses.
  std::forward_list<pending_response> awaited_responses_;

  /// Stores callbacks for multiplexed responses.
  std::unordered_map<message_id, behavior> multiplexed_responses_;

  /// Customization point for setting a default `message` callback.
  default_handler default_handler_;

  /// Customization point for setting a default `error` callback.
  error_handler error_handler_;

  /// Customization point for setting a default `down_msg` callback.
  down_handler down_handler_;

  /// Customization point for setting a default `exit_msg` callback.
  exit_handler exit_handler_;

  /// Pointer to a private thread object associated with a detached actor.
  detail::private_thread* private_thread_;

  // TODO: this type is quite heavy in terms of memory, maybe use vector?
  /// Holds state for all streams running through this actor.
  streams_map streams_;

# ifndef CAF_NO_EXCEPTIONS
  /// Customization point for setting a default exception callback.
  exception_handler exception_handler_;
# endif // CAF_NO_EXCEPTIONS

  /// @endcond
};

} // namespace caf

#endif // CAF_ABSTRACT_EVENT_BASED_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_COMPOSED_STATE_HPP
#define CAF_COMPOSED_STATE_HPP

#include "caf/param.hpp"
#include "caf/composable_behavior.hpp"
#include "caf/typed_actor_pointer.hpp"

namespace caf {

template <class... Ts>
class composed_behavior : public Ts... {
public:
  using signatures =
    typename detail::tl_union<typename Ts::signatures...>::type;

  using handle_type =
    typename detail::tl_apply<
      signatures,
      typed_actor
    >::type;

  using behavior_type = typename handle_type::behavior_type;

  using actor_base = typename handle_type::base;

  using broker_base = typename handle_type::broker_base;

  using self_pointer =
    typename detail::tl_apply<
      signatures,
      typed_actor_pointer
    >::type;

  composed_behavior() : self(nullptr) {
    // nop
  }

  template <class SelfPointer>
  unit_t init_selfptr(SelfPointer x) {
    CAF_ASSERT(x != nullptr);
    self = x;
    return unit(static_cast<Ts*>(this)->init_selfptr(x)...);
  }

  void init_behavior(message_handler& x) override {
    init_behavior_impl(x);
  }

  unit_t init_behavior_impl(message_handler& x) {
    return unit(static_cast<Ts*>(this)->init_behavior_impl(x)...);
  }

protected:
  self_pointer self;
};

} // namespace caf

#endif // CAF_COMPOSED_STATE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

// This file is referenced in the manual, do not modify without updating refs!
// ConfiguringActorApplications: 50-54

#ifndef CAF_ALLOWED_UNSAFE_MESSAGE_TYPE_HPP
#define CAF_ALLOWED_UNSAFE_MESSAGE_TYPE_HPP

#include <type_traits>

namespace caf {

/// Template specializations can whitelist individual
/// types for unsafe message passing operations.
template <class T>
struct allowed_unsafe_message_type : std::false_type {};

template <class T>
struct is_allowed_unsafe_message_type : allowed_unsafe_message_type<T> {};

template <class T>
struct is_allowed_unsafe_message_type<T&> : allowed_unsafe_message_type<T> {};

template <class T>
struct is_allowed_unsafe_message_type<T&&> : allowed_unsafe_message_type<T> {};

template <class T>
struct is_allowed_unsafe_message_type<const T&>
    : allowed_unsafe_message_type<T> {};

} // namespace caf

#define CAF_ALLOW_UNSAFE_MESSAGE_TYPE(type_name)                               \
  namespace caf {                                                              \
  template <>                                                                  \
  struct allowed_unsafe_message_type<type_name> : std::true_type {};           \
  }

#endif // CAF_ALLOWED_UNSAFE_MESSAGE_TYPE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_FUSED_SCATTERER
#define CAF_FUSED_SCATTERER

#include <tuple>
#include <cstddef>

#include "caf/logger.hpp"
#include "caf/stream_scatterer.hpp"

namespace caf {

namespace detail {

/// Utility function for repeating `x` for a given template parameter pack.
template <class T, class U>
U pack_repeat(U x) {
  return x;
}

template <class Iter>
class ptr_array_initializer {
public:
  ptr_array_initializer(Iter first) : i_(first) {
    // nop
  }

  void operator()() {
    // end of recursion
  }

  template <class T, class... Ts>
  void operator()(T& x, Ts&... xs) {
    *i_ = &x;
    ++i_;
    (*this)(xs...);
  }

private:
  Iter i_;
};

struct scatterer_selector {
  inline stream_scatterer* operator()(const message&) {
    return nullptr;
  }

  template <class T, class... Ts>
  stream_scatterer* operator()(const message& msg, T& x, Ts&... xs) {
    if (msg.match_element<stream<typename T::value_type>>(0))
      return &x;
    return (*this)(msg, xs...);
  }
};

} // namespace detail

/// A scatterer that delegates to any number of sub-scatterers. Data is only
/// pushed to the main scatterer `T` per default.
template <class T, class... Ts>
class fused_scatterer : public stream_scatterer {
public:
  using substreams_tuple = std::tuple<T, Ts...>;

  using pointer = stream_scatterer*;
  using const_pointer = const pointer;

  using iterator = pointer*;
  using const_iterator = const pointer*;

  fused_scatterer(local_actor* self)
      : substreams_(self, detail::pack_repeat<Ts>(self)...) {
    detail::ptr_array_initializer<pointer*> f{ptrs_};
    auto indices = detail::get_indices(substreams_);
    detail::apply_args(f, indices, substreams_);
  }

  path_ptr add_path(const stream_id& sid, strong_actor_ptr origin,
                    strong_actor_ptr sink_ptr,
                    mailbox_element::forwarding_stack stages,
                    message_id handshake_mid, message handshake_data,
                    stream_priority prio, bool redeployable) override {
    CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(origin) << CAF_ARG(sink_ptr)
                  << CAF_ARG(stages) << CAF_ARG(handshake_mid)
                  << CAF_ARG(handshake_data) << CAF_ARG(prio)
                  << CAF_ARG(redeployable));
    auto ptr = substream_by_handshake_type(handshake_data);
    if (!ptr)
      return nullptr;
    return ptr->add_path(sid, std::move(origin), std::move(sink_ptr),
                         std::move(stages), handshake_mid,
                         std::move(handshake_data), prio, redeployable);
  }

  path_ptr confirm_path(const stream_id& sid, const actor_addr& from,
                        strong_actor_ptr to, long initial_demand,
                        bool redeployable) override {
    CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(from) << CAF_ARG(to)
                  << CAF_ARG(initial_demand) << CAF_ARG(redeployable));
    return first_hit([&](pointer ptr) -> outbound_path* {
      // Note: we cannot blindly try `confirm_path` on each scatterer, because
      // this will trigger forced_close messages.
      if (ptr->find(sid, from) == nullptr)
        return nullptr;
      return ptr->confirm_path(sid, from, to, initial_demand, redeployable);
    });
  }

  bool remove_path(const stream_id& sid, const actor_addr& addr, error reason,
                   bool silent) override {
    CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(addr) << CAF_ARG(reason)
                  << CAF_ARG(silent));
    return std::any_of(begin(), end(), [&](pointer x) {
      return x->remove_path(sid, addr, reason, silent);
    });
  }

  bool paths_clean() const override {
    return std::all_of(begin(), end(),
                       [&](const_pointer x) { return x->paths_clean(); });
  }

  void close() override {
    CAF_LOG_TRACE("");
    for (auto ptr : ptrs_)
      ptr->close();
  }

  void abort(error reason) override {
    CAF_LOG_TRACE(CAF_ARG(reason));
    for (auto ptr : ptrs_)
      ptr->abort(reason);
  }

  long num_paths() const override {
    return std::accumulate(begin(), end(), 0l, [](long x, const_pointer y) {
      return x + y->num_paths();
    });
  }

  bool closed() const override {
    return std::all_of(begin(), end(),
                       [&](const_pointer x) { return x->closed(); });
  }

  bool continuous() const override {
    return std::any_of(begin(), end(),
                       [&](const_pointer x) { return x->continuous(); });
  }

  void continuous(bool value) override {
    for (auto ptr : ptrs_)
      ptr->continuous(value);
  }

  void emit_batches() override {
    CAF_LOG_TRACE("");
    for (auto ptr : ptrs_)
      ptr->emit_batches();
  }

  path_ptr find(const stream_id& sid, const actor_addr& x) override{
    return first_hit([&](const_pointer ptr) { return ptr->find(sid, x); });
  }

  path_ptr path_at(size_t idx) override {
    auto i = std::begin(ptrs_);
    auto e = std::end(ptrs_);
    while (i != e) {
      auto np = static_cast<size_t>((*i)->num_paths());
      if (idx < np)
        return (*i)->path_at(idx);
      idx -= np;
    }
    return nullptr;
  }

  long credit() const override {
    return std::accumulate(
      begin(), end(), std::numeric_limits<long>::max(),
      [](long x, pointer y) { return std::min(x, y->credit()); });
  }

  long buffered() const override {
    return std::accumulate(begin(), end(), 0l, [](long x, const_pointer y) {
      return x + y->buffered();
    });
  }

  long min_batch_size() const override {
    return main_stream().min_batch_size();
  }

  long max_batch_size() const override {
    return main_stream().max_batch_size();
  }

  long min_buffer_size() const override {
    return main_stream().min_buffer_size();
  }

  duration max_batch_delay() const override {
    return main_stream().max_batch_delay();
  }

  void min_batch_size(long x) override {
    main_stream().min_batch_size(x);
  }

  void max_batch_size(long x) override {
    main_stream().max_batch_size(x);
  }

  void min_buffer_size(long x) override {
    main_stream().min_buffer_size(x);
  }

  void max_batch_delay(duration x) override {
    main_stream().max_batch_delay(x);
  }

  template <class... Us>
  void push(Us&&... xs) {
    main_stream().push(std::forward<Us>(xs)...);
  }

  iterator begin() {
    return std::begin(ptrs_);
  }

  const_iterator begin() const {
    return std::begin(ptrs_);
  }

  iterator end() {
    return std::end(ptrs_);
  }

  const_iterator end() const {
    return std::end(ptrs_);
  }

  T& main_stream() {
    return std::get<0>(substreams_);
  }

  const T& main_stream() const {
    return std::get<0>(substreams_);
  }

  template <size_t I>
  typename std::tuple_element<I, substreams_tuple>::type& substream() {
    return std::get<I>(substreams_);
  }

  template <size_t I>
  const typename std::tuple_element<I, substreams_tuple>::type&
  substream() const {
    return std::get<I>(substreams_);
  }

  stream_scatterer* substream_by_handshake_type(const message& msg) {
    detail::scatterer_selector f;
    auto indices = detail::get_indices(substreams_);
    return detail::apply_args_prefixed(f, indices, substreams_, msg);
  }

private:
  template <class F>
  path_ptr first_hit(F f) {
    for (auto ptr : ptrs_) {
      auto result = f(ptr);
      if (result != nullptr)
        return result;
    }
    return nullptr;
  }

  substreams_tuple substreams_;
  stream_scatterer* ptrs_[sizeof...(Ts) + 1];
};

} // namespace caf

#endif // CAF_FUSED_SCATTERER

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_CONFIG_VALUE_HPP
#define CAF_CONFIG_VALUE_HPP

#include <string>
#include <cstdint>

#include "caf/atom.hpp"
#include "caf/variant.hpp"

namespace caf {

/// A variant type for config parameters.
using config_value = variant<std::string, double, int64_t, bool, atom_value>;

} // namespace caf

#endif // CAF_CONFIG_VALUE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ACTOR_STORAGE_HPP
#define CAF_ACTOR_STORAGE_HPP

#include <new>
#include <atomic>
#include <cstddef>
#include <type_traits>

#include "caf/config.hpp"
#include "caf/abstract_actor.hpp"
#include "caf/actor_control_block.hpp"

#ifdef CAF_GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Winvalid-offsetof"
#endif

namespace caf {

template <class T>
class actor_storage {
public:
  template <class... Us>
  actor_storage(actor_id x, node_id y, actor_system* sys, Us&&... zs)
      : ctrl(x, y, sys, data_dtor, block_dtor) {
    // construct data member
    new (&data) T(std::forward<Us>(zs)...);
  }

  ~actor_storage() {
    // 1) make sure control block fits into a single cache line
    static_assert(sizeof(actor_control_block) < CAF_CACHE_LINE_SIZE,
                  "actor_control_block exceeds a single cache line");
    // Clang in combination with libc++ on Linux complains about offsetof:
    //     error: 'actor_storage' does not refer to a value
    // Until we have found a reliable solution, we disable this safety check.
    #if !(defined(CAF_CLANG) && defined(CAF_LINUX))
    // 2) make sure reinterpret cast of the control block to the storage works
    static_assert(offsetof(actor_storage, ctrl) == 0,
                  "control block is not at the start of the storage");
    // 3) make sure we can obtain a data pointer by jumping one cache line
    static_assert(offsetof(actor_storage, data) == CAF_CACHE_LINE_SIZE,
                  "data is not at cache line size boundary");
    #else
    // 4) make sure static_cast and reinterpret_cast
    //    between T* and abstract_actor* are identical
    constexpr abstract_actor* dummy = nullptr;
    constexpr T* derived_dummy = static_cast<T*>(dummy);
    static_assert(derived_dummy == nullptr,
                  "actor subtype has illegal memory alignment "
                  "(probably due to virtual inheritance)");
    #endif
  }

  actor_storage(const actor_storage&) = delete;
  actor_storage& operator=(const actor_storage&) = delete;

  static_assert(sizeof(actor_control_block) < CAF_CACHE_LINE_SIZE,
                "actor_control_block exceeds 64 bytes");

  actor_control_block ctrl;
  char pad[CAF_CACHE_LINE_SIZE - sizeof(actor_control_block)];
  union { T data; };

private:
  static void data_dtor(abstract_actor* ptr) {
    // safe due to static assert #3
    ptr->on_destroy();
    static_cast<T*>(ptr)->~T();
  }

  static void block_dtor(actor_control_block* ptr) {
    // safe due to static assert #2
    delete reinterpret_cast<actor_storage*>(ptr);
  }
};

/// @relates actor_storage
template <class T>
bool intrusive_ptr_upgrade_weak(actor_storage<T>* x) {
  auto count = x->ctrl.strong_refs.load();
  while (count != 0) {
    if (x->ctrl.strong_refs.compare_exchange_weak(count, count + 1,
                                                  std::memory_order_relaxed))
      return true;
  }
  return false;
}

/// @relates actor_storage
template <class T>
void intrusive_ptr_add_weak_ref(actor_storage<T>* x) {
  x->ctrl.weak_refs.fetch_add(1, std::memory_order_relaxed);
}

/// @relates actor_storage
template <class T>
void intrusive_ptr_release_weak(actor_storage<T>* x) {
  // destroy object if last weak pointer expires
  if (x->ctrl.weak_refs == 1
      || x->ctrl.weak_refs.fetch_sub(1, std::memory_order_acq_rel) == 1)
    delete x;
}

/// @relates actor_storage
template <class T>
void intrusive_ptr_add_ref(actor_storage<T>* x) {
  x->ctrl.strong_refs.fetch_add(1, std::memory_order_relaxed);
}

/// @relates actor_storage
template <class T>
void intrusive_ptr_release(actor_storage<T>* x) {
  // release implicit weak pointer if the last strong ref expires
  // and destroy the data block
  if (x->ctrl.strong_refs.fetch_sub(1, std::memory_order_acq_rel) == 1) {
    x->destroy_data();
    intrusive_ptr_relase_weak(x);
  }
}

} // namespace caf

#ifdef CAF_GCC
#pragma GCC diagnostic pop
#endif

#endif // CAF_ACTOR_STORAGE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

namespace caf {
namespace tag {

/// Allows the testing DSL to recognize that subtypes are boxing content types.
struct boxing_type {};

} // namespace tag
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ATTACHABLE_HPP
#define CAF_ATTACHABLE_HPP

#include <memory>
#include <cstdint>
#include <typeinfo>

#include "caf/error.hpp"
#include "caf/optional.hpp"
#include "caf/exit_reason.hpp"
#include "caf/execution_unit.hpp"

namespace caf {

class abstract_actor;

/// Callback utility class.
class attachable {
public:
  attachable() = default;
  attachable(const attachable&) = delete;
  attachable& operator=(const attachable&) = delete;

  /// Represents a pointer to a value with its subtype as type ID number.
  struct token {
    /// Identifies a non-matchable subtype.
    static constexpr size_t anonymous = 0;

    /// Identifies `abstract_group::subscription`.
    static constexpr size_t subscription = 1;

    /// Identifies `default_attachable::observe_token`.
    static constexpr size_t observer = 2;

    /// Identifies `stream_aborter::token`.
    static constexpr size_t stream_aborter = 3;

    template <class T>
    token(const T& tk) : subtype(T::token_type), ptr(&tk) {
      // nop
    }

    /// Denotes the type of ptr.
    size_t subtype;

    /// Any value, used to identify attachable instances.
    const void* ptr;

    token(size_t typenr, const void* vptr);
  };

  virtual ~attachable();

  /// Executed if the actor finished execution with given `reason`.
  /// The default implementation does nothing.
  /// @warning `host` can be `nullptr`
  virtual void actor_exited(const error& fail_state, execution_unit* host);

  /// Returns `true` if `what` selects this instance, otherwise `false`.
  virtual bool matches(const token& what);

  /// Returns `true` if `what` selects this instance, otherwise `false`.
  template <class T>
  bool matches(const T& what) {
    return matches(token{T::token_type, &what});
  }

  std::unique_ptr<attachable> next;
};

/// @relates attachable
using attachable_ptr = std::unique_ptr<attachable>;

} // namespace caf

#endif // CAF_ATTACHABLE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MEMORY_MANAGED_HPP
#define CAF_MEMORY_MANAGED_HPP

namespace caf {

/// This base enables derived classes to enforce a different
/// allocation strategy than new/delete by providing a virtual
/// protected `request_deletion()` function and non-public destructor.
class memory_managed {
public:
  /// Default implementations calls `delete this, but can
  /// be overriden in case deletion depends on some condition or
  /// the class doesn't use default new/delete.
  /// @param decremented_rc Indicates whether the caller did reduce the
  ///                       reference of this object before calling this member
  ///                       function. This information is important when
  ///                       implementing a type with support for weak pointers.
  virtual void request_deletion(bool decremented_rc) noexcept;

protected:
  virtual ~memory_managed();
};

} // namespace caf

#endif // CAF_MEMORY_MANAGED_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_PRIMITIVE_VARIANT_HPP
#define CAF_PRIMITIVE_VARIANT_HPP

#include <new>
#include <cstdint>
#include <typeinfo>
#include <stdexcept>
#include <type_traits>

#include "caf/atom.hpp"
#include "caf/none.hpp"
#include "caf/variant.hpp"


namespace caf {

using primitive_variant = variant<int8_t, int16_t, int32_t, int64_t,
                                  uint8_t, uint16_t, uint32_t, uint64_t,
                                  float, double, long double,
                                  std::string, std::u16string, std::u32string,
                                  atom_value, bool>;

} // namespace caf

#endif // CAF_PRIMITIVE_VARIANT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_BLOCKING_ACTOR_HPP
#define CAF_BLOCKING_ACTOR_HPP

#include <chrono>
#include <mutex>
#include <condition_variable>

#include "caf/fwd.hpp"
#include "caf/send.hpp"
#include "caf/none.hpp"
#include "caf/after.hpp"
#include "caf/extend.hpp"
#include "caf/behavior.hpp"
#include "caf/local_actor.hpp"
#include "caf/typed_actor.hpp"
#include "caf/actor_config.hpp"
#include "caf/actor_marker.hpp"
#include "caf/mailbox_element.hpp"
#include "caf/is_timeout_or_catch_all.hpp"

#include "caf/detail/type_list.hpp"
#include "caf/detail/apply_args.hpp"
#include "caf/detail/type_traits.hpp"
#include "caf/detail/blocking_behavior.hpp"

#include "caf/mixin/sender.hpp"
#include "caf/mixin/requester.hpp"
#include "caf/mixin/subscriber.hpp"

namespace caf {
namespace mixin {

template <>
struct is_blocking_requester<blocking_actor> : std::true_type { };

} // namespace caf
} // namespace mixin

namespace caf {

/// A thread-mapped or context-switching actor using a blocking
/// receive rather than a behavior-stack based message processing.
/// @extends local_actor
class blocking_actor
    : public extend<local_actor, blocking_actor>::
             with<mixin::requester,
                  mixin::sender,
                  mixin::subscriber>,
      public dynamically_typed_actor_base {
public:
  // -- member types -----------------------------------------------------------

  /// Absolute timeout type.
  using timeout_type = std::chrono::high_resolution_clock::time_point;

  /// Supported behavior type.
  using behavior_type = behavior;

  /// Declared message passing interface.
  using signatures = none_t;

  // -- nested classes ---------------------------------------------------------

  /// Represents pre- and postconditions for receive loops.
  class receive_cond {
  public:
    virtual ~receive_cond();

    /// Returns whether a precondition for receiving a message still holds.
    virtual bool pre();

    /// Returns whether a postcondition for receiving a message still holds.
    virtual bool post();
  };

  /// Pseudo receive condition modeling a single receive.
  class accept_one_cond : public receive_cond {
  public:
    ~accept_one_cond() override;
    bool post() override;
  };

  /// Implementation helper for `blocking_actor::receive_while`.
  struct receive_while_helper {
    using fun_type = std::function<bool()>;

    blocking_actor* self;
    fun_type stmt_;

    template <class... Ts>
    void operator()(Ts&&... xs) {
      static_assert(sizeof...(Ts) > 0,
              "operator() requires at least one argument");
      struct cond : receive_cond {
        fun_type stmt;
        cond(fun_type x) : stmt(std::move(x)) {
          // nop
        }
        bool pre() override {
          return stmt();
        }
      };
      cond rc{std::move(stmt_)};
      self->varargs_receive(rc, make_message_id(), std::forward<Ts>(xs)...);
    }
  };

  /// Implementation helper for `blocking_actor::receive_for`.
  template <class T>
  struct receive_for_helper {
    blocking_actor* self;
    T& begin;
    T end;

    template <class... Ts>
    void operator()(Ts&&... xs) {
      struct cond : receive_cond {
        receive_for_helper& outer;
        cond(receive_for_helper& x) : outer(x) {
          // nop
        }
        bool pre() override {
          return outer.begin != outer.end;
        }
        bool post() override {
          ++outer.begin;
          return true;
        }
      };
      cond rc{*this};
      self->varargs_receive(rc, make_message_id(), std::forward<Ts>(xs)...);
    }
  };

  /// Implementation helper for `blocking_actor::do_receive`.
  struct do_receive_helper {
    std::function<void (receive_cond& rc)> cb;

    template <class Statement>
    void until(Statement stmt) {
      struct cond : receive_cond {
        Statement f;
        cond(Statement x) : f(std::move(x)) {
          // nop
        }
        bool post() override {
          return !f();
        }
      };
      cond rc{std::move(stmt)};
      cb(rc);
    }

    void until(const bool& bvalue) {
      until([&] { return bvalue; });
    }
  };

  // -- constructors and destructors -------------------------------------------

  blocking_actor(actor_config& cfg);

  ~blocking_actor() override;

  // -- overridden functions of abstract_actor ---------------------------------

  void enqueue(mailbox_element_ptr, execution_unit*) override;

  // -- overridden functions of local_actor ------------------------------------

  const char* name() const override;

  void launch(execution_unit* eu, bool lazy, bool hide) override;

  // -- virtual modifiers ------------------------------------------------------

  /// Implements the actor's behavior.
  virtual void act();

  // -- modifiers --------------------------------------------------------------

  /// Dequeues the next message from the mailbox that is
  /// matched by given behavior.
  template <class... Ts>
  void receive(Ts&&... xs) {
    accept_one_cond rc;
    varargs_receive(rc, make_message_id(), std::forward<Ts>(xs)...);
  }

  /// Receives messages for range `[begin, first)`.
  /// Semantically equal to:
  /// `for ( ; begin != end; ++begin) { receive(...); }`.
  ///
  /// **Usage example:**
  /// ~~~
  /// int i = 0;
  /// receive_for(i, 10) (
  ///   [&](get_atom) {
  ///     return i;
  ///   }
  /// );
  /// ~~~
  template <class T>
  receive_for_helper<T> receive_for(T& begin, T end) {
    return {this, begin, std::move(end)};
  }

  /// Receives messages as long as `stmt` returns true.
  /// Semantically equal to: `while (stmt()) { receive(...); }`.
  ///
  /// **Usage example:**
  /// ~~~
  /// int i = 0;
  /// receive_while([&]() { return (++i <= 10); }) (
  ///   ...
  /// );
  /// ~~~
  receive_while_helper receive_while(std::function<bool()> stmt);

  /// Receives messages as long as `ref` is true.
  /// Semantically equal to: `while (ref) { receive(...); }`.
  ///
  /// **Usage example:**
  /// ~~~
  /// bool running = true;
  /// receive_while(running) (
  ///   ...
  /// );
  /// ~~~
  receive_while_helper receive_while(const bool& ref);


  /// Receives messages until `stmt` returns true.
  ///
  /// Semantically equal to:
  /// `do { receive(...); } while (stmt() == false);`
  ///
  /// **Usage example:**
  /// ~~~
  /// int i = 0;
  /// do_receive
  /// (
  ///   on<int>() >> int_fun,
  ///   on<float>() >> float_fun
  /// )
  /// .until([&]() { return (++i >= 10); };
  /// ~~~
  template <class... Ts>
  do_receive_helper do_receive(Ts&&... xs) {
    auto tup = std::make_tuple(std::forward<Ts>(xs)...);
    auto cb = [=](receive_cond& rc) mutable {
      varargs_tup_receive(rc, make_message_id(), tup);
    };
    return {cb};
  }

  /// Blocks this actor until all other actors are done.
  void await_all_other_actors_done();

  /// Blocks this actor until all `xs...` have terminated.
  template <class... Ts>
  void wait_for(Ts&&... xs) {
    using wait_for_atom = atom_constant<atom("waitFor")>;
    size_t expected = 0;
    size_t i = 0;
    size_t attach_results[] = {attach_functor(xs)...};
    for (auto res : attach_results)
      expected += res;
    receive_for(i, expected)(
      [](wait_for_atom) {
        // nop
      }
    );
  }

  /// Sets a user-defined exit reason `err`. This reason
  /// is signalized to other actors after `act()` returns.
  void fail_state(error err);

  // -- customization points ---------------------------------------------------

  /// Blocks until at least one message is in the mailbox.
  virtual void await_data();

  /// Blocks until at least one message is in the mailbox or
  /// the absolute `timeout` was reached.
  virtual bool await_data(timeout_type timeout);

  /// Returns the next element from the mailbox or `nullptr`.
  /// The default implementation simply returns `next_message()`.
  virtual mailbox_element_ptr dequeue();

  /// @cond PRIVATE

  /// Receives messages until either a pre- or postcheck of `rcc` fails.
  template <class... Ts>
  void varargs_tup_receive(receive_cond& rcc, message_id mid,
                           std::tuple<Ts...>& tup) {
    using namespace detail;
    static_assert(sizeof...(Ts), "at least one argument required");
    // extract how many arguments are actually the behavior part,
    // i.e., neither `after(...) >> ...` nor `others >> ...`.
    using filtered =
      typename tl_filter_not<
        type_list<typename std::decay<Ts>::type...>,
        is_timeout_or_catch_all
      >::type;
    filtered tk;
    behavior bhvr{apply_moved_args(make_behavior_impl, get_indices(tk), tup)};
    using tail_indices = typename il_range<
                           tl_size<filtered>::value, sizeof...(Ts)
                         >::type;
    make_blocking_behavior_t factory;
    auto fun = apply_moved_args_prefixed(factory, tail_indices{}, tup, &bhvr);
    receive_impl(rcc, mid, fun);
  }

  /// Receives messages until either a pre- or postcheck of `rcc` fails.
  void varargs_tup_receive(receive_cond& rcc, message_id mid,
                           std::tuple<behavior&>& tup);

  /// Receives messages until either a pre- or postcheck of `rcc` fails.
  template <class... Ts>
  void varargs_receive(receive_cond& rcc, message_id mid, Ts&&... xs) {
    auto tup = std::forward_as_tuple(std::forward<Ts>(xs)...);
    varargs_tup_receive(rcc, mid, tup);
  }

  /// Receives messages until either a pre- or postcheck of `rcc` fails.
  void receive_impl(receive_cond& rcc, message_id mid,
                    detail::blocking_behavior& bhvr);

  /// @endcond

private:
  size_t attach_functor(const actor&);

  size_t attach_functor(const actor_addr&);

  size_t attach_functor(const strong_actor_ptr&);

  template <class... Ts>
  size_t attach_functor(const typed_actor<Ts...>& x) {
    return attach_functor(actor_cast<strong_actor_ptr>(x));
  }

  template <class Container>
  size_t attach_functor(const Container& xs) {
    size_t res = 0;
    for (auto& x : xs)
      res += attach_functor(x);
    return res;
  }
};

} // namespace caf

#endif // CAF_BLOCKING_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_INPUT_RANGE_HPP
#define CAF_INPUT_RANGE_HPP

#include <iterator>

#include "caf/detail/type_traits.hpp"

namespace caf {

template <class T>
class input_range {
public:
  virtual ~input_range() {
    // nop
  }

  input_range() = default;
  input_range(const input_range&) = default;
  input_range& operator=(const input_range&) = default;

  class iterator : public std::iterator<std::input_iterator_tag, T> {
  public:
    iterator(input_range* range) : xs_(range) {
      if (xs_)
        advance();
    }

    iterator(const iterator&) = default;
    iterator& operator=(const iterator&) = default;

    bool operator==(const iterator& other) const {
      return xs_ == other.xs_;
    }

    bool operator!=(const iterator& other) const {
      return !(*this == other);
    }

    T& operator*() {
      return *x_;
    }

    T* operator->() {
      return x_;
    }

    iterator& operator++() {
      advance();
      return *this;
    }

    iterator operator++(int) {
      iterator copy{xs_};
      advance();
      return copy;
    }

  private:
    void advance() {
      x_ = xs_->next();
      if (!x_)
        xs_ = nullptr;
    }

    input_range* xs_;
    T* x_;
  };

  virtual T* next() = 0;

  iterator begin() {
    return this;
  }

  iterator end() const {
    return nullptr;
  }
};

template <class I>
class input_range_impl : public input_range<detail::value_type_of_t<I>> {
public:
  using value_type = detail::value_type_of_t<I>;

  input_range_impl(I first, I last) : pos_(first), last_(last) {
    // nop
  }

  value_type* next() override {
    return (pos_ == last_) ? nullptr : &(*pos_++);
  }

private:
  I pos_;
  I last_;
};

/**
 * @relates input_range
 */
template <class I>
input_range_impl<I> make_input_range(I first, I last) {
  return {first, last};
}

} // namespace caf

#endif // CAF_INPUT_RANGE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_NAMED_CALLBACK_HPP
#define CAF_NAMED_CALLBACK_HPP

#include "caf/error.hpp"
#include "caf/config.hpp"

#include "caf/detail/type_traits.hpp"

// The class `callback` intentionally has no virtual destructor, because
// the lifetime of callback objects is never managed via base pointers.
CAF_PUSH_NON_VIRTUAL_DTOR_WARNING

namespace caf {

/// Describes a simple callback, usually implemented via lambda expression.
/// Callbacks are used as "type-safe function objects" wherever an interface
/// requires dynamic dispatching. The alternative would be to store the lambda
/// in a `std::function`, which adds another layer of indirection and
/// requires a heap allocation. With the callback implementation of CAF,
/// the object remains on the stack and does not cause more overhead
/// than necessary.
template <class... Ts>
class callback {
public:
  virtual error operator()(Ts...) = 0;
};

/// Utility class for wrapping a function object of type `Base`.
template <class F, class... Ts>
class callback_impl : public callback<Ts...> {
public:
  callback_impl(F&& f) : f_(std::move(f)) {
    // nop
  }

  callback_impl(callback_impl&&) = default;
  callback_impl& operator=(callback_impl&&) = default;

  error operator()(Ts... xs) override {
    return f_(xs...);
  }

private:
  F f_;
};

/// Utility class for selecting a `callback_impl`.
template <class F,
          class Args = typename detail::get_callable_trait<F>::arg_types>
struct select_callback;

template <class F, class... Ts>
struct select_callback<F, detail::type_list<Ts...>> {
  using type = callback_impl<F, Ts...>;
};

/// Creates a callback from a lambda expression.
/// @relates callback
template <class F>
typename select_callback<F>::type make_callback(F fun) {
  return {std::move(fun)};
}

} // namespace caf

CAF_POP_WARNINGS

#endif // CAF_NAMED_CALLBACK_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_AFTER_HPP
#define CAF_AFTER_HPP

#include <tuple>
#include <type_traits>

#include "caf/timeout_definition.hpp"

namespace caf {

class timeout_definition_builder {
public:
  constexpr timeout_definition_builder(duration d) : tout_(d) {
    // nop
  }

  template <class F>
  timeout_definition<F> operator>>(F f) const {
    return {tout_, std::move(f)};
  }

private:
  duration tout_;
};

/// Returns a generator for timeouts.
constexpr timeout_definition_builder after(duration d) {
  return {d};
}

/// Returns a generator for timeouts.
template <class Rep, class Period>
constexpr timeout_definition_builder
after(std::chrono::duration<Rep, Period> d) {
  return after(duration{d});
}

} // namespace caf

#endif // CAF_AFTER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_IS_TIMEOUT_OR_CATCH_ALL_HPP
#define CAF_IS_TIMEOUT_OR_CATCH_ALL_HPP

#include "caf/catch_all.hpp"
#include "caf/timeout_definition.hpp"

namespace caf {

template <class T>
struct is_timeout_or_catch_all : std::false_type {};

template <class T>
struct is_timeout_or_catch_all<catch_all<T>> : std::true_type {};

template <class T>
struct is_timeout_or_catch_all<timeout_definition<T>> : std::true_type {};

} // namespace caf

#endif // CAF_IS_TIMEOUT_OR_CATCH_ALL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_CAS_WEAK_HPP
#define CAF_DETAIL_CAS_WEAK_HPP

#include <atomic>

#include "caf/config.hpp"

namespace caf {
namespace detail {

template<class T>
bool cas_weak(std::atomic<T>* obj, T* expected, T desired) {
# if (defined(CAF_CLANG) && CAF_COMPILER_VERSION < 30401)                      \
     || (defined(CAF_GCC) && CAF_COMPILER_VERSION < 40803)
  return std::atomic_compare_exchange_strong(obj, expected, desired);
# else
  return std::atomic_compare_exchange_weak(obj, expected, desired);
# endif
}

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_CAS_WEAK_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_DECORATED_TUPLE_HPP
#define CAF_DETAIL_DECORATED_TUPLE_HPP

#include <vector>
#include <algorithm>

#include "caf/config.hpp"
#include "caf/ref_counted.hpp"

#include "caf/detail/type_list.hpp"

#include "caf/detail/tuple_vals.hpp"
#include "caf/detail/message_data.hpp"

namespace caf {
namespace detail {

class decorated_tuple : public message_data {
public:
  // -- member types -----------------------------------------------------------

  using message_data::cow_ptr;

  using vector_type = std::vector<size_t>;

  // -- constructors, destructors, and assignment operators --------------------

  decorated_tuple(cow_ptr&&, vector_type&&);

  static cow_ptr make(cow_ptr d, vector_type v);

  decorated_tuple& operator=(const decorated_tuple&) = delete;

  // -- overridden observers of message_data -----------------------------------

  cow_ptr copy() const override;

  // -- overridden modifiers of type_erased_tuple ------------------------------

  void* get_mutable(size_t pos) override;

  error load(size_t pos, deserializer& source) override;

  // -- overridden observers of type_erased_tuple ------------------------------

  size_t size() const noexcept override;

  uint32_t type_token() const noexcept override;

  rtti_pair type(size_t pos) const noexcept override;

  const void* get(size_t pos) const noexcept override;

  std::string stringify(size_t pos) const override;

  type_erased_value_ptr copy(size_t pos) const override;

  error save(size_t pos, serializer& sink) const override;

  // -- inline observers -------------------------------------------------------

  inline const cow_ptr& decorated() const {
    return decorated_;
  }

  inline const vector_type& mapping() const {
    return mapping_;
  }

private:
  // -- constructors, destructors, and assignment operators --------------------

  decorated_tuple(const decorated_tuple&) = default;

  // -- data members -----------------------------------------------------------

  cow_ptr decorated_;
  vector_type mapping_;
  uint32_t type_token_;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_DECORATED_TUPLE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_SPAWN_FWD_HPP
#define CAF_DETAIL_SPAWN_FWD_HPP

#include <functional>
#include <type_traits>

#include "caf/actor.hpp"

namespace caf {
namespace detail {

/// Converts `scoped_actor` and pointers to actors to handles of type `actor`
/// but simply forwards any other argument in the same way `std::forward` does.
template <class T>
typename std::conditional<
  is_convertible_to_actor<typename std::decay<T>::type>::value,
  actor,
  T&&
>::type
spawn_fwd(typename std::remove_reference<T>::type& arg) noexcept {
  return static_cast<T&&>(arg);
}

/// Converts `scoped_actor` and pointers to actors to handles of type `actor`
/// but simply forwards any other argument in the same way `std::forward` does.
template <class T>
typename std::conditional<
  is_convertible_to_actor<typename std::decay<T>::type>::value,
  actor,
  T&&
>::type
spawn_fwd(typename std::remove_reference<T>::type&& arg) noexcept {
  static_assert(!std::is_lvalue_reference<T>::value,
                "silently converting an lvalue to an rvalue");
  return static_cast<T&&>(arg);
}

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_SPAWN_FWD_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_TUPLE_VALS_HPP
#define CAF_DETAIL_TUPLE_VALS_HPP

#include <tuple>
#include <stdexcept>

#include "caf/type_nr.hpp"
#include "caf/serializer.hpp"
#include "caf/deserializer.hpp"
#include "caf/deep_to_string.hpp"
#include "caf/make_type_erased_value.hpp"

#include "caf/detail/type_list.hpp"
#include "caf/detail/safe_equal.hpp"
#include "caf/detail/message_data.hpp"
#include "caf/detail/try_serialize.hpp"
#include "caf/detail/stringification_inspector.hpp"

#define CAF_TUPLE_VALS_DISPATCH(x)                                             \
  case x:                                                                      \
    return tuple_inspect_delegate<x, sizeof...(Ts)-1>(data_, f)

namespace caf {
namespace detail {

// avoids triggering static asserts when using CAF_TUPLE_VALS_DISPATCH
template <size_t X, size_t Max, class T, class F>
auto tuple_inspect_delegate(T& data, F& f) -> decltype(f(std::get<Max>(data))) {
  return f(std::get<(X < Max ? X : Max)>(data));
}

template <size_t X, size_t N>
struct tup_ptr_access_pos {
  constexpr tup_ptr_access_pos() {
    // nop
  }
};

template <size_t X, size_t N>
constexpr tup_ptr_access_pos<X + 1, N> next(tup_ptr_access_pos<X, N>) {
  return {};
}

struct void_ptr_access {
  template <class T>
  void* operator()(T& x) const noexcept {
    return &x;
  }
};

template <class T, uint16_t N = type_nr<T>::value>
struct tuple_vals_type_helper {
  static typename message_data::rtti_pair get() noexcept {
    return {N, nullptr};
  }
};

template <class T>
struct tuple_vals_type_helper<T, 0> {
  static typename message_data::rtti_pair get() noexcept {
    return {0, &typeid(T)};
  }
};

template <class Base, class... Ts>
class tuple_vals_impl : public Base {
public:
  // -- static invariants ------------------------------------------------------

  static_assert(sizeof...(Ts) > 0, "tuple_vals is not allowed to be empty");

  // -- member types -----------------------------------------------------------

  using super = message_data;

  using rtti_pair = typename message_data::rtti_pair;

  using data_type = std::tuple<Ts...>;

  // -- friend functions -------------------------------------------------------

  template <class Inspector>
  friend typename Inspector::result_type inspect(Inspector& f,
                                                 tuple_vals_impl& x) {
    return apply_args(f, get_indices(x.data_), x.data_);
  }

  tuple_vals_impl(const tuple_vals_impl&) = default;

  template <class... Us>
  tuple_vals_impl(Us&&... xs)
      : data_(std::forward<Us>(xs)...),
        types_{{tuple_vals_type_helper<Ts>::get()...}} {
    // nop
  }

  data_type& data() {
    return data_;
  }

  const data_type& data() const {
    return data_;
  }

  size_t size() const noexcept override {
    return sizeof...(Ts);
  }

  const void* get(size_t pos) const noexcept override {
    CAF_ASSERT(pos < size());
    void_ptr_access f;
    return mptr()->dispatch(pos, f);
  }

  void* get_mutable(size_t pos) override {
    CAF_ASSERT(pos < size());
    void_ptr_access f;
    return this->dispatch(pos, f);
  }

  std::string stringify(size_t pos) const override {
    std::string result;
    stringification_inspector f{result};
    mptr()->dispatch(pos, f);
    return result;
  }

  using Base::copy;

  type_erased_value_ptr copy(size_t pos) const override {
    type_erased_value_factory f;
    return mptr()->dispatch(pos, f);
  }

  error load(size_t pos, deserializer& source) override {
    return dispatch(pos, source);
  }

  uint32_t type_token() const noexcept override {
    return make_type_token<Ts...>();
  }

  rtti_pair type(size_t pos) const noexcept override {
    return types_[pos];
  }

  error save(size_t pos, serializer& sink) const override {
    return mptr()->dispatch(pos, sink);
  }

private:
  template <class F>
  auto dispatch(size_t pos, F& f) -> decltype(f(std::declval<int&>())) {
    CAF_ASSERT(pos < sizeof...(Ts));
    switch (pos) {
      CAF_TUPLE_VALS_DISPATCH(0);
      CAF_TUPLE_VALS_DISPATCH(1);
      CAF_TUPLE_VALS_DISPATCH(2);
      CAF_TUPLE_VALS_DISPATCH(3);
      CAF_TUPLE_VALS_DISPATCH(4);
      CAF_TUPLE_VALS_DISPATCH(5);
      CAF_TUPLE_VALS_DISPATCH(6);
      CAF_TUPLE_VALS_DISPATCH(7);
      CAF_TUPLE_VALS_DISPATCH(8);
      CAF_TUPLE_VALS_DISPATCH(9);
      default:
        // fall back to recursive dispatch function
        static constexpr size_t max_pos = sizeof...(Ts) - 1;
        tup_ptr_access_pos<(10 < max_pos ? 10 : max_pos), max_pos> first;
        return rec_dispatch(pos, f, first);
    }
  }

  template <class F, size_t N>
  auto rec_dispatch(size_t, F& f, tup_ptr_access_pos<N, N>)
  -> decltype(f(std::declval<int&>())) {
    return tuple_inspect_delegate<N, N>(data_, f);
  }

  template <class F, size_t X, size_t N>
  auto rec_dispatch(size_t pos, F& f, tup_ptr_access_pos<X, N> token)
  -> decltype(f(std::declval<int&>())) {
    return pos == X ? tuple_inspect_delegate<X, N>(data_, f)
                    : rec_dispatch(pos, f, next(token));
  }

  tuple_vals_impl* mptr() const {
    return const_cast<tuple_vals_impl*>(this);
  }

  data_type data_;
  std::array<rtti_pair, sizeof...(Ts)> types_;
};

template <class... Ts>
class tuple_vals : public tuple_vals_impl<message_data, Ts...> {
public:
  static_assert(sizeof...(Ts) > 0, "tuple_vals is not allowed to be empty");

  using super = tuple_vals_impl<message_data, Ts...>;

  using super::super;

  using super::copy;

  message_data::cow_ptr copy() const override {
    return message_data::cow_ptr(new tuple_vals(*this), false);
  }
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_TUPLE_VALS_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_TBIND_HPP
#define CAF_DETAIL_TBIND_HPP

namespace caf {
namespace detail {

template <template <class, typename> class Tpl, typename Arg1>
struct tbind {
  template <class Arg2>
  struct type {
    static constexpr bool value = Tpl<Arg1, Arg2>::value;
  };
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_TBIND_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_LIMITED_VECTOR_HPP
#define CAF_DETAIL_LIMITED_VECTOR_HPP

#include <cstddef>
#include <iterator>
#include <algorithm>
#include <stdexcept>
#include <type_traits>
#include <initializer_list>

#include "caf/config.hpp"

namespace caf {
namespace detail {

// A vector with a fixed maximum size (uses an array internally).
// @warning This implementation is highly optimized for arithmetic types and
template <class T, size_t MaxSize>
class limited_vector {
public:
  using value_type              = T;
  using size_type               = size_t;
  using difference_type         = ptrdiff_t;
  using reference               = value_type&;
  using const_reference         = const value_type&;
  using pointer                 = value_type*;
  using const_pointer           = const value_type*;
  using iterator                = pointer;
  using const_iterator          = const_pointer;
  using reverse_iterator        = std::reverse_iterator<iterator>;
  using const_reverse_iterator  = std::reverse_iterator<const_iterator>;

  limited_vector() : size_(0) {
    // nop
  }

  explicit limited_vector(size_t initial_size) : size_(initial_size) {
    T tmp;
    std::fill_n(begin(), initial_size, tmp);
  }

  limited_vector(const limited_vector& other) : size_(other.size_) {
    std::copy(other.begin(), other.end(), begin());
  }

  limited_vector& operator=(const limited_vector& other) {
    resize(other.size());
    std::copy(other.begin(), other.end(), begin());
    return *this;
  }

  void resize(size_type s) {
    CAF_ASSERT(s <= MaxSize);
    size_ = s;
  }

  explicit limited_vector(std::initializer_list<T> init) : size_(init.size()) {
    CAF_ASSERT(init.size() <= MaxSize);
    std::copy(init.begin(), init.end(), begin());
  }

  void assign(size_type count, const_reference value) {
    resize(count);
    std::fill(begin(), end(), value);
  }

  template <class InputIterator>
  void assign(InputIterator first, InputIterator last,
              // dummy SFINAE argument
              typename std::iterator_traits<InputIterator>::pointer = nullptr) {
    auto dist = std::distance(first, last);
    CAF_ASSERT(dist >= 0);
    resize(static_cast<size_t>(dist));
    std::copy(first, last, begin());
  }

  size_type size() const {
    return size_;
  }

  size_type max_size() const {
    return MaxSize;
  }

  size_type capacity() const {
    return max_size() - size();
  }

  void clear() {
    size_ = 0;
  }

  bool empty() const {
    return size_ == 0;
  }

  bool full() const {
    return size_ == MaxSize;
  }

  void push_back(const_reference what) {
    CAF_ASSERT(!full());
    data_[size_++] = what;
  }

  void pop_back() {
    CAF_ASSERT(!empty());
    --size_;
  }

  reference at(size_type pos) {
    CAF_ASSERT(pos < size_);
    return data_[pos];
  }

  const_reference at(size_type pos) const {
    CAF_ASSERT(pos < size_);
    return data_[pos];
  }

  reference operator[](size_type pos) {
    return at(pos);
  }

  const_reference operator[](size_type pos) const {
    return at(pos);
  }

  iterator begin() {
    return data_;
  }

  const_iterator begin() const {
    return data_;
  }

  const_iterator cbegin() const {
    return begin();
  }

  iterator end() {
    return begin() + size_;
  }

  const_iterator end() const {
    return begin() + size_;
  }

  const_iterator cend() const {
    return end();
  }

  reverse_iterator rbegin() {
    return reverse_iterator(end());
  }

  const_reverse_iterator rbegin() const {
    return reverse_iterator(end());
  }

  const_reverse_iterator crbegin() const {
    return rbegin();
  }

  reverse_iterator rend() {
    return reverse_iterator(begin());
  }

  const_reverse_iterator rend() const {
    return reverse_iterator(begin());
  }

  const_reverse_iterator crend() const {
    return rend();
  }

  reference front() {
    CAF_ASSERT(!empty());
    return data_[0];
  }

  const_reference front() const {
    CAF_ASSERT(!empty());
    return data_[0];
  }

  reference back() {
    CAF_ASSERT(!empty());
    return data_[size_ - 1];
  }

  const_reference back() const {
    CAF_ASSERT(!empty());
    return data_[size_ - 1];
  }

  T* data() {
    return data_;
  }

  const T* data() const {
    return data_;
  }

  template <class InputIterator>
  void insert(iterator pos, InputIterator first, InputIterator last) {
    CAF_ASSERT(first <= last);
    auto num_elements = static_cast<size_t>(std::distance(first, last));
    if ((size() + num_elements) > MaxSize) {
      CAF_RAISE_ERROR("limited_vector::insert: too much elements");
    }
    if (pos == end()) {
      resize(size() + num_elements);
      std::copy(first, last, pos);
    }
    else {
      // move elements
      auto old_end = end();
      resize(size() + num_elements);
      std::copy_backward(pos, old_end, end());
      // insert new elements
      std::copy(first, last, pos);
    }
  }

private:
  size_t size_;
  T data_[(MaxSize > 0) ? MaxSize : 1];
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_LIMITED_VECTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_EMBEDDED_HPP
#define CAF_DETAIL_EMBEDDED_HPP

#include "caf/ref_counted.hpp"
#include "caf/intrusive_ptr.hpp"

namespace caf {
namespace detail {

template <class Base>
class embedded final : public Base {
public:
  template <class... Ts>
  embedded(intrusive_ptr<ref_counted> storage, Ts&&... xs)
      : Base(std::forward<Ts>(xs)...),
        storage_(std::move(storage)) {
    // nop
  }

  ~embedded() {
    // nop
  }

  void request_deletion(bool) noexcept override {
    intrusive_ptr<ref_counted> guard;
    guard.swap(storage_);
    // this code assumes that embedded is part of pair_storage<>,
    // i.e., this object lives inside a union!
    this->~embedded();
  }

protected:
  intrusive_ptr<ref_counted> storage_;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_EMBEDDED_HPP

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ARG_WRAPPER_HPP
#define CAF_ARG_WRAPPER_HPP

#include <tuple>
#include <string>

#include "caf/detail/int_list.hpp"
#include "caf/detail/type_list.hpp"
#include "caf/detail/apply_args.hpp"
#include "caf/detail/type_traits.hpp"

namespace caf {
namespace detail {

/// Enables automagical string conversion for `CAF_ARG`.
template <class T>
struct arg_wrapper {
  const char* name;
  const T& value;
  arg_wrapper(const char* x, const T& y) : name(x), value(y) {
    // nop
  }
};

template <class... Ts>
struct named_args_tuple {
  const std::array<const char*, sizeof...(Ts)>& names;
  std::tuple<const Ts&...> xs;
};

template <class... Ts>
named_args_tuple<Ts...>
make_named_args_tuple(std::array<const char*, sizeof...(Ts)>& names,
                      const Ts&... xs) {
  return {names, std::forward_as_tuple(xs...)};
};

template <size_t I, class... Ts>
auto get(const named_args_tuple<Ts...>& x)
-> arg_wrapper<typename type_at<I, Ts...>::type>{
  CAF_ASSERT(x.names[I] != nullptr);
  return {x.names[I], std::get<I>(x.xs)};
}

/// Used to implement `CAF_ARG`.
template <class T>
static arg_wrapper<T> make_arg_wrapper(const char* name, const T& value) {
  return {name, value};
}

struct arg_wrapper_maker {
  template <class... Ts>
  auto operator()(const Ts&... xs) const -> decltype(std::make_tuple(xs...)) {
    return std::make_tuple(xs...);
  }
};

/// Used to implement `CAF_ARGS`.
template <class... Ts>
static std::tuple<arg_wrapper<Ts>...>
make_args_wrapper(std::array<const char*, sizeof...(Ts)> names,
                  const Ts&... xs) {
  arg_wrapper_maker f;
  typename il_range<0, sizeof...(Ts)>::type indices;
  auto tup = make_named_args_tuple(names, xs...);
  return apply_args(f, indices, tup);
}

} // namespace detail
} // namespace caf

#endif // CAF_ARG_WRAPPER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_TAIL_ARGUMENT_TOKEN_HPP
#define CAF_DETAIL_TAIL_ARGUMENT_TOKEN_HPP

namespace caf {
namespace detail {

struct tail_argument_token { };

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_TAIL_ARGUMENT_TOKEN_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_INTRUSIVE_PARTITIONED_LIST_HPP
#define CAF_DETAIL_INTRUSIVE_PARTITIONED_LIST_HPP

#include "caf/config.hpp"

#include <memory>
#include <iterator>
#include <algorithm>

#include "caf/behavior.hpp"
#include "caf/invoke_message_result.hpp"

namespace caf {
namespace detail {

/// Describes a partitioned list of elements. The first part
/// of the list is described by the iterator pair `[begin, separator)`.
/// The second part by `[continuation, end)`. Actors use the second half
/// of the list to store previously skipped elements. Priority-aware actors
/// also use the first half of the list to sort messages by priority.
template <class T, class Delete = std::default_delete<T>>
class intrusive_partitioned_list {
public:
  using value_type = T;
  using pointer = value_type*;
  using deleter_type = Delete;

  struct iterator : std::iterator<std::bidirectional_iterator_tag, value_type> {
    pointer ptr;

    iterator(pointer init = nullptr) : ptr(init) {
      // nop
    }

    iterator(const iterator&) = default;
    iterator& operator=(const iterator&) = default;

    iterator& operator++() {
      ptr = ptr->next;
      return *this;
    }

    iterator operator++(int) {
      iterator res = *this;
      ptr = ptr->next;
      return res;
    }

    iterator& operator--() {
      ptr = ptr->prev;
      return *this;
    }

    iterator operator--(int) {
      iterator res = *this;
      ptr = ptr->prev;
      return res;
    }

    const value_type& operator*() const {
      return *ptr;
    }

    value_type& operator*() {
      return *ptr;
    }

    pointer operator->() {
      return ptr;
    }

    bool operator==(const iterator& other) const {
      return ptr == other.ptr;
    }

    bool operator!=(const iterator& other) const {
      return ptr != other.ptr;
    }

    iterator next() const {
      return ptr->next;
    }
  };

  intrusive_partitioned_list() {
    head_.next = &separator_;
    separator_.prev = &head_;
    separator_.next = &tail_;
    tail_.prev = &separator_;
  }

  ~intrusive_partitioned_list() {
    clear();
  }

  iterator begin() {
    return head_.next;
  }

  iterator separator() {
    return &separator_;
  }

  iterator continuation() {
    return separator_.next;
  }

  iterator end() {
    return &tail_;
  }

  using range = std::pair<iterator, iterator>;

  /// Returns the two iterator pairs describing the first and second part
  /// of the partitioned list.
  std::array<range, 2> ranges() {
    return {{range{begin(), separator()}, range{continuation(), end()}}};
  }

  template <class F>
  void clear(F f) {
    for (auto& range : ranges()) {
      auto i = range.first;
      auto e = range.second;
      while (i != e) {
        auto ptr = i.ptr;
        ++i;
        f(*ptr);
        delete_(ptr);
      }
    }
    if (head_.next != &separator_) {
      head_.next = &separator_;
      separator_.prev = &head_;
    }
    if (separator_.next != &tail_) {
      separator_.next = &tail_;
      tail_.prev = &separator_;
    }
  }

  void clear() {
    auto nop = [](value_type&) {};
    clear(nop);
  }

  iterator insert(iterator next, pointer val) {
    auto prev = next->prev;
    val->prev = prev;
    val->next = next.ptr;
    prev->next = val;
    next->prev = val;
    return val;
  }

  bool empty() const {
    return head_.next == &separator_ && separator_.next == &tail_;
  }

  pointer take(iterator pos) {
    auto res = pos.ptr;
    auto next = res->next;
    auto prev = res->prev;
    prev->next = next;
    next->prev = prev;
    return res;
  }

  iterator erase(iterator pos) {
    auto next = pos->next;
    delete_(take(pos));
    return next;
  }

  size_t count(size_t max_count = std::numeric_limits<size_t>::max()) {
    size_t result = 0;
    for (auto& range : ranges())
      for (auto i = range.first; i != range.second; ++i)
        if (++result == max_count)
          return max_count;
    return result;
  }

private:
  value_type head_;
  value_type separator_;
  value_type tail_;
  deleter_type delete_;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_INTRUSIVE_PARTITIONED_LIST_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_TEST_ACTOR_CLOCK_HPP
#define CAF_DETAIL_TEST_ACTOR_CLOCK_HPP

#include "caf/detail/simple_actor_clock.hpp"

namespace caf {
namespace detail {

class test_actor_clock : public simple_actor_clock {
public:
  time_point current_time;

  time_point now() const noexcept override;

  /// Tries to dispatch the next timeout or delayed message regardless of its
  /// timestamp. Returns `false` if `schedule().empty()`, otherwise `true`.
  bool dispatch_once();

  /// Dispatches all timeouts and delayed messages regardless of their
  /// timestamp. Returns the number of dispatched events.
  size_t dispatch();

  /// Advances the time by `x` and dispatches timeouts and delayed messages.
  void advance_time(duration_type x);
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_TEST_ACTOR_CLOCK_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

/******************************************************************************\
 *      Based on http://beej.us/guide/bgnet/examples/pack2.c      *
\ ******************************************************************************/

#ifndef CAF_DETAIL_IEEE_754_HPP
#define CAF_DETAIL_IEEE_754_HPP

#include <cmath>
#include <cstdint>

namespace caf {
namespace detail {

template <class T>
struct ieee_754_trait;

template <>
struct ieee_754_trait<float> {
  static constexpr uint32_t bits = 32;   // number of bits
  static constexpr uint32_t expbits = 8; // bits used for exponent
  static constexpr float zero = 0.0f;    // the value 0
  static constexpr float p5 = 0.5f;      // the value 0.5
  using packed_type = uint32_t;          // unsigned integer type
  using signed_packed_type = int32_t;    // signed integer type
  using float_type = float;              // floating point type

};

template <>
struct ieee_754_trait<uint32_t> : ieee_754_trait<float> {};

template <>
struct ieee_754_trait<double> {
  static constexpr uint64_t bits = 64;
  static constexpr uint64_t expbits = 11;
  static constexpr double zero = 0.0;
  static constexpr double p5 = 0.5;
  using packed_type = uint64_t;
  using signed_packed_type = int64_t;
  using float_type = double;

};

template <>
struct ieee_754_trait<uint64_t> : ieee_754_trait<double> {};

template <class T>
typename ieee_754_trait<T>::packed_type pack754(T f) {
  using trait = ieee_754_trait<T>;
  using result_type = typename trait::packed_type;
  // filter special type
  if (std::fabs(f) <= trait::zero) {
    return 0; // only true if f equals +0 or -0
  }
  auto significandbits = trait::bits - trait::expbits - 1; // -1 for sign bit
  // check sign and begin normalization
  result_type sign;
  T fnorm;
  if (f < 0) {
    sign = 1;
    fnorm = -f;
  } else {
    sign = 0;
    fnorm = f;
  }
  // get the normalized form of f and track the exponent
  typename ieee_754_trait<T>::packed_type shift = 0;
  while (fnorm >= static_cast<T>(2)) {
    fnorm /= static_cast<T>(2);
    ++shift;
  }
  while (fnorm < static_cast<T>(1)) {
    fnorm *= static_cast<T>(2);
    --shift;
  }
  fnorm = fnorm - static_cast<T>(1);
  // calculate 2^significandbits
  auto pownum = static_cast<T>(result_type{1} << significandbits);
  // calculate the binary form (non-float) of the significand data
  auto significand = static_cast<result_type>(fnorm * (pownum + trait::p5));
  // get the biased exponent
  auto exp = shift + ((1 << (trait::expbits - 1)) - 1); // shift + bias
  // return the final answer
  return (sign << (trait::bits - 1))
         | (exp << (trait::bits - trait::expbits - 1)) | significand;
}

template <class T>
typename ieee_754_trait<T>::float_type unpack754(T i) {
  using trait = ieee_754_trait<T>;
  using signed_type = typename trait::signed_packed_type;
  using result_type = typename trait::float_type;
  if (i == 0) return trait::zero;
  auto significandbits = trait::bits - trait::expbits - 1; // -1 for sign bit
  // pull the significand: mask, convert back to float + add the one back on
  auto result = static_cast<result_type>(i & ((T{1} << significandbits) - 1));
  result /= static_cast<result_type>(T{1} << significandbits);
  result += static_cast<result_type>(1);
  // deal with the exponent
  auto si = static_cast<signed_type>(i);
  auto bias = (1 << (trait::expbits - 1)) - 1;
  auto pownum = static_cast<signed_type>(1) << trait::expbits;
  auto shift = static_cast<signed_type>(
    ((si >> significandbits) & (pownum - 1)) - bias);
  while (shift > 0) {
    result *= static_cast<result_type>(2);
    --shift;
  }
  while (shift < 0) {
    result /= static_cast<result_type>(2);
    ++shift;
  }
  // sign it
  result *= ((i >> (trait::bits - 1)) & 1) ? -1 : 1;
  return result;
}

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_IEEE_754_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_PRIVATE_THREAD_HPP
#define CAF_DETAIL_PRIVATE_THREAD_HPP

#include <atomic>
#include <mutex>
#include <condition_variable>

#include "caf/fwd.hpp"

namespace caf {
namespace detail {

class private_thread {
public:
  enum worker_state {
    active,
    shutdown_requested,
    await_resume_or_shutdown
  };

  explicit private_thread(scheduled_actor* self);

  void run();

  bool await_resume();

  void resume();

  void shutdown();

  static void exec(private_thread* this_ptr);

  void notify_self_destroyed();

  void await_self_destroyed();

  void start();

private:
  std::mutex mtx_;
  std::condition_variable cv_;
  std::atomic<bool> self_destroyed_;
  std::atomic<scheduled_actor*> self_;
  std::atomic<worker_state> state_;
  actor_system& system_;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_PRIVATE_THREAD_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_PSEUDO_TUPLE_HPP
#define CAF_DETAIL_PSEUDO_TUPLE_HPP

#include <cstddef>

#include "caf/param.hpp"
#include "caf/config.hpp"

#include "caf/detail/type_traits.hpp"

namespace caf {
namespace detail {

// tuple-like access to an array of void pointers that is
// also aware of the semantics of param<T>
template <class... Ts>
struct pseudo_tuple {
  using pointer = void*;
  using const_pointer = const void*;

  pointer data[sizeof...(Ts) > 0 ? sizeof...(Ts) : 1];

  bool shared_access;

  template <class Tuple>
  pseudo_tuple(const Tuple& xs) : data(), shared_access(xs.shared()) {
    CAF_ASSERT(sizeof...(Ts) == xs.size());
    for (size_t i = 0; i < xs.size(); ++i)
      data[i] = const_cast<void*>(xs.get(i));
  }

  inline const_pointer at(size_t p) const {
    return data[p];
  }

  inline pointer get_mutable(size_t p) {
    return data[p];
  }

  inline pointer& operator[](size_t p) {
    return data[p];
  }
};

template <class T>
struct pseudo_tuple_access {
  using result_type = T&;

  template <class Tuple>
  static T& get(Tuple& xs, size_t pos) {
    auto vp = xs.get_mutable(pos);
    CAF_ASSERT(vp != nullptr);
    return *reinterpret_cast<T*>(vp);
  }
};

template <class T>
struct pseudo_tuple_access<const T> {
  using result_type = const T&;

  template <class Tuple>
  static const T& get(const Tuple& xs, size_t pos) {
    auto vp = xs.at(pos);
    CAF_ASSERT(vp != nullptr);
    return *reinterpret_cast<const T*>(vp);
  }
};

template <class T>
struct pseudo_tuple_access<param<T>> {
  using result_type = param<T>;

  template <class Tuple>
  static result_type get(const Tuple& xs, size_t pos) {
    auto vp = xs.at(pos);
    CAF_ASSERT(vp != nullptr);
    return {vp, xs.shared_access};
  }
};

template <class T>
struct pseudo_tuple_access<const param<T>> : pseudo_tuple_access<param<T>> {
  // nop
};

template <size_t N, class... Ts>
typename pseudo_tuple_access<
  const typename detail::type_at<N, Ts...>::type
>::result_type
get(const detail::pseudo_tuple<Ts...>& tv) {
  static_assert(N < sizeof...(Ts), "N >= tv.size()");
  using f = pseudo_tuple_access<const typename detail::type_at<N, Ts...>::type>;
  return f::get(tv, N);
}

template <size_t N, class... Ts>
typename pseudo_tuple_access<
  typename detail::type_at<N, Ts...>::type
>::result_type
get(detail::pseudo_tuple<Ts...>& tv) {
  static_assert(N < sizeof...(Ts), "N >= tv.size()");
  using f = pseudo_tuple_access<typename detail::type_at<N, Ts...>::type>;
  return f::get(tv, N);
}

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_PSEUDO_TUPLE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_DEFAULT_INVOKE_VISITOR_HPP
#define CAF_DETAIL_DEFAULT_INVOKE_VISITOR_HPP

#include "caf/local_actor.hpp"

#include "caf/detail/invoke_result_visitor.hpp"

namespace caf {
namespace detail {

template <class Self>
class default_invoke_result_visitor : public invoke_result_visitor {
public:
  inline default_invoke_result_visitor(Self* ptr) : self_(ptr) {
    // nop
  }

  ~default_invoke_result_visitor() override {
    // nop
  }

  void operator()() override {
    // nop
  }

  void operator()(error& x) override {
    CAF_LOG_TRACE(CAF_ARG(x));
    delegate(x);
  }

  void operator()(message& x) override {
    CAF_LOG_TRACE(CAF_ARG(x));
    delegate(x);
  }

  void operator()(const none_t& x) override {
    CAF_LOG_TRACE(CAF_ARG(x));
    delegate(x);
  }

private:
  void deliver(response_promise& rp, error& x) {
    CAF_LOG_DEBUG("report error back to requesting actor");
    rp.deliver(std::move(x));
  }

  void deliver(response_promise& rp, message& x) {
    CAF_LOG_DEBUG("respond via response_promise");
    // suppress empty messages for asynchronous messages
    if (x.empty() && rp.async())
      return;
    rp.deliver(std::move(x));
  }

  void deliver(response_promise& rp, const none_t&) {
    error err = sec::unexpected_response;
    deliver(rp, err);
  }

  template <class T>
  void delegate(T& x) {
    auto rp = self_->make_response_promise();
    if (!rp.pending()) {
      CAF_LOG_DEBUG("suppress response message: invalid response promise");
      return;
    }
    deliver(rp, x);
  }

  Self* self_;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_DEFAULT_INVOKE_VISITOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_COMPARABLE_HPP
#define CAF_COMPARABLE_HPP

namespace caf {
namespace detail {

/// Barton–Nackman trick implementation.
/// `Subclass` must provide a compare member function that compares
/// to instances of `T` and returns an integer x with:
/// - `x < 0` if `*this < other`
/// - `x > 0` if `*this > other`
/// - `x == 0` if `*this == other`
template <class Subclass, class T = Subclass>
class comparable {
  friend bool operator==(const Subclass& lhs, const T& rhs) noexcept {
    return lhs.compare(rhs) == 0;
  }

  friend bool operator==(const T& lhs, const Subclass& rhs) noexcept {
    return rhs.compare(lhs) == 0;
  }

  friend bool operator!=(const Subclass& lhs, const T& rhs) noexcept {
    return lhs.compare(rhs) != 0;
  }

  friend bool operator!=(const T& lhs, const Subclass& rhs) noexcept {
    return rhs.compare(lhs) != 0;
  }

  friend bool operator<(const Subclass& lhs, const T& rhs) noexcept {
    return lhs.compare(rhs) < 0;
  }

  friend bool operator>(const Subclass& lhs, const T& rhs) noexcept {
    return lhs.compare(rhs) > 0;
  }

  friend bool operator<(const T& lhs, const Subclass& rhs) noexcept {
    return rhs > lhs;
  }

  friend bool operator>(const T& lhs, const Subclass& rhs) noexcept {
    return rhs < lhs;
  }

  friend bool operator<=(const Subclass& lhs, const T& rhs) noexcept {
    return lhs.compare(rhs) <= 0;
  }

  friend bool operator>=(const Subclass& lhs, const T& rhs) noexcept {
    return lhs.compare(rhs) >= 0;
  }

  friend bool operator<=(const T& lhs, const Subclass& rhs) noexcept {
    return rhs >= lhs;
  }

  friend bool operator>=(const T& lhs, const Subclass& rhs) noexcept {
    return rhs <= lhs;
  }
};

template <class Subclass>
class comparable<Subclass, Subclass> {
  friend bool operator==(const Subclass& lhs, const Subclass& rhs) noexcept {
    return lhs.compare(rhs) == 0;
  }

  friend bool operator!=(const Subclass& lhs, const Subclass& rhs) noexcept {
    return lhs.compare(rhs) != 0;
  }

  friend bool operator<(const Subclass& lhs, const Subclass& rhs) noexcept {
    return lhs.compare(rhs) < 0;
  }

  friend bool operator<=(const Subclass& lhs, const Subclass& rhs) noexcept {
    return lhs.compare(rhs) <= 0;
  }

  friend bool operator>(const Subclass& lhs, const Subclass& rhs) noexcept {
    return lhs.compare(rhs) > 0;
  }

  friend bool operator>=(const Subclass& lhs, const Subclass& rhs) noexcept {
    return lhs.compare(rhs) >= 0;
  }
};

} // namespace details
} // namespace caf

#endif // CAF_COMPARABLE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_SQUASHED_INT_HPP
#define CAF_DETAIL_SQUASHED_INT_HPP

#include <cstdint>
#include <type_traits>

#include "caf/detail/type_list.hpp"

namespace caf {
namespace detail {

/// Compile-time list of integer types types.
using int_types_by_size =
  detail::type_list<                      // bytes
    void,                                 // 0
    detail::type_pair<int8_t, uint8_t>,   // 1
    detail::type_pair<int16_t, uint16_t>, // 2
    void,                                 // 3
    detail::type_pair<int32_t, uint32_t>, // 4
    void,                                 // 5
    void,                                 // 6
    void,                                 // 7
    detail::type_pair<int64_t, uint64_t>  // 8
  >;

/// Squashes integer types into [u]int_[8|16|32|64]_t equivalents
template <class T>
struct squashed_int {
  using tpair = typename detail::tl_at<int_types_by_size, sizeof(T)>::type;
  using type = 
    typename std::conditional<
      std::is_signed<T>::value,
      typename tpair::first,
      typename tpair::second
    >::type;
};

template <class T>
using squashed_int_t = typename squashed_int<T>::type;

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_SQUASHED_INT_HPP

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_ENUM_TO_STRING_HPP
#define CAF_DETAIL_ENUM_TO_STRING_HPP

#include <type_traits>

namespace caf {
namespace detail {

/// Converts x to its underlying type and fetches the name from the
/// lookup table. Assumes consecutive enum values.
template <class E, size_t N>
const char* enum_to_string(E x, const char* (&lookup_table)[N]) {
  auto index = static_cast<typename std::underlying_type<E>::type>(x);
  return index < N ? lookup_table[index] : "<unknown>";
}

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_ENUM_TO_STRING_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_MESSAGE_DATA_HPP
#define CAF_DETAIL_MESSAGE_DATA_HPP

#include <string>
#include <iterator>
#include <typeinfo>


#include "caf/fwd.hpp"
#include "caf/config.hpp"
#include "caf/ref_counted.hpp"
#include "caf/intrusive_ptr.hpp"
#include "caf/type_erased_tuple.hpp"

#include "caf/detail/type_list.hpp"

namespace caf {
namespace detail {

class message_data : public ref_counted, public type_erased_tuple {
public:
  // -- nested types -----------------------------------------------------------

  class cow_ptr;

  // -- constructors, destructors, and assignment operators --------------------

  message_data() = default;
  message_data(const message_data&) = default;

  ~message_data() override;

  // -- pure virtual observers -------------------------------------------------

  virtual cow_ptr copy() const = 0;

  // -- observers --------------------------------------------------------------

  using type_erased_tuple::copy;

  bool shared() const noexcept override;
};

class message_data::cow_ptr {
public:
  // -- constructors, destructors, and assignment operators ------------------

  cow_ptr() noexcept = default;
  cow_ptr(cow_ptr&&) noexcept = default;
  cow_ptr(const cow_ptr&) noexcept = default;
  cow_ptr& operator=(cow_ptr&&) noexcept = default;
  cow_ptr& operator=(const cow_ptr&) noexcept = default;

  template <class T>
  cow_ptr(intrusive_ptr<T> p) noexcept : ptr_(std::move(p)) {
    // nop
  }

  inline cow_ptr(message_data* ptr, bool add_ref) noexcept
      : ptr_(ptr, add_ref) {
    // nop
  }

  // -- modifiers ------------------------------------------------------------

  inline void swap(cow_ptr& other) noexcept {
    ptr_.swap(other.ptr_);
  }

  inline void reset(message_data* p = nullptr, bool add_ref = true) noexcept {
    ptr_.reset(p, add_ref);
  }

  inline message_data* release() noexcept {
    return ptr_.detach();
  }

  inline void unshare() {
    static_cast<void>(get_unshared());
  }

  inline message_data* operator->() {
    return get_unshared();
  }

  inline message_data& operator*() {
    return *get_unshared();
  }

  /// Returns the raw pointer. Callers are responsible for unsharing
  /// the content if necessary.
  inline message_data* raw_ptr() {
    return ptr_.get();
  }

  // -- observers ------------------------------------------------------------

  inline const message_data* operator->() const noexcept {
    return ptr_.get();
  }

  inline const message_data& operator*() const noexcept {
    return *ptr_;
  }

  inline explicit operator bool() const noexcept {
    return static_cast<bool>(ptr_);
  }

  inline message_data* get() const noexcept {
    return ptr_.get();
  }

private:
  message_data* get_unshared();
  intrusive_ptr<message_data> ptr_;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_MESSAGE_DATA_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_ATOM_VAL_HPP
#define CAF_DETAIL_ATOM_VAL_HPP

namespace caf {
namespace detail {

namespace {

// encodes ASCII characters to 6bit encoding
constexpr unsigned char encoding_table[] = {
/*     ..0 ..1 ..2 ..3 ..4 ..5 ..6 ..7 ..8 ..9 ..A ..B ..C ..D ..E ..F  */
/* 0.. */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
/* 1.. */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
/* 2.. */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
/* 3.. */  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 0,  0,  0,  0,  0,  0,
/* 4.. */  0, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
/* 5.. */ 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,  0,  0,  0,  0, 37,
/* 6.. */  0, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
/* 7.. */ 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,  0,  0,  0,  0,  0};

// decodes 6bit characters to ASCII
constexpr char decoding_table[] = " 0123456789"
                                  "ABCDEFGHIJKLMNOPQRSTUVWXYZ_"
                                  "abcdefghijklmnopqrstuvwxyz";

} // namespace <anonymous>

constexpr uint64_t next_interim(uint64_t current, size_t char_code) {
  return (current << 6) | encoding_table[(char_code <= 0x7F) ? char_code : 0];
}

constexpr uint64_t atom_val(const char* cstr, uint64_t interim = 0xF) {
  return (*cstr == '\0') ?
         interim :
         atom_val(cstr + 1,
            next_interim(interim, static_cast<size_t>(*cstr)));
}

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_ATOM_VAL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_TYPE_TRAITS_HPP
#define CAF_DETAIL_TYPE_TRAITS_HPP

#include <tuple>
#include <chrono>
#include <string>
#include <vector>
#include <utility>
#include <functional>
#include <type_traits>

#include "caf/fwd.hpp"
#include "caf/timestamp.hpp"

#include "caf/detail/type_list.hpp"

#define CAF_HAS_MEMBER_TRAIT(name)                                             \
template <class T>                                                             \
struct has_##name##_member {                                                   \
  template <class U>                                                           \
  static auto sfinae(U* x) -> decltype(x->name(), std::true_type());           \
                                                                               \
  template <class U>                                                           \
  static auto sfinae(...) -> std::false_type;                                  \
                                                                               \
  using type = decltype(sfinae<T>(nullptr));                                   \
  static constexpr bool value = type::value;                                   \
}

namespace caf {
namespace detail {

template <class T>
using decay_t = typename std::decay<T>::type;

template <bool V, class T = void>
using enable_if_t = typename std::enable_if<V, T>::type;

template <class Trait, class T = void>
using enable_if_tt = typename std::enable_if<Trait::value, T>::type;

/// Checks whether `T` is inspectable by `Inspector`.
template <class Inspector, class T>
class is_inspectable {
private:
  template <class U>
  static auto sfinae(Inspector& x, U& y) -> decltype(inspect(x, y));

  static std::false_type sfinae(Inspector&, ...);

  using result_type = decltype(sfinae(std::declval<Inspector&>(),
                                      std::declval<T&>()));

public:
  static constexpr bool value = !std::is_same<result_type, std::false_type>::value;
};

/// Checks whether `T` defines a free function `to_string`.
template <class T>
class has_to_string {
private:
  template <class U>
  static auto sfinae(const U& x) -> decltype(to_string(x));

  static void sfinae(...);

  using result = decltype(sfinae(std::declval<const T&>()));

public:
  static constexpr bool value = std::is_convertible<result, std::string>::value;
};

// pointers are never inspectable
template <class Inspector, class T>
struct is_inspectable<Inspector, T*> : std::false_type {};

template <bool X>
using bool_token = std::integral_constant<bool, X>;

template <int X>
using int_token = std::integral_constant<int, X>;

/// Joins all bool constants using operator &&.
template <bool... BoolConstants>
struct conjunction;

template <>
struct conjunction<> {
  static constexpr bool value = true;
};

template <bool X, bool... Xs>
struct conjunction<X, Xs...> {
  static constexpr bool value = X && conjunction<Xs...>::value;
};

/// Joins all bool constants using operator ||.
template <bool... BoolConstants>
struct disjunction;

template <>
struct disjunction<> {
  static constexpr bool value = false;
};

template <bool X, bool... Xs>
struct disjunction<X, Xs...> {
  static constexpr bool value = X || disjunction<Xs...>::value;
};

/// Checks wheter `X` is in the template parameter pack Ts.
template <class X, class... Ts>
struct is_one_of;

template <class X>
struct is_one_of<X> : std::false_type {};

template <class X, class... Ts>
struct is_one_of<X, X, Ts...> : std::true_type {};

template <class X, typename T0, class... Ts>
struct is_one_of<X, T0, Ts...> : is_one_of<X, Ts...> {};

/// Checks whether `T` is a `std::chrono::duration`.
template <class T>
struct is_duration : std::false_type {};

template <class Period, class Rep>
struct is_duration<std::chrono::duration<Period, Rep>> : std::true_type {};

/// Checks whether `T` is considered a builtin type.
///
/// Builtin types are: (1) all arithmetic types (including time types), (2)
/// string types from the STL, and (3) built-in types such as `actor_ptr`.
template <class T>
struct is_builtin {
  static constexpr bool value = std::is_arithmetic<T>::value
                                || is_duration<T>::value
                                || is_one_of<T, timestamp, std::string,
                                             std::u16string, std::u32string,
                                             atom_value, message, actor, group,
                                             node_id>::value;
};

/// Checks whether `T` is primitive, i.e., either an arithmetic type or
/// convertible to one of STL's string types.
template <class T>
struct is_primitive {
  static constexpr bool value = std::is_arithmetic<T>::value
                                || std::is_convertible<T, std::string>::value
                                || std::is_convertible<T, std::u16string>::value
                                || std::is_convertible<T, std::u32string>::value
                                || std::is_convertible<T, atom_value>::value;
};

/// Checks whether `T1` is comparable with `T2`.
template <class T1, typename T2>
class is_comparable {
  // SFINAE: If you pass a "bool*" as third argument, then
  //     decltype(cmp_help_fun(...)) is bool if there's an
  //     operator==(A, B) because
  //     cmp_help_fun(A*, B*, bool*) is a better match than
  //     cmp_help_fun(A*, B*, void*). If there's no operator==(A, B)
  //     available, then cmp_help_fun(A*, B*, void*) is the only
  //     candidate and thus decltype(cmp_help_fun(...)) is void.
  template <class A, typename B>
  static bool cmp_help_fun(const A* arg0, const B* arg1,
                           decltype(*arg0 == *arg1)* = nullptr);

  template <class A, typename B>
  static void cmp_help_fun(const A*, const B*, void* = nullptr);

  using result_type = decltype(cmp_help_fun(static_cast<T1*>(nullptr),
                                            static_cast<T2*>(nullptr),
                                            static_cast<bool*>(nullptr)));
public:
  static constexpr bool value = std::is_same<bool, result_type>::value;
};

/// Checks wheter `T` behaves like a forward iterator.
template <class T>
class is_forward_iterator {
  template <class C>
  static bool sfinae(C& x, C& y,
                     // check for operator*
                     decay_t<decltype(*x)>* = nullptr,
                     // check for operator++ returning an iterator
                     decay_t<decltype(x = ++y)>* = nullptr,
                     // check for operator==
                     decay_t<decltype(x == y)>* = nullptr,
                     // check for operator!=
                     decay_t<decltype(x != y)>* = nullptr);

  static void sfinae(...);

  using result_type = decltype(sfinae(std::declval<T&>(), std::declval<T&>()));

public:
  static constexpr bool value = std::is_same<bool, result_type>::value;
};

/// Checks whether `T` has `begin()` and `end()` member
/// functions returning forward iterators.
template <class T>
class is_iterable {
  // this horrible code would just disappear if we had concepts
  template <class C>
  static bool sfinae(C* cc,
                     // check if 'C::begin()' returns a forward iterator
                     enable_if_tt<is_forward_iterator<decltype(cc->begin())>>* = nullptr,
                     // check if begin() and end() both exist and are comparable
                     decltype(cc->begin() != cc->end())* = nullptr);

  // SFNINAE default
  static void sfinae(void*);

  using result_type = decltype(sfinae(static_cast<decay_t<T>*>(nullptr)));

public:
  static constexpr bool value = is_primitive<T>::value == false
                                && std::is_same<bool, result_type>::value;
};

template <class T>
constexpr bool is_iterable<T>::value;

/// Checks whether T is a contiguous sequence of byte.
template <class T>
struct is_byte_sequence : std::false_type { };

template <>
struct is_byte_sequence<std::vector<char>> : std::true_type { };

template <>
struct is_byte_sequence<std::vector<unsigned char>> : std::true_type { };

template <>
struct is_byte_sequence<std::string> : std::true_type { };

/// Checks whether `T` provides either a free function or a member function for
/// serialization. The checks test whether both serialization and
/// deserialization can succeed. The meta function tests the following
/// functions with `Processor` being both `serializer` and `deserializer` and
/// returns an integral constant if and only if the test succeeds for both.
///
/// - `serialize(Processor&, T&, const unsigned int)`
/// - `serialize(Processor&, T&)`
/// - `T::serialize(Processor&, const unsigned int)`.
/// - `T::serialize(Processor&)`.
template <class T,
          bool Ignore = std::is_pointer<T>::value
                        || std::is_function<T>::value>
struct has_serialize {
  template <class U>
  static auto test_serialize(caf::serializer* sink, U* x, unsigned int y = 0)
  -> decltype(serialize(*sink, *x, y));

  template <class U>
  static auto test_serialize(caf::serializer* sink, U* x)
  -> decltype(serialize(*sink, *x));

  template <class>
  static auto test_serialize(...) -> std::false_type;

  template <class U>
  static auto test_deserialize(caf::deserializer* source, U* x, unsigned int y = 0)
  -> decltype(serialize(*source, *x, y));

  template <class U>
  static auto test_deserialize(caf::deserializer* source, U* x)
  -> decltype(serialize(*source, *x));

  template <class>
  static auto test_deserialize(...) -> std::false_type;

  using serialize_type = decltype(test_serialize<T>(nullptr, nullptr));
  using deserialize_type = decltype(test_deserialize<T>(nullptr, nullptr));
  using type = std::integral_constant<
    bool,
    std::is_same<serialize_type, void>::value
    && std::is_same<deserialize_type, void>::value
  >;

  static constexpr bool value = type::value;
};

template <class T>
struct has_serialize<T, true> {
  static constexpr bool value = false;
};

/// Any inspectable type is considered to be serializable.
template <class T>
struct is_serializable;

template <class T,
          bool IsIterable = is_iterable<T>::value,
          bool Ignore = std::is_pointer<T>::value
                        || std::is_function<T>::value>
struct is_serializable_impl;


/// Checks whether `T` is builtin or provides a `serialize`
/// (free or member) function.
template <class T>
struct is_serializable_impl<T, false, false> {
  static constexpr bool value = has_serialize<T>::value
                                || is_inspectable<serializer, T>::value
                                || is_builtin<T>::value;
};

template <class F, class S>
struct is_serializable_impl<std::pair<F, S>, false, false> {
  static constexpr bool value = is_serializable<F>::value
                                && is_serializable<S>::value;
};

template <class... Ts>
struct is_serializable_impl<std::tuple<Ts...>, false, false> {
  static constexpr bool value = conjunction<
                                  is_serializable<Ts>::value...
                                >::value;
};

template <class T>
struct is_serializable_impl<T, true, false> {
  using value_type = typename T::value_type;
  static constexpr bool value = is_serializable<value_type>::value;
};

template <class T, size_t S>
struct is_serializable_impl<T[S], false, false> {
  static constexpr bool value = is_serializable<T>::value;
};

template <class T, bool IsIterable>
struct is_serializable_impl<T, IsIterable, true> {
  static constexpr bool value = false;
};

/// Checks whether `T` is builtin or provides a `serialize`
/// (free or member) function.
template <class T>
struct is_serializable {
  static constexpr bool value = is_serializable_impl<T>::value
                                || is_inspectable<serializer, T>::value
                                || std::is_empty<T>::value
                                || std::is_enum<T>::value;
};

template <>
struct is_serializable<bool> : std::true_type  {
  // nop
};

template <class T>
struct is_serializable<T&> : is_serializable<T> {
  // nop
};

template <class T>
struct is_serializable<const T> : is_serializable<T> {
  // nop
};

template <class T>
struct is_serializable<const T&> : is_serializable<T> {
  // nop
};

/// Checks wheter `T` is a non-const reference.
template <class T>
struct is_mutable_ref : std::false_type { };

template <class T>
struct is_mutable_ref<const T&> : std::false_type { };

template <class T>
struct is_mutable_ref<T&> : std::true_type { };

/// Defines `result_type,` `arg_types,` and `fun_type`. Functor is
///    (a) a member function pointer, (b) a function,
///    (c) a function pointer, (d) an std::function.
///
/// `result_type` is the result type found in the signature.
/// `arg_types` are the argument types as {@link type_list}.
/// `fun_type` is an std::function with an equivalent signature.
template <class Functor>
struct callable_trait;

// good ol' function
template <class R, class... Ts>
struct callable_trait<R (Ts...)> {
  using result_type = R;
  using arg_types = type_list<Ts...>;
  using fun_sig = R (Ts...);
  using fun_type = std::function<R (Ts...)>;
};

// member const function pointer
template <class C, typename R, class... Ts>
struct callable_trait<R (C::*)(Ts...) const> : callable_trait<R (Ts...)> {};

// member function pointer
template <class C, typename R, class... Ts>
struct callable_trait<R (C::*)(Ts...)> : callable_trait<R (Ts...)> {};

// good ol' function pointer
template <class R, class... Ts>
struct callable_trait<R (*)(Ts...)> : callable_trait<R (Ts...)> {};

template <class T>
struct has_apply_operator {
  template <class U>
  static auto sfinae(U*) -> decltype(&U::operator(), std::true_type());

  template <class U>
  static auto sfinae(...) -> std::false_type;

  using type = decltype(sfinae<T>(nullptr));
  static constexpr bool value = type::value;
};

// matches (IsFun || IsMemberFun)
template <class T,
          bool IsFun = std::is_function<T>::value
                       || std::is_function<
                            typename std::remove_pointer<T>::type
                          >::value
                       || std::is_member_function_pointer<T>::value,
          bool HasApplyOp = has_apply_operator<T>::value>
struct get_callable_trait_helper {
  using type = callable_trait<T>;
  using result_type = typename type::result_type;
  using arg_types = typename type::arg_types;
  using fun_type = typename type::fun_type;
  using fun_sig = typename type::fun_sig;
  static constexpr size_t num_args = tl_size<arg_types>::value;
};

// assume functor providing operator()
template <class T>
struct get_callable_trait_helper<T, false, true> {
  using type = callable_trait<decltype(&T::operator())>;
  using result_type = typename type::result_type;
  using arg_types = typename type::arg_types;
  using fun_type = typename type::fun_type;
  using fun_sig = typename type::fun_sig;
  static constexpr size_t num_args = tl_size<arg_types>::value;
};

template <class T>
struct get_callable_trait_helper<T, false, false> {};

/// Gets a callable trait for `T,` where `T` is a function object type,
/// i.e., a function, member function, or a class providing
/// the call operator.
template <class T>
struct get_callable_trait : get_callable_trait_helper<decay_t<T>> {};

/// Checks wheter `T` is a function or member function.
template <class T>
struct is_callable {
  template <class C>
  static bool _fun(C*, typename get_callable_trait<C>::type* = nullptr);

  static void _fun(void*);

  using result_type = decltype(_fun(static_cast<decay_t<T>*>(nullptr)));

public:
  static constexpr bool value = std::is_same<bool, result_type>::value;
};

/// Checks wheter `F` takes mutable references.
///
/// A manipulator is a functor that manipulates its arguments via
/// mutable references.
template <class F>
struct is_manipulator {
  static constexpr bool value =
    tl_exists<typename get_callable_trait<F>::arg_types, is_mutable_ref>::value;
};

/// Gets the Nth element of the template parameter pack `Ts`.
template <size_t N, class... Ts>
struct type_at;

template <size_t N, typename T0, class... Ts>
struct type_at<N, T0, Ts...> {
  using type = typename type_at<N - 1, Ts...>::type;
};

template <class T0, class... Ts>
struct type_at<0, T0, Ts...> {
  using type = T0;
};

// Checks whether T has a member variable named `name`.
template <class T, bool IsScalar = std::is_scalar<T>::value>
class has_name {
private:
  // a simple struct with a member called `name`
  struct fallback {
    int name;
  };

  // creates an ambiguity for any `T` with the requested member
  struct derived : T, fallback {
    // no members
  };

  // picked for any U without requested member since `U::name` is not ambigious
  template <class U>
  static char fun(U*, decltype(U::name)* = nullptr);

  // picked for any U with requested member since `U::name` is ambigious
  static int fun(void*);

public:
  static constexpr bool value = sizeof(fun(static_cast<derived*>(nullptr))) > 1;
};

template <class T>
class has_name<T, true> {
public:
  static constexpr bool value = false;
};

CAF_HAS_MEMBER_TRAIT(size);
CAF_HAS_MEMBER_TRAIT(data);

/// Checks whether F is convertible to either `std::function<void (T&)>`
/// or `std::function<void (const T&)>`.
template <class F, class T>
struct is_handler_for {
  static constexpr bool value =
      std::is_convertible<F, std::function<void (T&)>>::value
      || std::is_convertible<F, std::function<void (const T&)>>::value;
};

template <class T>
struct value_type_of {
  using type = typename T::value_type;
};

template <class T>
struct value_type_of<T*> {
  using type = T;
};

template <class T>
using value_type_of_t = typename value_type_of<T>::type;

template <class T>
using is_callable_t = typename std::enable_if<is_callable<T>::value>::type;

template <class F, class T>
using is_handler_for_ef =
  typename std::enable_if<is_handler_for<F, T>::value>::type;

template <class T>
struct strip_reference_wrapper {
  using type = T;
};

template <class T>
struct strip_reference_wrapper<std::reference_wrapper<T>> {
  using type = T;
};

template <class T>
constexpr bool can_insert_elements_impl(
  T*,
  decltype(std::declval<T&>()
           .insert(std::declval<T&>().end(),
                   std::declval<typename T::value_type>()))* = nullptr) {
  return true;
}

template <class T>
constexpr bool can_insert_elements_impl(void*) {
  return false;
}

template <class T>
constexpr bool can_insert_elements() {
  return can_insert_elements_impl<T>(static_cast<T*>(nullptr));
}

/// Checks whether `Tpl` is a specialization of `T` or not.
template <template <class...> class Tpl, class T>
struct is_specialization : std::false_type { };

template <template <class...> class T, class... Ts>
struct is_specialization<T, T<Ts...>> : std::true_type { };

/// Transfers const from `T` to `U`. `U` remains unchanged if `T` is not const.
template <class T, class U>
struct transfer_const {
  using type = U;
};

template <class T, class U>
struct transfer_const<const T, U> {
  using type = const U;
};

template <class T, class U>
using transfer_const_t = typename transfer_const<T, U>::type;

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_TYPE_TRAITS_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_BLOCKING_BEHAVIOR_HPP
#define CAF_BLOCKING_BEHAVIOR_HPP

#include "caf/behavior.hpp"
#include "caf/catch_all.hpp"
#include "caf/timeout_definition.hpp"

namespace caf {
namespace detail {

class blocking_behavior {
public:
  behavior& nested;

  blocking_behavior(behavior& x);
  blocking_behavior(blocking_behavior&&) = default;

  virtual ~blocking_behavior();

  virtual result<message> fallback(message_view&);

  virtual duration timeout();

  virtual void handle_timeout();
};

template <class F>
class blocking_behavior_v2 : public blocking_behavior {
public:
  catch_all<F> f;

  blocking_behavior_v2(behavior& x, catch_all<F> y)
      : blocking_behavior(x),
        f(std::move(y)) {
    // nop
  }

  blocking_behavior_v2(blocking_behavior_v2&&) = default;

  result<message> fallback(message_view& x) override {
    return f.handler(x);
  }
};

template <class F>
class blocking_behavior_v3 : public blocking_behavior {
public:
  timeout_definition<F> f;

  blocking_behavior_v3(behavior& x, timeout_definition<F> y)
      : blocking_behavior(x),
        f(std::move(y)) {
    // nop
  }

  blocking_behavior_v3(blocking_behavior_v3&&) = default;

  duration timeout() override {
    return f.timeout;
  }

  void handle_timeout() override {
    f.handler();
  }
};

template <class F1, class F2>
class blocking_behavior_v4 : public blocking_behavior {
public:
  catch_all<F1> f1;
  timeout_definition<F2> f2;

  blocking_behavior_v4(behavior& x, catch_all<F1> y, timeout_definition<F2> z)
      : blocking_behavior(x),
        f1(std::move(y)),
        f2(std::move(z)) {
    // nop
  }

  blocking_behavior_v4(blocking_behavior_v4&&) = default;

  result<message> fallback(message_view& x) override {
    return f1.handler(x);
  }

  duration timeout() override {
    return f2.timeout;
  }

  void handle_timeout() override {
    f2.handler();
  }
};

struct make_blocking_behavior_t {
  constexpr make_blocking_behavior_t() {
    // nop
  }

  inline blocking_behavior operator()(behavior* x) const {
    CAF_ASSERT(x != nullptr);
    return {*x};
  }

  template <class F>
  blocking_behavior_v2<F> operator()(behavior* x, catch_all<F> y) const {
    CAF_ASSERT(x != nullptr);
    return {*x, std::move(y)};
  }

  template <class F>
  blocking_behavior_v3<F> operator()(behavior* x,
                                     timeout_definition<F> y) const {
    CAF_ASSERT(x != nullptr);
    return {*x, std::move(y)};
  }

  template <class F1, class F2>
  blocking_behavior_v4<F1, F2> operator()(behavior* x, catch_all<F1> y,
                                          timeout_definition<F2> z) const {
    CAF_ASSERT(x != nullptr);
    return {*x, std::move(y), std::move(z)};
  }
};

constexpr make_blocking_behavior_t make_blocking_behavior = make_blocking_behavior_t{};

} // namespace detail
} // namespace caf

#endif // CAF_BLOCKING_BEHAVIOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_TYPED_ACTOR_DETAIL_HPP
#define CAF_DETAIL_TYPED_ACTOR_DETAIL_HPP

#include <tuple>

#include "caf/delegated.hpp"
#include "caf/replies_to.hpp"
#include "caf/system_messages.hpp"

#include "caf/detail/type_list.hpp"

namespace caf { // forward declarations

template <class... Ts>
class typed_actor;

} // namespace caf

namespace caf {
namespace detail {

template <class Arguments, class Signature>
struct input_is_eval_impl : std::false_type {};

template <class Arguments, class Out>
struct input_is_eval_impl<Arguments, typed_mpi<Arguments, Out>> : std::true_type {};

template <class Arguments>
struct input_is {
  template <class Signature>
  struct eval : input_is_eval_impl<Arguments, Signature> { };
};

template <class Output, class F>
struct type_checker {
  static void check() {
    using arg_types =
      typename tl_map<
        typename get_callable_trait<F>::arg_types,
        std::decay
      >::type;
    static_assert(std::is_same<Output, arg_types>::value
                  || (std::is_same<Output, type_list<void>>::value
                     && std::is_same<arg_types, type_list<>>::value),
                  "wrong functor signature");
  }
};


template <class F>
struct type_checker<message, F> {
  static void check() {
    // nop
  }
};

/// Generates an error using static_assert on an interface mismatch.
/// @tparam NumMessageHandlers The number of message handlers
///                            provided by the user.
/// @tparam Pos The index at which an error was detected or a negative value
///             if too many or too few handlers were provided.
/// @tparam RemainingXs The remaining deduced messaging interfaces of the
///                     provided message handlers at the time of the error.
/// @tparam RemainingYs The remaining unimplemented message handler
///                     signatures at the time of the error.
template <int NumMessageHandlers, int Pos, class RemainingXs, class RemainingYs>
struct static_error_printer {
  static_assert(NumMessageHandlers == Pos,
                "unexpected handler some index > 20");
};

template <int N, class Xs, class Ys>
struct static_error_printer<N, -2, Xs, Ys> {
  static_assert(N == -1, "too many message handlers");
};

template <int N, class Xs, class Ys>
struct static_error_printer<N, -1, Xs, Ys> {
  static_assert(N == -1, "not enough message handlers");
};

#define CAF_STATICERR(x)                                                       \
  template <int N, class Xs, class Ys>                                         \
  struct static_error_printer<N, x, Xs, Ys> {                                  \
    static_assert(N == x, "unexpected handler at index " #x );                 \
  }

CAF_STATICERR( 0); CAF_STATICERR( 1); CAF_STATICERR( 2);
CAF_STATICERR( 3); CAF_STATICERR( 4); CAF_STATICERR( 5);
CAF_STATICERR( 6); CAF_STATICERR( 7); CAF_STATICERR( 8);
CAF_STATICERR( 9); CAF_STATICERR(10); CAF_STATICERR(11);
CAF_STATICERR(12); CAF_STATICERR(13); CAF_STATICERR(14);
CAF_STATICERR(15); CAF_STATICERR(16); CAF_STATICERR(17);
CAF_STATICERR(18); CAF_STATICERR(19); CAF_STATICERR(20);

template <class... Ts>
struct extend_with_helper;

template <class... Xs>
struct extend_with_helper<typed_actor<Xs...>> {
  using type = typed_actor<Xs...>;
};

template <class... Xs, class... Ys, class... Ts>
struct extend_with_helper<typed_actor<Xs...>, typed_actor<Ys...>, Ts...>
  : extend_with_helper<typed_actor<Xs..., Ys...>, Ts...> {
  // nop
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_TYPED_ACTOR_DETAIL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_NETWORK_ORDER_HPP
#define CAF_DETAIL_NETWORK_ORDER_HPP

#include "caf/config.hpp"

namespace caf {
namespace detail {

#ifdef CAF_MSVC // we assume Windows is always little endian

inline uint16_t to_network_order(uint16_t value) {
  return _byteswap_ushort(value);
}

inline uint32_t to_network_order(uint32_t value) {
  return _byteswap_ulong(value);
}

inline uint64_t to_network_order(uint64_t value) {
  return _byteswap_uint64(value);
}

#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__

inline uint16_t to_network_order(uint16_t value) {
  return __builtin_bswap16(value);
}

inline uint32_t to_network_order(uint32_t value) {
  return __builtin_bswap32(value);
}

inline uint64_t to_network_order(uint64_t value) {
  return __builtin_bswap64(value);
}

#else

template <class T>
inline T to_network_order(T value) {
  return value;
}

#endif

template <class T>
inline T from_network_order(T value) {
  // swapping the bytes again gives the native order
  return to_network_order(value);
}

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_NETWORK_ORDER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_BEHAVIOR_STACK_HPP
#define CAF_DETAIL_BEHAVIOR_STACK_HPP

#include <vector>
#include <memory>
#include <utility>
#include <algorithm>

#include "caf/optional.hpp"

#include "caf/config.hpp"
#include "caf/behavior.hpp"
#include "caf/message_id.hpp"
#include "caf/mailbox_element.hpp"

namespace caf {
namespace detail {

struct behavior_stack_mover;

class behavior_stack {
public:
  friend struct behavior_stack_mover;

  behavior_stack(const behavior_stack&) = delete;
  behavior_stack& operator=(const behavior_stack&) = delete;

  behavior_stack() = default;

  // erases the last (asynchronous) behavior
  void pop_back();

  void clear();

  inline bool empty() const {
    return elements_.empty();
  }

  inline behavior& back() {
    CAF_ASSERT(!empty());
    return elements_.back();
  }

  inline void push_back(behavior&& what) {
    elements_.emplace_back(std::move(what));
  }

  template <class... Ts>
    inline void emplace_back(Ts&&... xs) {
      elements_.emplace_back(std::forward<Ts>(xs)...);
    }

  inline void cleanup() {
    erased_elements_.clear();
  }

private:
  std::vector<behavior> elements_;
  std::vector<behavior> erased_elements_;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_BEHAVIOR_STACK_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_PULL5_GATHERER_HPP
#define CAF_PULL5_GATHERER_HPP

#include "caf/random_gatherer.hpp"

namespace caf {
namespace detail {

/// Always pulls exactly 5 elements from sources. Used in unit tests only.
class pull5_gatherer : public random_gatherer {
public:
  using super = random_gatherer;

  pull5_gatherer(local_actor* selfptr);

  void assign_credit(long available) override;

  long initial_credit(long, inbound_path*) override;
};

} // namespace detail
} // namespace caf

#endif // CAF_PULL5_GATHERER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_TYPE_ERASED_VALUE_IMPL_HPP
#define CAF_DETAIL_TYPE_ERASED_VALUE_IMPL_HPP

#include <cstdint>
#include <typeinfo>
#include <functional>

#include "caf/error.hpp"
#include "caf/type_erased_value.hpp"

#include "caf/detail/safe_equal.hpp"
#include "caf/detail/try_serialize.hpp"

namespace caf {
namespace detail {

/// @relates type_erased_value
/// Default implementation for single type-erased values.
template <class T>
class type_erased_value_impl : public type_erased_value {
public:
  // -- member types -----------------------------------------------------------

  using value_type = typename detail::strip_reference_wrapper<T>::type;

  // -- constructors, destructors, and assignment operators --------------------

  template <class... Ts>
  type_erased_value_impl(Ts&&... xs) : x_(std::forward<Ts>(xs)...) {
    // nop
  }

  template <class U, size_t N,
            class = typename std::enable_if<std::is_same<T, U[N]>::value>::type>
  type_erased_value_impl(const U (&ys)[N]) {
    array_copy(x_, ys);
  }

  template <class U, size_t N,
            class = typename std::enable_if<std::is_same<T, U[N]>::value>::type>
  type_erased_value_impl(const U (&&ys)[N]) {
    array_copy(x_, ys);
  }

  type_erased_value_impl(type_erased_value_impl&& other)
      : type_erased_value_impl(std::move(other.x_)) {
    // nop
  }

  type_erased_value_impl(const type_erased_value_impl& other)
      : type_erased_value_impl(other.x_) {
    // nop
  }

  // -- overridden modifiers ---------------------------------------------------

  void* get_mutable() override {
    return addr_of(x_);
  }

  error load(deserializer& source) override {
    return source(*addr_of(x_));
  }

  // -- overridden observers ---------------------------------------------------

  static rtti_pair type(std::integral_constant<uint16_t, 0>) {
    return {0, &typeid(value_type)};
  }

  template <uint16_t V>
  static rtti_pair type(std::integral_constant<uint16_t, V>) {
    return {V, nullptr};
  }

  rtti_pair type() const override {
    std::integral_constant<uint16_t, caf::type_nr<value_type>::value> token;
    return type(token);
  }

  const void* get() const override {
    // const is restored when returning from the function
    return addr_of(const_cast<T&>(x_));
  }

  error save(serializer& sink) const override {
    return sink(*addr_of(const_cast<T&>(x_)));
  }

  std::string stringify() const override {
    return deep_to_string(x_);
  }

  type_erased_value_ptr copy() const override {
    return type_erased_value_ptr{new type_erased_value_impl(x_)};
  }

  // -- conversion operators ---------------------------------------------------

  operator value_type&() {
    return x_;
  }

  operator const value_type&() const {
    return x_;
  }

private:
  // -- address-of-member utility ----------------------------------------------

  template <class U>
  static inline U* addr_of(const U& x) {
    return const_cast<U*>(&x);
  }

  template <class U, size_t S>
  static inline U* addr_of(const U (&x)[S]) {
    return const_cast<U*>(static_cast<const U*>(x));
  }

  template <class U>
  static inline U* addr_of(std::reference_wrapper<U>& x) {
    return &x.get();
  }

  template <class U>
  static inline U* addr_of(const std::reference_wrapper<U>& x) {
    return &x.get();
  }

  // -- array copying utility --------------------------------------------------

  template <class U, size_t Len>
  static void array_copy_impl(U (&x)[Len], const U (&y)[Len], std::true_type) {
    for (size_t i = 0; i < Len; ++i)
      array_copy(x[i], y[i]);
  }

  template <class U, size_t Len>
  static void array_copy_impl(U (&x)[Len], const U (&y)[Len], std::false_type) {
    std::copy(y, y + Len, x);
  }

  template <class U, size_t Len>
  static void array_copy(U (&x)[Len], const U (&y)[Len]) {
    std::integral_constant<bool, std::is_array<U>::value> token;
    array_copy_impl(x, y, token);
  }

  // -- data members -----------------------------------------------------------

  T x_;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_TYPE_ERASED_VALUE_IMPL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_INT_LIST_HPP
#define CAF_DETAIL_INT_LIST_HPP

#include "caf/detail/type_list.hpp"

namespace caf {
namespace detail {

/// A list of integers (wraps a long... template parameter pack).
template <long... Is>
struct int_list {};

template <size_t N, size_t Size, long... Is>
struct il_right_impl;

template <size_t N, size_t Size>
struct il_right_impl<N, Size> {
  using type = int_list<>;
};

template <size_t N, size_t Size, long I, long... Is>
struct il_right_impl<N, Size, I, Is...> : il_right_impl<N, Size - 1, Is...> { };

template <size_t N, long I, long... Is>
struct il_right_impl<N, N, I, Is...> {
  using type = int_list<I, Is...>;
};

template <class List, size_t N>
struct il_right;

template <long... Is, size_t N>
struct il_right<int_list<Is...>, N> {
  using type = typename il_right_impl<(N > sizeof...(Is) ? sizeof...(Is) : N),
                                      sizeof...(Is), Is...>::type;
};

template <bool Done, size_t Num, class List, long... Is>
struct il_take_impl;

template <class List, long... Is>
struct il_take_impl<true, 0, List, Is...> {
  using type = List;
};

template <size_t Num, long... Rs, long I, long... Is>
struct il_take_impl<false, Num, int_list<Rs...>, I, Is...> {
  using type = typename il_take_impl<Num == 1, Num - 1, int_list<Rs..., I>, Is...>::type;
};

template <class List, size_t N>
struct il_take;

template <long... Is, size_t N>
struct il_take<int_list<Is...>, N> {
  using type = typename il_take_impl<N == 0, N, int_list<>, Is...>::type;
};


/// Creates indices for `List` beginning at `Pos`.
template <class List, long Pos = 0, typename Indices = int_list<>>
struct il_indices;

template <template <class...> class List, long... Is, long Pos>
struct il_indices<List<>, Pos, int_list<Is...>> {
  using type = int_list<Is...>;
};

template <template <class...> class List,
     typename T0,
     class... Ts,
     long Pos,
     long... Is>
struct il_indices<List<T0, Ts...>, Pos, int_list<Is...>> {
  // always use type_list to forward remaining Ts... arguments
  using type =
    typename il_indices<
      type_list<Ts...>,
      Pos + 1,
      int_list<Is..., Pos>
    >::type;
};

template <class T>
typename il_indices<T>::type get_indices(const T&) {
  return {};
}

template <size_t Num, class T>
typename il_right<typename il_indices<T>::type, Num>::type
get_right_indices(const T&) {
  return {};
}

template <long First, long Last, long... Is>
struct il_range : il_range<First + 1, Last, Is..., First> {};

template <long Last, long... Is>
struct il_range<Last, Last, Is...> {
  using type = int_list<Is...>;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_INT_LIST_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_BEHAVIOR_IMPL_HPP
#define CAF_DETAIL_BEHAVIOR_IMPL_HPP

#include <tuple>
#include <type_traits>

#include "caf/none.hpp"
#include "caf/variant.hpp"
#include "caf/optional.hpp"
#include "caf/match_case.hpp"
#include "caf/make_counted.hpp"
#include "caf/intrusive_ptr.hpp"

#include "caf/atom.hpp"
#include "caf/message.hpp"
#include "caf/duration.hpp"
#include "caf/ref_counted.hpp"
#include "caf/skip.hpp"
#include "caf/response_promise.hpp"
#include "caf/timeout_definition.hpp"
#include "caf/typed_response_promise.hpp"

#include "caf/detail/int_list.hpp"
#include "caf/detail/apply_args.hpp"
#include "caf/detail/type_traits.hpp"
#include "caf/detail/tail_argument_token.hpp"
#include "caf/detail/invoke_result_visitor.hpp"

namespace caf {

class message_handler;

} // namespace caf

namespace caf {
namespace detail {

class behavior_impl : public ref_counted {
public:
  using pointer = intrusive_ptr<behavior_impl>;

  ~behavior_impl() override;

  behavior_impl(duration tout = duration{});

  virtual match_case::result invoke_empty(detail::invoke_result_visitor& f);

  virtual match_case::result invoke(detail::invoke_result_visitor& f,
                                    type_erased_tuple& xs);

  match_case::result invoke(detail::invoke_result_visitor& f, message& xs);

  optional<message> invoke(message&);

  optional<message> invoke(type_erased_tuple&);

  virtual void handle_timeout();

  inline const duration& timeout() const {
    return timeout_;
  }

  pointer or_else(const pointer& other);

protected:
  duration timeout_;
  match_case_info* begin_;
  match_case_info* end_;
};

template <class Tuple>
void call_timeout_handler(Tuple& tup, std::true_type) {
  auto& f = std::get<std::tuple_size<Tuple>::value - 1>(tup);
  f.handler();
}

template <class Tuple>
void call_timeout_handler(Tuple&, std::false_type) {
  // nop
}

template <class T, bool IsTimeout = is_timeout_definition<T>::value>
struct lift_behavior {
  using type = trivial_match_case<T>;
};

template <class T>
struct lift_behavior<T, true> {
  using type = T;
};

template <bool HasTimeout, class Tuple>
struct with_generic_timeout;

template <class... Ts>
struct with_generic_timeout<false, std::tuple<Ts...>> {
  using type = std::tuple<Ts..., generic_timeout_definition>;
};

template <class... Ts>
struct with_generic_timeout<true, std::tuple<Ts...>> {
  using type =
    typename tl_apply<
      typename tl_replace_back<
        type_list<Ts...>,
        generic_timeout_definition
      >::type,
      std::tuple
    >::type;
};

template <class Tuple>
class default_behavior_impl;

template <class... Ts>
class default_behavior_impl<std::tuple<Ts...>> : public behavior_impl {
public:
  using tuple_type = std::tuple<Ts...>;

  using back_type = typename tl_back<type_list<Ts...>>::type;

  static constexpr bool has_timeout = is_timeout_definition<back_type>::value;

  static constexpr size_t num_cases = sizeof...(Ts) - (has_timeout ? 1 : 0);

  using cases =
    typename std::conditional<
      has_timeout,
      typename tl_pop_back<type_list<Ts...>>::type,
      type_list<Ts...>
    >::type;

  default_behavior_impl(tuple_type&& tup) : cases_(std::move(tup)) {
    init();
  }

  template <class... Us>
  default_behavior_impl(Us&&... xs) : cases_(std::forward<Us>(xs)...) {
    init();
  }

  void handle_timeout() override {
    std::integral_constant<bool, has_timeout> token;
    call_timeout_handler(cases_, token);
  }

private:
  void init() {
    std::integral_constant<size_t, 0> first;
    std::integral_constant<size_t, num_cases> last;
    init(first, last);
  }

  template <size_t Last>
  void init(std::integral_constant<size_t, Last>,
            std::integral_constant<size_t, Last>) {
    this->begin_ = arr_.data();
    this->end_ = arr_.data() + arr_.size();
    std::integral_constant<bool, has_timeout> token;
    set_timeout(token);
  }

  template <size_t First, size_t Last>
  void init(std::integral_constant<size_t, First>,
            std::integral_constant<size_t, Last> last) {
    auto& element = std::get<First>(cases_);
    arr_[First] = match_case_info{element.type_token(), &element};
    init(std::integral_constant<size_t, First + 1>{}, last);
  }

  void set_timeout(std::true_type) {
    this->timeout_ = std::get<num_cases>(cases_).timeout;
  }

  void set_timeout(std::false_type) {
    // nop
  }

  tuple_type cases_;
  std::array<match_case_info, num_cases> arr_;
};

template <class Tuple>
struct behavior_factory {
  template <class... Ts>
  typename behavior_impl::pointer operator()(Ts&&... xs) const {
    return make_counted<default_behavior_impl<Tuple>>(std::forward<Ts>(xs)...);
  }
};

struct make_behavior_t {
  constexpr make_behavior_t() {
    // nop
  }

  template <class... Ts>
  intrusive_ptr<
    default_behavior_impl<std::tuple<typename lift_behavior<Ts>::type...>>>
  operator()(Ts... xs) const {
    using type =
      default_behavior_impl<std::tuple<typename lift_behavior<Ts>::type...>>;
    return make_counted<type>(std::move(xs)...);
  }
};

constexpr make_behavior_t make_behavior = make_behavior_t{};

using behavior_impl_ptr = intrusive_ptr<behavior_impl>;

// utility for getting a type-erased version of make_behavior
struct make_behavior_impl_t {
  constexpr make_behavior_impl_t() {
    // nop
  }

  template <class... Ts>
  behavior_impl_ptr operator()(Ts&&... xs) const {
    return make_behavior(std::forward<Ts>(xs)...);
  }
};

constexpr make_behavior_impl_t make_behavior_impl = make_behavior_impl_t{};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_BEHAVIOR_IMPL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_IMPLICIT_CONVERSIONS_HPP
#define CAF_DETAIL_IMPLICIT_CONVERSIONS_HPP

#include <string>
#include <type_traits>

#include "caf/fwd.hpp"
#include "caf/actor_marker.hpp"

#include "caf/detail/type_list.hpp"
#include "caf/detail/type_traits.hpp"

namespace caf {
namespace detail {

template <class T,
          bool IsDyn = std::is_base_of<dynamically_typed_actor_base, T>::value,
          bool IsStat = std::is_base_of<statically_typed_actor_base, T>::value>
struct implicit_actor_conversions {
  using type = T;
};

template <class T>
struct implicit_actor_conversions<T, true, false> {
  using type = actor;
};

template <class T>
struct implicit_actor_conversions<T, false, true> {
  using type =
    typename detail::tl_apply<
      typename T::signatures,
      typed_actor
    >::type;
};

template <>
struct implicit_actor_conversions<actor_control_block, false, false> {
  using type = strong_actor_ptr;
};

template <class T>
struct implicit_conversions {
  using type =
    typename std::conditional<
      std::is_convertible<T, error>::value,
      error,
      T
    >::type;
};

template <class T>
struct implicit_conversions<T*> : implicit_actor_conversions<T> {};

template <>
struct implicit_conversions<char*> {
  using type = std::string;
};

template <size_t N>
struct implicit_conversions<char[N]>
    : implicit_conversions<char*> {};

template <>
struct implicit_conversions<const char*>
    : implicit_conversions<char*> {};

template <size_t N>
struct implicit_conversions<const char[N]>
    : implicit_conversions<char*> {};

template <>
struct implicit_conversions<char16_t*> {
  using type = std::u16string;
};

template <size_t N>
struct implicit_conversions<char16_t[N]>
    : implicit_conversions<char16_t*> {};

template <>
struct implicit_conversions<const char16_t*>
    : implicit_conversions<char16_t*> {};

template <size_t N>
struct implicit_conversions<const char16_t[N]>
  : implicit_conversions<char16_t*> {};

template <>
struct implicit_conversions<char32_t*> {
  using type = std::u16string;
};

template <size_t N>
struct implicit_conversions<char32_t[N]>
    : implicit_conversions<char32_t*> {};

template <>
struct implicit_conversions<const char32_t*>
    : implicit_conversions<char32_t*> {};

template <size_t N>
struct implicit_conversions<const char32_t[N]>
    : implicit_conversions<char32_t*> {};

template <>
struct implicit_conversions<scoped_actor> {
  using type = actor;
};

template <class T>
using implicit_conversions_t = typename implicit_conversions<T>::type;

template <class T>
struct strip_and_convert {
  using type =
    typename implicit_conversions<
      typename std::remove_const<
        typename std::remove_reference<
          T
        >::type
      >::type
    >::type;
};

template <class T>
using strip_and_convert_t = typename strip_and_convert<T>::type;

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_IMPLICIT_CONVERSIONS_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_RAW_ACCESS_HPP
#define CAF_DETAIL_RAW_ACCESS_HPP

#include "caf/actor.hpp"
#include "caf/group.hpp"
#include "caf/channel.hpp"
#include "caf/actor_addr.hpp"
#include "caf/abstract_actor.hpp"
#include "caf/abstract_group.hpp"
#include "caf/abstract_channel.hpp"

namespace caf {
namespace detail {

class raw_access {

public:

  template <class ActorHandle>
  static abstract_actor* get(const ActorHandle& hdl) {
    return hdl.ptr_.get();
  }

  static abstract_channel* get(const channel& hdl) {
    return hdl.ptr_.get();
  }

  static abstract_group* get(const group& hdl) {
    return hdl.ptr_.get();
  }

  static actor unsafe_cast(abstract_actor* ptr) {
    return {ptr};
  }

  static actor unsafe_cast(const actor_addr& hdl) {
    return {get(hdl)};
  }

  static actor unsafe_cast(const abstract_actor_ptr& ptr) {
    return {ptr.get()};
  }

  template <class T>
  static void unsafe_assign(T& lhs, const actor& rhs) {
    lhs = T{get(rhs)};
  }

  template <class T>
  static void unsafe_assign(T& lhs, const abstract_actor_ptr& ptr) {
    lhs = T{ptr.get()};
  }

};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_RAW_ACCESS_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_SIMPLE_ACTOR_CLOCK_HPP
#define CAF_DETAIL_SIMPLE_ACTOR_CLOCK_HPP

#include <map>

#include "caf/actor_clock.hpp"
#include "caf/actor_control_block.hpp"
#include "caf/group.hpp"
#include "caf/mailbox_element.hpp"
#include "caf/message.hpp"
#include "caf/message_id.hpp"
#include "caf/variant.hpp"

namespace caf {
namespace detail {

class simple_actor_clock : public actor_clock {
public:
  // -- member types -----------------------------------------------------------

  /// Request for a `timeout_msg`.
  struct receive_timeout {
    strong_actor_ptr self;
    uint32_t id;
  };

  /// Request for a `sec::request_timeout` error.
  struct request_timeout {
    strong_actor_ptr self;
    message_id id;
  };

  /// Request for sending a message to an actor at a later time.
  struct actor_msg {
    strong_actor_ptr receiver;
    mailbox_element_ptr content;
  };

  /// Request for sending a message to a group at a later time.
  struct group_msg {
    group target;
    strong_actor_ptr sender;
    message content;
  };

  using value_type = variant<receive_timeout, request_timeout,
                             actor_msg, group_msg>;

  using map_type = std::multimap<time_point, value_type>;

  using secondary_map = std::multimap<abstract_actor*, map_type::iterator>;

  struct receive_predicate {
    bool operator()(const secondary_map::value_type& x) const noexcept;
  };

  struct request_predicate {
    message_id id;
    bool operator()(const secondary_map::value_type& x) const noexcept;
  };

  struct visitor {
    simple_actor_clock* thisptr;

    void operator()(receive_timeout& x);

    void operator()(request_timeout& x);

    void operator()(actor_msg& x);

    void operator()(group_msg& x);
  };

  void set_receive_timeout(time_point t, abstract_actor* self,
                           uint32_t id) override;

  void set_request_timeout(time_point t, abstract_actor* self,
                           message_id id) override;

  void cancel_receive_timeout(abstract_actor* self) override;

  void cancel_request_timeout(abstract_actor* self, message_id id) override;

  void cancel_timeouts(abstract_actor* self) override;

  void schedule_message(time_point t, strong_actor_ptr receiver,
                        mailbox_element_ptr content) override;

  void schedule_message(time_point t, group target, strong_actor_ptr sender,
                        message content) override;

  inline const map_type& schedule() const {
    return schedule_;
  }

  inline const secondary_map& actor_lookup() const {
    return actor_lookup_;
  }

protected:
  template <class Predicate>
  secondary_map::iterator lookup(abstract_actor* self, Predicate pred) {
    auto e = actor_lookup_.end();
    auto range = actor_lookup_.equal_range(self);
    if (range.first == range.second)
      return e;
    auto i = std::find_if(range.first, range.second, pred);
    return i != range.second ? i : e;
  }

  template <class Predicate>
  void cancel(abstract_actor* self, Predicate pred) {
    auto i = lookup(self, pred);
    if (i != actor_lookup_.end()) {
      schedule_.erase(i->second);
      actor_lookup_.erase(i);
    }
  }

  template <class Predicate>
  void drop_lookup(abstract_actor* self, Predicate pred) {
    auto i = lookup(self, pred);
    if (i != actor_lookup_.end())
      actor_lookup_.erase(i);
  }

  map_type schedule_;

  secondary_map actor_lookup_;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_SIMPLE_ACTOR_CLOCK_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_TRY_MATCH_HPP
#define CAF_DETAIL_TRY_MATCH_HPP

#include <array>
#include <numeric>
#include <typeinfo>

#include "caf/atom.hpp"
#include "caf/type_nr.hpp"

#include "caf/detail/type_list.hpp"

namespace caf {
namespace detail {

struct meta_element {
  atom_value v;
  uint16_t typenr;
  const std::type_info* type;
  bool (*fun)(const meta_element&, const type_erased_tuple&, size_t);
};

bool match_element(const meta_element&, const type_erased_tuple&, size_t);

bool match_atom_constant(const meta_element&, const type_erased_tuple&, size_t);

template <class T, uint16_t TN = type_nr<T>::value>
struct meta_element_factory {
  static meta_element create() {
    return {static_cast<atom_value>(0), TN, nullptr, match_element};
  }
};

template <class T>
struct meta_element_factory<T, 0> {
  static meta_element create() {
    return {static_cast<atom_value>(0), 0, &typeid(T), match_element};
  }
};

template <atom_value V>
struct meta_element_factory<atom_constant<V>, type_nr<atom_value>::value> {
  static meta_element create() {
    return {V, type_nr<atom_value>::value, nullptr, match_atom_constant};
  }
};

template <class TypeList>
struct meta_elements;

template <class... Ts>
struct meta_elements<type_list<Ts...>> {
  std::array<meta_element, sizeof...(Ts)> arr;
  meta_elements() : arr{{meta_element_factory<Ts>::create()...}} {
    // nop
  }
};

bool try_match(const type_erased_tuple& xs, const meta_element* iter,
               size_t ps);

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_TRY_MATCH_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_TYPE_PAIR_HPP
#define CAF_DETAIL_TYPE_PAIR_HPP

namespace caf {
namespace detail {

template <class First, typename Second>
struct type_pair {
  using first = First;
  using second = Second;
};

template <class First, typename Second>
struct to_type_pair {
  using type = type_pair<First, Second>;
};

template <class What>
struct is_type_pair {
  static constexpr bool value = false;
};

template <class First, typename Second>
struct is_type_pair<type_pair<First, Second>> {
  static constexpr bool value = true;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_TYPE_PAIR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_PUSH5_SCATTERER_HPP
#define CAF_PUSH5_SCATTERER_HPP

#include "caf/broadcast_scatterer.hpp"

namespace caf {
namespace detail {

/// Always pushs exactly 5 elements to sinks. Used in unit tests only.
template <class T>
class push5_scatterer : public broadcast_scatterer<T> {
public:
  using super = broadcast_scatterer<T>;

  push5_scatterer(local_actor* self) : super(self) {
    // nop
  }

  using super::min_batch_size;
  using super::max_batch_size;
  using super::min_buffer_size;

  long min_batch_size() const override {
    return 1;
  }

  long max_batch_size() const override {
    return 5;
  }

  long min_buffer_size() const override {
    return 5;
  }
};

} // namespace detail
} // namespace caf

#endif // CAF_PUSH5_SCATTERER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

// The rationale of this header is to provide a serialization API
// that is compatbile to boost.serialization. In particular, the
// design goals are:
// - allow users to integrate existing boost.serialization-based code easily
// - allow to switch out this header with the actual boost header in boost.actor
//
// Differences in semantics are:
// - CAF does *not* respect class versions
// - the `unsigned int` argument is always 0 and ignored by CAF
//
// Since CAF requires all runtime instances to have the same types
// announced, different class versions in a single actor system would
// cause inconsistencies that are not recoverable.

#ifndef CAF_DETAIL_PRETTY_TYPE_NAME_HPP
#define CAF_DETAIL_PRETTY_TYPE_NAME_HPP

#include <string>
#include <typeinfo>

namespace caf {
namespace detail {

void prettify_type_name(std::string& class_name);

void prettify_type_name(std::string& class_name, const char* input_class_name);

std::string pretty_type_name(const std::type_info& x);

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_PRETTY_TYPE_NAME_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_SELECT_INTEGER_TYPE_HPP
#define CAF_DETAIL_SELECT_INTEGER_TYPE_HPP

#include <cstdint>

namespace caf {
namespace detail {

template <int>
struct select_integer_type;

template <>
struct select_integer_type<-1> {
  using type = int8_t;
};

template <>
struct select_integer_type<1> {
  using type = uint8_t;
};

template <>
struct select_integer_type<-2> {
  using type = int16_t;
};

template <>
struct select_integer_type<2> {
  using type = uint16_t;
};

template <>
struct select_integer_type<-4> {
  using type = int32_t;
};

template <>
struct select_integer_type<4> {
  using type = uint32_t;
};

template <>
struct select_integer_type<-8> {
  using type = int64_t;
};

template <>
struct select_integer_type<8> {
  using type = uint64_t;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_SELECT_INTEGER_TYPE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_SPLIT_JOIN_HPP
#define CAF_DETAIL_SPLIT_JOIN_HPP

#include <vector>

#include "caf/actor.hpp"
#include "caf/locks.hpp"
#include "caf/actor_system.hpp"
#include "caf/event_based_actor.hpp"

#include "caf/detail/shared_spinlock.hpp"

namespace caf {
namespace detail {

using actor_msg_vec = std::vector<std::pair<actor, message>>;

template <class T, class Split, class Join>
class split_join_collector : public event_based_actor {
public:
  split_join_collector(actor_config& cfg, T init_value,
                       Split s, Join j, actor_msg_vec xs)
      : event_based_actor(cfg),
        workset_(std::move(xs)),
        awaited_results_(workset_.size()),
        join_(std::move(j)),
        split_(std::move(s)),
        value_(std::move(init_value)) {
    // nop
  }

  behavior make_behavior() override {
    auto f = [=](scheduled_actor*, message_view& xs) -> result<message> {
      auto msg = xs.move_content_to_message();
      auto rp = this->make_response_promise();
      split_(workset_, msg);
      for (auto& x : workset_)
        this->send(x.first, std::move(x.second));
      auto g = [=](scheduled_actor*, message_view& ys) mutable
               -> result<message> {
        auto res = ys.move_content_to_message();
        join_(value_, res);
        if (--awaited_results_ == 0) {
          rp.deliver(value_);
          quit();
        }
        return delegated<message>{};
      };
      set_default_handler(g);
      return delegated<message>{};
    };
    set_default_handler(f);
    return {
      [] {
        // nop
      }
    };
  }

private:
  actor_msg_vec workset_;
  size_t awaited_results_;
  Join join_;
  Split split_;
  T value_;
};

struct nop_split {
  inline void operator()(actor_msg_vec& xs, message& y) const {
    for (auto& x : xs) {
      x.second = y;
    }
  }
};

template <class T, class Split, class Join>
class split_join {
public:
  split_join(T init_value, Split s, Join j)
      : init_(std::move(init_value)),
        sf_(std::move(s)),
        jf_(std::move(j)) {
    // nop
  }

  void operator()(actor_system& sys,
                  upgrade_lock<detail::shared_spinlock>& ulock,
                  const std::vector<actor>& workers,
                  mailbox_element_ptr& ptr,
                  execution_unit* host) {
    if (!ptr->sender)
      return;
    actor_msg_vec xs;
    xs.reserve(workers.size());
    for (const auto & worker : workers)
      xs.emplace_back(worker, message{});
    ulock.unlock();
    using collector_t = split_join_collector<T, Split, Join>;
    auto hdl = sys.spawn<collector_t, lazy_init>(init_, sf_, jf_, std::move(xs));
    hdl->enqueue(std::move(ptr), host);
  }

private:
  T init_;
  Split sf_; // split function
  Join jf_;  // join function
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_SPLIT_JOIN_HPP

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_MERGED_TUPLE_HPP
#define CAF_DETAIL_MERGED_TUPLE_HPP

#include "caf/message.hpp"
#include "caf/actor_addr.hpp"
#include "caf/attachable.hpp"
#include "caf/abstract_actor.hpp"

namespace caf {
namespace detail {

class merged_tuple : public message_data {
public:
  // -- member types -----------------------------------------------------------

  using message_data::cow_ptr;

  using data_type = std::vector<cow_ptr>;

  using mapping_type = std::vector<std::pair<size_t, size_t>>;

  // -- constructors, destructors, and assignment operators --------------------

  static cow_ptr make(message x, message y);

  merged_tuple(data_type xs, mapping_type ys);

  merged_tuple& operator=(const merged_tuple&) = delete;

  // -- overridden observers of message_data -----------------------------------

  cow_ptr copy() const override;

  // -- overridden modifiers of type_erased_tuple ------------------------------

  void* get_mutable(size_t pos) override;

  error load(size_t pos, deserializer& source) override;

  // -- overridden observers of type_erased_tuple ------------------------------

  size_t size() const noexcept override;

  uint32_t type_token() const noexcept override;

  rtti_pair type(size_t pos) const noexcept override;

  const void* get(size_t pos) const noexcept override;

  std::string stringify(size_t pos) const override;

  type_erased_value_ptr copy(size_t pos) const override;

  error save(size_t pos, serializer& sink) const override;

  // -- observers --------------------------------------------------------------

  const mapping_type& mapping() const;

private:
  // -- constructors, destructors, and assignment operators --------------------

  merged_tuple(const merged_tuple&) = default;

  // -- data members -----------------------------------------------------------

  data_type data_;
  uint32_t type_token_;
  mapping_type mapping_;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_MERGED_TUPLE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_DOUBLE_ENDED_QUEUE_HPP
#define CAF_DETAIL_DOUBLE_ENDED_QUEUE_HPP

#include "caf/config.hpp"

#include <chrono>
#include <thread>
#include <atomic>
#include <cassert>

// GCC hack
#if defined(CAF_GCC) && !defined(_GLIBCXX_USE_SCHED_YIELD)
#include <time.h>
namespace std {
namespace this_thread {
namespace {
inline void yield() noexcept {
  timespec req;
  req.tv_sec = 0;
  req.tv_nsec = 1;
  nanosleep(&req, nullptr);
}
} // namespace anonymous>
} // namespace this_thread
} // namespace std
#endif

// another GCC hack
#if defined(CAF_GCC) && !defined(_GLIBCXX_USE_NANOSLEEP)
#include <time.h>
namespace std {
namespace this_thread {
namespace {
template <class Rep, typename Period>
inline void sleep_for(const chrono::duration<Rep, Period>& rt) {
  auto sec = chrono::duration_cast<chrono::seconds>(rt);
  auto nsec = chrono::duration_cast<chrono::nanoseconds>(rt - sec);
  timespec req;
  req.tv_sec = sec.count();
  req.tv_nsec = nsec.count();
  nanosleep(&req, nullptr);
}
} // namespace anonymous>
} // namespace this_thread
} // namespace std
#endif

namespace caf {
namespace detail {

/*
 * A thread-safe double-ended queue based on http://drdobbs.com/cpp/211601363.
 * This implementation is optimized for FIFO, i.e., it supports fast insertion
 * at the end and fast removal from the beginning. As long as the queue is
 * only used for FIFO operations, readers do not block writers and vice versa.
 */
template <class T>
class double_ended_queue {
public:
  using value_type = T;
  using size_type = size_t;
  using difference_type = ptrdiff_t;
  using reference = value_type&;
  using const_reference = const value_type&;
  using pointer = value_type*;
  using const_pointer = const value_type*;

  class node {
  public:
    pointer value;
    std::atomic<node*> next;
    explicit node(pointer val) : value(val), next(nullptr) {
      // nop
    }
  private:
    static constexpr size_type payload_size =
      sizeof(pointer) + sizeof(std::atomic<node*>);
    static constexpr size_type cline_size = CAF_CACHE_LINE_SIZE;
    static constexpr size_type pad_size =
      (cline_size * ((payload_size / cline_size) + 1)) - payload_size;
    // avoid false sharing
    static_assert(pad_size > 0, "invalid padding size calculated");
    char pad[pad_size];
  };

  using unique_node_ptr = std::unique_ptr<node>;

  static_assert(sizeof(node*) < CAF_CACHE_LINE_SIZE,
                "sizeof(node*) >= CAF_CACHE_LINE_SIZE");

  double_ended_queue() {
    head_lock_.clear();
    tail_lock_.clear();
    auto ptr = new node(nullptr);
    head_ = ptr;
    tail_ = ptr;
  }

  ~double_ended_queue() {
    auto ptr = head_.load();
    while (ptr) {
      unique_node_ptr tmp{ptr};
      ptr = tmp->next.load();
    }
  }

  // acquires only one lock
  void append(pointer value) {
    CAF_ASSERT(value != nullptr);
    auto* tmp = new node(value);
    lock_guard guard(tail_lock_);
    // publish & swing last forward
    tail_.load()->next = tmp;
    tail_ = tmp;
  }

  // acquires both locks
  void prepend(pointer value) {
    CAF_ASSERT(value != nullptr);
    auto* tmp = new node(value);
    node* first = nullptr;
    // acquire both locks since we might touch last_ too
    lock_guard guard1(head_lock_);
    lock_guard guard2(tail_lock_);
    first = head_.load();
    CAF_ASSERT(first != nullptr);
    auto next = first->next.load();
    // first_ always points to a dummy with no value,
    // hence we put the new element second
    if (next) {
      CAF_ASSERT(first != tail_);
      tmp->next = next;
    } else {
      // queue is empty
      CAF_ASSERT(first == tail_);
      tail_ = tmp;
    }
    first->next = tmp;
  }

  // acquires only one lock, returns nullptr on failure
  pointer take_head() {
    unique_node_ptr first;
    pointer result = nullptr;
    { // lifetime scope of guard
      lock_guard guard(head_lock_);
      first.reset(head_.load());
      node* next = first->next;
      if (next == nullptr) {
        // queue is empty
        first.release();
        return nullptr;
      }
      // take it out of the node & swing first forward
      result = next->value;
      next->value = nullptr;
      head_ = next;
    }
    return result;
  }

  // acquires both locks, returns nullptr on failure
  pointer take_tail() {
    pointer result = nullptr;
    unique_node_ptr last;
    { // lifetime scope of guards
      lock_guard guard1(head_lock_);
      lock_guard guard2(tail_lock_);
      CAF_ASSERT(head_ != nullptr);
      last.reset(tail_.load());
      if (last.get() == head_.load()) {
        last.release();
        return nullptr;
      }
      result = last->value;
      tail_ = find_predecessor(last.get());
      CAF_ASSERT(tail_ != nullptr);
      tail_.load()->next = nullptr;
    }
    return result;
  }

  // does not lock
  bool empty() const {
    // atomically compares first and last pointer without locks
    return head_.load() == tail_.load();
  }

private:
  // precondition: *both* locks acquired
  node* find_predecessor(node* what) {
    for (auto i = head_.load(); i != nullptr; i = i->next) {
      if (i->next == what) {
        return i;
      }
    }
    return nullptr;
  }

  // guarded by head_lock_
  std::atomic<node*> head_;
  char pad1_[CAF_CACHE_LINE_SIZE - sizeof(node*)];
  // guarded by tail_lock_
  std::atomic<node*> tail_;
  char pad2_[CAF_CACHE_LINE_SIZE - sizeof(node*)];
  // enforce exclusive access
  std::atomic_flag head_lock_;
  std::atomic_flag tail_lock_;

  class lock_guard {
  public:
    explicit lock_guard(std::atomic_flag& lock) : lock_(lock) {
      while (lock.test_and_set(std::memory_order_acquire)) {
        std::this_thread::yield();
      }
    }
    ~lock_guard() {
      lock_.clear(std::memory_order_release);
    }
  private:
    std::atomic_flag& lock_;
  };
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_DOUBLE_ENDED_QUEUE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_TRY_SERIALIZE_HPP
#define CAF_DETAIL_TRY_SERIALIZE_HPP

namespace caf {
namespace detail {

template <class Processor, class T>
auto try_serialize(Processor& proc, T* x) -> decltype(proc & *x) {
  proc & *x;
}

template <class Processor>
void try_serialize(Processor&, void*) {
  // nop
}

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_TRY_SERIALIZE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

/******************************************************************************\
 * Based on http://homes.esat.kuleuven.be/~cosicart/ps/AB-9601/rmd160.h;
 * original header:
 *
 *    AUTHOR:   Antoon Bosselaers, ESAT-COSIC
 *    DATE:     1 March 1996
 *    VERSION:  1.0
 *
 *    Copyright (c) Katholieke Universiteit Leuven
 *    1996, All Rights Reserved
 *
 *  Conditions for use of the RIPEMD-160 Software
 *
 *  The RIPEMD-160 software is freely available for use under the terms and
 *  conditions described hereunder, which shall be deemed to be accepted by
 *  any user of the software and applicable on any use of the software:
 *
 *  1. K.U.Leuven Department of Electrical Engineering-ESAT/COSIC shall for
 *     all purposes be considered the owner of the RIPEMD-160 software and of
 *     all copyright, trade secret, patent or other intellectual property
 *     rights therein.
 *  2. The RIPEMD-160 software is provided on an "as is" basis without
 *     warranty of any sort, express or implied. K.U.Leuven makes no
 *     representation that the use of the software will not infringe any
 *     patent or proprietary right of third parties. User will indemnify
 *     K.U.Leuven and hold K.U.Leuven harmless from any claims or liabilities
 *     which may arise as a result of its use of the software. In no
 *     circumstances K.U.Leuven R&D will be held liable for any deficiency,
 *     fault or other mishappening with regard to the use or performance of
 *     the software.
 *  3. User agrees to give due credit to K.U.Leuven in scientific publications
 *     or communications in relation with the use of the RIPEMD-160 software
 *     as follows: RIPEMD-160 software written by Antoon Bosselaers,
 *     available at http://www.esat.kuleuven.be/~cosicart/ps/AB-9601/.
\******************************************************************************/

#ifndef CAF_DETAIL_RIPEMD_160_HPP
#define CAF_DETAIL_RIPEMD_160_HPP

#include <array>
#include <string>

namespace caf {
namespace detail {

/// Creates a hash from `data` using the RIPEMD-160 algorithm.
void ripemd_160(std::array<uint8_t, 20>& storage, const std::string& data);

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_RIPEMD_160_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

// The rationale of this header is to provide a serialization API
// that is compatbile to boost.serialization. In particular, the
// design goals are:
// - allow users to integrate existing boost.serialization-based code easily
// - allow to switch out this header with the actual boost header in boost.actor
//
// Differences in semantics are:
// - CAF does *not* respect class versions
// - the `unsigned int` argument is always 0 and ignored by CAF
//
// Since CAF requires all runtime instances to have the same types
// announced, different class versions in a single actor system would
// cause inconsistencies that are not recoverable.

#ifndef CAF_DETAIL_SERIALIZATION_HPP
#define CAF_DETAIL_SERIALIZATION_HPP

#include <utility>
#include <type_traits>

#include "caf/detail/type_traits.hpp"

namespace boost {
namespace serialization {

} // namespace serialization
} // namespace boost

namespace caf {
namespace detail {

// Calls `serialize(...)` with `using namespace boost::serialization`
// to enable both ADL and picking up existing boost code.

template <class Processor, class U>
auto delegate_serialize(Processor& proc, U& x, const unsigned int y = 0)
  -> decltype(serialize(proc, x, y)) {
  using namespace boost::serialization;
  serialize(proc, x, y);
}

// Calls `serialize(...)` without the unused version argument, which CAF
// ignores anyway.

template <class Processor, class U>
auto delegate_serialize(Processor& proc, U& x)
  -> decltype(serialize(proc, x)) {
  serialize(proc, x);
}

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_SERIALIZATION_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENCE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_FUNCTOR_ATTACHABLE_HPP
#define CAF_FUNCTOR_ATTACHABLE_HPP

#include "caf/attachable.hpp"

#include "caf/detail/type_list.hpp"
#include "caf/detail/type_traits.hpp"

namespace caf {
namespace detail {

template <class F,
          int Args = tl_size<typename get_callable_trait<F>::arg_types>::value>
struct functor_attachable : attachable {
  static_assert(Args == 1 || Args == 2,
                "Only 0, 1 or 2 arguments for F are supported");
  F functor_;
  functor_attachable(F arg) : functor_(std::move(arg)) {
    // nop
  }
  void actor_exited(const error& fail_state, execution_unit*) override {
    functor_(fail_state);
  }
  static constexpr size_t token_type = attachable::token::anonymous;
};

template <class F>
struct functor_attachable<F, 2> : attachable {
  F functor_;
  functor_attachable(F arg) : functor_(std::move(arg)) {
    // nop
  }
  void actor_exited(const error& x, execution_unit* y) override {
    functor_(x, y);
  }
};


template <class F>
struct functor_attachable<F, 0> : attachable {
  F functor_;
  functor_attachable(F arg) : functor_(std::move(arg)) {
    // nop
  }
  void actor_exited(const error&, execution_unit*) override {
    functor_();
  }
};

} // namespace detail
} // namespace caf

#endif // CAF_FUNCTOR_ATTACHABLE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_TYPE_LIST_HPP
#define CAF_DETAIL_TYPE_LIST_HPP

#include <cstddef>
#include <typeinfo>
#include <type_traits>

#include "caf/unit.hpp"
#include "caf/none.hpp"

#include "caf/detail/tbind.hpp"
#include "caf/detail/type_pair.hpp"

namespace caf {
namespace detail {

/// A list of types.
template <class... Ts>
struct type_list {
  constexpr type_list() {
    // nop
  }
};

/// Denotes the empty list.
using empty_type_list = type_list<>;

template <class T>
struct is_type_list {
  static constexpr bool value = false;
};

template <class... Ts>
struct is_type_list<type_list<Ts...>> {
  static constexpr bool value = true;
};

// Uncomment after having switched to C++14
//template <class T>
//inline constexpr bool is_type_list_v = is_type_list<T>::value;

// T head(type_list)

/// Gets the first element of `List`.
template <class List>
struct tl_head;

template <>
struct tl_head<type_list<>> {
  using type = void;
};

template <typename T0, class... Ts>
struct tl_head<type_list<T0, Ts...>> {
  using type = T0;
};

template <class List>
using tl_head_t = typename tl_head<List>::type;

// type_list tail(type_list)

/// Gets the tail of `List`.
template <class List>
struct tl_tail;

template <>
struct tl_tail<type_list<>> {
  using type = type_list<>;
};

template <typename T0, class... Ts>
struct tl_tail<type_list<T0, Ts...>> {
  using type = type_list<Ts...>;
};

template <class List>
using tl_tail_t = typename tl_tail<List>::type;

// size_t size(type_list)

/// Gets the number of template parameters of `List`.
template <class List>
struct tl_size;

template <class... Ts>
struct tl_size<type_list<Ts...>> {
  static constexpr size_t value = sizeof...(Ts);
};

template <class... Ts>
constexpr size_t tl_size<type_list<Ts...>>::value;

// Uncomment after having switched to C++14
//template <class List>
//inline constexpr size_t tl_size_v = tl_size<List>::value;

// T back(type_list)

/// Gets the last element in `List`.
template <class List>
struct tl_back;

template <>
struct tl_back<type_list<>> {
  using type = unit_t;
};

template <typename T0>
struct tl_back<type_list<T0>> {
  using type = T0;
};

template <typename T0, typename T1, class... Ts>
struct tl_back<type_list<T0, T1, Ts...>> {
  // remaining arguments are forwarded as type_list to prevent
  // recursive instantiation of List class
  using type = typename tl_back<type_list<T1, Ts...>>::type;
};

template <class List>
using tl_back_t = typename tl_back<List>::type;

// bool empty(type_list)

/// Tests whether a list is empty.
template <class List>
struct tl_empty {
  static constexpr bool value = std::is_same<empty_type_list, List>::value;
};

// Uncomment after having switched to C++14
//template <class List>
//inline constexpr bool tl_empty_v = tl_empty<List>::value;

// list slice(size_t, size_t)

template <size_t LeftOffset,
     size_t Remaining,
     typename PadType,
     class List,
     class... Ts>
struct tl_slice_impl {
  using type =
    typename tl_slice_impl<
      LeftOffset - 1,
      Remaining,
      PadType,
      tl_tail_t<List>,
      Ts...
    >::type;
};

template <size_t Remaining, typename PadType, class List, class... Ts>
struct tl_slice_impl<0, Remaining, PadType, List, Ts...> {
  using type =
    typename tl_slice_impl<
      0,
      Remaining - 1,
      PadType,
      tl_tail_t<List>,
      Ts...,
      tl_head_t<List>
    >::type;
};

template <size_t Remaining, typename PadType, class... Ts>
struct tl_slice_impl<0, Remaining, PadType, empty_type_list, Ts...> {
  using type =
    typename tl_slice_impl<
      0,
      Remaining - 1,
      PadType,
      empty_type_list,
      Ts...,
      PadType
    >::type;
};

template <class PadType, class List, class... T>
struct tl_slice_impl<0, 0, PadType, List, T...> {
  using type = type_list<T...>;
};

template <class PadType, class... T>
struct tl_slice_impl<0, 0, PadType, empty_type_list, T...> {
  using type = type_list<T...>;
};

template <class List, size_t ListSize, size_t First, size_t Last,
      typename PadType = unit_t>
struct tl_slice_ {
  using type =
    typename tl_slice_impl<
      First,
      (Last - First),
      PadType,
      List
    >::type;
};

template <class List, size_t ListSize, typename PadType>
struct tl_slice_<List, ListSize, 0, ListSize, PadType> {
  using type = List;
};

/// Creates a new list from range (First, Last].
template <class List, size_t First, size_t Last>
struct tl_slice {
  using type =
    typename tl_slice_<
      List,
      tl_size<List>::value,
      (First > Last ? Last : First),
      Last
    >::type;
};

template <class List, size_t First, size_t Last>
using tl_slice_t = typename tl_slice<List, First, Last>::type;

/// Creates a new list containing the last `N` elements.
template <class List, size_t NewSize, size_t OldSize = tl_size<List>::value>
struct tl_right {
  static constexpr size_t first_idx = OldSize > NewSize ? OldSize - NewSize : 0;
  using type = tl_slice_t<List, first_idx, OldSize>;
};

template <class List, size_t N>
struct tl_right<List, N, N> {
  using type = List;
};

template <size_t N>
struct tl_right<empty_type_list, N, 0> {
  using type = empty_type_list;
};

template <>
struct tl_right<empty_type_list, 0, 0> {
  using type = empty_type_list;
};

template <class List, size_t NewSize, size_t OldSize = tl_size<List>::value>
using tl_right_t = typename tl_right<List, NewSize, OldSize>::type;

template <class ListA, class ListB,
          template <class, typename> class Fun = to_type_pair>
struct tl_zip_impl;

template <class... LhsElements, class... RhsElements,
          template <class, typename> class Fun>
struct tl_zip_impl<type_list<LhsElements...>, type_list<RhsElements...>, Fun> {
  static_assert(sizeof...(LhsElements) == sizeof...(RhsElements),
                "Lists have different size");
  using type = type_list<typename Fun<LhsElements, RhsElements>::type...>;
};

/// Zips two lists of equal size.
///
/// Creates a list formed from the two lists `ListA` and `ListB,`
/// e.g., tl_zip<type_list<int, double>, type_list<float, string>>::type
/// is type_list<type_pair<int, float>, type_pair<double, string>>.
template <class ListA, class ListB, template <class, class> class Fun>
struct tl_zip {
  static constexpr size_t sizea = tl_size<ListA>::value;
  static constexpr size_t sizeb = tl_size<ListB>::value;
  static constexpr size_t result_size = (sizea < sizeb) ? sizea : sizeb;
  using type =
    typename tl_zip_impl<
      tl_slice_t<ListA, 0, result_size>,
      tl_slice_t<ListB, 0, result_size>,
      Fun
    >::type;
};

template <class ListA, class ListB, template <class, class> class Fun>
using tl_zip_t = typename tl_zip<ListA, ListB, Fun>::type;

/// Equal to `zip(right(ListA, N), right(ListB, N), Fun)`.
template <class ListA, class ListB, template <class, class> class Fun, size_t N>
struct tl_zip_right {
  using type =
    typename tl_zip_impl<
      tl_right_t<ListA, N>,
      tl_right_t<ListB, N>,
      Fun
    >::type;
};

template <class ListA, class ListB, template <class, class> class Fun, size_t N>
using tl_zip_right_t = typename tl_zip_right<ListA, ListB, Fun, N>::type;

template <class ListA, class ListB,
          typename PadA = unit_t, typename PadB = unit_t,
          template <class, typename> class Fun = to_type_pair>
struct tl_zip_all {
  static constexpr size_t result_size =
    (tl_size<ListA>::value > tl_size<ListB>::value) ? tl_size<ListA>::value
                                                    : tl_size<ListB>::value;
  using type =
    typename tl_zip_impl<
      typename tl_slice_<ListA, tl_size<ListA>::value, 0, result_size>::type,
      typename tl_slice_<ListB, tl_size<ListB>::value, 0, result_size>::type,
      Fun
    >::type;
};

template <class ListA, class ListB,
          typename PadA = unit_t, typename PadB = unit_t,
          template <class, typename> class Fun = to_type_pair>
using tl_zip_all_t = typename tl_zip_all<ListA, ListB, PadA, PadB, Fun>::type;

template <class ListA>
struct tl_unzip;

template <class... Elements>
struct tl_unzip<type_list<Elements...>> {
  using first = type_list<typename Elements::first...>;
  using second = type_list<typename Elements::second...>;
};

// int index_of(list, type)

/// Finds the first element of type `What` beginning at index `Pos`.
template <int Pos, class X, class... Ts>
struct tl_index_of_impl;

template <int Pos, class X>
struct tl_index_of_impl<Pos, X> {
  static constexpr int value = -1;
};

template <int Pos, class X, class... Ts>
struct tl_index_of_impl<Pos, X, X, Ts...> {
  static constexpr int value = Pos;
};

template <int Pos, class X, class T, class... Ts>
struct tl_index_of_impl<Pos, X, T, Ts...> {
  static constexpr int value = tl_index_of_impl<Pos + 1, X, Ts...>::value;
};

/// Finds the first element satisfying `Pred` beginning at index `Pos`.
template <class List, class T>
struct tl_index_of;

template <class... Ts, class T>
struct tl_index_of<type_list<Ts...>, T> {
  static constexpr int value = tl_index_of_impl<0, T, Ts...>::value;
};

// Uncomment after having switched to C++14
//template <class List, class T>
//inline constexpr int tl_index_of_v = tl_index_of<List, T>::value;

// int index_of(list, predicate)

template <int Pos, template <class> class Pred, class... Ts>
struct tl_index_where_impl;

template <int Pos, template <class> class Pred>
struct tl_index_where_impl<Pos, Pred> {
  static constexpr int value = -1;
};

template <int Pos, template <class> class Pred, class T, class... Ts>
struct tl_index_where_impl<Pos, Pred, T, Ts...> {
  static constexpr int value
    = Pred<T>::value ? Pos : tl_index_where_impl<Pos + 1, Pred, Ts...>::value;
};

/// Finds the first element satisfying a given predicate.
template <class List, template <class> class Pred>
struct tl_index_where;

template <class... Ts, template <class> class Pred>
struct tl_index_where<type_list<Ts...>, Pred> {
  static constexpr int value = tl_index_where_impl<0, Pred, Ts...>::value;
};

// Uncomment after having switched to C++14
//template <class List, template <class> class Pred>
//inline constexpr int tl_index_where_v = tl_index_where<List, Pred>::value;

// list reverse()

template <class From, class... Elements>
struct tl_reverse_impl;

template <class T0, class... T, class... E>
struct tl_reverse_impl<type_list<T0, T...>, E...> {
  using type = typename tl_reverse_impl<type_list<T...>, T0, E...>::type;
};

template <class... E>
struct tl_reverse_impl<empty_type_list, E...> {
  using type = type_list<E...>;
};

/// Creates a new list wih elements in reversed order.
template <class List>
struct tl_reverse {
  using type = typename tl_reverse_impl<List>::type;
};

template <class List>
using tl_reverse_t = typename tl_reverse<List>::type;

// type find(list, predicate)

/// Finds the first element of type `What` beginning at index `Pos`.
template <template <class> class Pred, class... Ts>
struct tl_find_impl;

template <template <class> class Pred>
struct tl_find_impl<Pred> {
  using type = none_t;
};

template <template <class> class Pred, class T, class... Ts>
struct tl_find_impl<Pred, T, Ts...> {
  using type =
    typename std::conditional<
      Pred<T>::value,
      T,
      typename tl_find_impl<Pred, Ts...>::type
    >::type;
};

/// Finds the first element satisfying `Pred` beginning at index `Pos`.
template <class List, template <class> class Pred>
struct tl_find;

template <class... Ts, template <class> class Pred>
struct tl_find<type_list<Ts...>, Pred> {
  using type = typename tl_find_impl<Pred, Ts...>::type;
};

template <class List, template <class> class Pred>
using tl_find_t = typename tl_find<List, Pred>::type;

// bool forall(predicate)

/// Tests whether a predicate holds for all elements of a list.
template <class List, template <class> class Pred>
struct tl_forall {
  static constexpr bool value =
      Pred<tl_head_t<List>>::value
      && tl_forall<tl_tail_t<List>, Pred>::value;
};

template <template <class> class Pred>
struct tl_forall<empty_type_list, Pred> {
  static constexpr bool value = true;
};

// Uncomment after having switched to C++14
//template <class List, template <class> class Pred>
//inline constexpr bool tl_forall_v = tl_forall<List, Pred>::value;

template <class ListA, class ListB, template <class, class> class Pred>
struct tl_forall2_impl {
  static constexpr bool value =
      Pred<tl_head_t<ListA>, tl_head_t<ListB>>::value
      && tl_forall2_impl<tl_tail_t<ListA>, tl_tail_t<ListB>, Pred>::value;
};

template <template <class, typename> class Pred>
struct tl_forall2_impl<empty_type_list, empty_type_list, Pred> {
  static constexpr bool value = true;
};

/// Tests whether a binary predicate holds for all
///    corresponding elements of `ListA` and `ListB`.
template <class ListA, class ListB, template <class, class> class Pred>
struct tl_binary_forall {
  static constexpr bool value =
    tl_size<ListA>::value == tl_size<ListB>::value
    && tl_forall2_impl<ListA, ListB, Pred>::value;
};

// Uncomment after having switched to C++14
//template <class ListA, class ListB, template <class, class> class Pred>
//inline constexpr bool tl_binary_forall_v
//  = tl_binary_forall<ListA, ListB, Pred>::value;

/// Tests whether a predicate holds for some of the elements of a list.
template <class List, template <class> class Pred>
struct tl_exists {
  static constexpr bool value =
    Pred<tl_head_t<List>>::value || tl_exists<tl_tail_t<List>, Pred>::value;
};

template <template <class> class Pred>
struct tl_exists<empty_type_list, Pred> {
  static constexpr bool value = false;
};

// Uncomment after having switched to C++14
//template <class List, template <class> class Pred>
//inline constexpr bool tl_exists_v = tl_exists<List, Pred>::value;

// size_t count(predicate)

/// Counts the number of elements in the list which satisfy a predicate.
template <class List, template <class> class Pred>
struct tl_count {
  static constexpr size_t value =
    (Pred<tl_head_t<List>>::value ? 1 : 0)
    + tl_count<tl_tail_t<List>, Pred>::value;
};

template <template <class> class Pred>
struct tl_count<empty_type_list, Pred> {
  static constexpr size_t value = 0;
};

template <class List, template <class> class Pred>
constexpr size_t tl_count<List, Pred>::value;

// Uncomment after having switched to C++14
//template <class List, template <class> class Pred>
//inline constexpr size_t tl_count_v = tl_count<List, Pred>::value;

// size_t count(type)

/// Counts the number of elements in the list which are equal to `T`.
template <class List, class T>
struct tl_count_type {
  static constexpr size_t value =
    (std::is_same<tl_head_t<List>, T>::value ? 1 : 0)
    + tl_count_type<tl_tail_t<List>, T>::value;
};

template <class T>
struct tl_count_type<empty_type_list, T> {
  static constexpr size_t value = 0;
};

template <class List, class T>
constexpr size_t tl_count_type<List, T>::value;

// Uncomment after having switched to C++14
//template <class List, class T>
//inline constexpr size_t tl_count_type_v = tl_count_type<List, T>::value;

// size_t count_not(predicate)

/// Counts the number of elements in the list which satisfy a predicate.
template <class List, template <class> class Pred>
struct tl_count_not {
  static constexpr size_t value =
    (Pred<tl_head_t<List>>::value ? 0 : 1) +
    tl_count_not<tl_tail_t<List>, Pred>::value;

};

template <template <class> class Pred>
struct tl_count_not<empty_type_list, Pred> {
  static constexpr size_t value = 0;
};

// Uncomment after having switched to C++14
//template <class List, template <class> class Pred>
//inline constexpr size_t tl_count_not_v = tl_count_not<List, Pred>::value;

template <class ListA, class ListB>
struct tl_concat_impl;

/// Concatenates two lists.
template <class... LhsTs, class... RhsTs>
struct tl_concat_impl<type_list<LhsTs...>, type_list<RhsTs...>> {
  using type = type_list<LhsTs..., RhsTs...>;
};

// static list concat(list, list)

/// Concatenates lists.
template <class... Lists>
struct tl_concat;

template <class List0>
struct tl_concat<List0> {
  using type = List0;
};

template <class List0, class List1, class... Lists>
struct tl_concat<List0, List1, Lists...> {
  using type =
    typename tl_concat<
      typename tl_concat_impl<List0, List1>::type,
      Lists...
    >::type;
};

template <class... Lists>
using tl_concat_t = typename tl_concat<Lists...>::type;

// list push_back(list, type)

template <class List, class What>
struct tl_push_back;

/// Appends `What` to given list.
template <class... ListTs, class What>
struct tl_push_back<type_list<ListTs...>, What> {
  using type = type_list<ListTs..., What>;
};

template <class List, class What>
using tl_push_back_t = typename tl_push_back<List, What>::type;

template <class List, class What>
struct tl_push_front;

/// Appends `What` to given list.
template <class... ListTs, class What>
struct tl_push_front<type_list<ListTs...>, What> {
  using type = type_list<What, ListTs...>;
};

template <class List, class What>
using tl_push_front_t = typename tl_push_front<List, What>::type;

/// Alias for `tl_push_front<List, What>`.
template <class What, class List>
struct tl_cons : tl_push_front<List, What> {
  // nop
};

template <class List, class What>
using tl_cons_t = tl_push_front_t<List, What>;

// list map(list, trait)

template <class T, template <class> class... Funs>
struct tl_apply_all;

template <class T>
struct tl_apply_all<T> {
  using type = T;
};

template <class T, template <class> class Fun0, template <class> class... Funs>
struct tl_apply_all<T, Fun0, Funs...> {
  using type = typename tl_apply_all<typename Fun0<T>::type, Funs...>::type;
};

template <class T, template <class> class... Funs>
using tl_apply_all_t = typename tl_apply_all<T, Funs...>::type;

/// Creates a new list by applying a "template function" to each element.
template <class List, template <class> class... Funs>
struct tl_map;

template <class... Ts, template <class> class... Funs>
struct tl_map<type_list<Ts...>, Funs...> {
  using type = type_list<tl_apply_all_t<Ts, Funs...>...>;
};

template <class List, template <class> class... Funs>
using tl_map_t = typename tl_map<List, Funs...>::type;

/// Creates a new list by applying a `Fun` to each element which
///    returns `TraitResult` for `Trait`.
template <class List, template <class> class Trait, bool TRes,
          template <class> class... Funs>
struct tl_map_conditional {
  using type =
    tl_concat_t<
      type_list<
        typename std::conditional<
          Trait<tl_head_t<List>>::value == TRes,
          tl_apply_all_t<tl_head_t<List>, Funs...>,
          tl_head_t<List>
        >::type
      >,
      typename tl_map_conditional<tl_tail_t<List>, Trait, TRes, Funs...>::type
    >;
};

template <template <class> class Trait, bool TraitResult,
         template <class> class... Funs>
struct tl_map_conditional<empty_type_list, Trait, TraitResult, Funs...> {
  using type = empty_type_list;
};

// list pop_back()

/// Creates a new list wih all but the last element of `List`.
template <class List>
struct tl_pop_back {
  using type = typename tl_slice<List, 0, tl_size<List>::value - 1>::type;
};

template <>
struct tl_pop_back<empty_type_list> {
  using type = empty_type_list;
};

template <class List>
using tl_pop_back_t = typename tl_pop_back<List>::type;

// list replace_back()

/// Creates a new list with all but the last element of `List`
/// and append `T` to the new list.
template <class List, class Back, class Intermediate = type_list<>>
struct tl_replace_back;

template <class T0, class T1, class... Ts, class Back, class... Us>
struct tl_replace_back<type_list<T0, T1, Ts...>, Back, type_list<Us...>>
    : tl_replace_back<type_list<T1, Ts...>, Back, type_list<Us..., T0>> {};

template <class T, class Back, class... Us>
struct tl_replace_back<type_list<T>, Back, type_list<Us...>> {
  using type = type_list<Us..., Back>;
};

template <class List, class Back, class Intermediate = type_list<>>
using tl_replace_back_t
  = typename tl_replace_back<List, Back, Intermediate>::type;

// type at(size_t)

template <size_t N, class... E>
struct tl_at_impl;

template <size_t N, typename E0, class... E>
struct tl_at_impl<N, E0, E...> {
  using type = typename tl_at_impl<N - 1, E...>::type;
};

template <class E0, class... E>
struct tl_at_impl<0, E0, E...> {
  using type = E0;
};

template <size_t N>
struct tl_at_impl<N> {
  using type = unit_t; // no such element
};

template <class List, size_t N>
struct tl_at;

/// Gets element at index `N` of `List`.
template <size_t N, class... E>
struct tl_at<type_list<E...>, N> {
  using type = typename tl_at_impl<N, E...>::type;
};

template <class List, size_t N>
using tl_at_t = typename tl_at<List, N>::type;

// list prepend(type)

template <class List, class What>
struct tl_prepend;

/// Creates a new list with `What` prepended to `List`.
template <class What, class... T>
struct tl_prepend<type_list<T...>, What> {
  using type = type_list<What, T...>;
};

template <class List, class What>
using tl_prepend_t = typename tl_prepend<List, What>::type;

// list filter(predicate)
// list filter_not(predicate)

template <class List, bool... Selected>
struct tl_filter_impl;

template <>
struct tl_filter_impl<empty_type_list> {
  using type = empty_type_list;
};

template <class T0, class... T, bool... S>
struct tl_filter_impl<type_list<T0, T...>, false, S...> {
  using type = typename tl_filter_impl<type_list<T...>, S...>::type;
};

template <class T0, class... T, bool... S>
struct tl_filter_impl<type_list<T0, T...>, true, S...> {
  using type =
    tl_prepend_t<
      typename tl_filter_impl<
        type_list<T...>,
        S...
      >::type,
      T0
    >;
};

template <class List, template <class> class Pred>
struct tl_filter;

/// Create a new list containing all elements which satisfy `Pred`.
template <template <class> class Pred, class... T>
struct tl_filter<type_list<T...>, Pred> {
  using type =
    typename tl_filter_impl<
      type_list<T...>,
      Pred<T>::value...
    >::type;
};

template <class List, template <class> class Pred>
using tl_filter_t = typename tl_filter<List, Pred>::type;

/// Creates a new list containing all elements which
///    do not satisfy `Pred`.
template <class List, template <class> class Pred>
struct tl_filter_not;

template <template <class> class Pred>
struct tl_filter_not<empty_type_list, Pred> {
  using type = empty_type_list;
};

template <template <class> class Pred, class... T>
struct tl_filter_not<type_list<T...>, Pred> {
  using type =
    typename tl_filter_impl<
      type_list<T...>,
      !Pred<T>::value...
    >::type;
};

template <class List, template <class> class Pred>
using tl_filter_not_t = typename tl_filter_not<List, Pred>::type;

/// Creates a new list containing all elements which
///    are equal to `Type`.
template <class List, class Type>
struct tl_filter_type;

template <class Type, class... T>
struct tl_filter_type<type_list<T...>, Type> {
  using type =
    typename tl_filter_impl<
      type_list<T...>,
      !std::is_same<T, Type>::value...
    >::type;
};

template <class List, class T>
using tl_filter_type_t = typename tl_filter_type<List, T>::type;

/// Creates a new list containing all elements which
///    are not equal to `Type`.
template <class List, class Type>
struct tl_filter_not_type;

template <class Type, class... T>
struct tl_filter_not_type<type_list<T...>, Type> {
  using type =
    typename tl_filter_impl<
      type_list<T...>,
      (!std::is_same<T, Type>::value)...
    >::type;
};

template <class List, class T>
using tl_filter_not_type_t = typename tl_filter_not_type<List, T>::type;

// list distinct(list)

/// Creates a new list from `List` without any duplicate elements.
template <class List>
struct tl_distinct;

template <>
struct tl_distinct<empty_type_list> {
  using type = empty_type_list;
};

template <class T0, class... Ts>
struct tl_distinct<type_list<T0, Ts...>> {
  using type =
    tl_concat_t<
      type_list<T0>,
      typename tl_distinct<
        tl_filter_type_t<
          type_list<Ts...>,
          T0
        >
      >::type
    >;
};

template <class List>
using tl_distinct_t = typename tl_distinct<List>::type;

// bool is_distinct

/// Tests whether a list is distinct.
template <class List>
struct tl_is_distinct {
  static constexpr bool value =
    tl_size<List>::value == tl_size<tl_distinct_t<List>>::value;
};

// Uncomment after having switched to C++14
//template <class List>
//inline constexpr bool tl_is_distinct_v = tl_is_distinct<List>::value;

// list resize(list, size, fill_type)

template <class List, bool OldSizeLessNewSize, size_t OldSize, size_t NewSize,
      class FillType>
struct tl_pad_right_impl;

template <class List, size_t OldSize, size_t NewSize, class FillType>
struct tl_pad_right_impl<List, false, OldSize, NewSize, FillType> {
  using type = tl_slice_t<List, 0, NewSize>;
};

template <class List, size_t Size, class FillType>
struct tl_pad_right_impl<List, false, Size, Size, FillType> {
  using type = List;
};

template <class List, size_t OldSize, size_t NewSize, class FillType>
struct tl_pad_right_impl<List, true, OldSize, NewSize, FillType> {
  using type =
    typename tl_pad_right_impl<
      tl_push_back_t<List, FillType>,
      OldSize + 1 < NewSize,
      OldSize + 1,
      NewSize,
      FillType
    >::type;
};

/// Resizes the list to contain `NewSize` elements and uses
///    `FillType` to initialize the new elements with.
template <class List, size_t NewSize, class FillType = unit_t>
struct tl_pad_right {
  using type =
    typename tl_pad_right_impl<
      List,
      (tl_size<List>::value < NewSize),
      tl_size<List>::value,
      NewSize,
      FillType
    >::type;
};

template <class List, size_t NewSize, class FillType = unit_t>
using tl_pad_right_t = typename tl_pad_right<List, NewSize, FillType>::type;

// bool pad_left(list, N)

template <class List, size_t OldSize, size_t NewSize, class FillType>
struct tl_pad_left_impl {
  using type =
    typename tl_pad_left_impl<
      tl_push_front_t<List, FillType>,
      OldSize + 1,
      NewSize,
      FillType
    >::type;
};

template <class List, size_t Size, class FillType>
struct tl_pad_left_impl<List, Size, Size, FillType> {
  using type = List;
};

/// Resizes the list to contain `NewSize` elements and uses
///    `FillType` to initialize prepended elements with.
template <class List, size_t NewSize, class FillType = unit_t>
struct tl_pad_left {
  static constexpr size_t list_size = tl_size<List>::value;
  using type =
    typename tl_pad_left_impl<
      List,
      list_size,
      (list_size > NewSize) ? list_size : NewSize,
      FillType
    >::type;
};

template <class List, size_t NewSize, class FillType = unit_t>
using tl_pad_left_t = typename tl_pad_left<List, NewSize, FillType>::type;

// bool is_zipped(list)

template <class List>
struct tl_is_zipped {
  static constexpr bool value = tl_forall<List, is_type_pair>::value;
};

// Uncomment after having switched to C++14
//template <class List>
//inline constexpr bool tl_is_zipped_v = tl_is_zipped<List>::value;

/// Removes trailing `What` elements from the end.
template <class List, class What = unit_t>
struct tl_trim {
  using type =
    typename std::conditional<
      std::is_same<typename tl_back<List>::type, What>::value,
      typename tl_trim<tl_pop_back_t<List>, What>::type,
      List
    >::type;
};

template <class What>
struct tl_trim<empty_type_list, What> {
  using type = empty_type_list;
};

template <class List, class What = unit_t>
using tl_trim_t = typename tl_trim<List, What>::type;

// list union(list1, list2)

template <class... Ts>
struct tl_union {
  using type = tl_distinct_t<tl_concat_t<Ts...>>;
};

template <class... Ts>
using tl_union_t = typename tl_union<Ts...>::type;

// list intersect(list1, list2)

template <class List,
          bool HeadIsUnique = tl_count_type<List, tl_head_t<List>>::value == 1>
struct tl_intersect_impl;

template <>
struct tl_intersect_impl<empty_type_list, false> {
  using type = empty_type_list;
};

template <class T0, class... Ts>
struct tl_intersect_impl<type_list<T0, Ts...>, true> {
  using type = typename tl_intersect_impl<type_list<Ts...>>::type;
};

template <class T0, class... Ts>
struct tl_intersect_impl<type_list<T0, Ts...>, false> {
  using type =
    tl_concat_t<
      type_list<T0>,
      typename tl_intersect_impl<
        tl_filter_type_t<
          type_list<Ts...>,
          T0
        >
      >::type
    >;
};

template <class... Ts>
struct tl_intersect {
  using type =
    typename tl_intersect_impl<
      tl_concat_t<Ts...>
    >::type;
};

template <class... Ts>
using tl_intersect_t = typename tl_intersect<Ts...>::type;

// list group_by(list, predicate)

template <bool Append, class What, class Where>
struct tl_group_by_impl_step;

template <class What, class... Ts>
struct tl_group_by_impl_step<true, What, type_list<Ts...>> {
  using type = type_list<type_list<Ts..., What>>;
};

template <class What, class List>
struct tl_group_by_impl_step<false, What, List> {
  using type = type_list<List, type_list<What>>;
};

template <class In, class Out, template <class, typename> class Pred>
struct tl_group_by_impl {
  using last_group = tl_back_t<Out>;
  using suffix =
    typename tl_group_by_impl_step<
      Pred<
        tl_head<In>,
        tl_back<last_group>
      >::value,
      tl_head_t<In>,
      last_group
    >::type;
  using prefix = tl_pop_back_t<Out>;
  using new_out = tl_concat_t<prefix, suffix>;
  using type =
    typename tl_group_by_impl<
      tl_tail_t<In>,
      new_out,
      Pred
    >::type;
};

template <template <class, class> class Pred, class T0, class... Ts>
struct tl_group_by_impl<type_list<T0, Ts...>, empty_type_list, Pred> {
  using type =
    typename tl_group_by_impl<
      type_list<Ts...>,
      type_list<type_list<T0>>,
      Pred
    >::type;
};

template <class Out, template <class, typename> class Pred>
struct tl_group_by_impl<empty_type_list, Out, Pred> {
  using type = Out;
};

template <class List, template <class, typename> class Pred>
struct tl_group_by {
  using type =
    typename tl_group_by_impl<
      List,
      empty_type_list,
      Pred
    >::type;
};

template <class List, template <class, typename> class Pred>
using tl_group_by_t = typename tl_group_by<List, Pred>::type;

/// Applies the types of the list to `VarArgTemplate`.
template <class List, template <class...> class VarArgTemplate>
struct tl_apply;

template <class... Ts, template <class...> class VarArgTemplate>
struct tl_apply<type_list<Ts...>, VarArgTemplate> {
  using type = VarArgTemplate<Ts...>;
};

template <class List, template <class...> class VarArgTemplate>
using tl_apply_t = typename tl_apply<List, VarArgTemplate>::type;

// contains(list, x)

template <class List, class X>
struct tl_contains;

template <class X>
struct tl_contains<type_list<>, X> : std::false_type {};

template <class... Ts, class X>
struct tl_contains<type_list<X, Ts...>, X> : std::true_type {};

template <class T, class... Ts, class X>
struct tl_contains<type_list<T, Ts...>, X> : tl_contains<type_list<Ts...>, X> {};

// Uncomment after having switched to C++14
//template <class List, class X>
//inline constexpr bool tl_contains_v = tl_contains<List, X>::value;

// subset_of(list, list)

template <class ListA, class ListB, bool Fwd = true>
struct tl_subset_of;

template <class List>
struct tl_subset_of<type_list<>, List, true> : std::true_type {};

template <class ListA, class ListB>
struct tl_subset_of<ListA, ListB, false> : std::false_type {};

template <class T, class... Ts, class List>
struct tl_subset_of<type_list<T, Ts...>, List>
    : tl_subset_of<type_list<Ts...>, List, tl_contains<List, T>::value> {};

// Uncomment after having switched to C++14
// template <class ListA, class ListB, bool Fwd = true>
// inline constexpr bool tl_subset_of_v = tl_subset_of<ListA, ListB, Fwd>::value;

/// Tests whether ListA contains the same elements as ListB
/// and vice versa. This comparison ignores element positions.
template <class ListA, class ListB>
struct tl_equal {
  static constexpr bool value = tl_subset_of<ListA, ListB>::value
                                && tl_subset_of<ListB, ListA>::value;
};

// Uncomment after having switched to C++14
// template <class ListA, class ListB>
// inline constexpr bool tl_equal_v = tl_equal<ListA, ListB>::value;

template <size_t N, class T>
struct tl_replicate {
  using type = tl_cons_t<T, typename tl_replicate<N - 1, T>::type>;
};

template <class T>
struct tl_replicate<0, T> {
  using type = type_list<>;
};

template <size_t N, class T>
using tl_replicate_t = typename tl_replicate<N, T>::type;

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_TYPE_LIST_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_TYPE_ERASED_TUPLE_VIEW_HPP
#define CAF_DETAIL_TYPE_ERASED_TUPLE_VIEW_HPP

#include <tuple>
#include <cstddef>
#include <cstdint>
#include <typeinfo>
#include <functional>

#include "caf/fwd.hpp"
#include "caf/error.hpp"
#include "caf/type_nr.hpp"
#include "caf/type_erased_value.hpp"
#include "caf/type_erased_tuple.hpp"

#include "caf/detail/try_match.hpp"
#include "caf/detail/apply_args.hpp"

namespace caf {
namespace detail {

template <class... Ts>
class type_erased_tuple_view : public type_erased_tuple {
public:
  // -- member types -----------------------------------------------------------

  template <size_t X>
  using num_token = std::integral_constant<size_t, X>;

  using tuple_type = std::tuple<type_erased_value_impl<std::reference_wrapper<Ts>>...>;

  // -- constructors, destructors, and assignment operators --------------------

  type_erased_tuple_view(Ts&... xs) : xs_(xs...) {
    init();
  }

  type_erased_tuple_view(const type_erased_tuple_view& other)
      : type_erased_tuple(),
        xs_(other.xs_) {
    init();
  }

  type_erased_tuple_view& operator=(type_erased_tuple_view&&) = delete;
  type_erased_tuple_view& operator=(const type_erased_tuple_view&) = delete;

  // -- overridden modifiers ---------------------------------------------------

  void* get_mutable(size_t pos) override {
    return ptrs_[pos]->get_mutable();
  }

  error load(size_t pos, deserializer& source) override {
    return ptrs_[pos]->load(source);
  }

  // -- overridden observers ---------------------------------------------------

  size_t size() const noexcept override {
    return sizeof...(Ts);
  }

  uint32_t type_token() const noexcept override {
    return make_type_token<Ts...>();
  }

  rtti_pair type(size_t pos) const noexcept override {
    return ptrs_[pos]->type();
  }

  const void* get(size_t pos) const noexcept override {
    return ptrs_[pos]->get();
  }

  std::string stringify(size_t pos) const override {
    return ptrs_[pos]->stringify();
  }

  type_erased_value_ptr copy(size_t pos) const override {
    return ptrs_[pos]->copy();
  }

  error save(size_t pos, serializer& sink) const override {
    return ptrs_[pos]->save(sink);
  }

  // -- member variables access ------------------------------------------------

  tuple_type& data() {
    return xs_;
  }

  const tuple_type& data() const {
    return xs_;
  }

private:
  // -- pointer "lookup table" utility -----------------------------------------

  template <size_t N>
  void init(num_token<N>, num_token<N>) {
    // end of recursion
  }

  template <size_t P, size_t N>
  void init(num_token<P>, num_token<N> last) {
    ptrs_[P] = &std::get<P>(xs_);
    init(num_token<P + 1>{}, last);
  }

  void init() {
    init(num_token<0>{}, num_token<sizeof...(Ts)>{});
  }

  // -- data members -----------------------------------------------------------

  tuple_type xs_;
  type_erased_value* ptrs_[sizeof...(Ts) == 0 ? 1 : sizeof...(Ts)];
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_TYPE_ERASED_TUPLE_VIEW_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_GET_ROOT_UUID_HPP
#define CAF_DETAIL_GET_ROOT_UUID_HPP

#include <string>

namespace caf {
namespace detail {

std::string get_root_uuid();

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_GET_ROOT_UUID_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_STREAM_DISTRIBUTION_TREE_HPP
#define CAF_DETAIL_STREAM_DISTRIBUTION_TREE_HPP

#include <memory>
#include <unordered_map>

#include "caf/ref_counted.hpp"
#include "caf/stream_manager.hpp"
#include "caf/random_gatherer.hpp"
#include "caf/scheduled_actor.hpp"
#include "caf/broadcast_scatterer.hpp"

namespace caf {
namespace detail {

/// A stream distribution tree consist of peers forming an acyclic graph. The
/// user is responsible for making sure peers do not form a loop. Data is
/// flooded along the tree. Each peer serves any number of subscribers. The
/// policy of the tree enables subscriptions to different chunks of the whole
/// stream (substreams).
///
/// The tree uses two CAF streams between each pair of peers for transmitting
/// data. This automatically adds backpressure to the system, i.e., no peer can
/// overwhelm others.
///
/// Policies need to provide the following member types and functions:
///
/// ~~~{.cpp}
/// struct policy {
///   /// Any number of user-defined arguments.
///   policy(...);
///
///   /// Tuple of available substream scatterers to subscribers. Each
///   /// element of the tuple is a subtype of `topic_scatterer<T>` (or
///   /// provides a similar interface).
///   using substream_scatterers = ...;
///
///   /// A compile-time index type identifying individual substreams.
///   using substream_index_type = ...;
///
///   /// Represent a single topic for filtering stream data.
///   using topic_type = ...;
///
///   /// Groups multiple topics into a single selection filter.
///   using filter_type = ...;
///
///   /// Policy for gathering data from peers.
///   using gatherer_type = ...;
///
///   /// Policy for scattering data to peers.
///   using scatterer_type = ...;
///
///   /// Decides whether a filter applies to a given message.
///   bool selected(const filter_type& sieve, const message& sand) const;
///
///   // + one overload to `selected` for each substream data type.
///
///   /// Accesses individual substream scatterers by index.
///   auto& substream(substream_scatterers&, substream_index_type);
///
///   /// Accesses individual substream scatterers by stream ID.
///   stream_scatterer* substream(substream_scatterers&, const stream_id&);
///
///   /// Returns true if the substreams have no data pending and the policy
///   /// decides to shutdown this peer.
///   bool at_end() const;
///
///   /// Returns true if outgoing data originating on this peer is
///   /// forwarded to all substreams. Otherwise, the substreams receive data
///   /// produced on other peers exclusively.
///   bool substream_local_data() const;
///
///   /// Handles a batch if matches the data types managed by any of the
///   /// substreams. Returns `none` if the batch is a peer message, otherwise
///   /// the error resulting from handling the batch.
///   optional<error> batch(const stream_id& sid, const actor_addr& hdl,
///                         long xs_size, message& xs, int64_t xs_id);
///
///   ///
///   void push_to_substreams(message msg);
/// };
/// ~~~
template <class Policy>
class stream_distribution_tree : public stream_manager {
public:
  // -- nested types -----------------------------------------------------------
  
  using super = stream_manager;

  using gatherer_type = typename Policy::gatherer_type;

  using scatterer_type = typename Policy::scatterer_type;

  // --- constructors and destructors ------------------------------------------

  template <class... Ts>
  stream_distribution_tree(scheduled_actor* selfptr, Ts&&... xs)
      : self_(selfptr),
        in_(selfptr),
        out_(selfptr),
        policy_(this, std::forward<Ts>(xs)...) {
    // nop
  }

  ~stream_distribution_tree() override {
    // nop
  }

  // -- Accessors --------------------------------------------------------------
 
  inline Policy& policy() {
    return policy_;
  }

  inline const Policy& policy() const {
    return policy_;
  }

  void close_remote_input();


  // -- Overridden member functions of `stream_manager` ------------------------

  /// Terminates the core actor with log output `log_message` if `at_end`
  /// returns `true`.
  void shutdown_if_at_end(const char* log_message) {
    CAF_IGNORE_UNUSED(log_message);
    if (policy_.at_end()) {
      CAF_LOG_DEBUG(log_message);
      self_->quit(caf::exit_reason::user_shutdown);
    }
  }

  // -- overridden member functions of `stream_manager` ------------------------

  error ack_open(const stream_id& sid, const actor_addr& rebind_from,
                 strong_actor_ptr rebind_to, long initial_demand,
                 bool redeployable) override {
    CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(rebind_from) << CAF_ARG(rebind_to)
                  << CAF_ARG(initial_demand) << CAF_ARG(redeployable));
    auto res = super::ack_open(sid, rebind_from, rebind_to, initial_demand,
                               redeployable);
    if (res == none)
      policy_.ack_open_success(sid, rebind_from, rebind_to);
    else
      policy_.ack_open_failure(sid, rebind_from, rebind_to, res);
    return res;
  }

  error process_batch(message& xs) override {
    CAF_LOG_TRACE(CAF_ARG(xs));
    policy_.handle_batch(xs);
    return none;
  }

  error batch(const stream_id& sid, const actor_addr& hdl, long xs_size,
              message& xs, int64_t xs_id) override {
    CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(hdl) << CAF_ARG(xs_size)
                  << CAF_ARG(xs) << CAF_ARG(xs_id));
    policy_.before_handle_batch(sid, hdl, xs_size, xs, xs_id);
    auto res = super::batch(sid, hdl, xs_size, xs, xs_id);
    policy_.after_handle_batch(sid, hdl, xs_id);
    push();
    return res;
  }

  bool done() const override {
    return false;
  }

  gatherer_type& in() override {
    return in_;
  }

  scatterer_type& out() override {
    return out_;
  }

  void downstream_demand(outbound_path*, long) override {
    CAF_LOG_TRACE("");
    push();
    in_.assign_credit(out_.credit());
  }

  error close(const stream_id& sid, const actor_addr& hdl) override {
    CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(hdl));
    if (in_.remove_path(sid, hdl, none, true))
      return policy_.path_closed(sid, hdl);
    return none;
  }

  error drop(const stream_id& sid, const actor_addr& hdl) override {
    CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(hdl));
    if (out_.remove_path(sid, hdl, none, true))
      return policy_.path_dropped(sid, hdl);
    return none;
  }

  error forced_close(const stream_id& sid, const actor_addr& hdl,
                     error reason) override {
    CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(hdl) << CAF_ARG(reason));
    if (in_.remove_path(sid, hdl, reason, true))
      return policy_.path_force_closed(sid, hdl, std::move(reason));
    return none;
  }

  error forced_drop(const stream_id& sid, const actor_addr& hdl,
                     error reason) override {
    if (out_.remove_path(sid, hdl, reason, true))
      return policy_.path_force_dropped(sid, hdl, std::move(reason));
    return none;
  }

  scheduled_actor* self() {
    return self_;
  }

private:
  scheduled_actor* self_;
  gatherer_type in_;
  scatterer_type out_;
  Policy policy_;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_STREAM_DISTRIBUTION_TREE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_INIT_FUN_FACTORY_HPP
#define CAF_DETAIL_INIT_FUN_FACTORY_HPP

#include <tuple>
#include <functional>

#include "caf/fwd.hpp"

#include "caf/detail/apply_args.hpp"
#include "caf/detail/type_traits.hpp"

namespace caf {
namespace detail {

template <class Base, class F, class ArgsPtr,
          bool ReturnsBehavior, bool HasSelfPtr>
class init_fun_factory_helper {
public:
  init_fun_factory_helper(init_fun_factory_helper&&) = default;
  init_fun_factory_helper(const init_fun_factory_helper&) = default;

  init_fun_factory_helper(F fun, ArgsPtr args)
      : fun_(std::move(fun)),
        args_(std::move(args)) {
    // nop
  }

  behavior operator()(local_actor* self) {
    bool_token<ReturnsBehavior> returns_behavior_token;
    bool_token<HasSelfPtr> captures_self_token;
    return apply(returns_behavior_token, captures_self_token, self);
  }

private:
  // behavior (pointer)
  behavior apply(std::true_type, std::true_type, local_actor* ptr) {
    auto res = apply_moved_args_prefixed(fun_, get_indices(*args_), *args_,
                                         static_cast<Base*>(ptr));
    return std::move(res.unbox());
  }

  // void (pointer)
  behavior apply(std::false_type, std::true_type, local_actor* ptr) {
    apply_moved_args_prefixed(fun_, get_indices(*args_),
                              *args_, static_cast<Base*>(ptr));
    return behavior{};
  }

  // behavior ()
  behavior apply(std::true_type, std::false_type, local_actor*) {
    auto res = apply_args(fun_, get_indices(*args_), *args_);
    return std::move(res.unbox());
  }

  // void ()
  behavior apply(std::false_type, std::false_type, local_actor*) {
    apply_args(fun_, get_indices(*args_), *args_);
    return behavior{};
  }

  F fun_;
  ArgsPtr args_;
};

template <class Base, class F>
class init_fun_factory {
public:
  using fun = std::function<behavior (local_actor*)>;

  template <class... Ts>
  fun operator()(F f, Ts&&... xs) {
    static_assert(std::is_base_of<local_actor, Base>::value,
                  "Given Base does not extend local_actor");
    using trait = typename detail::get_callable_trait<F>::type;
    using arg_types = typename trait::arg_types;
    using res_type = typename trait::result_type;
    using first_arg = typename detail::tl_head<arg_types>::type;
    constexpr bool selfptr = std::is_pointer<first_arg>::value;
    constexpr bool rets = std::is_convertible<res_type, behavior>::value;
    using tuple_type = decltype(std::make_tuple(detail::spawn_fwd<Ts>(xs)...));
    using tuple_ptr = std::shared_ptr<tuple_type>;
    using helper = init_fun_factory_helper<Base, F, tuple_ptr, rets, selfptr>;
    return helper{std::move(f),
                  sizeof...(Ts) > 0
                  ? std::make_shared<tuple_type>(detail::spawn_fwd<Ts>(xs)...)
                  : nullptr};
  }
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_INIT_FUN_FACTORY_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 * Dominik Charousset <dominik.charousset (at) haw-hamburg.de>                *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_BUILD_CONFIG_HPP
#define CAF_DETAIL_BUILD_CONFIG_HPP

// this header is auto-generated by CMake

#if 1 != -1
#define CAF_LOG_LEVEL 2
#endif

#if -1 != -1
#define CAF_NO_MEM_MANAGEMENT
#endif

#if -1 != -1
#define CAF_ENABLE_RUNTIME_CHECKS
#endif

#if -1 != -1
#define CAF_USE_ASIO
#endif

#if -1 != -1
#define CAF_NO_EXCEPTIONS
#endif

#endif //CAF_DETAIL_BUILD_CONFIG_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_OPTIONAL_MESSAGE_VISITOR_HPP
#define CAF_DETAIL_OPTIONAL_MESSAGE_VISITOR_HPP

#include "caf/none.hpp"
#include "caf/unit.hpp"
#include "caf/optional.hpp"
#include "caf/delegated.hpp"
#include "caf/skip.hpp"
#include "caf/static_visitor.hpp"
#include "caf/response_promise.hpp"
#include "caf/typed_response_promise.hpp"

#include "caf/detail/type_traits.hpp"

namespace caf {
namespace detail {

template <class T>
struct is_message_id_wrapper {
  template <class U>
  static char (&test(typename U::message_id_wrapper_tag))[1];
  template <class U>
  static char (&test(...))[2];
  static constexpr bool value = sizeof(test<T>(0)) == 1;
};

template <class T>
struct is_response_promise : std::false_type { };

template <>
struct is_response_promise<response_promise> : std::true_type { };

template <class... Ts>
struct is_response_promise<typed_response_promise<Ts...>> : std::true_type { };

template <class... Ts>
struct is_response_promise<delegated<Ts...>> : std::true_type { };


template <class T>
struct optional_message_visitor_enable_tpl {
  static constexpr bool value =
      !is_one_of<
        typename std::remove_const<T>::type,
        none_t,
        unit_t,
        skip_t,
        optional<skip_t>
      >::value
      && !is_message_id_wrapper<T>::value
      && !is_response_promise<T>::value;
};

class optional_message_visitor : public static_visitor<optional<message>> {
public:
  optional_message_visitor() = default;

  using opt_msg = optional<message>;

  inline opt_msg operator()(const none_t&) const {
    return none;
  }

  inline opt_msg operator()(const skip_t&) const {
    return none;
  }

  inline opt_msg operator()(const unit_t&) const {
    return message{};
  }

  inline opt_msg operator()(optional<skip_t>& val) const {
    if (val)
      return none;
    return message{};
  }

  inline opt_msg operator()(opt_msg& msg) {
    return msg;
  }

  template <class T>
  typename std::enable_if<is_response_promise<T>::value, opt_msg>::type
  operator()(const T&) const {
    return message{};
  }

  template <class T, class... Ts>
  typename std::enable_if<
    optional_message_visitor_enable_tpl<T>::value,
    opt_msg
  >::type
  operator()(T& x, Ts&... xs) const {
    return make_message(std::move(x), std::move(xs)...);
  }

  template <class T>
  typename std::enable_if<is_message_id_wrapper<T>::value, opt_msg>::type
  operator()(T& value) const {
    return make_message(atom("MESSAGE_ID"),
                        value.get_message_id().integer_value());
  }

  template <class... Ts>
  opt_msg operator()(std::tuple<Ts...>& value) const {
    return apply_args(*this, get_indices(value), value);
  }

  template <class T>
  opt_msg operator()(optional<T>& value) const {
    if (value)
      return (*this)(*value);
    if (value.empty())
      return message{};
    return value.error();
  }
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_OPTIONAL_MESSAGE_VISITOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_SAFE_EQUAL_HPP
#define CAF_DETAIL_SAFE_EQUAL_HPP

#include <cmath> // fabs
#include <limits>
#include <type_traits>

namespace caf {
namespace detail {

/// Compares two values by using `operator==` unless two floating
/// point numbers are compared. In the latter case, the function
/// performs an epsilon comparison.
template <class T, typename U>
typename std::enable_if<
  !std::is_floating_point<T>::value
  && !std::is_floating_point<U>::value
  && !(std::is_same<T, U>::value && std::is_empty<T>::value),
  bool
>::type
safe_equal(const T& lhs, const U& rhs) {
  return lhs == rhs;
}

template <class T, typename U>
typename std::enable_if<
  std::is_same<T, U>::value && std::is_empty<T>::value,
  bool
>::type
safe_equal(const T&, const U&) {
  return true;
}

template <class T, typename U>
typename std::enable_if<
  std::is_floating_point<T>::value || std::is_floating_point<U>::value,
  bool
>::type
safe_equal(const T& lhs, const U& rhs) {
  using res_type = decltype(lhs - rhs);
  return std::fabs(lhs - rhs) <= std::numeric_limits<res_type>::epsilon();
}

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_SAFE_EQUAL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_GET_PROCESS_ID_HPP
#define CAF_DETAIL_GET_PROCESS_ID_HPP

#include <string>
#include <vector>
#include <utility>

namespace caf {
namespace detail {

unsigned get_process_id();

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_GET_PROCESS_ID_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_SINGLE_READER_QUEUE_HPP
#define CAF_DETAIL_SINGLE_READER_QUEUE_HPP

#include "caf/config.hpp"

#include <list>
#include <deque>
#include <mutex>
#include <atomic>
#include <memory>
#include <limits>
#include <condition_variable> // std::cv_status

#include "caf/detail/intrusive_partitioned_list.hpp"

namespace caf {
namespace detail {

/// Denotes in which state queue and reader are after an enqueue.
enum class enqueue_result {
  /// Indicates that the enqueue operation succeeded and
  /// the reader is ready to receive the data.
  success,

  /// Indicates that the enqueue operation succeeded and
  /// the reader is currently blocked, i.e., needs to be re-scheduled.
  unblocked_reader,

  /// Indicates that the enqueue operation failed because the
  /// queue has been closed by the reader.
  queue_closed
};

/// An intrusive, thread-safe queue implementation.
template <class T, class Delete = std::default_delete<T>>
class single_reader_queue {
public:
  using value_type = T;
  using pointer = value_type*;
  using deleter_type = Delete;
  using unique_pointer = std::unique_ptr<value_type, deleter_type>;
  using cache_type = intrusive_partitioned_list<value_type, deleter_type>;

  /// Tries to dequeue a new element from the mailbox.
  /// @warning Call only from the reader (owner).
  pointer try_pop() {
    return take_head();
  }

  /// Tries to enqueue a new element to the mailbox.
  /// @threadsafe
  enqueue_result enqueue(pointer new_element) {
    CAF_ASSERT(new_element != nullptr);
    pointer e = stack_.load();
    for (;;) {
      if (!e) {
        // if tail is nullptr, the queue has been closed
        delete_(new_element);
        return enqueue_result::queue_closed;
      }
      // a dummy is never part of a non-empty list
      new_element->next = is_dummy(e) ? nullptr : e;
      if (stack_.compare_exchange_strong(e, new_element)) {
        return  (e == reader_blocked_dummy()) ? enqueue_result::unblocked_reader
                                              : enqueue_result::success;
      }
      // continue with new value of e
    }
  }

  /// Queries whether there is new data to read, i.e., whether the next
  /// call to {@link try_pop} would succeeed.
  /// @pre !closed()
  bool can_fetch_more() {
    if (head_ != nullptr)
      return true;
    auto ptr = stack_.load();
    CAF_ASSERT(ptr != nullptr);
    return !is_dummy(ptr);
  }

  /// Queries whether this queue is empty.
  /// @warning Call only from the reader (owner).
  bool empty() {
    CAF_ASSERT(!closed());
    return cache_.empty() && !head_ && is_dummy(stack_.load());
  }

  /// Queries whether this has been closed.
  bool closed() {
    return !stack_.load();
  }

  /// Queries whether this has been marked as blocked, i.e.,
  /// the owner of the list is waiting for new data.
  bool blocked() {
    return stack_.load() == reader_blocked_dummy();
  }

  /// Tries to set this queue from state `empty` to state `blocked`.
  bool try_block() {
    auto e = stack_empty_dummy();
    return stack_.compare_exchange_strong(e, reader_blocked_dummy());
    //return res || e == reader_blocked_dummy();
  }

  /// Tries to set this queue from state `blocked` to state `empty`.
  bool try_unblock() {
    auto e = reader_blocked_dummy();
    return stack_.compare_exchange_strong(e, stack_empty_dummy());
  }

  /// Closes this queue and deletes all remaining elements.
  /// @warning Call only from the reader (owner).
  void close() {
    auto nop = [](const T&) { };
    close(nop);
  }

  /// Closes this queue and applies f to all remaining
  ///        elements before deleting them.
  /// @warning Call only from the reader (owner).
  template <class F>
  void close(const F& f) {
    clear_cached_elements(f);
    if (!blocked() && fetch_new_data(nullptr))
      clear_cached_elements(f);
    cache_.clear(f);
  }

  single_reader_queue() : head_(nullptr) {
    stack_ = stack_empty_dummy();
  }

  ~single_reader_queue() {
    if (!closed())
      close();
  }

  size_t count(size_t max_count = std::numeric_limits<size_t>::max()) {
    size_t res = cache_.count(max_count);
    if (res >= max_count)
      return res;
    fetch_new_data();
    auto ptr = head_;
    while (ptr && res < max_count) {
      ptr = ptr->next;
      ++res;
    }
    return res;
  }

  pointer peek() {
    if (head_ != nullptr || fetch_new_data())
      return head_;
    return nullptr;
  }

  template <class F>
  void peek_all(F fun) {
    auto ranges = cache_.ranges();
    for (auto& range : ranges)
      for (auto i = range.first; i != range.second; ++i)
        fun(*i);
    // Fetch new data if needed
    if (head_ == nullptr) {
      fetch_new_data();
    } else if (!is_dummy(stack_.load())) {
      // Calling fetch_new_data() iterates the stack and prepends messages via
      // head_. This would cause reordering of messages when traversing via
      // peek_all. We hence store the current state of the singly-linked list
      // pointed to by head_ and then reset the list before calling
      // fetch_new_data. Finally, we prepend the old list in order to get a
      // consistent view.
      auto old_head = head_;
      head_ = nullptr;
      auto tail = old_head;
      while (tail->next != nullptr)
        tail = tail->next;
      // This gets new data from the stack and rewrite head_.
      fetch_new_data();
      tail->next = head_;
      head_ = old_head;
    }
    auto ptr = head_;
    while (ptr) {
      fun(*ptr);
      ptr = ptr->next;
    }
  }

  // note: the cache is intended to be used by the owner, the queue itself
  //       never accesses the cache other than for counting;
  //       the first partition of the cache is meant to be used to store and
  //       sort messages that were not processed yet, while the second
  //       partition is meant to store skipped messages
  cache_type& cache() {
    return cache_;
  }

  /**************************************************************************
   *                    support for synchronized access                     *
   **************************************************************************/

  template <class Mutex, class CondVar>
  bool synchronized_enqueue(Mutex& mtx, CondVar& cv, pointer new_element) {
    switch (enqueue(new_element)) {
      case enqueue_result::unblocked_reader: {
        std::unique_lock<Mutex> guard(mtx);
        cv.notify_one();
        return true;
      }
      case enqueue_result::success:
        // enqueued message to a running actor's mailbox
        return true;
      case enqueue_result::queue_closed:
        // actor no longer alive
        return false;
    }
    // should be unreachable
    CAF_CRITICAL("invalid result of enqueue()");
  }

  template <class Mutex, class CondVar>
  void synchronized_await(Mutex& mtx, CondVar& cv) {
    CAF_ASSERT(!closed());
    if (!can_fetch_more() && try_block()) {
      std::unique_lock<Mutex> guard(mtx);
      while (blocked())
        cv.wait(guard);
    }
  }

  template <class Mutex, class CondVar, class TimePoint>
  bool synchronized_await(Mutex& mtx, CondVar& cv, const TimePoint& timeout) {
    CAF_ASSERT(!closed());
    if (!can_fetch_more() && try_block()) {
      std::unique_lock<Mutex> guard(mtx);
      while (blocked()) {
        if (cv.wait_until(guard, timeout) == std::cv_status::timeout) {
          // if we're unable to set the queue from blocked to empty,
          // than there's a new element in the list
          return !try_unblock();
        }
      }
    }
    return true;
  }

private:
  // exposed to "outside" access
  std::atomic<pointer> stack_;

  // accessed only by the owner
  pointer head_;
  deleter_type delete_;
  intrusive_partitioned_list<value_type, deleter_type> cache_;

  // atomically sets stack_ back and enqueues all elements to the cache
  bool fetch_new_data(pointer end_ptr) {
    CAF_ASSERT(!end_ptr || end_ptr == stack_empty_dummy());
    pointer e = stack_.load();
    // must not be called on a closed queue
    CAF_ASSERT(e != nullptr);
    // fetching data while blocked is an error
    CAF_ASSERT(e != reader_blocked_dummy());
    // it's enough to check this once, since only the owner is allowed
    // to close the queue and only the owner is allowed to call this
    // member function
    while (e != end_ptr) {
      if (stack_.compare_exchange_weak(e, end_ptr)) {
        // fetching data while blocked is an error
        CAF_ASSERT(e != reader_blocked_dummy());
        if (is_dummy(e)) {
          // only use-case for this is closing a queue
          CAF_ASSERT(!end_ptr);
          return false;
        }
        while (e) {
          CAF_ASSERT(!is_dummy(e));
          auto next = e->next;
          e->next = head_;
          head_ = e;
          e = next;
        }
        return true;
      }
      // next iteration
    }
    return false;
  }

  bool fetch_new_data() {
    return fetch_new_data(stack_empty_dummy());
  }

  pointer take_head() {
    if (head_ != nullptr || fetch_new_data()) {
      auto result = head_;
      head_ = head_->next;
      return result;
    }
    return nullptr;
  }

  template <class F>
  void clear_cached_elements(const F& f) {
    while (head_) {
      auto next = head_->next;
      f(*head_);
      delete_(head_);
      head_ = next;
    }
  }

  pointer stack_empty_dummy() {
    // we are *never* going to dereference the returned pointer;
    // it is only used as indicator wheter this queue is closed or not
    return reinterpret_cast<pointer>(this);
  }

  pointer reader_blocked_dummy() {
    // we are not going to dereference this pointer either
    return reinterpret_cast<pointer>(reinterpret_cast<intptr_t>(this)
                                     + static_cast<intptr_t>(sizeof(void*)));
  }

  bool is_dummy(pointer ptr) {
    return ptr == stack_empty_dummy() || ptr == reader_blocked_dummy();
  }
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_SINGLE_READER_QUEUE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_CONCATENATED_TUPLE_HPP
#define CAF_DETAIL_CONCATENATED_TUPLE_HPP

#include <vector>
#include <algorithm>

#include "caf/detail/decorated_tuple.hpp"

namespace caf {
namespace detail {

class concatenated_tuple : public message_data {
public:
  // -- member types -----------------------------------------------------------

  using message_data::cow_ptr;

  using vector_type = std::vector<cow_ptr>;

  // -- constructors, destructors, and assignment operators --------------------

  concatenated_tuple(std::initializer_list<cow_ptr> xs);

  static cow_ptr make(std::initializer_list<cow_ptr> xs);

  concatenated_tuple(const concatenated_tuple&) = default;

  concatenated_tuple& operator=(const concatenated_tuple&) = delete;

  // -- overridden observers of message_data -----------------------------------

  cow_ptr copy() const override;

  // -- overridden modifiers of type_erased_tuple ------------------------------

  void* get_mutable(size_t pos) override;

  error load(size_t pos, deserializer& source) override;

  // -- overridden observers of type_erased_tuple ------------------------------

  size_t size() const noexcept override;

  uint32_t type_token() const noexcept override;

  rtti_pair type(size_t pos) const noexcept override;

  const void* get(size_t pos) const noexcept override;

  std::string stringify(size_t pos) const override;

  type_erased_value_ptr copy(size_t pos) const override;

  error save(size_t pos, serializer& sink) const override;

  // -- observers --------------------------------------------------------------

  std::pair<message_data*, size_t> select(size_t pos) const;

private:
  // -- data members -----------------------------------------------------------

  vector_type data_;
  uint32_t type_token_;
  size_t size_;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_CONCATENATED_TUPLE_HPP

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_APPLY_ARGS_HPP
#define CAF_DETAIL_APPLY_ARGS_HPP

#include <utility>

#include "caf/detail/int_list.hpp"
#include "caf/detail/type_list.hpp"

namespace caf {
namespace detail {

// this utterly useless function works around a bug in Clang that causes
// the compiler to reject the trailing return type of apply_args because
// "get" is not defined (it's found during ADL)
template<long Pos, class... Ts>
typename tl_at<type_list<Ts...>, Pos>::type get(const type_list<Ts...>&);

template <class F, long... Is, class Tuple>
auto apply_args(F& f, detail::int_list<Is...>, Tuple& tup)
-> decltype(f(get<Is>(tup)...)) {
  return f(get<Is>(tup)...);
}

template <class F, long... Is, class Tuple>
auto apply_moved_args(F& f, detail::int_list<Is...>, Tuple& tup)
-> decltype(f(std::move(get<Is>(tup))...)) {
  return f(std::move(get<Is>(tup))...);
}

template <class F, class Tuple, class... Ts>
auto apply_args_prefixed(F& f, detail::int_list<>, Tuple&, Ts&&... xs)
-> decltype(f(std::forward<Ts>(xs)...)) {
  return f(std::forward<Ts>(xs)...);
}

template <class F, long... Is, class Tuple, class... Ts>
auto apply_args_prefixed(F& f, detail::int_list<Is...>, Tuple& tup, Ts&&... xs)
-> decltype(f(std::forward<Ts>(xs)..., get<Is>(tup)...)) {
  return f(std::forward<Ts>(xs)..., get<Is>(tup)...);
}

template <class F, class Tuple, class... Ts>
auto apply_moved_args_prefixed(F& f, detail::int_list<>, Tuple&, Ts&&... xs)
-> decltype(f(std::forward<Ts>(xs)...)) {
  return f(std::forward<Ts>(xs)...);
}

template <class F, long... Is, class Tuple, class... Ts>
auto apply_moved_args_prefixed(F& f, detail::int_list<Is...>, Tuple& tup, Ts&&... xs)
-> decltype(f(std::forward<Ts>(xs)..., std::move(get<Is>(tup))...)) {
  return f(std::forward<Ts>(xs)..., std::move(get<Is>(tup))...);
}

template <class F, long... Is, class Tuple, class... Ts>
auto apply_args_suffxied(F& f, detail::int_list<Is...>, Tuple& tup, Ts&&... xs)
-> decltype(f(get<Is>(tup)..., std::forward<Ts>(xs)...)) {
  return f(get<Is>(tup)..., std::forward<Ts>(xs)...);
}

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_APPLY_ARGS_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_INVOKE_VISITOR_HPP
#define CAF_DETAIL_INVOKE_VISITOR_HPP

#include <tuple>

#include "caf/fwd.hpp"
#include "caf/none.hpp"
#include "caf/unit.hpp"
#include "caf/skip.hpp"
#include "caf/result.hpp"
#include "caf/message.hpp"
#include "caf/expected.hpp"
#include "caf/optional.hpp"
#include "caf/make_message.hpp"

#include "caf/detail/int_list.hpp"
#include "caf/detail/apply_args.hpp"

namespace caf {
namespace detail {

class invoke_result_visitor {
public:
  virtual ~invoke_result_visitor();

  constexpr invoke_result_visitor() {
    // nop
  }

  // severs as catch-all case for all values producing
  // no result such as response_promise
  virtual void operator()() = 0;

  // called if the message handler explicitly returned an error
  virtual void operator()(error&) = 0;

  // called if the message handler returned any "ordinary" value
  virtual void operator()(message&) = 0;

  // called if the message handler returns explictly none or unit
  virtual void operator()(const none_t&) = 0;

  // map unit to an empty message
  inline void operator()(const unit_t&) {
    message empty_msg;
    (*this)(empty_msg);
  }

  // unwrap optionals
  template <class T>
  void operator()(optional<T>& x) {
    if (x)
      (*this)(*x);
    else
      (*this)(none);
  }

  // unwrap expecteds
  template <class T>
  void operator()(expected<T>& x) {
    if (x)
      (*this)(*x);
    else
      (*this)(x.error());
  }

  // convert values to messages
  template <class... Ts>
  void operator()(Ts&... xs) {
    auto tmp = make_message(std::move(xs)...);
    (*this)(tmp);
  }

  // unwrap tuples
  template <class... Ts>
  void operator()(std::tuple<Ts...>& xs) {
    apply_args(*this, get_indices(xs), xs);
  }

  // disambiguations

  inline void operator()(none_t& x) {
    (*this)(const_cast<const none_t&>(x));
  }

  inline void operator()(unit_t& x) {
    (*this)(const_cast<const unit_t&>(x));
  }

  // special purpose handler that don't procude results

  inline void operator()(response_promise&) {
    (*this)();
  }

  template <class... Ts>
  void operator()(typed_response_promise<Ts...>&) {
    (*this)();
  }

  template <class... Ts>
  void operator()(delegated<Ts...>&) {
    (*this)();
  }

  template <class T>
  void operator()(stream<T>&) {
    (*this)();
  }

  // visit API - returns true if T was visited, false if T was skipped

  template <class T>
  bool visit(T& x) {
    (*this)(x);
    return true;
  }

  inline bool visit(skip_t&) {
    return false;
  }

  inline bool visit(const skip_t&) {
    return false;
  }

  template <class T>
  bool visit(stream<T>&) {
    return true;
  }

  inline bool visit(optional<skip_t>& x) {
    if (x)
      return false;
    (*this)();
    return true;
  }

  template <class... Ts>
  bool visit(result<Ts...>& x) {
    switch (x.flag) {
      case rt_value:
        (*this)(x.value);
        return true;
      case rt_error:
        (*this)(x.err);
        return true;
      case rt_delegated:
        (*this)();
        return true;
      default:
        return false;
    }
  }
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_INVOKE_VISITOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_STRINGIFICATION_INSPECTOR_HPP
#define CAF_DETAIL_STRINGIFICATION_INSPECTOR_HPP

#include <string>
#include <vector>
#include <functional>
#include <type_traits>

#include "caf/atom.hpp"
#include "caf/none.hpp"
#include "caf/error.hpp"

#include "caf/meta/type_name.hpp"
#include "caf/meta/omittable.hpp"
#include "caf/meta/annotation.hpp"
#include "caf/meta/hex_formatted.hpp"
#include "caf/meta/omittable_if_none.hpp"
#include "caf/meta/omittable_if_empty.hpp"

#include "caf/detail/int_list.hpp"
#include "caf/detail/apply_args.hpp"
#include "caf/detail/type_traits.hpp"

namespace caf {
namespace detail {

class stringification_inspector {
public:
  // -- member types required by Inspector concept -----------------------------

  using result_type = void;

  static constexpr bool reads_state = true;

  // -- constructors, destructors, and assignment operators --------------------

  stringification_inspector(std::string& result) : result_(result) {
    // nop
  }

  // -- operator() -------------------------------------------------------------

  template <class... Ts>
  void operator()(Ts&&... xs) {
    traverse(std::forward<Ts>(xs)...);
  }

  /// Prints a separator to the result string.
  void sep();

  inline void traverse() noexcept {
    // end of recursion
  }

  void consume(atom_value& x);

  void consume(const char* cstr);

  void consume_hex(const uint8_t* xs, size_t n);

  inline void consume(bool& x) {
    result_ += x ? "true" : "false";
  }

  inline void consume(char* cstr) {
    consume(const_cast<const char*>(cstr));
  }

  inline void consume(std::string& str) {
    consume(str.c_str());
  }

  template <class T>
  enable_if_tt<std::is_arithmetic<T>> consume(T& x) {
    result_ += std::to_string(x);
  }

  // unwrap std::ref
  template <class T>
  void consume(std::reference_wrapper<T>& x) {
    return consume(x.get());
  }

  /// Picks up user-defined `to_string` functions.
  template <class T>
  enable_if_t<!std::is_pointer<T>::value && has_to_string<T>::value>
  consume(T& x) {
    result_ += to_string(x);
  }

  /// Delegates to `inspect(*this, x)` if available and `T`
  /// does not provide a `to_string`.
  template <class T>
  enable_if_t<
    is_inspectable<stringification_inspector, T>::value
    && !has_to_string<T>::value>
  consume(T& x) {
    inspect(*this, x);
  }

  template <class F, class S>
  void consume(std::pair<F, S>& x) {
    result_ += '(';
    traverse(deconst(x.first), deconst(x.second));
    result_ += ')';
  }

  template <class... Ts>
  void consume(std::tuple<Ts...>& x) {
    result_ += '(';
    apply_args(*this, get_indices(x), x);
    result_ += ')';
  }

  template <class T>
  enable_if_t<is_iterable<T>::value
              && !is_inspectable<stringification_inspector, T>::value
              && !has_to_string<T>::value>
  consume(T& xs) {
    result_ += '[';
    // use a hand-written for loop instead of for-each to avoid
    // range-loop-analysis warnings when using this function with vector<bool>
    for (auto i = xs.begin(); i != xs.end(); ++i) {
      sep();
      consume(deconst(*i));
    }
    result_ += ']';
  }

  template <class T>
  void consume(T* xs, size_t n) {
    result_ += '(';
    for (size_t i = 0; i < n; ++i) {
      sep();
      consume(deconst(xs[i]));
    }
    result_ += ')';
  }

  template <class T, size_t S>
  void consume(std::array<T, S>& xs) {
    return consume(xs.data(), S);
  }

  template <class T, size_t S>
  void consume(T (&xs)[S]) {
    return consume(xs, S);
  }

  template <class T>
  enable_if_tt<std::is_pointer<T>> consume(T ptr) {
    if (ptr) {
      result_ += '*';
      consume(*ptr);
    } else {
      result_ += "<null>";
    }
  }

  /// Fallback printing `<unprintable>`.
  template <class T>
  enable_if_t<
    !is_iterable<T>::value
    && !std::is_pointer<T>::value
    && !is_inspectable<stringification_inspector, T>::value
    && !std::is_arithmetic<T>::value
    && !has_to_string<T>::value>
  consume(T&) {
    result_ += "<unprintable>";
  }

  template <class T, class... Ts>
  void traverse(meta::hex_formatted_t, T& x, Ts&&... xs) {
    sep();
    consume_hex(reinterpret_cast<uint8_t*>(deconst(x).data()), x.size());
    traverse(std::forward<Ts>(xs)...);
  }

  template <class T, class... Ts>
  void traverse(meta::omittable_if_none_t, T& x, Ts&&... xs) {
    if (x != none) {
      sep();
      consume(x);
    }
    traverse(std::forward<Ts>(xs)...);
  }

  template <class T, class... Ts>
  void traverse(meta::omittable_if_empty_t, T& x, Ts&&... xs) {
    if (!x.empty()) {
      sep();
      consume(x);
    }
    traverse(std::forward<Ts>(xs)...);
  }

  template <class T, class... Ts>
  void traverse(meta::omittable_t, T&, Ts&&... xs) {
    traverse(std::forward<Ts>(xs)...);
  }

  template <class... Ts>
  void traverse(meta::type_name_t x, Ts&&... xs) {
    sep();
    result_ += x.value;
    result_ += '(';
    traverse(std::forward<Ts>(xs)...);
    result_ += ')';
  }

  template <class... Ts>
  void traverse(const meta::annotation&, Ts&&... xs) {
    traverse(std::forward<Ts>(xs)...);
  }

  template <class T, class... Ts>
  enable_if_t<!meta::is_annotation<T>::value> traverse(T&& x, Ts&&... xs) {
    sep();
    consume(deconst(x));
    traverse(std::forward<Ts>(xs)...);
  }

private:
  template <class T>
  T& deconst(const T& x) {
    return const_cast<T&>(x);
  }

  std::string& result_;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_STRINGIFICATION_INSPECTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_SHARED_SPINLOCK_HPP
#define CAF_DETAIL_SHARED_SPINLOCK_HPP

#include <atomic>
#include <cstddef>

namespace caf {
namespace detail {

/// A spinlock implementation providing shared and exclusive locking.
class shared_spinlock {

  std::atomic<long> flag_;

public:

  shared_spinlock();

  void lock();
  void unlock();
  bool try_lock();

  void lock_shared();
  void unlock_shared();
  bool try_lock_shared();

  void lock_upgrade();
  void unlock_upgrade();
  void unlock_upgrade_and_lock();
  void unlock_and_lock_upgrade();

};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_SHARED_SPINLOCK_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_ARG_MATCH_T_HPP
#define CAF_DETAIL_ARG_MATCH_T_HPP

namespace caf {
namespace detail {

struct arg_match_t {};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_ARG_MATCH_T_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_SCOPE_GUARD_HPP
#define CAF_DETAIL_SCOPE_GUARD_HPP

#include <utility>

namespace caf {
namespace detail {

/// A lightweight scope guard implementation.
template <class Fun>
class scope_guard {

  scope_guard() = delete;
  scope_guard(const scope_guard&) = delete;
  scope_guard& operator=(const scope_guard&) = delete;

public:

  scope_guard(Fun f) : fun_(std::move(f)), enabled_(true) {}

  scope_guard(scope_guard&& other)
      : fun_(std::move(other.fun_)), enabled_(other.enabled_) {
    other.enabled_ = false;
  }

  ~scope_guard() {
    if (enabled_) fun_();
  }

  /// Disables this guard, i.e., the guard does not
  /// run its cleanup code as it goes out of scope.
  inline void disable() { enabled_ = false; }

private:

  Fun fun_;
  bool enabled_;

};

/// Creates a guard that executes `f` as soon as it goes out of scope.
/// @relates scope_guard
template <class Fun>
scope_guard<Fun> make_scope_guard(Fun f) {
  return {std::move(f)};
}

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_SCOPE_GUARD_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_THREAD_SAFE_ACTOR_CLOCK_HPP
#define CAF_DETAIL_THREAD_SAFE_ACTOR_CLOCK_HPP

#include <mutex>
#include <atomic>
#include <condition_variable>

#include "caf/detail/simple_actor_clock.hpp"

namespace caf {
namespace detail {

class thread_safe_actor_clock : public simple_actor_clock {
public:
  using super = simple_actor_clock;

  thread_safe_actor_clock();

  void set_receive_timeout(time_point t, abstract_actor* self,
                           uint32_t id) override;

  void set_request_timeout(time_point t, abstract_actor* self,
                           message_id id) override;

  void cancel_receive_timeout(abstract_actor* self) override;

  void cancel_request_timeout(abstract_actor* self, message_id id) override;

  void cancel_timeouts(abstract_actor* self) override;

  void schedule_message(time_point t, strong_actor_ptr receiver,
                        mailbox_element_ptr content) override;

  void schedule_message(time_point t, group target, strong_actor_ptr sender,
                        message content) override;

  void run_dispatch_loop();

  void cancel_dispatch_loop();

private:
  std::mutex mx_;
  std::condition_variable cv_;
  std::atomic<bool> done_;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_THREAD_SAFE_ACTOR_CLOCK_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_PARSE_INI_HPP
#define CAF_DETAIL_PARSE_INI_HPP

#include <string>
#include <istream>
#include <functional>

#include "caf/atom.hpp"
#include "caf/variant.hpp"
#include "caf/optional.hpp"
#include "caf/config_value.hpp"

namespace caf {
namespace detail {

struct parse_ini_t {
  /// Denotes an optional error output stream
  using opt_err = optional<std::ostream&>;
  /// Denotes a callback for consuming configuration values.
  using config_consumer = std::function<void (size_t, std::string,
                                              config_value&, opt_err)>;

  /// Parse the given input stream as INI formatted data and
  /// calls the consumer with every key-value pair.
  /// @param input Input stream of INI formatted text.
  /// @param consumer_fun Callback consuming generated key-value pairs.
  /// @param errors Output stream for parser errors.
  void operator()(std::istream& input,
                  const config_consumer& consumer_fun,
                  opt_err errors = none) const;

};

constexpr parse_ini_t parse_ini = parse_ini_t{};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_PARSE_INI_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_DISPOSER_HPP
#define CAF_DETAIL_DISPOSER_HPP

#include <type_traits>

#include "caf/memory_managed.hpp"

namespace caf {
namespace detail {

class disposer {
public:
  inline void operator()(memory_managed* ptr) const {
    ptr->request_deletion(false);
  }

  template <class T>
  typename std::enable_if<!std::is_base_of<memory_managed, T>::value>::type
  operator()(T* ptr) const {
    delete ptr;
  }
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_DISPOSER_HPP

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_DYNAMIC_MESSAGE_DATA_HPP
#define CAF_DETAIL_DYNAMIC_MESSAGE_DATA_HPP

#include <vector>

#include "caf/type_erased_value.hpp"

#include "caf/detail/message_data.hpp"

namespace caf {
namespace detail {

class dynamic_message_data : public message_data {
public:
  // -- member types -----------------------------------------------------------

  using elements = std::vector<type_erased_value_ptr>;

  // -- constructors, destructors, and assignment operators --------------------

  dynamic_message_data();

  dynamic_message_data(elements&& data);

  dynamic_message_data(const dynamic_message_data& other);

  ~dynamic_message_data() override;

  // -- overridden observers of message_data -----------------------------------

  cow_ptr copy() const override;

  // -- overridden modifiers of type_erased_tuple ------------------------------

  void* get_mutable(size_t pos) override;

  error load(size_t pos, deserializer& source) override;

  // -- overridden observers of type_erased_tuple ------------------------------

  size_t size() const noexcept override;

  uint32_t type_token() const noexcept override;

  rtti_pair type(size_t pos) const noexcept override;

  const void* get(size_t pos) const noexcept override;

  std::string stringify(size_t pos) const override;

  type_erased_value_ptr copy(size_t pos) const override;

  error save(size_t pos, serializer& sink) const override;

  // -- modifiers --------------------------------------------------------------

  void clear();

  void append(type_erased_value_ptr x);

  void add_to_type_token(uint16_t typenr);

private:
  // -- data members -----------------------------------------------------------

  elements elements_;
  uint32_t type_token_;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_DYNAMIC_MESSAGE_DATA_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_MPI_SPLICE_HPP
#define CAF_DETAIL_MPI_SPLICE_HPP

#include <type_traits>

#include "caf/replies_to.hpp"

#include "caf/detail/type_list.hpp"
#include "caf/detail/typed_actor_util.hpp"

namespace caf {
namespace detail {

/*
template <class Input, class X, class... Ts>
struct mpi_splice_one;

template <class Input, class X>
struct mpi_splice_one<Input, X> {
  using type = X;
};

template <class Input, class X, class... Ts>
struct mpi_splice_one<Input, X, none_t, Ts...> {
  using type = none_t;
};

template <class Input, class... Ys, class... Zs, class... Ts>
struct mpi_splice_one<Input,
                      typed_mpi<Input, type_list<Ys...>>,
                      typed_mpi<Input, type_list<Zs...>>,
                      Ts...>
: mpi_splice_one<typed_mpi<type_list<Xs...>, type_list<Ys..., Zs...>>, Ts...> {
  // combine signatures with same input
};
*/

template <class T, class... Lists>
struct mpi_splice_by_input;

template <class T>
struct mpi_splice_by_input<T> {
  using type = T;
};

template <class T, class... Lists>
struct mpi_splice_by_input<T, type_list<>, Lists...> {
  // consumed an entire list without match -> fail
  using type = none_t;
};

// splice two MPIs if they have the same input
template <class Input, class... Xs, class... Ys, class... Ts, class... Lists>
struct mpi_splice_by_input<typed_mpi<Input, type_list<Xs...>>, type_list<typed_mpi<Input, type_list<Ys...>>, Ts...>, Lists...>
  : mpi_splice_by_input<typed_mpi<Input, type_list<Xs..., Ys...>>, Lists...> { };

// skip element in list until empty
template <class MPI, class MPI2, class... Ts, class... Lists>
struct mpi_splice_by_input<MPI, type_list<MPI2, Ts...>, Lists...>
  : mpi_splice_by_input<MPI, type_list<Ts...>, Lists...> { };

template <class Result, class CurrentNeedle, class... Lists>
struct input_mapped;

template <class... Rs, class... Lists>
struct input_mapped<type_list<Rs...>, none_t, type_list<>, Lists...> {
  using type = type_list<Rs...>;
};

template <class... Rs, class T, class... Ts, class... Lists>
struct input_mapped<type_list<Rs...>, none_t, type_list<T, Ts...>, Lists...>
    : input_mapped<type_list<Rs...>, T, type_list<Ts...>, Lists...> {};

template <class... Rs, class T, class FirstList, class... Lists>
struct input_mapped<type_list<Rs...>, T, FirstList, Lists...>
  : input_mapped<type_list<Rs..., typename mpi_splice_by_input<T, Lists...>::type>, none_t, FirstList, Lists...> { };

template <template <class...> class Target, class ListA, class ListB>
struct mpi_splice;

template <template <class...> class Target, class... Ts, class List>
struct mpi_splice<Target, type_list<Ts...>, List> {
  using spliced_list =
    typename input_mapped<type_list<>, none_t, type_list<Ts...>, List>::type;
  using filtered_list =
    typename tl_filter_not_type<
      spliced_list,
      none_t
    >::type;
  static_assert(tl_size<filtered_list>::value > 0,
                "cannot splice incompatible actor handles");
  using type = typename tl_apply<filtered_list, Target>::type;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_MPI_SPLICE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_VARIANT_DATA_HPP
#define CAF_DETAIL_VARIANT_DATA_HPP

#include <stdexcept>
#include <type_traits>

#include "caf/unit.hpp"
#include "caf/none.hpp"

#define CAF_VARIANT_DATA_CONCAT(x, y) x ## y

#define CAF_VARIANT_DATA_GETTER(pos)                                           \
  inline CAF_VARIANT_DATA_CONCAT(T, pos) &                                     \
  get(std::integral_constant<int, pos>) {                                      \
    return CAF_VARIANT_DATA_CONCAT(v, pos);                                    \
  }                                                                            \
  inline const CAF_VARIANT_DATA_CONCAT(T, pos) &                               \
  get(std::integral_constant<int, pos>) const {                                \
    return CAF_VARIANT_DATA_CONCAT(v, pos);                                    \
  }

namespace caf {
namespace detail {

template <class T0,       typename T1  = unit_t, typename T2  = unit_t,
     typename T3  = unit_t, typename T4  = unit_t, typename T5  = unit_t,
     typename T6  = unit_t, typename T7  = unit_t, typename T8  = unit_t,
     typename T9  = unit_t, typename T10 = unit_t, typename T11 = unit_t,
     typename T12 = unit_t, typename T13 = unit_t, typename T14 = unit_t,
     typename T15 = unit_t, typename T16 = unit_t, typename T17 = unit_t,
     typename T18 = unit_t, typename T19 = unit_t, typename T20 = unit_t>
struct variant_data {
  union {
    T0  v0;  T1  v1;  T2  v2;
    T3  v3;  T4  v4;  T5  v5;
    T6  v6;  T7  v7;  T8  v8;
    T9  v9;  T10 v10; T11 v11;
    T12 v12; T13 v13; T14 v14;
    T15 v15; T16 v16; T17 v17;
    T18 v18; T19 v19; T20 v20;
  };

  variant_data() {
    // nop
  }

  ~variant_data() {
    // nop
  }

  CAF_VARIANT_DATA_GETTER(0)
  CAF_VARIANT_DATA_GETTER(1)
  CAF_VARIANT_DATA_GETTER(2)
  CAF_VARIANT_DATA_GETTER(3)
  CAF_VARIANT_DATA_GETTER(4)
  CAF_VARIANT_DATA_GETTER(5)
  CAF_VARIANT_DATA_GETTER(6)
  CAF_VARIANT_DATA_GETTER(7)
  CAF_VARIANT_DATA_GETTER(8)
  CAF_VARIANT_DATA_GETTER(9)
  CAF_VARIANT_DATA_GETTER(10)
  CAF_VARIANT_DATA_GETTER(11)
  CAF_VARIANT_DATA_GETTER(12)
  CAF_VARIANT_DATA_GETTER(13)
  CAF_VARIANT_DATA_GETTER(14)
  CAF_VARIANT_DATA_GETTER(15)
  CAF_VARIANT_DATA_GETTER(16)
  CAF_VARIANT_DATA_GETTER(17)
  CAF_VARIANT_DATA_GETTER(18)
  CAF_VARIANT_DATA_GETTER(19)
  CAF_VARIANT_DATA_GETTER(20)
};

struct variant_data_destructor {
  using result_type = void;

  template <class T>
  void operator()(T& storage) const {
    storage.~T();
  }
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_VARIANT_DATA_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_GET_MAC_ADDRESSES_HPP
#define CAF_DETAIL_GET_MAC_ADDRESSES_HPP

#include <string>
#include <vector>
#include <utility>

namespace caf {
namespace detail {

using iface_info = std::pair<std::string /* interface name */,
                             std::string /* interface address */>;

std::vector<iface_info> get_mac_addresses();

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_GET_MAC_ADDRESSES_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_SYNC_REQUEST_BOUNCER_HPP
#define CAF_DETAIL_SYNC_REQUEST_BOUNCER_HPP

#include <cstdint>

#include "caf/fwd.hpp"
#include "caf/exit_reason.hpp"

namespace caf {

class actor_addr;
class message_id;
class local_actor;
class mailbox_element;

} // namespace caf

namespace caf {
namespace detail {

struct sync_request_bouncer {
  error rsn;
  explicit sync_request_bouncer(error r);
  void operator()(const strong_actor_ptr& sender, const message_id& mid) const;
  void operator()(const mailbox_element& e) const;
};

} // namespace detail
} // namespace caf

#endif // CAF_DETAIL_SYNC_REQUEST_BOUNCER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_CONFIG_HPP
#define CAF_CONFIG_HPP

// this header must be generated by the build system (may be empty)
#include "caf/detail/build_config.hpp"

// Platform-specific adjustments.
#define CAF_CACHE_LINE_SIZE 64

// Config pararameters defined by the build system (usually CMake):
//
// CAF_ENABLE_RUNTIME_CHECKS:
//   - check requirements at runtime
//
// CAF_LOG_LEVEL:
//   - denotes the amount of logging, ranging from error messages only (0)
//     to complete traces (4)

/// Denotes version of CAF in the format {MAJOR}{MINOR}{PATCH},
/// whereas each number is a two-digit decimal number without
/// leading zeros (e.g. 900 is version 0.9.0).
#define CAF_VERSION 1506

/// Defined to the major version number of CAF.
#define CAF_MAJOR_VERSION (CAF_VERSION / 10000)

/// Defined to the minor version number of CAF.
#define CAF_MINOR_VERSION ((CAF_VERSION / 100) % 100)

/// Defined to the patch version number of CAF.
#define CAF_PATCH_VERSION (CAF_VERSION % 100)

// This compiler-specific block defines:
// - CAF_DEPRECATED to annotate deprecated functions
// - CAF_PUSH_WARNINGS/CAF_POP_WARNINGS to surround "noisy" header includes
// - CAF_ANNOTATE_FALLTHROUGH to suppress warnings in switch/case statements
// - CAF_COMPILER_VERSION to retrieve the compiler version in CAF_VERSION format
// - One of the following:
//   + CAF_CLANG
//   + CAF_GCC
//   + CAF_MSVC

// sets CAF_DEPRECATED, CAF_ANNOTATE_FALLTHROUGH,
// CAF_PUSH_WARNINGS and CAF_POP_WARNINGS
#if defined(__clang__)
#  define CAF_CLANG
#  define CAF_DEPRECATED __attribute__((deprecated))
#  define CAF_DEPRECATED_MSG(msg) __attribute__((deprecated(msg)))
#  define CAF_PUSH_WARNINGS                                                    \
    _Pragma("clang diagnostic push")                                           \
    _Pragma("clang diagnostic ignored \"-Wall\"")                              \
    _Pragma("clang diagnostic ignored \"-Wextra\"")                            \
    _Pragma("clang diagnostic ignored \"-Wundef\"")                            \
    _Pragma("clang diagnostic ignored \"-Wshadow\"")                           \
    _Pragma("clang diagnostic ignored \"-Wdeprecated\"")                       \
    _Pragma("clang diagnostic ignored \"-Wextra-semi\"")                       \
    _Pragma("clang diagnostic ignored \"-Wconversion\"")                       \
    _Pragma("clang diagnostic ignored \"-Wcast-align\"")                       \
    _Pragma("clang diagnostic ignored \"-Wfloat-equal\"")                      \
    _Pragma("clang diagnostic ignored \"-Wswitch-enum\"")                      \
    _Pragma("clang diagnostic ignored \"-Wweak-vtables\"")                     \
    _Pragma("clang diagnostic ignored \"-Wdocumentation\"")                    \
    _Pragma("clang diagnostic ignored \"-Wold-style-cast\"")                   \
    _Pragma("clang diagnostic ignored \"-Wsign-conversion\"")                  \
    _Pragma("clang diagnostic ignored \"-Wshorten-64-to-32\"")                 \
    _Pragma("clang diagnostic ignored \"-Wunreachable-code\"")                 \
    _Pragma("clang diagnostic ignored \"-Wdouble-promotion\"")                 \
    _Pragma("clang diagnostic ignored \"-Wc++14-extensions\"")                 \
    _Pragma("clang diagnostic ignored \"-Wunused-parameter\"")                 \
    _Pragma("clang diagnostic ignored \"-Wnested-anon-types\"")                \
    _Pragma("clang diagnostic ignored \"-Wreserved-id-macro\"")                \
    _Pragma("clang diagnostic ignored \"-Wconstant-conversion\"")              \
    _Pragma("clang diagnostic ignored \"-Wimplicit-fallthrough\"")             \
    _Pragma("clang diagnostic ignored \"-Wused-but-marked-unused\"")           \
    _Pragma("clang diagnostic ignored \"-Wdisabled-macro-expansion\"")
#  define CAF_PUSH_NON_VIRTUAL_DTOR_WARNING                                    \
    _Pragma("clang diagnostic push")                                           \
    _Pragma("clang diagnostic ignored \"-Wnon-virtual-dtor\"")
#  define CAF_POP_WARNINGS                                                     \
    _Pragma("clang diagnostic pop")
#  define CAF_ANNOTATE_FALLTHROUGH [[clang::fallthrough]]
#  define CAF_COMPILER_VERSION                                                 \
    (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__)
#  if !__has_feature(cxx_thread_local)
#    define CAF_NO_THREAD_LOCAL
#  endif
#elif defined(__GNUC__)
#  define CAF_GCC
#  define CAF_DEPRECATED __attribute__((deprecated))
#  define CAF_DEPRECATED_MSG(msg) __attribute__((deprecated(msg)))
#  define CAF_PUSH_WARNINGS
    _Pragma("GCC diagnostic push")                                             \
    _Pragma("GCC diagnostic ignored \"-Wshadow\"")                             \
    _Pragma("GCC diagnostic ignored \"-Wpragmas\"")                            \
    _Pragma("GCC diagnostic ignored \"-Wpedantic\"")                           \
    _Pragma("GCC diagnostic ignored \"-Wcast-qual\"")                          \
    _Pragma("GCC diagnostic ignored \"-Wconversion\"")                         \
    _Pragma("GCC diagnostic ignored \"-Wfloat-equal\"")                        \
    _Pragma("GCC diagnostic ignored \"-Wc++14-extensions\"")
#  define CAF_PUSH_NON_VIRTUAL_DTOR_WARNING                                    \
    _Pragma("GCC diagnostic push")                                             \
    _Pragma("GCC diagnostic ignored \"-Wnon-virtual-dtor\"")
#  define CAF_POP_WARNINGS                                                     \
    _Pragma("GCC diagnostic pop")
#  define CAF_ANNOTATE_FALLTHROUGH static_cast<void>(0)
#  define CAF_COMPILER_VERSION                                                 \
     (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
    // disable thread_local on GCC/macOS due to heap-use-after-free bug:
    // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67135
#  ifdef __APPLE__
#    define CAF_NO_THREAD_LOCAL
#  endif
#elif defined(_MSC_VER)
#  define CAF_MSVC
#  define CAF_DEPRECATED
#  define CAF_DEPRECATED_MSG(msg)
#  define CAF_PUSH_WARNINGS
#  define CAF_PUSH_NON_VIRTUAL_DTOR_WARNING
#  define CAF_POP_WARNINGS
#  define CAF_ANNOTATE_FALLTHROUGH static_cast<void>(0)
#  define CAF_COMPILER_VERSION _MSC_FULL_VER
#  pragma warning( disable : 4624 )
#  pragma warning( disable : 4800 )
#  pragma warning( disable : 4503 )
#  ifndef NOMINMAX
#    define NOMINMAX
#  endif // NOMINMAX
#else
#  define CAF_DEPRECATED
#  define CAF_PUSH_WARNINGS
#  define CAF_POP_WARNINGS
#  define CAF_ANNOTATE_FALLTHROUGH static_cast<void>(0)
#endif

// This OS-specific block defines one of the following:
// - CAF_MACOS
// - CAF_LINUX
// - CAF_BSD
// - CAF_WINDOWS
// It also defines CAF_POSIX for POSIX-compatible systems
#if defined(__APPLE__)
#  include "TargetConditionals.h"
#  if TARGET_OS_IPHONE || TARGET_IPHONE_SIMULATOR
#    define CAF_IOS
#  else
#    define CAF_MACOS
#    if defined(CAF_GCC) && !defined(_GLIBCXX_HAS_GTHREADS)
#      define _GLIBCXX_HAS_GTHREADS
#    endif
#  endif
#elif defined(__ANDROID__)
#  define CAF_ANDROID
#elif defined(__linux__)
#  define CAF_LINUX
#  include <linux/version.h>
#  if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,16)
#    define CAF_POLL_IMPL
#  endif
#elif defined(__FreeBSD__)
#  define CAF_BSD
#elif defined(__CYGWIN__)
#  define CAF_CYGWIN
#elif defined(WIN32) || defined(_WIN32)
#  define CAF_WINDOWS
#else
#  error Platform and/or compiler not supportet
#endif
#if defined(CAF_MACOS) || defined(CAF_LINUX) || defined(CAF_BSD) || defined(CAF_CYGWIN)
#  define CAF_POSIX
#endif

#if defined(CAF_WINDOWS)
#  if defined(__clang__)
     struct IUnknown; // fix for issue with static_cast<> in objbase.h (see https://github.com/philsquared/Catch/issues/690)
#  endif
#endif

#include <cstdio>
#include <cstdlib>

// Optionally enable CAF_ASSERT
#ifndef CAF_ENABLE_RUNTIME_CHECKS
# define CAF_ASSERT(unused) static_cast<void>(0)
#elif defined(CAF_WINDOWS) || defined(CAF_BSD)
# define CAF_ASSERT(stmt)                                                      \
  if (static_cast<bool>(stmt) == false) {                                      \
    printf("%s:%u: requirement failed '%s'\n", __FILE__, __LINE__, #stmt);     \
    ::abort();                                                                 \
  } static_cast<void>(0)
#else // defined(CAF_LINUX) || defined(CAF_MACOS)
# include <execinfo.h>
# define CAF_ASSERT(stmt)                                                      \
  if (static_cast<bool>(stmt) == false) {                                      \
    printf("%s:%u: requirement failed '%s'\n", __FILE__, __LINE__, #stmt);     \
    void* array[20];                                                           \
    auto caf_bt_size = ::backtrace(array, 20);                                 \
    ::backtrace_symbols_fd(array, caf_bt_size, 2);                             \
    ::abort();                                                                 \
  } static_cast<void>(0)
#endif

// Convenience macros.
#define CAF_IGNORE_UNUSED(x) static_cast<void>(x)

#define CAF_CRITICAL(error)                                                    \
  do {                                                                         \
    fprintf(stderr, "[FATAL] %s:%u: critical error: '%s'\n",                   \
            __FILE__, __LINE__, error);                                        \
    ::abort();                                                                 \
  } while (false)

#ifdef CAF_NO_EXCEPTIONS
# define CAF_RAISE_ERROR(msg)                                                  \
  do { std::string str = msg; CAF_CRITICAL(str.c_str()); } while (true)
#else // CAF_NO_EXCEPTIONS
# define CAF_RAISE_ERROR(msg)                                                  \
  throw std::runtime_error(msg)
#endif // CAF_NO_EXCEPTIONS

#endif // CAF_CONFIG_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_UNIFYN_HPP
#define CAF_UNIFYN_HPP

#define CAF_CONCAT_(LHS, RHS) LHS ## RHS
#define CAF_CONCAT(LHS, RHS) CAF_CONCAT_(LHS, RHS)
#define CAF_UNIFYN(NAME) CAF_CONCAT(NAME, __LINE__)

#endif // CAF_UNIFYN_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_EXEC_MAIN_HPP
#define CAF_EXEC_MAIN_HPP

#include "caf/actor_system.hpp"
#include "caf/actor_system_config.hpp"

#include "caf/detail/type_list.hpp"
#include "caf/detail/type_traits.hpp"

namespace caf {

template <class>
struct exec_main_helper;

template <>
struct exec_main_helper<detail::type_list<actor_system&>> {
  using config = actor_system_config;

  template <class F>
  void operator()(F& fun, actor_system& sys, config&) {
    fun(sys);
  }
};

template <class T>
struct exec_main_helper<detail::type_list<actor_system&, const T&>> {
  using config = T;

  template <class F>
  void operator()(F& fun, actor_system& sys, config& cfg) {
    fun(sys, cfg);
  }
};

template <class... Ts, class F = void (*)(actor_system&)>
int exec_main(F fun, int argc, char** argv,
              const char* config_file_name = "caf-application.ini") {
  using trait = typename detail::get_callable_trait<F>::type;
  using arg_types = typename trait::arg_types;
  static_assert(detail::tl_size<arg_types>::value == 1
                || detail::tl_size<arg_types>::value == 2,
                "main function must have one or two arguments");
  static_assert(std::is_same<
                  typename detail::tl_head<arg_types>::type,
                  actor_system&
                >::value,
                "main function must take actor_system& as first parameter");
  using arg2 = typename detail::tl_at<arg_types, 1>::type;
  using decayed_arg2 = typename std::decay<arg2>::type;
  static_assert(std::is_same<arg2, unit_t>::value
                || (std::is_base_of<actor_system_config, decayed_arg2>::value
                    && std::is_same<arg2, const decayed_arg2&>::value),
                "second parameter of main function must take a subtype of "
                "actor_system_config as const reference");
  using helper = exec_main_helper<typename trait::arg_types>;
  // pass CLI options to config
  typename helper::config cfg;
  cfg.parse(argc, argv, config_file_name);
  // return immediately if a help text was printed
  if (cfg.cli_helptext_printed)
    return 0;
  // load modules
  std::initializer_list<unit_t> unused{unit_t{cfg.template load<Ts>()}...};
  CAF_IGNORE_UNUSED(unused);
  // pass config to the actor system
  actor_system system{cfg};
  if (cfg.slave_mode) {
    if (!cfg.slave_mode_fun) {
      std::cerr << "cannot run slave mode, I/O module not loaded" << std::endl;
      return 1;
    }
    return cfg.slave_mode_fun(system, cfg);
  }
  helper f;
  f(fun, system, cfg);
  return 0;
}

} // namespace caf

#define CAF_MAIN(...)                                                          \
  int main(int argc, char** argv) {                                            \
    return ::caf::exec_main<__VA_ARGS__>(caf_main, argc, argv);                \
  }

#endif // CAF_EXEC_MAIN_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_RANDOM_TOPIC_SCATTERER_HPP
#define CAF_RANDOM_TOPIC_SCATTERER_HPP

#include <map>
#include <tuple>
#include <deque>
#include <vector>
#include <functional>

#include "caf/topic_scatterer.hpp"

namespace caf {

/// A topic scatterer that delivers data to sinks in random order.
template <class T, class Filter, class Select>
class random_topic_scatterer
    : public topic_scatterer<T, Filter, Select> {
public:
  using super = topic_scatterer<T, Filter, Select>;

  random_topic_scatterer(local_actor* selfptr) : super(selfptr) {
    // nop
  }

  long credit() const override {
    // We receive messages until we have exhausted all downstream credit and
    // have filled our buffer to its minimum size.
    return this->total_credit() + this->min_buffer_size();
  }

  void emit_batches() override {
    CAF_LOG_TRACE("");
    this->fan_out();
    for (auto& kvp : this->lanes_) {
      auto& l = kvp.second;
      super::sort_by_credit(l.paths);
      for (auto& x : l.paths) {
        auto chunk = super::get_chunk(l.buf, x->open_credit);
        auto csize = static_cast<long>(chunk.size());
        if (csize == 0)
          break;
        x->emit_batch(csize, make_message(std::move(chunk)));
      }
    }
  }
};

} // namespace caf

#endif // CAF_RANDOM_TOPIC_SCATTERER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ACTOR_FACTORY_HPP
#define CAF_ACTOR_FACTORY_HPP

#include <set>
#include <string>

#include "caf/actor_addr.hpp"
#include "caf/actor_system.hpp"
#include "caf/infer_handle.hpp"
#include "caf/execution_unit.hpp"

#include "caf/detail/type_traits.hpp"

namespace caf {

using actor_factory_result = std::pair<strong_actor_ptr, std::set<std::string>>;

using actor_factory = std::function<actor_factory_result (actor_config&, message&)>;

using selfptr_mode_token = spawn_mode_token<spawn_mode::function_with_selfptr>;

using void_mode_token = spawn_mode_token<spawn_mode::function>;

template <class F, class T, class Bhvr, spawn_mode Mode, class R, class Sig>
class fun_decorator;

template <class F, class T, class Bhvr, class R, class... Ts>
class fun_decorator<F, T, Bhvr, spawn_mode::function,
                    R, detail::type_list<Ts...>> {
public:
  fun_decorator(F  f, T*) : f_(std::move(f)) {
    // nop
  }

  behavior operator()(Ts... xs) {
    detail::type_list<R> token;
    return apply(token, xs...);
  }

  template <class U>
  typename std::enable_if<
    std::is_convertible<U, Bhvr>::value,
    behavior
  >::type
  apply(detail::type_list<U>, Ts... xs) {
    auto bhvr = f_(xs...);
    return std::move(bhvr.unbox());
  }

  template <class U>
  typename std::enable_if<
    !std::is_convertible<U, Bhvr>::value,
    behavior
  >::type
  apply(detail::type_list<U>, Ts... xs) {
    f_(xs...);
    return {};
  }

private:
  F f_;
};

template <class F, class T, class Bhvr, class R, class... Ts>
class fun_decorator<F, T, Bhvr, spawn_mode::function_with_selfptr,
                    R, detail::type_list<T*, Ts...>> {
public:
  fun_decorator(F  f, T* ptr) : f_(std::move(f)), ptr_(ptr) {
    // nop
  }

  behavior operator()(Ts... xs) {
    detail::type_list<R> token;
    return apply(token, xs...);
  }

  template <class U>
  typename std::enable_if<
    std::is_convertible<U, Bhvr>::value,
    behavior
  >::type
  apply(detail::type_list<U>, Ts... xs) {
    auto bhvr = f_(ptr_, xs...);
    return std::move(bhvr.unbox());
  }

  template <class U>
  typename std::enable_if<
    !std::is_convertible<U, Bhvr>::value,
    behavior
  >::type
  apply(detail::type_list<U>, Ts... xs) {
    f_(ptr_, xs...);
    return {};
  }

private:
  F f_;
  T* ptr_;
};

template <class Args>
struct message_verifier;

template <>
struct message_verifier<detail::type_list<>> {
  bool operator()(message& msg, void_mode_token) {
    return msg.empty();
  }
};

template <class T, class... Ts>
struct message_verifier<detail::type_list<T, Ts...>> {
  bool operator()(message& msg, void_mode_token) {
    return msg.match_elements<T, Ts...>();
  }
  bool operator()(message& msg, selfptr_mode_token) {
    return msg.match_elements<Ts...>();
  }
};

template <class F>
actor_factory make_actor_factory(F fun) {
  return [fun](actor_config& cfg, message& msg) -> actor_factory_result {
    using trait = infer_handle_from_fun<F>;
    using handle = typename trait::type;
    using impl = typename trait::impl;
    using behavior_t = typename trait::behavior_type;
    spawn_mode_token<trait::mode> tk;
    message_verifier<typename trait::arg_types> mv;
    if (!mv(msg, tk))
      return {};
    cfg.init_fun = [=](local_actor* x) -> behavior {
      CAF_ASSERT(cfg.host);
      using ctrait = typename detail::get_callable_trait<F>::type;
      using fd = fun_decorator<F, impl, behavior_t, trait::mode,
                               typename ctrait::result_type,
                               typename ctrait::arg_types>;
      fd f{fun, static_cast<impl*>(x)};
      empty_type_erased_tuple dummy_;
      auto& ct = msg.empty() ? dummy_ : const_cast<message&>(msg).content();
      auto opt = ct.apply(f);
      if (!opt)
        return {};
      return std::move(*opt);
    };
    handle hdl = cfg.host->system().spawn_class<impl, no_spawn_options>(cfg);
    return {actor_cast<strong_actor_ptr>(std::move(hdl)),
            cfg.host->system().message_types<handle>()};
  };
}

template <class Handle, class T, class... Ts>
struct dyn_spawn_class_helper {
  Handle& result;
  actor_config& cfg;
  void operator()(Ts... xs) {
    CAF_ASSERT(cfg.host);
    result = cfg.host->system().spawn_class<T, no_spawn_options>(cfg, xs...);
  }
};

template <class T, class... Ts>
actor_factory_result dyn_spawn_class(actor_config& cfg, message& msg) {
  CAF_ASSERT(cfg.host);
  using handle = typename infer_handle_from_class<T>::type;
  handle hdl;
  dyn_spawn_class_helper<handle, T, Ts...> factory{hdl, cfg};
  msg.apply(factory);
  return {actor_cast<strong_actor_ptr>(std::move(hdl)),
          cfg.host->system().message_types<handle>()};
}

template <class T, class... Ts>
actor_factory make_actor_factory() {
  /*
  static_assert(std::is_same<T*, decltype(new T(std::declval<actor_config&>(),
                                                std::declval<Ts>()...))>::value,
                "no constructor for T(Ts...) exists");
  */
  static_assert(detail::conjunction<
                  std::is_lvalue_reference<Ts>::value...
                >::value,
                "all Ts must be lvalue references");
  static_assert(std::is_base_of<local_actor, T>::value,
                "T is not derived from local_actor");
  return &dyn_spawn_class<T, Ts...>;
}

} // namespace caf

#endif // CAF_ACTOR_FACTORY_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_RANDOM_GATHERER_HPP
#define CAF_RANDOM_GATHERER_HPP

#include "caf/stream_gatherer_impl.hpp"

namespace caf {

/// Pulls data from sources in arbitrary order.
class random_gatherer : public stream_gatherer_impl {
public:
  using super = stream_gatherer_impl;

  random_gatherer(local_actor* selfptr);

  ~random_gatherer() override;

  void assign_credit(long downstream_capacity) override;

  long initial_credit(long downstream_capacity, path_type* x) override;
};

} // namespace caf

#endif // CAF_RANDOM_GATHERER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_RESPONSE_PROMISE_HPP
#define CAF_RESPONSE_PROMISE_HPP

#include <vector>

#include "caf/actor.hpp"
#include "caf/message.hpp"
#include "caf/actor_addr.hpp"
#include "caf/message_id.hpp"
#include "caf/response_type.hpp"
#include "caf/check_typed_input.hpp"

namespace caf {

/// A response promise can be used to deliver a uniquely identifiable
/// response message from the server (i.e. receiver of the request)
/// to the client (i.e. the sender of the request).
class response_promise {
public:
  using forwarding_stack = std::vector<strong_actor_ptr>;

  /// Constructs an invalid response promise.
  response_promise();

  response_promise(none_t);

  response_promise(strong_actor_ptr self, mailbox_element& src);

  response_promise(response_promise&&) = default;
  response_promise(const response_promise&) = default;
  response_promise& operator=(response_promise&&) = default;
  response_promise& operator=(const response_promise&) = default;

  /// Satisfies the promise by sending a non-error response message.
  template <class T, class... Ts>
  typename std::enable_if<
    (sizeof...(Ts) > 0) || !std::is_convertible<T, error>::value,
    response_promise
  >::type
  deliver(T&&x, Ts&&... xs) {
    static_assert(!detail::is_specialization<result, T>::value
                  && !detail::disjunction<
                       detail::is_specialization<result, Ts>::value...
                     >::value,
                  "it is not possible to deliver objects of type result<...>");
    return deliver_impl(make_message(std::forward<T>(x),
                                     std::forward<Ts>(xs)...));
  }

  /// Satisfies the promise by delegating to another actor.
  template <message_priority P = message_priority::normal,
           class Handle = actor, class... Ts>
   typename response_type<
    typename Handle::signatures,
    detail::implicit_conversions_t<typename std::decay<Ts>::type>...
  >::delegated_type
  delegate(const Handle& dest, Ts&&... xs) {
    static_assert(sizeof...(Ts) > 0, "nothing to delegate");
    using token =
      detail::type_list<
        typename detail::implicit_conversions<
          typename std::decay<Ts>::type
        >::type...>;
    static_assert(response_type_unbox<signatures_of_t<Handle>, token>::valid,
                  "receiver does not accept given message");
    if (dest) {
      auto mid = P == message_priority::high ? id_.with_high_priority() : id_;
      dest->enqueue(make_mailbox_element(std::move(source_), mid,
                                         std::move(stages_),
                                         std::forward<Ts>(xs)...),
                    context());
    }
    return {};
  }

  /// Satisfies the promise by sending an error response message.
  /// For non-requests, nothing is done.
  response_promise deliver(error x);

  /// Returns whether this response promise replies to an asynchronous message.
  bool async() const;

  /// Queries whether this promise is a valid promise that is not satisfied yet.
  inline bool pending() const {
    return !stages_.empty() || source_;
  }

  /// Returns the source of the corresponding request.
  inline const strong_actor_ptr& source() const {
    return source_;
  }

  /// Returns the remaining stages for the corresponding request.
  inline const forwarding_stack& stages() const {
    return stages_;
  }

  /// Returns the message ID of the corresponding request.
  inline message_id id() const {
    return id_;
  }

private:
  execution_unit* context();

  response_promise deliver_impl(message msg);

  strong_actor_ptr self_;
  strong_actor_ptr source_;
  forwarding_stack stages_;
  message_id id_;
};

} // namespace caf

#endif // CAF_RESPONSE_PROMISE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ACTOR_CONFIG_HPP
#define CAF_ACTOR_CONFIG_HPP

#include <string>
#include <functional>

#include "caf/fwd.hpp"
#include "caf/behavior.hpp"
#include "caf/input_range.hpp"
#include "caf/abstract_channel.hpp"

namespace caf {

/// Stores spawn-time flags and groups.
class actor_config {
public:
  execution_unit* host;
  int flags;
  input_range<const group>* groups;
  std::function<behavior (local_actor*)> init_fun;

  explicit actor_config(execution_unit* ptr = nullptr);

  inline actor_config& add_flag(int x) {
    flags |= x;
    return *this;
  }
};

/// @relates actor_config
std::string to_string(const actor_config& x);

} // namespace caf

#endif // CAF_ACTOR_CONFIG_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_GATHERER_IMPL_HPP
#define CAF_STREAM_GATHERER_IMPL_HPP

#include <vector>
#include <cstdint>
#include <utility>

#include "caf/fwd.hpp"
#include "caf/stream_gatherer.hpp"
#include "caf/stream_edge_impl.hpp"
#include "caf/response_promise.hpp"

namespace caf {

/// Type-erased policy for receiving data from sources.
class stream_gatherer_impl : public stream_edge_impl<stream_gatherer> {
public:
  using super = stream_edge_impl<stream_gatherer>;

  using assignment_pair = std::pair<path_type*, long>;

  stream_gatherer_impl(local_actor* selfptr);

  ~stream_gatherer_impl();

  path_ptr add_path(const stream_id& sid, strong_actor_ptr x,
                    strong_actor_ptr original_stage, stream_priority prio,
                    long available_credit, bool redeployable,
                    response_promise result_cb) override;

  bool remove_path(const stream_id& sid, const actor_addr& x, error reason,
                   bool silent) override;

  void close(message result) override;

  void abort(error reason) override;

  long high_watermark() const override;

  long min_credit_assignment() const override;

  long max_credit() const override;

  void high_watermark(long x) override;

  void min_credit_assignment(long x) override;

  void max_credit(long x) override;

protected:
  void emit_credits();

  long high_watermark_;
  long min_credit_assignment_;
  long max_credit_;
  std::vector<assignment_pair> assignment_vec_;

  /// Listeners for the final result.
  std::vector<response_promise> listeners_;
};

} // namespace caf

#endif // CAF_STREAM_GATHERER_IMPL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_RESULT_HPP
#define CAF_STREAM_RESULT_HPP

#include "caf/fwd.hpp"
#include "caf/none.hpp"
#include "caf/stream_id.hpp"
#include "caf/stream_manager.hpp"

#include "caf/meta/type_name.hpp"

namespace caf {

/// Terminates a stream by reducing it to a single value.
template <class T>
class stream_result {
public:
  stream_result() = default;
  stream_result(stream_result&&) = default;
  stream_result(const stream_result&) = default;
  stream_result& operator=(stream_result&&) = default;
  stream_result& operator=(const stream_result&) = default;

  stream_result(none_t) : stream_result() {
    // nop
  }

  stream_result(stream_id sid) : id_(std::move(sid)) {
    // nop
  }

  /// Convenience constructor for returning the result of `self->new_stream_result`
  /// and similar functions.
  stream_result(stream_id sid, stream_manager_ptr sptr)
      : id_(std::move(sid)),
        ptr_(std::move(sptr)) {
    // nop
  }

  /// Convenience constructor for returning the result of `self->new_stream_result`
  /// and similar functions.
  stream_result(stream_result other,  stream_manager_ptr sptr)
      : id_(std::move(other.id_)),
        ptr_(std::move(sptr)) {
    // nop
  }

  /// Returns the unique identifier for this stream_result.
  inline const stream_id& id() const {
    return id_;
  }

  /// Returns the handler assigned to this stream_result on this actor.
  inline const stream_manager_ptr& ptr() const {
    return ptr_;
  }

  template <class Inspector>
  friend typename Inspector::result_type inspect(Inspector& f, stream_result& x) {
    return f(meta::type_name("stream_result"), x.id_);
  }

private:
  stream_id id_;
  stream_manager_ptr ptr_;
};

} // namespace caf

#endif // CAF_STREAM_RESULT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_UNIT_HPP
#define CAF_UNIT_HPP

#include <string>

#include "caf/detail/comparable.hpp"

namespace caf {

/// Unit is analogous to `void`, but can be safely returned, stored, etc.
/// to enable higher-order abstraction without cluttering code with
/// exceptions for `void` (which can't be stored, for example).
struct unit_t : detail::comparable<unit_t> {
  constexpr unit_t() noexcept {
    // nop
  }

  constexpr unit_t(const unit_t&) noexcept {
    // nop
  }

  template <class T>
  explicit constexpr unit_t(T&&) noexcept {
    // nop
  }

  static constexpr int compare(const unit_t&) noexcept {
    return 0;
  }

  template <class... Ts>
  constexpr unit_t operator()(Ts&&...) const noexcept {
    return {};
  }
};

static constexpr unit_t unit = unit_t{};

/// @relates unit_t
template <class Processor>
void serialize(Processor&, const unit_t&, unsigned int) {
  // nop
}

/// @relates unit_t
inline std::string to_string(const unit_t&) {
  return "unit";
}

template <class T>
struct lift_void {
  using type = T;
};

template <>
struct lift_void<void> {
  using type = unit_t;
};

template <class T>
struct unlift_void {
  using type = T;
};

template <>
struct unlift_void<unit_t> {
  using type = void;
};

} // namespace caf

#endif // CAF_UNIT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TYPED_ACTOR_POINTER_HPP
#define CAF_TYPED_ACTOR_POINTER_HPP

#include "caf/typed_actor_view.hpp"

#include "caf/detail/type_list.hpp"

namespace caf {

template <class... Sigs>
class typed_actor_pointer {
public:
  /// Stores the template parameter pack.
  using signatures = detail::type_list<Sigs...>;

  template <class Supertype>
  typed_actor_pointer(Supertype* selfptr) : view_(selfptr) {
    using namespace caf::detail;
    static_assert(tl_subset_of<
                    type_list<Sigs...>,
                    typename Supertype::signatures
                  >::value,
                  "cannot create a pointer view to an unrelated actor type");
  }

  typed_actor_pointer(std::nullptr_t) : view_(nullptr) {
    // nop
  }

  typed_actor_view<Sigs...>* operator->() {
    return &view_;
  }

  inline explicit operator bool() const {
    return static_cast<bool>(view_.internal_ptr());
  }

  /// @private
  actor_control_block* get() const {
    return view_.ctrl();
  }

  /// @private
  scheduled_actor* internal_ptr() const {
    return view_.internal_ptr();
  }

  template <class Supertype>
  typed_actor_pointer& operator=(Supertype* ptr) {
    using namespace caf::detail;
    static_assert(tl_subset_of<
                    type_list<Sigs...>,
                    typename Supertype::signatures
                  >::value,
                  "cannot assign pointer of unrelated actor type");
    view_ = ptr;
    return *this;
  }

private:
  typed_actor_view<Sigs...> view_;
};

} // namespace caf

#endif // CAF_TYPED_ACTOR_POINTER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_HPP
#define CAF_STREAM_HPP

#include "caf/fwd.hpp"
#include "caf/stream_id.hpp"
#include "caf/stream_manager.hpp"

#include "caf/meta/type_name.hpp"

namespace caf {

/// Marker type for constructing invalid `stream` objects.
struct invalid_stream_t {};

/// Identifies an unbound sequence of messages.
template <class T>
class stream {
public:
  // -- member types -----------------------------------------------------------

  using value_type = T;

  // -- constructors and destructors -------------------------------------------

  stream() = default;
  stream(stream&&) = default;
  stream(const stream&) = default;
  stream& operator=(stream&&) = default;
  stream& operator=(const stream&) = default;

  stream(none_t) : stream() {
    // nop
  }

  stream(stream_id sid) : id_(std::move(sid)) {
    // nop
  }

  /// Convenience constructor for returning the result of `self->new_stream`
  /// and similar functions.
  stream(stream_id sid, stream_manager_ptr sptr)
      : id_(std::move(sid)),
        ptr_(std::move(sptr)) {
    // nop
  }

  /// Convenience constructor for returning the result of `self->new_stream`
  /// and similar functions.
  stream(stream other,  stream_manager_ptr sptr)
      : id_(std::move(other.id_)),
        ptr_(std::move(sptr)) {
    // nop
  }

  stream(invalid_stream_t) {
    // nop
  }

  // -- accessors --------------------------------------------------------------

  /// Returns the unique identifier for this stream.
  inline const stream_id& id() const {
    return id_;
  }

  /// Returns the handler assigned to this stream on this actor.
  inline const stream_manager_ptr& ptr() const {
    return ptr_;
  }

  // -- serialization support --------------------------------------------------

  template <class Inspector>
  friend typename Inspector::result_type inspect(Inspector& f, stream& x) {
    return f(meta::type_name("stream"), x.id_);
  }

private:
  // -- member variables -------------------------------------------------------

  stream_id id_;
  stream_manager_ptr ptr_;
};

/// @relates stream
template <class T>
inline bool operator==(const stream<T>& x, const stream<T>& y) {
  return x.id() == y.id();
}

/// @relates stream
constexpr invalid_stream_t invalid_stream = invalid_stream_t{};

/// Identifies an unbound sequence of messages annotated with the additional
/// handshake arguments emitted to the next stage.
template <class T, class... Ts>
class annotated_stream final : public stream<T> {
public:
  /// Dennotes the supertype.
  using super = stream<T>;

  // Import constructors.
  using super::super;
};

} // namespace caf

#endif // CAF_STREAM_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_FWD_HPP
#define CAF_FWD_HPP

#include <memory>
#include <cstdint>

namespace caf {

// -- 1 param templates --------------------------------------------------------

template <class> class param;
template <class> class stream;
template <class> class optional;
template <class> class expected;
template <class> class downstream;
template <class> class intrusive_ptr;
template <class> class behavior_type_of;
template <class> class trivial_match_case;
template <class> class weak_intrusive_ptr;

template <class> struct timeout_definition;

// -- 3 param templates --------------------------------------------------------

template <class, class, int> class actor_cast_access;

template <class, class, class> class broadcast_topic_scatterer;
template <class, class, class> class random_topic_scatterer;

// -- variadic templates -------------------------------------------------------

template <class...> class result;
template <class...> class variant;
template <class...> class delegated;
template <class...> class typed_actor;
template <class...> class typed_actor_pointer;
template <class...> class typed_response_promise;
template <class...> class typed_event_based_actor;

// -- variadic templates with 1 fixed argument ---------------------------------

template <class, class...> class fused_scatterer;
template <class, class...> class annotated_stream;

// -- classes ------------------------------------------------------------------

class actor;
class error;
class group;
class message;
class node_id;
class behavior;
class duration;
class resumable;
class stream_id;
class actor_addr;
class actor_pool;
class message_id;
class serializer;
class actor_clock;
class actor_proxy;
class local_actor;
class ref_counted;
class actor_config;
class actor_system;
class deserializer;
class group_module;
class message_view;
class scoped_actor;
class inbound_path;
class outbound_path;
class abstract_actor;
class abstract_group;
class actor_registry;
class blocking_actor;
class execution_unit;
class proxy_registry;
class stream_manager;
class random_gatherer;
class stream_gatherer;
class actor_companion;
class mailbox_element;
class message_handler;
class scheduled_actor;
class stream_scatterer;
class response_promise;
class event_based_actor;
class type_erased_tuple;
class type_erased_value;
class stream_msg_visitor;
class actor_control_block;
class actor_system_config;
class uniform_type_info_map;
class forwarding_actor_proxy;

// -- structs ------------------------------------------------------------------

struct unit_t;
struct exit_msg;
struct down_msg;
struct stream_msg;
struct timeout_msg;
struct group_down_msg;
struct invalid_actor_t;
struct invalid_actor_addr_t;
struct illegal_message_element;
struct prohibit_top_level_spawn_marker;

// -- enums --------------------------------------------------------------------

enum class stream_priority;
enum class atom_value : uint64_t;

// -- aliases ------------------------------------------------------------------

using actor_id = uint64_t;

// -- marker classes for mixins ------------------------------------------------

namespace mixin {

struct subscriber_base;

} // namespace mixin

// -- I/O classes --------------------------------------------------------------

namespace io {

class hook;
class broker;
class middleman;

namespace basp {

struct header;

} // namespace basp

} // namespace io

// -- OpenCL classes -----------------------------------------------------------

namespace opencl {

class manager;

} // namespace opencl

// -- scheduler classes --------------------------------------------------------

namespace scheduler {

class abstract_worker;
class test_coordinator;
class abstract_coordinator;

} // namespace scheduler


// -- OpenSSL classes ----------------------------------------------------------

namespace openssl {

class manager;

} // namespace openssl

// -- detail classes -----------------------------------------------------------

namespace detail {

template <class> class type_erased_value_impl;
template <class> class stream_distribution_tree;

class disposer;
class message_data;
class group_manager;
class private_thread;
class dynamic_message_data;

} // namespace detail

// -- weak pointer aliases -----------------------------------------------------

using weak_actor_ptr = weak_intrusive_ptr<actor_control_block>;

// -- intrusive pointer aliases ------------------------------------------------

using strong_actor_ptr = intrusive_ptr<actor_control_block>;
using stream_manager_ptr = intrusive_ptr<stream_manager>;

// -- unique pointer aliases ---------------------------------------------------

using type_erased_value_ptr = std::unique_ptr<type_erased_value>;
using mailbox_element_ptr = std::unique_ptr<mailbox_element, detail::disposer>;

} // namespace caf

#endif // CAF_FWD_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_CHECK_TYPED_INPUT_HPP
#define CAF_CHECK_TYPED_INPUT_HPP

#include "caf/fwd.hpp"
#include "caf/replies_to.hpp"

#include "caf/detail/type_list.hpp"
#include "caf/detail/typed_actor_util.hpp"

namespace caf {

template <class T>
struct output_types_of {
  // nop
};

template <class In, class Out>
struct output_types_of<typed_mpi<In, Out>> {
  using type = Out;
};

template <class T>
struct signatures_of {
  using type = typename std::remove_pointer<T>::type::signatures;
};

template <class T>
using signatures_of_t = typename signatures_of<T>::type;

template <class T>
constexpr bool statically_typed() {
  return !std::is_same<
           none_t,
           typename std::remove_pointer<T>::type::signatures
         >::value;
}

template <class T>
struct is_void_response : std::false_type {};

template <>
struct is_void_response<detail::type_list<void>> : std::true_type {};

// true for the purpose of type checking performed by send()
template <>
struct is_void_response<none_t> : std::true_type {};

} // namespace caf

#endif // CAF_CHECK_TYPED_INPUT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_RESPONSE_HANDLE_HPP
#define CAF_RESPONSE_HANDLE_HPP

#include <type_traits>

#include "caf/sec.hpp"
#include "caf/catch_all.hpp"
#include "caf/message_id.hpp"
#include "caf/typed_behavior.hpp"
#include "caf/system_messages.hpp"

#include "caf/detail/type_list.hpp"
#include "caf/detail/typed_actor_util.hpp"

namespace caf {

/// This helper class identifies an expected response message
/// and enables `request(...).then(...)`.
template <class Self, class Output, bool IsBlocking>
class response_handle;

/******************************************************************************
 *                                 nonblocking                                *
 ******************************************************************************/
template <class Self, class Output>
class response_handle<Self, Output, false> {
public:
  response_handle() = delete;
  response_handle(const response_handle&) = default;
  response_handle& operator=(const response_handle&) = default;

  response_handle(message_id mid, Self* self) : mid_(mid), self_(self) {
    // nop
  }

  template <class F, class E = detail::is_callable_t<F>>
  void await(F f) const {
    await_impl(f);
  }

  template <class F, class OnError,
            class E1 = detail::is_callable_t<F>,
            class E2 = detail::is_handler_for_ef<OnError, error>>
  void await(F f, OnError e) const {
    await_impl(f, e);
  }

  template <class F, class E = detail::is_callable_t<F>>
  void then(F f) const {
    then_impl(f);
  }

  template <class F, class OnError,
            class E1 = detail::is_callable_t<F>,
            class E2 = detail::is_handler_for_ef<OnError, error>>
  void then(F f, OnError e) const {
    then_impl(f, e);
  }

private:
  template <class F>
  void await_impl(F& f) const {
    static_assert(std::is_same<
                    void,
                    typename detail::get_callable_trait<F>::result_type
                  >::value,
                  "response handlers are not allowed to have a return "
                  "type other than void");
    detail::type_checker<Output, F>::check();
    self_->add_awaited_response_handler(mid_, message_handler{std::move(f)});
  }

  template <class F, class OnError>
  void await_impl(F& f, OnError& ef) const {
    static_assert(std::is_same<
                    void,
                    typename detail::get_callable_trait<F>::result_type
                  >::value,
                  "response handlers are not allowed to have a return "
                  "type other than void");
    detail::type_checker<Output, F>::check();
    self_->add_awaited_response_handler(mid_, behavior{std::move(f),
                                                       std::move(ef)});
  }

  template <class F>
  void then_impl(F& f) const {
    static_assert(std::is_same<
                    void,
                    typename detail::get_callable_trait<F>::result_type
                  >::value,
                  "response handlers are not allowed to have a return "
                  "type other than void");
    detail::type_checker<Output, F>::check();
    self_->add_multiplexed_response_handler(mid_, behavior{std::move(f)});
  }

  template <class F, class OnError>
  void then_impl(F& f, OnError& ef) const {
    static_assert(std::is_same<
                    void,
                    typename detail::get_callable_trait<F>::result_type
                  >::value,
                  "response handlers are not allowed to have a return "
                  "type other than void");
    detail::type_checker<Output, F>::check();
    self_->add_multiplexed_response_handler(mid_, behavior{std::move(f),
                                                           std::move(ef)});
  }

  message_id mid_;
  Self* self_;
};

/******************************************************************************
 *                                  blocking                                  *
 ******************************************************************************/
template <class Self, class Output>
class response_handle<Self, Output, true> {
public:
  response_handle() = delete;
  response_handle(const response_handle&) = default;
  response_handle& operator=(const response_handle&) = default;

  response_handle(message_id mid, Self* self) : mid_(mid), self_(self) {
    // nop
  }

  using error_handler = std::function<void (error&)>;

  template <class F, class OnError,
            class E = detail::is_handler_for_ef<OnError, error>>
  detail::is_callable_t<F> receive(F f, OnError ef) {
    static_assert(std::is_same<
                    void,
                    typename detail::get_callable_trait<F>::result_type
                  >::value,
                  "response handlers are not allowed to have a return "
                  "type other than void");
    detail::type_checker<Output, F>::check();
    typename Self::accept_one_cond rc;
    self_->varargs_receive(rc, mid_, std::move(f), std::move(ef));
  }

  template <class OnError, class F,
            class E = detail::is_callable_t<F>>
  detail::is_handler_for_ef<OnError, error> receive(OnError ef, F f) {
    receive(std::move(f), std::move(ef));
  }

  template <class OnError, class F,
            class E = detail::is_handler_for_ef<OnError, error>>
  void receive(OnError ef, catch_all<F> ca) {
    typename Self::accept_one_cond rc;
    self_->varargs_receive(rc, mid_, std::move(ef), std::move(ca));
  }


private:
  message_id mid_;
  Self* self_;
};

} // namespace caf

#endif // CAF_RESPONSE_HANDLE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_ABORTER_HPP
#define CAF_STREAM_ABORTER_HPP

#include "caf/fwd.hpp"
#include "caf/stream_id.hpp"
#include "caf/actor_addr.hpp"
#include "caf/attachable.hpp"

namespace caf {

class stream_aborter : public attachable {
public:
  enum mode {
    source_aborter,
    sink_aborter
  };

  struct token {
    const actor_addr& observer;
    const stream_id& sid;
    mode m;
    static constexpr size_t token_type = attachable::token::stream_aborter;
  };

  ~stream_aborter() override;

  void actor_exited(const error& rsn, execution_unit* host) override;

  bool matches(const attachable::token& what) override;

  inline static attachable_ptr make(actor_addr observed, actor_addr observer,
                                    const stream_id& sid, mode m) {
    return attachable_ptr{
      new stream_aborter(std::move(observed), std::move(observer), sid, m)};
  }

  /// Adds a stream aborter to `observed`.
  static void add(strong_actor_ptr observed, actor_addr observer,
                  const stream_id& sid, mode m);

  /// Removes a stream aborter from `observed`.
  static void del(strong_actor_ptr observed, const actor_addr& observer,
                  const stream_id& sid, mode m);

private:
  stream_aborter(actor_addr&& observed, actor_addr&& observer,
                 const stream_id& type, mode m);

  actor_addr observed_;
  actor_addr observer_;
  stream_id sid_;
  mode mode_;
};

} // namespace caf


#endif // CAF_STREAM_ABORTER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MAILBOX_ELEMENT_HPP
#define CAF_MAILBOX_ELEMENT_HPP

#include <cstddef>

#include "caf/extend.hpp"
#include "caf/message.hpp"
#include "caf/message_id.hpp"
#include "caf/ref_counted.hpp"
#include "caf/make_message.hpp"
#include "caf/message_view.hpp"
#include "caf/memory_managed.hpp"
#include "caf/type_erased_tuple.hpp"
#include "caf/actor_control_block.hpp"

#include "caf/meta/type_name.hpp"
#include "caf/meta/omittable_if_empty.hpp"

#include "caf/detail/disposer.hpp"
#include "caf/detail/tuple_vals.hpp"
#include "caf/detail/type_erased_tuple_view.hpp"

namespace caf {

class mailbox_element : public memory_managed, public message_view {
public:
  using forwarding_stack = std::vector<strong_actor_ptr>;

  /// Intrusive pointer to the next mailbox element.
  mailbox_element* next;

  /// Intrusive pointer to the previous mailbox element.
  mailbox_element* prev;

  /// Avoids multi-processing in blocking actors via flagging.
  bool marked;

  /// Source of this message and receiver of the final response.
  strong_actor_ptr sender;

  /// Denotes whether this an asynchronous message or a request.
  message_id mid;

  /// `stages.back()` is the next actor in the forwarding chain,
  /// if this is empty then the original sender receives the response.
  forwarding_stack stages;

  mailbox_element();

  mailbox_element(strong_actor_ptr&& x, message_id y,
                  forwarding_stack&& z);

  ~mailbox_element() override;

  type_erased_tuple& content() override;

  message move_content_to_message() override;

  message copy_content_to_message() const override;

  const type_erased_tuple& content() const;

  mailbox_element(mailbox_element&&) = delete;
  mailbox_element(const mailbox_element&) = delete;
  mailbox_element& operator=(mailbox_element&&) = delete;
  mailbox_element& operator=(const mailbox_element&) = delete;

  inline bool is_high_priority() const {
    return mid.is_high_priority();
  }

protected:
  empty_type_erased_tuple dummy_;
};

/// @relates mailbox_element
template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, mailbox_element& x) {
  return f(meta::type_name("mailbox_element"), x.sender, x.mid,
           meta::omittable_if_empty(), x.stages, x.content());
}

/// Encapsulates arbitrary data in a message element.
template <class... Ts>
class mailbox_element_vals
    : public mailbox_element,
      public detail::tuple_vals_impl<type_erased_tuple, Ts...> {
public:
  template <class... Us>
  mailbox_element_vals(strong_actor_ptr&& x0, message_id x1,
                       forwarding_stack&& x2, Us&&... xs)
      : mailbox_element(std::move(x0), x1, std::move(x2)),
        detail::tuple_vals_impl<type_erased_tuple, Ts...>(std::forward<Us>(xs)...) {
    // nop
  }

  type_erased_tuple& content() override {
    return *this;
  }

  message move_content_to_message() override {
    message_factory f;
    auto& xs = this->data();
    return detail::apply_moved_args(f, detail::get_indices(xs), xs);
  }

  message copy_content_to_message() const override {
    message_factory f;
    auto& xs = this->data();
    return detail::apply_args(f, detail::get_indices(xs), xs);
  }

  void dispose() noexcept {
    this->deref();
  }
};

/// Provides a view for treating arbitrary data as message element.
template <class... Ts>
class mailbox_element_view : public mailbox_element,
                             public detail::type_erased_tuple_view<Ts...> {
public:
  mailbox_element_view(strong_actor_ptr&& x0, message_id x1,
                       forwarding_stack&& x2, Ts&... xs)
    : mailbox_element(std::move(x0), x1, std::move(x2)),
      detail::type_erased_tuple_view<Ts...>(xs...) {
    // nop
  }

  type_erased_tuple& content() override {
    return *this;
  }

  message move_content_to_message() override {
    message_factory f;
    auto& xs = this->data();
    return detail::apply_moved_args(f, detail::get_indices(xs), xs);
  }

  message copy_content_to_message() const override {
    message_factory f;
    auto& xs = this->data();
    return detail::apply_args(f, detail::get_indices(xs), xs);
  }
};

/// @relates mailbox_element
using mailbox_element_ptr = std::unique_ptr<mailbox_element, detail::disposer>;

/// @relates mailbox_element
mailbox_element_ptr
make_mailbox_element(strong_actor_ptr sender, message_id id,
                     mailbox_element::forwarding_stack stages, message msg);

/// @relates mailbox_element
template <class T, class... Ts>
typename std::enable_if<
  !std::is_same<typename std::decay<T>::type, message>::value
  || (sizeof...(Ts) > 0),
  mailbox_element_ptr
>::type
make_mailbox_element(strong_actor_ptr sender, message_id id,
                     mailbox_element::forwarding_stack stages,
                     T&& x, Ts&&... xs) {
  using impl =
    mailbox_element_vals<
      typename unbox_message_element<
        typename detail::strip_and_convert<T>::type
      >::type,
      typename unbox_message_element<
        typename detail::strip_and_convert<Ts>::type
      >::type...
    >;
  auto ptr = new impl(std::move(sender), id, std::move(stages),
                      std::forward<T>(x), std::forward<Ts>(xs)...);
  return mailbox_element_ptr{ptr};
}

} // namespace caf

#endif // CAF_MAILBOX_ELEMENT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ACTOR_CAST_HPP
#define CAF_ACTOR_CAST_HPP

#include <type_traits>

#include "caf/fwd.hpp"
#include "caf/abstract_actor.hpp"
#include "caf/actor_control_block.hpp"

namespace caf {

namespace {

// The function actor_cast<> computes the type of the cast for
// actor_cast_access via the following formula:
//     x = 0 if To is a raw pointer
//       = 1 if To is a strong pointer
//       = 2 if To is a weak pointer
//     y = 0 if From is a raw pointer
//       = 6 if From is a strong pointer
//       = 2 if From is a weak pointer
// the result of x * y + z then denotes which operation the cast is performing:
//     raw              <- raw              =  0
//     raw              <- weak             =  0
//     raw              <- strong           =  0
//     weak             <- raw              =  0
//     weak             <- weak             =  6
//     weak             <- strong           = 12
//     strong           <- raw              =  0
//     strong           <- weak             =  3
//     strong           <- strong           =  6
// x * y is then interpreted as follows:
// -  0 is a conversion to or from a raw pointer
// -  6 is a conversion between pointers with same semantics
// -  3 is a conversion from a weak pointer to a strong pointer
// - 12 is a conversion from a strong pointer to a weak pointer

constexpr int raw_ptr_cast = 0; // either To or From is a raw pointer
constexpr int weak_ptr_downgrade_cast = 12; // To is weak, From is strong
constexpr int weak_ptr_upgrade_cast = 3; // To is strong, From is weak
constexpr int neutral_cast = 6; // To and From are both weak or both strong

template <class T>
struct is_weak_ptr {
  static constexpr bool value = T::has_weak_ptr_semantics;
};

template <class T>
struct is_weak_ptr<T*> : std::false_type {};

template <class... Ts>
struct is_weak_ptr<typed_actor_pointer<Ts...>> : std::false_type {};

} // namespace <anonymous>

template <class To, class From, int>
class actor_cast_access;

template <class To, class From>
class actor_cast_access<To, From, raw_ptr_cast> {
public:
  To operator()(actor_control_block* x) const {
    return x;
  }

  To operator()(abstract_actor* x) const {
    return x->ctrl();
  }

  template <class T,
            class = typename std::enable_if<!std::is_pointer<T>::value>::type>
  To operator()(const T& x) const {
    return x.get();
  }
};

template <class To, class From>
class actor_cast_access<To*, From, raw_ptr_cast> {
public:
  To* operator()(actor_control_block* x) const {
    return static_cast<To*>(x->get());
  }

  To* operator()(abstract_actor* x) const {
    return static_cast<To*>(x);
  }

  template <class T,
            class = typename std::enable_if<!std::is_pointer<T>::value>::type>
  To* operator()(const T& x) const {
    return (*this)(x.get());
  }
};

template <class From>
class actor_cast_access<actor_control_block*, From, raw_ptr_cast> {
public:
  actor_control_block* operator()(actor_control_block* x) const {
    return x;
  }

  actor_control_block* operator()(abstract_actor* x) const {
    return x->ctrl();
  }

  template <class T,
            class = typename std::enable_if<!std::is_pointer<T>::value>::type>
  actor_control_block* operator()(const T& x) const {
    return x.get();
  }
};

template <class To, class From>
class actor_cast_access<To, From, weak_ptr_downgrade_cast> {
public:
  To operator()(const From& x) const {
    return x.get();
  }
};

template <class To, class From>
class actor_cast_access<To, From, weak_ptr_upgrade_cast> {
public:
  To operator()(const From& x) const {
    return {x.get_locked(), false};
  }
};

template <class To, class From>
class actor_cast_access<To, From, neutral_cast> {
public:
  To operator()(const From& x) const {
    return x.get();
  }

  To operator()(From&& x) const {
    return {x.release(), false};
  }
};

/// Converts actor handle `what` to a different actor
/// handle or raw pointer of type `T`.
template <class T, class U>
T actor_cast(U&& what) {
  using from_type =
    typename std::remove_const<
      typename std::remove_reference<U>::type
    >::type;
  // query traits for T
  constexpr bool to_raw = std::is_pointer<T>::value;
  constexpr bool to_weak = is_weak_ptr<T>::value;
  // query traits for U
  constexpr bool from_raw = std::is_pointer<from_type>::value;
  constexpr bool from_weak = is_weak_ptr<from_type>::value;
  // calculate x and y
  constexpr int x = to_raw ? 0 : (to_weak ? 2 : 1);
  constexpr int y = from_raw ? 0 : (from_weak ? 3 : 6);
  // perform cast
  actor_cast_access<T, from_type, x * y> f;
  return f(std::forward<U>(what));
}

} // namespace caf

#endif // CAF_ACTOR_CAST_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_LOCAL_ACTOR_HPP
#define CAF_LOCAL_ACTOR_HPP

#include <atomic>
#include <cstdint>
#include <utility>
#include <exception>
#include <functional>
#include <type_traits>
#include <forward_list>
#include <unordered_map>

#include "caf/fwd.hpp"

#include "caf/actor.hpp"
#include "caf/error.hpp"
#include "caf/extend.hpp"
#include "caf/logger.hpp"
#include "caf/message.hpp"
#include "caf/duration.hpp"
#include "caf/behavior.hpp"
#include "caf/delegated.hpp"
#include "caf/resumable.hpp"
#include "caf/actor_cast.hpp"
#include "caf/message_id.hpp"
#include "caf/exit_reason.hpp"
#include "caf/typed_actor.hpp"
#include "caf/actor_config.hpp"
#include "caf/actor_system.hpp"
#include "caf/response_type.hpp"
#include "caf/spawn_options.hpp"
#include "caf/abstract_actor.hpp"
#include "caf/abstract_group.hpp"
#include "caf/execution_unit.hpp"
#include "caf/message_handler.hpp"
#include "caf/response_promise.hpp"
#include "caf/message_priority.hpp"
#include "caf/check_typed_input.hpp"
#include "caf/monitorable_actor.hpp"
#include "caf/invoke_message_result.hpp"
#include "caf/typed_response_promise.hpp"

#include "caf/scheduler/abstract_coordinator.hpp"

#include "caf/detail/disposer.hpp"
#include "caf/detail/behavior_stack.hpp"
#include "caf/detail/typed_actor_util.hpp"
#include "caf/detail/single_reader_queue.hpp"

namespace caf {

namespace detail {

template <class... Ts>
struct make_response_promise_helper {
  using type = typed_response_promise<Ts...>;
};

template <class... Ts>
struct make_response_promise_helper<typed_response_promise<Ts...>>
    : make_response_promise_helper<Ts...> {};

template <>
struct make_response_promise_helper<response_promise> {
  using type = response_promise;
};

} // namespace detail

/// Base class for actors running on this node, either
/// living in an own thread or cooperatively scheduled.
class local_actor : public monitorable_actor {
public:

  // -- member types -----------------------------------------------------------

  /// A queue optimized for single-reader-many-writers.
  using mailbox_type = detail::single_reader_queue<mailbox_element,
                                                   detail::disposer>;

  // -- constructors, destructors, and assignment operators --------------------

  local_actor(actor_config& cfg);

  ~local_actor() override;

  void on_destroy() override;

  // -- pure virtual modifiers -------------------------------------------------

  virtual void launch(execution_unit* eu, bool lazy, bool hide) = 0;

  // -- timeout management -----------------------------------------------------

  /// Requests a new timeout for `mid`.
  /// @pre `mid.valid()`
  void request_response_timeout(const duration& d, message_id mid);

  // -- spawn functions --------------------------------------------------------

  template <class T, spawn_options Os = no_spawn_options, class... Ts>
  infer_handle_from_class_t<T> spawn(Ts&&... xs) {
    actor_config cfg{context()};
    return eval_opts(Os, system().spawn_class<T, make_unbound(Os)>(cfg, std::forward<Ts>(xs)...));
  }

  template <class T, spawn_options Os = no_spawn_options>
  infer_handle_from_state_t<T> spawn() {
    using impl = composable_behavior_based_actor<T>;
    actor_config cfg{context()};
    return eval_opts(Os, system().spawn_class<impl, make_unbound(Os)>(cfg));
  }

  template <spawn_options Os = no_spawn_options, class F, class... Ts>
  infer_handle_from_fun_t<F> spawn(F fun, Ts&&... xs) {
    actor_config cfg{context()};
    return eval_opts(Os, system().spawn_functor<make_unbound(Os)>(cfg, fun, std::forward<Ts>(xs)...));
  }

  template <class T, spawn_options Os = no_spawn_options, class Groups,
            class... Ts>
  actor spawn_in_groups(const Groups& gs, Ts&&... xs) {
    actor_config cfg{context()};
    return eval_opts(Os, system().spawn_class_in_groups<T, make_unbound(Os)>(cfg, gs.begin(), gs.end(), std::forward<Ts>(xs)...));
  }

  template <class T, spawn_options Os = no_spawn_options, class... Ts>
  actor spawn_in_groups(std::initializer_list<group> gs, Ts&&... xs) {
    actor_config cfg{context()};
    return eval_opts(Os, system().spawn_class_in_groups<T, make_unbound(Os)>(cfg, gs.begin(), gs.end(), std::forward<Ts>(xs)...));
  }

  template <class T, spawn_options Os = no_spawn_options, class... Ts>
  actor spawn_in_group(const group& grp, Ts&&... xs) {
    actor_config cfg{context()};
    auto first = &grp;
    return eval_opts(Os, system().spawn_class_in_groups<T, make_unbound(Os)>(cfg, first, first + 1, std::forward<Ts>(xs)...));
  }

  template <spawn_options Os = no_spawn_options, class Groups, class F, class... Ts>
  actor spawn_in_groups(const Groups& gs, F fun, Ts&&... xs) {
    actor_config cfg{context()};
    return eval_opts(Os, system().spawn_fun_in_groups<make_unbound(Os)>(cfg, gs.begin(), gs.end(), fun, std::forward<Ts>(xs)...));
  }

  template <spawn_options Os = no_spawn_options, class F, class... Ts>
  actor spawn_in_groups(std::initializer_list<group> gs, F fun, Ts&&... xs) {
    actor_config cfg{context()};
    return eval_opts(Os, system().spawn_fun_in_groups<make_unbound(Os)>(cfg, gs.begin(), gs.end(), fun, std::forward<Ts>(xs)...));
  }

  template <spawn_options Os = no_spawn_options, class F, class... Ts>
  actor spawn_in_group(const group& grp, F fun, Ts&&... xs) {
    actor_config cfg{context()};
    auto first = &grp;
    return eval_opts(Os, system().spawn_fun_in_groups<make_unbound(Os)>(cfg, first, first + 1, fun, std::forward<Ts>(xs)...));
  }

  // -- sending asynchronous messages ------------------------------------------

  /// Sends an exit message to `dest`.
  void send_exit(const actor_addr& whom, error reason);

  void send_exit(const strong_actor_ptr& dest, error reason);

  /// Sends an exit message to `dest`.
  template <class ActorHandle>
  void send_exit(const ActorHandle& dest, error reason) {
    dest->eq_impl(make_message_id(), ctrl(), context(),
                  exit_msg{address(), std::move(reason)});
  }

  // -- miscellaneous actor operations -----------------------------------------

  /// Returns the execution unit currently used by this actor.
  inline execution_unit* context() const {
    return context_;
  }

  /// Sets the execution unit for this actor.
  inline void context(execution_unit* x) {
    context_ = x;
  }

  /// Returns the hosting actor system.
  inline actor_system& system() const {
    CAF_ASSERT(context_);
    return context_->system();
  }

  /// Returns the clock of the actor system.
  inline actor_clock& clock() const {
    return home_system().clock();
  }

  /// @cond PRIVATE

  void monitor(abstract_actor* ptr);

  /// @endcond

  /// Returns a pointer to the sender of the current message.
  /// @pre `current_mailbox_element() != nullptr`
  inline strong_actor_ptr& current_sender() {
    CAF_ASSERT(current_element_);
    return current_element_->sender;
  }

  /// Returns the ID of the current message.
  inline message_id current_message_id() {
    CAF_ASSERT(current_element_);
    return current_element_->mid;
  }

  /// Returns the ID of the current message and marks the ID stored in the
  /// current mailbox element as answered.
  inline message_id take_current_message_id() {
    CAF_ASSERT(current_element_);
    auto result = current_element_->mid;
    current_element_->mid.mark_as_answered();
    return result;
  }

  /// Marks the current message ID as answered.
  inline void drop_current_message_id() {
    CAF_ASSERT(current_element_);
    current_element_->mid.mark_as_answered();
  }

  /// Returns a pointer to the next stage from the forwarding path of the
  /// current message or `nullptr` if the path is empty.
  inline strong_actor_ptr current_next_stage() {
    CAF_ASSERT(current_element_);
    auto& stages = current_element_->stages;
    if (!stages.empty())
      stages.back();
    return nullptr;
  }

  /// Returns a pointer to the next stage from the forwarding path of the
  /// current message and removes it from the path. Returns `nullptr` if the
  /// path is empty.
  inline strong_actor_ptr take_current_next_stage() {
    CAF_ASSERT(current_element_);
    auto& stages = current_element_->stages;
    if (!stages.empty()) {
      auto result = stages.back();
      stages.pop_back();
      return result;
    }
    return nullptr;
  }

  /// Returns the forwarding stack from the current mailbox element.
  const mailbox_element::forwarding_stack& current_forwarding_stack() {
    CAF_ASSERT(current_element_);
    return current_element_->stages;
  }

  /// Moves the forwarding stack from the current mailbox element.
  mailbox_element::forwarding_stack take_current_forwarding_stack() {
    CAF_ASSERT(current_element_);
    return std::move(current_element_->stages);
  }

  /// Returns a pointer to the currently processed mailbox element.
  inline mailbox_element* current_mailbox_element() {
    return current_element_;
  }

  /// Adds a unidirectional `monitor` to `whom`.
  /// @note Each call to `monitor` creates a new, independent monitor.
  template <class Handle>
  void monitor(const Handle& whom) {
    monitor(actor_cast<abstract_actor*>(whom));
  }

  /// Removes a monitor from `whom`.
  void demonitor(const actor_addr& whom);

  /// Removes a monitor from `whom`.
  inline void demonitor(const actor& whom) {
    demonitor(whom.address());
  }

  /// Can be overridden to perform cleanup code after an actor
  /// finished execution.
  virtual void on_exit();

  /// Creates a `typed_response_promise` to respond to a request later on.
  /// `make_response_promise<typed_response_promise<int, int>>()`
  /// is equivalent to `make_response_promise<int, int>()`.
  template <class... Ts>
  typename detail::make_response_promise_helper<Ts...>::type
  make_response_promise() {
    auto& ptr = current_element_;
    if (!ptr)
      return {};
    auto& mid = ptr->mid;
    if (mid.is_answered())
      return {};
    return {this->ctrl(), *ptr};
  }

  /// Creates a `response_promise` to respond to a request later on.
  inline response_promise make_response_promise() {
    return make_response_promise<response_promise>();
  }

  /// Creates a `typed_response_promise` and responds immediately.
  /// Return type is deduced from arguments.
  /// Return value is implicitly convertible to untyped response promise.
  template <class... Ts,
            class R =
              typename detail::make_response_promise_helper<
                typename std::decay<Ts>::type...
              >::type>
  R response(Ts&&... xs) {
    auto promise = make_response_promise<R>();
    promise.deliver(std::forward<Ts>(xs)...);
    return promise;
  }

  const char* name() const override;

  /// Serializes the state of this actor to `sink`. This function is
  /// only called if this actor has set the `is_serializable` flag.
  /// The default implementation throws a `std::logic_error`.
  virtual error save_state(serializer& sink, unsigned int version);

  /// Deserializes the state of this actor from `source`. This function is
  /// only called if this actor has set the `is_serializable` flag.
  /// The default implementation throws a `std::logic_error`.
  virtual error load_state(deserializer& source, unsigned int version);

  /// Returns the currently defined fail state. If this reason is not
  /// `none` then the actor will terminate with this error after executing
  /// the current message handler.
  inline const error& fail_state() const {
    return fail_state_;
  }

  // -- here be dragons: end of public interface -------------------------------

  /// @cond PRIVATE

  template <class ActorHandle>
  inline ActorHandle eval_opts(spawn_options opts, ActorHandle res) {
    if (has_monitor_flag(opts))
      monitor(res->address());
    if (has_link_flag(opts))
      link_to(res->address());
    return res;
  }

  // returns 0 if last_dequeued() is an asynchronous or sync request message,
  // a response id generated from the request id otherwise
  inline message_id get_response_id() const {
    auto mid = current_element_->mid;
    return (mid.is_request()) ? mid.response_id() : message_id();
  }

  template <message_priority P = message_priority::normal,
            class Handle = actor, class... Ts>
  typename response_type<
    typename Handle::signatures,
    detail::implicit_conversions_t<typename std::decay<Ts>::type>...
  >::delegated_type
  delegate(const Handle& dest, Ts&&... xs) {
    static_assert(sizeof...(Ts) > 0, "nothing to delegate");
    using token =
      detail::type_list<
        typename detail::implicit_conversions<
          typename std::decay<Ts>::type
        >::type...>;
    static_assert(response_type_unbox<signatures_of_t<Handle>, token>::valid,
                  "receiver does not accept given message");
    auto mid = current_element_->mid;
    current_element_->mid = P == message_priority::high
                            ? mid.with_high_priority()
                            : mid.with_normal_priority();
    dest->enqueue(make_mailbox_element(std::move(current_element_->sender),
                                       mid, std::move(current_element_->stages),
                                       std::forward<Ts>(xs)...),
                  context());
    return {};
  }

  inline mailbox_type& mailbox() {
    return mailbox_;
  }

  virtual void initialize();

  bool cleanup(error&& fail_state, execution_unit* host) override;

  message_id new_request_id(message_priority mp);

  // -- message processing -----------------------------------------------------

  /// Returns the next message from the mailbox or `nullptr`
  /// if the mailbox is drained.
  mailbox_element_ptr next_message();

  /// Returns whether the mailbox contains at least one element.
  bool has_next_message();

  /// Appends `x` to the cache for later consumption.
  void push_to_cache(mailbox_element_ptr ptr);

protected:
  // -- member variables -------------------------------------------------------

  // used by both event-based and blocking actors
  mailbox_type mailbox_;

  // identifies the execution unit this actor is currently executed by
  execution_unit* context_;

  // pointer to the sender of the currently processed message
  mailbox_element* current_element_;

  // last used request ID
  message_id last_request_id_;

  /// Factory function for returning initial behavior in function-based actors.
  std::function<behavior (local_actor*)> initial_behavior_fac_;
};

} // namespace caf

#endif // CAF_LOCAL_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_SKIP_HPP
#define CAF_SKIP_HPP

#include <functional>

#include "caf/fwd.hpp"

namespace caf {

/// @relates local_actor
/// Default handler function that leaves messages in the mailbox.
/// Can also be used inside custom message handlers to signalize
/// skipping to the runtime.
class skip_t {
public:
  using fun = std::function<result<message> (scheduled_actor* self,
                                             message_view&)>;

  constexpr skip_t() {
    // nop
  }

  constexpr skip_t operator()() const {
    return *this;
  }

  operator fun() const;

private:
  static result<message> skip_fun_impl(scheduled_actor*, message_view&);
};

/// Tells the runtime system to skip a message when used as message
/// handler, i.e., causes the runtime to leave the message in
/// the mailbox of an actor.
constexpr skip_t skip = skip_t{};

} // namespace caf

#endif // CAF_SKIP_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_SCATTERER_IMPL_HPP
#define CAF_STREAM_SCATTERER_IMPL_HPP

#include <cstddef>

#include "caf/fwd.hpp"
#include "caf/duration.hpp"
#include "caf/stream_edge_impl.hpp"
#include "caf/stream_scatterer.hpp"

namespace caf {

/// Type-erased policy for dispatching data to sinks.
class stream_scatterer_impl : public stream_edge_impl<stream_scatterer> {
public:
  // -- member types -----------------------------------------------------------

  using super = stream_edge_impl<stream_scatterer>;

  // -- constructors, destructors, and assignment operators --------------------

  stream_scatterer_impl(local_actor* selfptr);

  ~stream_scatterer_impl() override;

  // -- static utility functions for operating on paths ------------------------

  /// Removes all paths with an error message.
  void abort(error reason) override;

  /// Folds `paths()` by extracting the `open_credit` from each path.
  template <class PathContainer, class F>
  static long fold_credit(const PathContainer& xs, long x0, F f) {
    auto g = [f](long x, const typename PathContainer::value_type& y) {
      return f(x, y->open_credit);
    };
    return super::fold(xs, x0, std::move(g));
  }

  /// Returns the total number (sum) of all credit in `xs`.
  template <class PathContainer>
  static long total_credit(const PathContainer& xs) {
    return fold_credit(xs, 0l, [](long x, long y) { return x + y; });
  }

  /// Returns the minimum number of credit in `xs`.
  template <class PathContainer>
  static long min_credit(const PathContainer& xs) {
    return !xs.empty()
           ? fold_credit(xs, std::numeric_limits<long>::max(),
                         [](long x, long y) { return std::min(x, y); })
           : 0;
  }

  template <class PathContainer>
  static long max_credit(const PathContainer& xs) {
    return fold_credit(xs, 0l, [](long x, long y) { return std::max(x, y); });
}

  // -- convenience functions for children classes -----------------------------

  /// Returns the total number (sum) of all credit in `paths()`.
  long total_credit() const;

  /// Returns the minimum number of credit in `paths()`.
  long min_credit() const;

  /// Returns the maximum number of credit in `paths()`.
  long max_credit() const;

  // -- overridden functions ---------------------------------------------------

  void close() override;

  path_ptr add_path(const stream_id& sid, strong_actor_ptr origin,
                    strong_actor_ptr sink_ptr,
                    mailbox_element::forwarding_stack stages,
                    message_id handshake_mid, message handshake_data,
                    stream_priority prio, bool redeployable) override;

  path_ptr confirm_path(const stream_id& sid, const actor_addr& from,
                        strong_actor_ptr to, long initial_demand,
                        bool redeployable) override;

  bool paths_clean() const override;

  long min_batch_size() const override;

  long max_batch_size() const override;

  long min_buffer_size() const override;

  duration max_batch_delay() const override;

  void min_batch_size(long x) override;

  void max_batch_size(long x) override;

  void min_buffer_size(long x) override;

  void max_batch_delay(duration x) override;

protected:
  long min_batch_size_;
  long max_batch_size_;
  long min_buffer_size_;
  duration max_batch_delay_;
};

} // namespace caf

#endif // CAF_STREAM_SCATTERER_IMPL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_RAW_EVENT_BASED_ACTOR_HPP
#define CAF_RAW_EVENT_BASED_ACTOR_HPP

#include "caf/event_based_actor.hpp"

namespace caf {

/// A cooperatively raw scheduled actor is a dynamically typed actor that does
/// not handle any system messages. All handler for system messages as well as
/// the default handler are ignored. This actor type is for testing and
/// system-level actors.
/// @extends event_based_actor
class raw_event_based_actor : public event_based_actor {
public:
  // -- member types -----------------------------------------------------------

  /// Required by `spawn` for type deduction.
  using signatures = none_t;

  /// Required by `spawn` for type deduction.
  using behavior_type = behavior;

  // -- constructors and destructors -------------------------------------------

  explicit raw_event_based_actor(actor_config& cfg);

  invoke_message_result consume(mailbox_element& x) override;
};

} // namespace caf

#endif // CAF_RAW_EVENT_BASED_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TYPED_EVENT_BASED_ACTOR_HPP
#define CAF_TYPED_EVENT_BASED_ACTOR_HPP

#include "caf/replies_to.hpp"
#include "caf/local_actor.hpp"
#include "caf/typed_actor.hpp"
#include "caf/actor_system.hpp"
#include "caf/typed_behavior.hpp"
#include "caf/scheduled_actor.hpp"

#include "caf/mixin/requester.hpp"
#include "caf/mixin/behavior_changer.hpp"

namespace caf {

template <class... Sigs>
class behavior_type_of<typed_event_based_actor<Sigs...>> {
public:
  using type = typed_behavior<Sigs...>;
};

/// A cooperatively scheduled, event-based actor
/// implementation with static type-checking.
/// @extends local_actor
template <class... Sigs>
class typed_event_based_actor : public extend<scheduled_actor,
                                              typed_event_based_actor<Sigs...>
                                       >::template
                                       with<mixin::sender, mixin::requester,
                                            mixin::behavior_changer>,
                                public statically_typed_actor_base {
public:
  using super = typename
                extend<scheduled_actor,
                       typed_event_based_actor<Sigs...>>::template
                with<mixin::sender, mixin::requester, mixin::behavior_changer>;

  explicit typed_event_based_actor(actor_config& cfg) : super(cfg) {
    // nop
  }

  using signatures = detail::type_list<Sigs...>;

  using behavior_type = typed_behavior<Sigs...>;

  using actor_hdl = typed_actor<Sigs...>;

  std::set<std::string> message_types() const override {
    detail::type_list<typed_actor<Sigs...>> token;
    return this->system().message_types(token);
  }

  void initialize() override {
    this->setf(abstract_actor::is_initialized_flag);
    auto bhvr = make_behavior();
    CAF_LOG_DEBUG_IF(!bhvr, "make_behavior() did not return a behavior:"
                             << CAF_ARG(this->has_behavior()));
    if (bhvr) {
      // make_behavior() did return a behavior instead of using become()
      CAF_LOG_DEBUG("make_behavior() did return a valid behavior");
      this->do_become(std::move(bhvr.unbox()), true);
    }
    super::initialize();
  }

protected:
  virtual behavior_type make_behavior() {
    if (this->initial_behavior_fac_) {
      auto bhvr = this->initial_behavior_fac_(this);
      this->initial_behavior_fac_ = nullptr;
      if (bhvr)
        this->do_become(std::move(bhvr), true);
    }
    return behavior_type::make_empty_behavior();
  }
};

} // namespace caf

#endif // CAF_TYPED_EVENT_BASED_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ACTOR_MARKER_HPP
#define CAF_ACTOR_MARKER_HPP

#include "caf/fwd.hpp"

namespace caf {

class statically_typed_actor_base {
  // used as marker only
};

class dynamically_typed_actor_base {
  // used as marker only
};

template <class T>
struct actor_marker {
  using type = statically_typed_actor_base;
};

template <>
struct actor_marker<behavior> {
  using type = dynamically_typed_actor_base;
};

} // namespace caf

#endif // CAF_ACTOR_MARKER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DURATION_HPP
#define CAF_DURATION_HPP

#include <string>
#include <chrono>
#include <cstdint>
#include <stdexcept>

#include "caf/error.hpp"

namespace caf {

/// SI time units to specify timeouts.
/// @relates duration
enum class time_unit : uint32_t {
  invalid,
  minutes,
  seconds,
  milliseconds,
  microseconds,
  nanoseconds
};

/// Relates time_unit
std::string to_string(time_unit x);

// Calculates the index of a time_unit from the denominator of a ratio.
constexpr intmax_t denom_to_unit_index(intmax_t x, intmax_t offset = 2) {
  return x < 1000 ? (x == 1 ? offset : 0)
                  : denom_to_unit_index(x / 1000, offset + 1);
}

constexpr time_unit denom_to_time_unit(intmax_t x) {
  return static_cast<time_unit>(denom_to_unit_index(x));
}

/// Converts the ratio Num/Denom to a `time_unit` if the ratio describes
/// seconds, milliseconds, microseconds, or minutes. Minutes are mapped
/// to `time_unit::seconds`, any unrecognized ratio to `time_unit::invalid`.
/// @relates duration
template <intmax_t Num, intmax_t Denom>
struct ratio_to_time_unit_helper;

template <intmax_t Denom>
struct ratio_to_time_unit_helper<1, Denom> {
  static constexpr time_unit value = denom_to_time_unit(Denom);
};

template <>
struct ratio_to_time_unit_helper<60, 1> {
  static constexpr time_unit value = time_unit::minutes;
};

/// Converts an STL time period to a `time_unit`.
/// @relates duration
template <class Period>
constexpr time_unit get_time_unit_from_period() {
  return ratio_to_time_unit_helper<Period::num, Period::den>::value;
}

/// Represents an infinite amount of timeout for specifying "invalid" timeouts.
struct infinite_t {
  constexpr infinite_t() {
    // nop
  }
};

static constexpr infinite_t infinite = infinite_t{};

/// Time duration consisting of a `time_unit` and a 64 bit unsigned integer.
class duration {
public:
  constexpr duration() : unit(time_unit::invalid), count(0) {
    // nop
  }

  constexpr duration(time_unit u, uint32_t v) : unit(u), count(v) {
    // nop
  }

  constexpr duration(infinite_t) : unit(time_unit::invalid), count(0) {
    // nop
  }

  /// Creates a new instance from an STL duration.
  /// @throws std::invalid_argument Thrown if `d.count() is negative.
  template <class Rep, class Period,
            class E =
              typename std::enable_if<
                std::is_integral<Rep>::value
                && get_time_unit_from_period<Period>() != time_unit::invalid
              >::type>
  explicit duration(const std::chrono::duration<Rep, Period>& d)
      : unit(get_time_unit_from_period<Period>()),
        count(d.count() < 0 ? 0u : static_cast<uint64_t>(d.count())) {
    // nop
  }

  /// Returns `unit != time_unit::invalid`.
  constexpr bool valid() const {
    return unit != time_unit::invalid;
  }

  /// Returns `count == 0`.
  constexpr bool is_zero() const {
    return count == 0;
  }

  time_unit unit;

  uint64_t count;
};

/// @relates duration
template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, duration& x) {
  return f(x.unit, x.count);
}

/// @relates duration
std::string to_string(const duration& x);

/// @relates duration
bool operator==(const duration& lhs, const duration& rhs);

/// @relates duration
inline bool operator!=(const duration& lhs, const duration& rhs) {
  return !(lhs == rhs);
}

/// @relates duration
template <class Clock, class Duration>
std::chrono::time_point<Clock, Duration>&
operator+=(std::chrono::time_point<Clock, Duration>& lhs, const duration& rhs) {
  switch (rhs.unit) {
    case time_unit::invalid:
      break;
    case time_unit::minutes:
      lhs += std::chrono::minutes(rhs.count);
      break;
    case time_unit::seconds:
      lhs += std::chrono::seconds(rhs.count);
      break;
    case time_unit::milliseconds:
      lhs += std::chrono::milliseconds(rhs.count);
      break;
    case time_unit::microseconds:
      lhs += std::chrono::microseconds(rhs.count);
      break;
    case time_unit::nanoseconds:
      lhs += std::chrono::nanoseconds(rhs.count);
      break;
  }
  return lhs;
}

} // namespace caf

#endif // CAF_DURATION_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_MANAGER_HPP
#define CAF_STREAM_MANAGER_HPP

#include <vector>
#include <cstdint>
#include <cstddef>

#include "caf/fwd.hpp"
#include "caf/ref_counted.hpp"
#include "caf/mailbox_element.hpp"

namespace caf {

/// Manages a single stream with any number of down- and upstream actors.
/// @relates stream_msg
class stream_manager : public ref_counted {
public:
  ~stream_manager() override;

  /// Handles `stream_msg::open` messages.
  /// @returns Initial credit to the source.
  /// @param hdl Handle to the sender.
  /// @param original_stage Handle to the initial receiver of the handshake.
  /// @param priority Affects credit assignment and maximum bandwidth.
  /// @param redeployable Configures whether `hdl` could get redeployed, i.e.,
  ///                     can resume after an abort.
  /// @param result_cb Callback for the listener of the final stream result.
  ///                  Ignored when returning `nullptr`, because the previous
  ///                  stage is responsible for it until this manager
  ///                  acknowledges the handshake.
  /// @pre `hdl != nullptr`
  virtual error open(const stream_id& sid, strong_actor_ptr hdl,
                     strong_actor_ptr original_stage, stream_priority priority,
                     bool redeployable, response_promise result_cb);

  /// Handles `stream_msg::ack_open` messages, i.e., finalizes the stream
  /// handshake.
  /// @param sid ID of the outgoing stream.
  /// @param rebind_from Receiver of the original `open` message.
  /// @param rebind_to Sender of this confirmation.
  /// @param initial_demand Credit received with this `ack_open`.
  /// @param redeployable Denotes whether the runtime can redeploy
  ///                     `rebind_to` on failure.
  /// @pre `hdl != nullptr`
  virtual error ack_open(const stream_id& sid, const actor_addr& rebind_from,
                         strong_actor_ptr rebind_to, long initial_demand,
                         bool redeployable);

  /// Handles `stream_msg::batch` messages.
  /// @param hdl Handle to the sender.
  /// @param xs_size Size of the vector stored in `xs`.
  /// @param xs A type-erased vector of size `xs_size`.
  /// @param xs_id ID of this batch (must be ACKed).
  /// @pre `hdl != nullptr`
  /// @pre `xs_size > 0`
  virtual error batch(const stream_id& sid, const actor_addr& hdl, long xs_size,
                      message& xs, int64_t xs_id);

  /// Handles `stream_msg::ack_batch` messages.
  /// @param hdl Handle to the sender.
  /// @param new_demand New credit for sending data.
  /// @param cumulative_batch_id Id of last handled batch.
  /// @pre `hdl != nullptr`
  virtual error ack_batch(const stream_id& sid, const actor_addr& hdl,
                          long new_demand, int64_t cumulative_batch_id);

  /// Handles `stream_msg::close` messages.
  /// @param hdl Handle to the sender.
  /// @pre `hdl != nullptr`
  virtual error close(const stream_id& sid, const actor_addr& hdl);

  /// Handles `stream_msg::drop` messages.
  /// @param hdl Handle to the sender.
  /// @pre `hdl != nullptr`
  virtual error drop(const stream_id& sid, const actor_addr& hdl);

  /// Handles `stream_msg::drop` messages. The default implementation calls
  /// `abort(reason)` and returns `sec::unhandled_stream_error`.
  /// @param hdl Handle to the sender.
  /// @param reason Reported error from the source.
  /// @pre `hdl != nullptr`
  /// @pre `err != none`
  virtual error forced_close(const stream_id& sid, const actor_addr& hdl,
                             error reason);

  /// Handles `stream_msg::drop` messages. The default implementation calls
  /// `abort(reason)` and returns `sec::unhandled_stream_error`.
  /// @param hdl Handle to the sender.
  /// @param reason Reported error from the sink.
  /// @pre `hdl != nullptr`
  /// @pre `err != none`
  virtual error forced_drop(const stream_id& sid, const actor_addr& hdl,
                            error reason);

  /// Adds a new sink to the stream.
  virtual bool add_sink(const stream_id& sid, strong_actor_ptr origin,
                        strong_actor_ptr sink_ptr,
                        mailbox_element::forwarding_stack stages,
                        message_id handshake_mid, message handshake_data,
                        stream_priority prio, bool redeployable);

  /// Adds the source `hdl` to a stream. Convenience function for calling
  /// `in().add_path(sid, hdl).second`.
  virtual bool add_source(const stream_id& sid, strong_actor_ptr source_ptr,
                          strong_actor_ptr original_stage, stream_priority prio,
                          bool redeployable, response_promise result_cb);

  /// Pushes new data to downstream actors by sending batches. The amount of
  /// pushed data is limited by the available credit.
  virtual void push();

  /// Aborts a stream after any stream message handler returned a non-default
  /// constructed error `reason` or the parent actor terminates with a
  /// non-default error.
  /// @param reason Previous error or non-default exit reason of the parent.
  virtual void abort(error reason);

  /// Closes the stream when the parent terminates with default exit reason or
  /// the stream reached its end.
  virtual void close();

  // -- implementation hooks for all children classes --------------------------

  /// Returns the stream edge for incoming data.
  virtual stream_gatherer& in() = 0;

  /// Returns the stream edge for outgoing data.
  virtual stream_scatterer& out() = 0;

  /// Returns whether the stream has reached the end and can be discarded
  /// safely.
  virtual bool done() const = 0;

  // -- implementation hooks for sources ---------------------------------------

  /// Tries to generate new messages for the stream. This member function does
  /// nothing on stages and sinks, but can trigger a source to produce more
  /// messages.
  virtual bool generate_messages();

protected:
  // -- implementation hooks for sinks -----------------------------------------

  /// Called when the gatherer closes to produce the final stream result for
  /// all listeners. The default implementation returns an empty message.
  virtual message make_final_result();

  /// Called to handle incoming data. The default implementation logs an error
  /// (sinks are expected to override this member function).
  virtual error process_batch(message& msg);

  /// Called when `in().closed()` changes to `true`. The default
  /// implementation does nothing.
  virtual void input_closed(error reason);

  // -- implementation hooks for sources ---------------------------------------

  /// Returns a type-erased `stream<T>` as handshake token for downstream
  /// actors. Returns an empty message for sinks.
  virtual message make_output_token(const stream_id&) const;

  /// Called whenever new credit becomes available. The default implementation
  /// logs an error (sources are expected to override this hook).
  virtual void downstream_demand(outbound_path* ptr, long demand);

  /// Called when `out().closed()` changes to `true`. The default
  /// implementation does nothing.
  virtual void output_closed(error reason);

  /// Pointer to the parent actor.
  local_actor* self_;

  /// Keeps track of pending handshakes.
  
};

/// A reference counting pointer to a `stream_manager`.
/// @relates stream_manager
using stream_manager_ptr = intrusive_ptr<stream_manager>;

} // namespace caf

#endif // CAF_STREAM_MANAGER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ACTOR_SYSTEM_HPP
#define CAF_ACTOR_SYSTEM_HPP

#include <array>
#include <mutex>
#include <atomic>
#include <string>
#include <memory>
#include <cstddef>
#include <functional>
#include <condition_variable>

#include "caf/fwd.hpp"
#include "caf/logger.hpp"
#include "caf/actor_cast.hpp"
#include "caf/make_actor.hpp"
#include "caf/actor_clock.hpp"
#include "caf/infer_handle.hpp"
#include "caf/actor_config.hpp"
#include "caf/spawn_options.hpp"
#include "caf/group_manager.hpp"
#include "caf/is_typed_actor.hpp"
#include "caf/abstract_actor.hpp"
#include "caf/actor_registry.hpp"
#include "caf/string_algorithms.hpp"
#include "caf/scoped_execution_unit.hpp"
#include "caf/uniform_type_info_map.hpp"
#include "caf/composable_behavior_based_actor.hpp"
#include "caf/prohibit_top_level_spawn_marker.hpp"

#include "caf/detail/spawn_fwd.hpp"
#include "caf/detail/init_fun_factory.hpp"

namespace caf {

using rtti_pair = std::pair<uint16_t, const std::type_info*>;

using rtti_pair_vec = std::vector<rtti_pair>;

using rtti_pair_vec_triple = std::tuple<rtti_pair_vec,
                                        rtti_pair_vec,
                                        rtti_pair_vec>;

template <class T>
struct mpi_field_access {
  std::string operator()(const uniform_type_info_map& types) {
    auto nr = type_nr<T>::value;
    if (nr != 0)
      return *types.portable_name(nr, nullptr);
    auto ptr = types.portable_name(0, &typeid(T));
    if (ptr != nullptr)
      return *ptr;
    std::string result = "<invalid-type[typeid ";
    result += typeid(T).name();
    result += "]>";
    return result;
  }
};

template <atom_value X>
struct mpi_field_access<atom_constant<X>> {
  std::string operator()(const uniform_type_info_map&) {
    return to_string(X);
  }
};

template <>
struct mpi_field_access<void> {
  std::string operator()(const uniform_type_info_map&) {
    return "void";
  }
};
template <class T>
std::string get_mpi_field(const uniform_type_info_map& types) {
  mpi_field_access<T> f;
  return f(types);
}

template <class T>
struct typed_mpi_access;

template <class... Is, class... Ls>
struct typed_mpi_access<typed_mpi<detail::type_list<Is...>,
                                  output_tuple<Ls...>>> {
  std::string operator()(const uniform_type_info_map& types) const {
    static_assert(sizeof...(Is) > 0, "typed MPI without inputs");
    static_assert(sizeof...(Ls) > 0, "typed MPI without outputs");
    std::vector<std::string> inputs{get_mpi_field<Is>(types)...};
    std::vector<std::string> outputs1{get_mpi_field<Ls>(types)...};
    std::string result = "caf::replies_to<";
    result += join(inputs, ",");
    result += ">::with<";
    result += join(outputs1, ",");
    result += ">";
    return result;
  }
};

template <class T>
std::string get_rtti_from_mpi(const uniform_type_info_map& types) {
  typed_mpi_access<T> f;
  return f(types);
}

/// Actor environment including scheduler, registry, and optional components
/// such as a middleman.
class actor_system {
public:
  friend class logger;
  friend class io::middleman;
  friend class abstract_actor;

  /// The number of actors implictly spawned by the actor system on startup.
  static constexpr size_t num_internal_actors = 2;

  /// Returns the ID of an internal actor by its name.
  /// @pre x in {'SpawnServ', 'ConfigServ', 'StreamServ'}
  static constexpr size_t internal_actor_id(atom_value x) {
    return x == atom("SpawnServ") ? 0 : (x == atom("ConfigServ") ? 1 : 2);
  }

  /// Returns the internal actor for dynamic spawn operations.
  inline const strong_actor_ptr& spawn_serv() const {
    return internal_actors_[internal_actor_id(atom("SpawnServ"))];
  }

  /// Returns the internal actor for storing the runtime configuration
  /// for this actor system.
  inline const strong_actor_ptr& config_serv() const {
    return internal_actors_[internal_actor_id(atom("ConfigServ"))];
  }

  actor_system() = delete;
  actor_system(const actor_system&) = delete;
  actor_system& operator=(const actor_system&) = delete;

  /// An (optional) component of the actor system.
  class module {
  public:
    enum id_t {
      scheduler,
      middleman,
      opencl_manager,
      openssl_manager,
      num_ids
    };

    virtual ~module();

    /// Starts any background threads needed by the module.
    virtual void start() = 0;

    /// Stops all background threads of the module.
    virtual void stop() = 0;

    /// Allows the module to change the
    /// configuration of the actor system during startup.
    virtual void init(actor_system_config&) = 0;

    /// Returns the identifier of this module.
    virtual id_t id() const = 0;

    /// Returns a pointer to the subtype.
    virtual void* subtype_ptr() = 0;
  };

  using module_ptr = std::unique_ptr<module>;

  using module_array = std::array<module_ptr, module::num_ids>;

  /// @warning The system stores a reference to `cfg`, which means the
  ///          config object must outlive the actor system.
  explicit actor_system(actor_system_config& cfg);

  virtual ~actor_system();

  /// A message passing interface (MPI) in run-time checkable representation.
  using mpi = std::set<std::string>;

  template <class T,
            class E = typename std::enable_if<!is_typed_actor<T>::value>::type>
  mpi message_types(detail::type_list<T>) const {
    return mpi{};
  }

  template <class... Ts>
  mpi message_types(detail::type_list<typed_actor<Ts...>>) const {
    static_assert(sizeof...(Ts) > 0, "empty typed actor handle given");
    mpi result{get_rtti_from_mpi<Ts>(types())...};
    return result;
  }

  template <class T,
            class E =
              typename std::enable_if<!detail::is_type_list<T>::value>::type>
  mpi message_types(const T&) const {
    detail::type_list<T> token;
    return message_types(token);
  }

  /// Returns a string representation of the messaging
  /// interface using portable names;
  template <class T>
  mpi message_types() const {
    detail::type_list<T> token;
    return message_types(token);
  }

  /// Returns whether actor handles described by `xs`
  /// can be assigned to actor handles described by `ys`.
  /// @experimental
  inline bool assignable(const mpi& xs, const mpi& ys) const {
    if (ys.empty())
      return xs.empty();
    if (xs.size() == ys.size())
      return xs == ys;
    return std::includes(xs.begin(), xs.end(), ys.begin(), ys.end());
  }

  /// Returns whether actor handles described by `xs`
  /// can be assigned to actor handles of type `T`.
  /// @experimental
  template <class T>
  bool assignable(const std::set<std::string>& xs) const {
    return assignable(xs, message_types<T>());
  }

  /// Returns the host-local identifier for this system.
  const node_id& node() const;

  /// Returns the scheduler instance.
  scheduler::abstract_coordinator& scheduler();

  /// Returns the system-wide event logger.
  caf::logger& logger();

  /// Returns the system-wide actor registry.
  actor_registry& registry();

  /// Returns the system-wide factory for custom types and actors.
  const uniform_type_info_map& types() const;

  /// Returns a string representation for `err`.
  std::string render(const error& x) const;

  /// Returns the system-wide group manager.
  group_manager& groups();

  /// Returns `true` if the I/O module is available, `false` otherwise.
  bool has_middleman() const;

  /// Returns the middleman instance from the I/O module.
  /// @throws `std::logic_error` if module is not loaded.
  io::middleman& middleman();

  /// Returns `true` if the opencl module is available, `false` otherwise.
  bool has_opencl_manager() const;

  /// Returns the manager instance from the OpenCL module.
  /// @throws `std::logic_error` if module is not loaded.
  opencl::manager& opencl_manager() const;

  /// Returns `true` if the openssl module is available, `false` otherwise.
  bool has_openssl_manager() const;

  /// Returns the manager instance from the OpenSSL module.
  /// @throws `std::logic_error` if module is not loaded.
  openssl::manager& openssl_manager() const;

  /// Returns a dummy execution unit that forwards
  /// everything to the scheduler.
  scoped_execution_unit* dummy_execution_unit();

  /// Returns a new actor ID.
  actor_id next_actor_id();

  /// Returns the last given actor ID.
  actor_id latest_actor_id() const;

  /// Blocks this caller until all actors are done.
  void await_all_actors_done() const;

  /// Called by `spawn` when used to create a class-based actor to
  /// apply automatic conversions to `xs` before spawning the actor.
  /// Should not be called by users of the library directly.
  /// @param cfg To-be-filled config for the actor.
  /// @param xs Constructor arguments for `C`.
  template <class C, spawn_options Os, class... Ts>
  infer_handle_from_class_t<C>
  spawn_class(actor_config& cfg, Ts&&... xs) {
    return spawn_impl<C, Os>(cfg, detail::spawn_fwd<Ts>(xs)...);
  }

  /// Returns a new actor of type `C` using `xs...` as constructor
  /// arguments. The behavior of `spawn` can be modified by setting `Os`, e.g.,
  /// to opt-out of the cooperative scheduling.
  /// @param xs Constructor arguments for `C`.
  template <class C, spawn_options Os = no_spawn_options, class... Ts>
  infer_handle_from_class_t<C> spawn(Ts&&... xs) {
    check_invariants<C>();
    actor_config cfg;
    return spawn_impl<C, Os>(cfg, detail::spawn_fwd<Ts>(xs)...);
  }

  template <class S, spawn_options Os = no_spawn_options>
  infer_handle_from_state_t<S> spawn() {
    return spawn<composable_behavior_based_actor<S>, Os>();
  }

  /// Called by `spawn_functor` to apply static assertions and
  /// store an initialization function in `cfg` before calling `spawn_class`.
  /// @param cfg To-be-filled config for the actor.
  /// @param fun Function object for the actor's behavior; will be moved.
  /// @param xs Arguments for `fun`.
  template <spawn_options Os, class C, class F, class... Ts>
  infer_handle_from_class_t<C>
  spawn_functor_impl(actor_config& cfg, F& fun, Ts&&... xs) {
    detail::init_fun_factory<C, F> fac;
    cfg.init_fun = fac(std::move(fun), std::forward<Ts>(xs)...);
    return spawn_impl<C, Os>(cfg);
  }

  /// Called by `spawn` when used to create a functor-based actor to select
  /// a proper implementation and then delegates to `spawn_functor_impl`.
  /// Should not be called by users of the library directly.
  /// @param cfg To-be-filled config for the actor.
  /// @param fun Function object for the actor's behavior; will be moved.
  /// @param xs Arguments for `fun`.
  template <spawn_options Os = no_spawn_options, class F, class... Ts>
  infer_handle_from_fun_t<F>
  spawn_functor(actor_config& cfg, F& fun, Ts&&... xs) {
    using impl = infer_impl_from_fun_t<F>;
    return spawn_functor_impl<Os, impl>(cfg, fun, std::forward<Ts>(xs)...);
  }

  /// Returns a new functor-based actor. The first argument must be the functor,
  /// the remainder of `xs...` is used to invoke the functor.
  /// The behavior of `spawn` can be modified by setting `Os`, e.g.,
  /// to opt-out of the cooperative scheduling.
  template <spawn_options Os = no_spawn_options, class F, class... Ts>
  infer_handle_from_fun_t<F>
  spawn(F fun, Ts&&... xs) {
    check_invariants<infer_impl_from_fun_t<F>>();
    actor_config cfg;
    return spawn_functor<Os>(cfg, fun, std::forward<Ts>(xs)...);
  }

  /// Returns a new actor with run-time type `name`, constructed
  /// with the arguments stored in `args`.
  /// @experimental
  template <class Handle,
            class E = typename std::enable_if<is_handle<Handle>::value>::type>
  expected<Handle> spawn(const std::string& name, message args,
                         execution_unit* ctx = nullptr,
                         bool check_interface = true,
                         const mpi* expected_ifs = nullptr) {
    mpi tmp;
    if (check_interface && !expected_ifs) {
      tmp = message_types<Handle>();
      expected_ifs = &tmp;
    }
    auto res = dyn_spawn_impl(name, args, ctx, check_interface, expected_ifs);
    if (!res)
      return std::move(res.error());
    return actor_cast<Handle>(std::move(*res));
  }

  /// Spawns a class-based actor `T` immediately joining the groups in
  /// range `[first, last)`.
  /// @private
  template <class T, spawn_options Os, class Iter, class... Ts>
  infer_handle_from_class_t<T>
  spawn_class_in_groups(actor_config& cfg, Iter first, Iter last, Ts&&... xs) {
    static_assert(std::is_same<infer_handle_from_class_t<T>, actor>::value,
                  "Only dynamically typed actors can be spawned in a group.");
    check_invariants<T>();
    auto irange = make_input_range(first, last);
    cfg.groups = &irange;
    return spawn_class<T, Os>(cfg, std::forward<Ts>(xs)...);
  }

  /// Spawns a class-based actor `T` immediately joining the groups in
  /// range `[first, last)`.
  /// @private
  template <spawn_options Os, class Iter, class F, class... Ts>
  infer_handle_from_fun_t<F>
  spawn_fun_in_groups(actor_config& cfg, Iter first, Iter second,
                      F& fun, Ts&&... xs) {
    static_assert(std::is_same<infer_handle_from_fun_t<F>, actor>::value,
                  "Only dynamically actors can be spawned in a group.");
    check_invariants<infer_impl_from_fun_t<F>>();
    auto irange = make_input_range(first, second);
    cfg.groups = &irange;
    return spawn_functor<Os>(cfg, fun, std::forward<Ts>(xs)...);
  }

  /// Returns a new functor-based actor subscribed to all groups in `gs`.
  template <spawn_options Os = no_spawn_options, class F, class... Ts>
  infer_handle_from_fun_t<F>
  spawn_in_groups(std::initializer_list<group> gs, F fun, Ts&&... xs) {
    actor_config cfg;
    return spawn_fun_in_groups<Os>(cfg, gs.begin(), gs.end(), fun,
                                   std::forward<Ts>(xs)...);
  }

  /// Returns a new functor-based actor subscribed to all groups in `gs`.
  template <spawn_options Os = no_spawn_options, class Gs, class F, class... Ts>
  infer_handle_from_fun_t<F>
  spawn_in_groups(const Gs& gs, F fun, Ts&&... xs) {
    actor_config cfg;
    return spawn_fun_in_groups<Os>(cfg, gs.begin(), gs.end(), fun,
                                   std::forward<Ts>(xs)...);
  }

  /// Returns a new functor-based actor subscribed to all groups in `gs`.
  template <spawn_options Os = no_spawn_options, class F, class... Ts>
  infer_handle_from_fun_t<F>
  spawn_in_group(const group& grp, F fun, Ts&&... xs) {
    return spawn_in_groups<Os>({grp}, std::move(fun),
                               std::forward<Ts>(xs)...);
  }

  /// Returns a new class-based actor subscribed to all groups in `gs`.
  template <class T, spawn_options Os = no_spawn_options, class... Ts>
  infer_handle_from_class_t<T>
  spawn_in_groups(std::initializer_list<group> gs, Ts&&... xs) {
    actor_config cfg;
    return spawn_class_in_groups<T, Os>(cfg, gs.begin(), gs.end(),
                                        std::forward<Ts>(xs)...);
  }

  /// Returns a new class-based actor subscribed to all groups in `gs`.
  template <class T, spawn_options Os = no_spawn_options, class Gs, class... Ts>
  infer_handle_from_class_t<T>
  spawn_in_groups(const Gs& gs, Ts&&... xs) {
    actor_config cfg;
    return spawn_class_in_groups<T, Os>(cfg, gs.begin(), gs.end(),
                                        std::forward<Ts>(xs)...);
  }

  /// Returns a new class-based actor subscribed to all groups in `gs`.
  template <class T, spawn_options Os = no_spawn_options, class... Ts>
  infer_handle_from_class_t<T>
  spawn_in_group(const group& grp, Ts&&... xs) {
    return spawn_in_groups<T, Os>({grp}, std::forward<Ts>(xs)...);
  }

  /// Returns whether this actor system calls `await_all_actors_done`
  /// in its destructor before shutting down.
  inline bool await_actors_before_shutdown() const {
    return await_actors_before_shutdown_;
  }

  /// Configures whether this actor system calls `await_all_actors_done`
  /// in its destructor before shutting down.
  inline void await_actors_before_shutdown(bool x) {
    await_actors_before_shutdown_ = x;
  }

  /// Returns the configuration of this actor system.
  inline const actor_system_config& config() const {
    return cfg_;
  }

  /// Returns the system-wide clock.
  actor_clock& clock() noexcept;

  /// @cond PRIVATE

  /// Increases running-detached-threads-count by one.
  void inc_detached_threads();

  /// Decreases running-detached-threads-count by one.
  void dec_detached_threads();

  /// Blocks the caller until all detached threads are done.
  void await_detached_threads();

  /// Calls all thread started hooks
  /// @warning must be called by thread which is about to start
  void thread_started();

  /// Calls all thread terminates hooks
  /// @warning must be called by thread which is about to terminate
  void thread_terminates();

  /// @endcond

private:
  template <class T>
  void check_invariants() {
    static_assert(!std::is_base_of<prohibit_top_level_spawn_marker, T>::value,
                  "This actor type cannot be spawned throught an actor system. "
                  "Probably you have tried to spawn a broker or opencl actor.");
  }

  expected<strong_actor_ptr> dyn_spawn_impl(const std::string& name,
                                            message& args,
                                            execution_unit* ctx,
                                            bool check_interface,
                                            optional<const mpi&> expected_ifs);

  template <class C, spawn_options Os, class... Ts>
  infer_handle_from_class_t<C>
  spawn_impl(actor_config& cfg, Ts&&... xs) {
    static_assert(is_unbound(Os),
                  "top-level spawns cannot have monitor or link flag");
    cfg.flags = has_priority_aware_flag(Os)
                ? abstract_actor::is_priority_aware_flag
                : 0;
    if (has_detach_flag(Os) || std::is_base_of<blocking_actor, C>::value)
      cfg.flags |= abstract_actor::is_detached_flag;
    if (has_hide_flag(Os))
      cfg.flags |= abstract_actor::is_hidden_flag;
    if (!cfg.host)
      cfg.host = dummy_execution_unit();
    CAF_SET_LOGGER_SYS(this);
    auto res = make_actor<C>(next_actor_id(), node(), this,
                             cfg, std::forward<Ts>(xs)...);
    auto ptr = static_cast<C*>(actor_cast<abstract_actor*>(res));
    ptr->launch(cfg.host, has_lazy_init_flag(Os), has_hide_flag(Os));
    return res;
  }

  /// Sets the internal actor for dynamic spawn operations.
  inline void spawn_serv(strong_actor_ptr x) {
    internal_actors_[internal_actor_id(atom("SpawnServ"))] = std::move(x);
  }

  /// Sets the internal actor for storing the runtime configuration.
  inline void config_serv(strong_actor_ptr x) {
    internal_actors_[internal_actor_id(atom("ConfigServ"))] = std::move(x);
  }

  std::atomic<size_t> ids_;
  uniform_type_info_map types_;
  node_id node_;
  intrusive_ptr<caf::logger> logger_;
  actor_registry registry_;
  group_manager groups_;
  module_array modules_;
  scoped_execution_unit dummy_execution_unit_;
  bool await_actors_before_shutdown_;
  // Stores SpawnServ, ConfigServ, and StreamServ
  std::array<strong_actor_ptr, num_internal_actors> internal_actors_;
  std::atomic<size_t> detached;
  mutable std::mutex detached_mtx;
  mutable std::condition_variable detached_cv;
  actor_system_config& cfg_;
  std::mutex logger_dtor_mtx_;
  std::condition_variable logger_dtor_cv_;
  volatile bool logger_dtor_done_;
};

} // namespace caf

#endif // CAF_ACTOR_SYSTEM_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

// This file is partially included in the manual, do not modify
// without updating the references in the *.tex files!
// Manual references: lines 32-93 (Error.tex)

#ifndef CAF_SEC_HPP
#define CAF_SEC_HPP

#include "caf/error.hpp"
#include "caf/make_message.hpp"

namespace caf {

/// SEC stands for "System Error Code". This enum contains
/// error codes used internally by CAF.
enum class sec : uint8_t {
  /// Indicates that an actor dropped an unexpected message.
  unexpected_message = 1,
  /// Indicates that a response message did not match the provided handler.
  unexpected_response,
  /// Indicates that the receiver of a request is no longer alive.
  request_receiver_down,
  /// Indicates that a request message timed out.
  request_timeout,
  /// Indicates that requested group module does not exist.
  no_such_group_module = 5,
  /// Unpublishing or connecting failed: no actor bound to given port.
  no_actor_published_at_port,
  /// Connecting failed because a remote actor had an unexpected interface.
  unexpected_actor_messaging_interface,
  /// Migration failed because the state of an actor is not serializable.
  state_not_serializable,
  /// An actor received an unsupported key for `('sys', 'get', key)` messages.
  unsupported_sys_key,
  /// An actor received an unsupported system message.
  unsupported_sys_message = 10,
  /// A remote node disconnected during CAF handshake.
  disconnect_during_handshake,
  /// Tried to forward a message via BASP to an invalid actor handle.
  cannot_forward_to_invalid_actor,
  /// Tried to forward a message via BASP to an unknown node ID.
  no_route_to_receiving_node,
  /// Middleman could not assign a connection handle to a broker.
  failed_to_assign_scribe_from_handle,
  /// Middleman could not assign an acceptor handle to a broker.
  failed_to_assign_doorman_from_handle = 15,
  /// User requested to close port 0 or to close a port not managed by CAF.
  cannot_close_invalid_port,
  /// Middleman could not connect to a remote node.
  cannot_connect_to_node,
  /// Middleman could not open requested port.
  cannot_open_port,
  /// A C system call in the middleman failed.
  network_syscall_failed,
  /// A function received one or more invalid arguments.
  invalid_argument = 20,
  /// A network socket reported an invalid network protocol family.
  invalid_protocol_family,
  /// Middleman could not publish an actor because it was invalid.
  cannot_publish_invalid_actor,
  /// A remote spawn failed because the provided types did not match.
  cannot_spawn_actor_from_arguments,
  /// Serialization failed because there was not enough data to read.
  end_of_stream,
  /// Serialization failed because no CAF context is available.
  no_context = 25,
  /// Serialization failed because CAF misses run-time type information.
  unknown_type,
  /// Serialization of actors failed because no proxy registry is available.
  no_proxy_registry,
  /// An exception was thrown during message handling.
  runtime_error,
  /// Linking to a remote actor failed because actor no longer exists.
  remote_linking_failed,
  /// Adding an upstream to a stream failed.
  cannot_add_upstream = 30,
  /// Adding an upstream to a stream failed because it already exists.
  upstream_already_exists,
  /// Unable to process upstream messages because upstream is invalid.
  invalid_upstream,
  /// Adding a downstream to a stream failed.
  cannot_add_downstream,
  /// Adding a downstream to a stream failed because it already exists.
  downstream_already_exists,
  /// Unable to process downstream messages because downstream is invalid.
  invalid_downstream = 35,
  /// Cannot start streaming without next stage.
  no_downstream_stages_defined,
  /// Actor failed to initialize state after receiving a stream handshake.
  stream_init_failed,
  /// Unable to process a stream since due to missing state.
  invalid_stream_state,
  /// Stream aborted due to unexpected error.
  unhandled_stream_error,
  /// A function view was called without assigning an actor first.
  bad_function_call = 40,
  /// Feature is disabled in the actor system config.
  feature_disabled,
};

/// @relates sec
std::string to_string(sec);

/// @relates sec
error make_error(sec);

/// @relates sec
template <class T, class... Ts>
error make_error(sec code, T&& x, Ts&&... xs) {
  return {static_cast<uint8_t>(code), atom("system"),
          make_message(std::forward<T>(x), std::forward<Ts>(xs)...)};
}

} // namespace caf

#endif // CAF_SEC_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_PARAM_HPP
#define CAF_PARAM_HPP

#include <type_traits>

#include "caf/atom.hpp"

namespace caf {

/// Represents a message handler parameter of type `T` and
/// guarantees copy-on-write semantics.
template <class T>
class param {
public:
  enum flag {
    shared_access,    // x_ lives in a shared type_erased_tuple
    exclusive_access, // x_ lives in an unshared type_erased_tuple
    private_access    // x_ is a copy of the original value
  };

  param(const void* ptr, bool is_shared)
      : x_(reinterpret_cast<T*>(const_cast<void*>(ptr))) {
    flag_ = is_shared ? shared_access : exclusive_access;
  }

  param(const param& other) = delete;
  param& operator=(const param& other) = delete;

  param(param&& other) : x_(other.x_), flag_(other.flag_) {
    other.x_ = nullptr;
  }

  ~param() {
    if (flag_ == private_access)
      delete x_;
  }

  const T& get() const {
    return *x_;
  }

  operator const T&() const {
    return *x_;
  }

  const T* operator->() const {
    return x_;
  }

  /// Detaches the value if needed and returns a mutable reference to it.
  T& get_mutable() {
    if (flag_ == shared_access) {
      auto cpy = new T(get());
      x_ = cpy;
      flag_ = private_access;
    }
    return *x_;
  }

  /// Moves the value out of the `param`.
  T&& move() {
    return std::move(get_mutable());
  }

private:
  T* x_;
  flag flag_;
};

/// Convenience alias that wraps `T` into `param<T>`
/// unless `T` is arithmetic or an atom constant.
template <class T>
using param_t =
  typename std::conditional<
    std::is_arithmetic<T>::value || is_atom_constant<T>::value,
    T,
    param<T>
  >::type;

/// Unpacks `param<T>` to `T`.
template <class T>
struct remove_param {
  using type = T;
};

template <class T>
struct remove_param<param<T>> {
  using type = T;
};

/// Convenience struct for `remove_param<std::decay<T>>`.
template <class T>
struct param_decay {
  using type = typename remove_param<typename std::decay<T>::type>::type;
};

} // namespace caf

#endif // CAF_PARAM_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_NODE_ID_HPP
#define CAF_NODE_ID_HPP

#include <array>
#include <string>
#include <cstdint>
#include <functional>

#include "caf/fwd.hpp"
#include "caf/none.hpp"
#include "caf/error.hpp"
#include "caf/config.hpp"
#include "caf/ref_counted.hpp"
#include "caf/make_counted.hpp"
#include "caf/intrusive_ptr.hpp"

#include "caf/meta/type_name.hpp"
#include "caf/meta/hex_formatted.hpp"

#include "caf/detail/comparable.hpp"
#include "caf/detail/scope_guard.hpp"
#include "caf/detail/type_traits.hpp"

namespace caf {

/// A node ID consists of a host ID and process ID. The host ID identifies
/// the physical machine in the network, whereas the process ID identifies
/// the running system-level process on that machine.
class node_id {
public:
  ~node_id();

  node_id() = default;

  node_id(const node_id&) = default;

  node_id(const none_t&);

  node_id& operator=(const node_id&) = default;

  node_id& operator=(const none_t&);

  /// A 160 bit hash (20 bytes).
  static constexpr size_t host_id_size = 20;

  /// The size of a `node_id` in serialized form.
  static constexpr size_t serialized_size = host_id_size + sizeof(uint32_t);

  /// Represents a 160 bit hash.
  using host_id_type = std::array<uint8_t, host_id_size>;

  /// Creates a node ID from `process_id` and `hash`.
  /// @param procid System-wide unique process identifier.
  /// @param hash Unique node id as hexadecimal string representation.
  node_id(uint32_t procid, const std::string& hash);

  /// Creates a node ID from `process_id` and `hash`.
  /// @param procid System-wide unique process identifier.
  /// @param hid Unique node id.
  node_id(uint32_t procid, const host_id_type& hid);

  /// Identifies the running process.
  /// @returns A system-wide unique process identifier.
  uint32_t process_id() const;

  /// Identifies the host system.
  /// @returns A hash build from the MAC address of the first network device
  ///      and the UUID of the root partition (mounted in "/" or "C:").
  const host_id_type& host_id() const;

  /// Queries whether this node is not default-constructed.
  explicit operator bool() const;

  void swap(node_id&);

  /// @cond PRIVATE

  // A reference counted container for host ID and process ID.
  class data : public ref_counted {
  public:
    static intrusive_ptr<data> create_singleton();

    int compare(const node_id& other) const;

    ~data() override;

    data();

    data(uint32_t procid, host_id_type hid);

    data(uint32_t procid, const std::string& hash);

    data(const data&) = default;

    data& operator=(const data&) = default;

    bool valid() const;

    uint32_t pid_;

    host_id_type host_;
  };

  // "inherited" from comparable<node_id>
  int compare(const node_id& other) const;

  // "inherited" from comparable<node_id, invalid_node_id_t>
  int compare(const none_t&) const;

  explicit node_id(intrusive_ptr<data> dataptr);

  template <class Inspector>
  friend detail::enable_if_t<Inspector::reads_state,
                             typename Inspector::result_type>
  inspect(Inspector& f, node_id& x) {
    data tmp;
    data* ptr = x ? x.data_.get() : &tmp;
    return f(meta::type_name("node_id"), ptr->pid_,
             meta::hex_formatted(), ptr->host_);
  }

  template <class Inspector>
  friend detail::enable_if_t<Inspector::writes_state,
                             typename Inspector::result_type>
  inspect(Inspector& f, node_id& x) {
    data tmp;
    // write changes to tmp back to x at scope exit
    auto sg = detail::make_scope_guard([&] {
      if (!tmp.valid())
        x.data_.reset();
      else if (!x || !x.data_->unique())
        x.data_ = make_counted<data>(tmp);
      else
        *x.data_ = tmp;
    });
    return f(meta::type_name("node_id"), tmp.pid_,
             meta::hex_formatted(), tmp.host_);
  }

  /// @endcond

private:
  intrusive_ptr<data> data_;
};

/// @relates node_id
inline bool operator==(const node_id& x, none_t) {
  return !x;
}

/// @relates node_id
inline bool operator==(none_t, const node_id& x) {
  return !x;
}

/// @relates node_id
inline bool operator!=(const node_id& x, none_t) {
  return static_cast<bool>(x);
}

/// @relates node_id
inline bool operator!=(none_t, const node_id& x) {
  return static_cast<bool>(x);
}

inline bool operator==(const node_id& lhs, const node_id& rhs) {
  return lhs.compare(rhs) == 0;
}

inline bool operator!=(const node_id& lhs, const node_id& rhs) {
  return !(lhs == rhs);
}

inline bool operator<(const node_id& lhs, const node_id& rhs) {
  return lhs.compare(rhs) < 0;
}

/// Converts `x` into a human-readable string representation.
/// @relates node_id
std::string to_string(const node_id& x);

/// Appends `y` in human-readable string representation to `x`.
/// @relates node_id
void append_to_string(std::string& x, const node_id& y);

} // namespace caf

namespace std{

template<>
struct hash<caf::node_id> {
  size_t operator()(const caf::node_id& nid) const {
    if (nid == caf::none)
      return 0;
    // xor the first few bytes from the node ID and the process ID
    auto x = static_cast<size_t>(nid.process_id());
    auto y = *(reinterpret_cast<const size_t*>(&nid.host_id()));
    return x ^ y;
  }
};

} // namespace std

#endif // CAF_NODE_ID_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_REF_COUNTED_HPP
#define CAF_REF_COUNTED_HPP

#include <atomic>
#include <cstddef>

#include "caf/memory_managed.hpp"

namespace caf {

/// Base class for reference counted objects with an atomic reference count.
/// Serves the requirements of {@link intrusive_ptr}.
/// @note *All* instances of `ref_counted` start with a reference count of 1.
/// @relates intrusive_ptr
class ref_counted : public memory_managed {
public:
  ~ref_counted() override;

  ref_counted();
  ref_counted(const ref_counted&);
  ref_counted& operator=(const ref_counted&);

  /// Increases reference count by one.
  inline void ref() noexcept {
    rc_.fetch_add(1, std::memory_order_relaxed);
  }

  /// Decreases reference count by one and calls `request_deletion`
  /// when it drops to zero.
  void deref() noexcept;

  /// Queries whether there is exactly one reference.
  inline bool unique() const noexcept {
    return rc_ == 1;
  }

  inline size_t get_reference_count() const noexcept {
    return rc_;
  }

protected:
  std::atomic<size_t> rc_;
};

/// @relates ref_counted
inline void intrusive_ptr_add_ref(ref_counted* p) {
  p->ref();
}

/// @relates ref_counted
inline void intrusive_ptr_release(ref_counted* p) {
  p->deref();
}

} // namespace caf

#endif // CAF_REF_COUNTED_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_EVENT_BASED_ACTOR_HPP
#define CAF_EVENT_BASED_ACTOR_HPP

#include <type_traits>

#include "caf/fwd.hpp"
#include "caf/extend.hpp"
#include "caf/local_actor.hpp"
#include "caf/actor_marker.hpp"
#include "caf/response_handle.hpp"
#include "caf/scheduled_actor.hpp"

#include "caf/mixin/sender.hpp"
#include "caf/mixin/requester.hpp"
#include "caf/mixin/subscriber.hpp"
#include "caf/mixin/behavior_changer.hpp"

#include "caf/logger.hpp"

namespace caf {

template <>
class behavior_type_of<event_based_actor> {
public:
  using type = behavior;
};

/// A cooperatively scheduled, event-based actor implementation. This is the
/// recommended base class for user-defined actors.
/// @extends local_actor
class event_based_actor : public extend<scheduled_actor,
                                        event_based_actor>::
                                 with<mixin::sender,
                                      mixin::requester,
                                      mixin::subscriber,
                                      mixin::behavior_changer>,
                          public dynamically_typed_actor_base {
public:
  // -- member types -----------------------------------------------------------

  /// Required by `spawn` for type deduction.
  using signatures = none_t;

  /// Required by `spawn` for type deduction.
  using behavior_type = behavior;

  // -- constructors, destructors ----------------------------------------------

  explicit event_based_actor(actor_config& cfg);

  ~event_based_actor() override;

  // -- overridden functions of local_actor ------------------------------------

  void initialize() override;

protected:
  // -- behavior management ----------------------------------------------------

  /// Returns the initial actor behavior.
  virtual behavior make_behavior();
};

} // namespace caf

#endif // CAF_EVENT_BASED_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_DEEP_TO_STRING_HPP
#define CAF_DETAIL_DEEP_TO_STRING_HPP

#include <array>
#include <tuple>
#include <string>
#include <utility>
#include <functional>
#include <type_traits>

#include "caf/atom.hpp"
#include "caf/detail/apply_args.hpp"
#include "caf/detail/type_traits.hpp"
#include "caf/detail/stringification_inspector.hpp"

namespace caf {

class deep_to_string_t {
public:
  constexpr deep_to_string_t() {
    // nop
  }

  template <class... Ts>
  std::string operator()(Ts&&... xs) const {
    std::string result;
    detail::stringification_inspector f{result};
    f(std::forward<Ts>(xs)...);
    return result;
  }
};

/// Unrolls collections such as vectors/maps, decomposes
/// tuples/pairs/arrays, auto-escapes strings and calls
/// `to_string` for user-defined types via argument-dependent
/// loopkup (ADL). Any user-defined type that does not
/// provide a `to_string` is mapped to `<unprintable>`.
constexpr deep_to_string_t deep_to_string = deep_to_string_t{};

/// Convenience function for `deep_to_string(std::forward_as_tuple(xs...))`.
template <class... Ts>
std::string deep_to_string_as_tuple(Ts&&... xs) {
  return deep_to_string(std::forward_as_tuple(std::forward<Ts>(xs)...));
}

} // namespace caf

#endif // CAF_DETAIL_DEEP_TO_STRING_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MESSAGE_HANDLER_HPP
#define CAF_MESSAGE_HANDLER_HPP

#include <list>
#include <vector>
#include <memory>
#include <utility>
#include <type_traits>

#include "caf/fwd.hpp"
#include "caf/none.hpp"
#include "caf/intrusive_ptr.hpp"

#include "caf/message.hpp"
#include "caf/duration.hpp"
#include "caf/behavior.hpp"
#include "caf/ref_counted.hpp"
#include "caf/may_have_timeout.hpp"
#include "caf/timeout_definition.hpp"

#include "caf/detail/behavior_impl.hpp"

namespace caf {

/// A partial function implementation used to process a `message`.
class message_handler {
public:
  friend class behavior;

  message_handler() = default;
  message_handler(message_handler&&) = default;
  message_handler(const message_handler&) = default;
  message_handler& operator=(message_handler&&) = default;
  message_handler& operator=(const message_handler&) = default;

  /// A pointer to the underlying implementation.
  using impl_ptr = intrusive_ptr<detail::behavior_impl>;

  /// Returns a pointer to the implementation.
  inline const impl_ptr& as_behavior_impl() const {
    return impl_;
  }

  /// Creates a message handler from @p ptr.
  message_handler(impl_ptr ptr);

  /// Checks whether the message handler is not empty.
  inline operator bool() const {
    return static_cast<bool>(impl_);
  }

  /// Create a message handler a list of match expressions,
  /// functors, or other message handlers.
  template <class T, class... Ts>
  message_handler(const T& v, Ts&&... xs) {
    assign(v, std::forward<Ts>(xs)...);
  }

  /// Assigns new message handlers.
  template <class... Ts>
  void assign(Ts... xs) {
    static_assert(sizeof...(Ts) > 0, "assign without arguments called");
    static_assert(!detail::disjunction<may_have_timeout<
                      typename std::decay<Ts>::type>::value...
                    >::value, "Timeouts are only allowed in behaviors");
    impl_ = detail::make_behavior(xs...);
  }

  /// Equal to `*this = other`.
  void assign(message_handler what);

  /// Runs this handler and returns its (optional) result.
  inline optional<message> operator()(message& arg) {
    return (impl_) ? impl_->invoke(arg) : none;
  }

  /// Runs this handler and returns its (optional) result.
  inline optional<message> operator()(type_erased_tuple& xs) {
    return impl_ ? impl_->invoke(xs) : none;
  }

  /// Runs this handler with callback.
  inline match_case::result operator()(detail::invoke_result_visitor& f,
                                       type_erased_tuple& xs) {
    return impl_ ? impl_->invoke(f, xs) : match_case::no_match;
  }

  /// Runs this handler with callback.
  inline match_case::result operator()(detail::invoke_result_visitor& f,
                                       message& xs) {
    return impl_ ? impl_->invoke(f, xs) : match_case::no_match;
  }

  /// Returns a new handler that concatenates this handler
  /// with a new handler from `xs...`.
  template <class... Ts>
  typename std::conditional<
    detail::disjunction<may_have_timeout<
      typename std::decay<Ts>::type>::value...
    >::value,
    behavior,
    message_handler
  >::type
  or_else(Ts&&... xs) const {
    // using a behavior is safe here, because we "cast"
    // it back to a message_handler when appropriate
    behavior tmp{std::forward<Ts>(xs)...};
    if (!tmp) {
      return *this;
    }
    if (impl_)
      return impl_->or_else(tmp.as_behavior_impl());
    return tmp.as_behavior_impl();
  }

  /// @cond PRIVATE

  inline message_handler& unbox() {
    return *this;
  }

  /// @endcond

private:
  impl_ptr impl_;
};

} // namespace caf

#endif // CAF_MESSAGE_HANDLER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_SERIALIZER_HPP
#define CAF_SERIALIZER_HPP

#include <string>
#include <cstddef> // size_t
#include <type_traits>

#include "caf/config.hpp"

#ifndef CAF_NO_EXCEPTIONS
#include <exception>
#endif // CAF_NO_EXCEPTIONS

#include "caf/fwd.hpp"
#include "caf/data_processor.hpp"

namespace caf {

/// @ingroup TypeSystem
/// Technology-independent serialization interface.
class serializer : public data_processor<serializer> {
public:
  using super = data_processor<serializer>;

  static constexpr bool reads_state = true;
  static constexpr bool writes_state = false;

  // Boost Serialization compatibility
  using is_saving = std::true_type;
  using is_loading = std::false_type;

  explicit serializer(actor_system& sys);

  explicit serializer(execution_unit* ctx = nullptr);

  ~serializer() override;
};

#ifndef CAF_NO_EXCEPTIONS

template <class T>
typename std::enable_if<
  std::is_same<
    error,
    decltype(std::declval<serializer&>().apply(std::declval<T&>()))
  >::value
>::type
operator&(serializer& sink, const T& x) {
  // implementations are required to never modify `x` while saving
  auto e = sink.apply(const_cast<T&>(x));
  if (e)
    CAF_RAISE_ERROR(to_string(e));
}

template <class T>
typename std::enable_if<
  std::is_same<
    error,
    decltype(std::declval<serializer&>().apply(std::declval<T&>()))
  >::value,
  serializer&
>::type
operator<<(serializer& sink, const T& x) {
  sink & x;
  return sink;
}

#endif // CAF_NO_EXCEPTIONS

} // namespace caf

#endif // CAF_SERIALIZER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_COMPOSABLE_STATE_BASED_ACTOR_HPP
#define CAF_COMPOSABLE_STATE_BASED_ACTOR_HPP

#include "caf/stateful_actor.hpp"
#include "caf/message_handler.hpp"

namespace caf {

/// Implementation class for spawning composable states directly as actors.
template <class State, class Base = typename State::actor_base>
class composable_behavior_based_actor : public stateful_actor<State, Base> {
 public:
  static_assert(!std::is_abstract<State>::value,
                "State is abstract, please make sure to override all "
                "virtual operator() member functions");

  using super = stateful_actor<State, Base>;

  composable_behavior_based_actor(actor_config& cfg) : super(cfg) {
    // nop
  }

  using behavior_type = typename State::behavior_type;

  behavior_type make_behavior() override {
    this->state.init_selfptr(this);
    message_handler tmp;
    this->state.init_behavior(tmp);
    return behavior_type{typename behavior_type::unsafe_init{}, std::move(tmp)};
  }
};

} // namespace caf

#endif // CAF_COMPOSABLE_STATE_BASED_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_INVALID_STREAM_SCATTERER_HPP
#define CAF_INVALID_STREAM_SCATTERER_HPP

#include "caf/stream_scatterer.hpp"

namespace caf {

/// Type-erased policy for dispatching data to sinks.
class invalid_stream_scatterer : public stream_scatterer {
public:
  invalid_stream_scatterer() = default;

  ~invalid_stream_scatterer() override;

  path_ptr add_path(const stream_id& sid, strong_actor_ptr origin,
                    strong_actor_ptr sink_ptr,
                    mailbox_element::forwarding_stack stages,
                    message_id handshake_mid, message handshake_data,
                    stream_priority prio, bool redeployable) override;

  path_ptr confirm_path(const stream_id& sid, const actor_addr& from,
                        strong_actor_ptr to, long initial_demand,
                        bool redeployable) override;

  bool remove_path(const stream_id& sid, const actor_addr& x,
                           error reason, bool silent) override;

  void close() override;

  void abort(error reason) override;

  long num_paths() const override;

  bool closed() const override;

  bool continuous() const override;

  void continuous(bool value) override;

  path_type* path_at(size_t index) override;

  void emit_batches() override;

  path_type* find(const stream_id& sid, const actor_addr& x) override;

  long credit() const override;

  long buffered() const override;

  long min_batch_size() const override;

  long max_batch_size() const override;

  long min_buffer_size() const override;

  duration max_batch_delay() const override;

  void min_batch_size(long x) override;

  void max_batch_size(long x) override;

  void min_buffer_size(long x) override;

  void max_batch_delay(duration x) override;
};

} // namespace caf

#endif // CAF_INVALID_STREAM_SCATTERER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_SINK_TRAIT_HPP
#define CAF_STREAM_SINK_TRAIT_HPP

#include "caf/message.hpp"
#include "caf/make_message.hpp"

#include "caf/detail/type_traits.hpp"

namespace caf {

template <class Fun, class Fin>
struct stream_sink_trait;

template <class State, class In, class Out>
struct stream_sink_trait<void (State&, In), Out (State&)> {
  using state = State;
  using input = In;
  using output = Out;
  template <class F>
  static message make_result(state& st, F f) {
    return make_message(f(st));
  }
};

template <class State, class In>
struct stream_sink_trait<void (State&, In), void (State&)> {
  using state = State;
  using input = In;
  using output = void;
  template <class F>
  static message make_result(state& st, F& f) {
    f(st);
    return make_message();
  }
};

template <class Fun, class Fin>
using stream_sink_trait_t =
  stream_sink_trait<typename detail::get_callable_trait<Fun>::fun_sig,
                    typename detail::get_callable_trait<Fin>::fun_sig>;

} // namespace caf

#endif // CAF_STREAM_SINK_TRAIT_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_SOURCE_IMPL_HPP
#define CAF_STREAM_SOURCE_IMPL_HPP

#include "caf/logger.hpp"
#include "caf/downstream.hpp"
#include "caf/outbound_path.hpp"
#include "caf/stream_manager.hpp"
#include "caf/stream_source_trait.hpp"
#include "caf/invalid_stream_gatherer.hpp"

namespace caf {

template <class Fun, class Predicate, class DownstreamPolicy>
class stream_source_impl : public stream_manager {
public:
  using trait = stream_source_trait_t<Fun>;

  using state_type = typename trait::state;

  using output_type = typename trait::output;

  stream_source_impl(local_actor* self, Fun fun, Predicate pred)
      : fun_(std::move(fun)),
        pred_(std::move(pred)),
        out_(self) {
    // nop
  }

  bool done() const override {
    return at_end() && out_.paths_clean();
  }

  invalid_stream_gatherer& in() override {
    return in_;
  }

  DownstreamPolicy& out() override {
    return out_;
  }

  bool generate_messages() override {
    // produce new elements
    auto capacity = out_.credit() - out_.buffered();
    if (capacity <= 0)
      return false;
    downstream<typename DownstreamPolicy::value_type> ds{out_.buf()};
    fun_(state_, ds, static_cast<size_t>(capacity));
    return true;
  }

  state_type& state() {
    return state_;
  }

protected:
  bool at_end() const {
    return pred_(state_);
  }

  void downstream_demand(outbound_path* path, long) override {
    CAF_LOG_TRACE(CAF_ARG(path));
    if (!at_end()) {
      generate_messages();
      push();
    } else if (out_.buffered() > 0) {
      push();
    } else {
      auto sid = path->sid;
      auto hdl = path->hdl;
      out().remove_path(sid, hdl, none, false);
    }
  }

private:
  state_type state_;
  Fun fun_;
  Predicate pred_;
  DownstreamPolicy out_;
  invalid_stream_gatherer in_;
};

} // namespace caf

#endif // CAF_STREAM_SOURCE_IMPL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_SCOPED_ACTOR_HPP
#define CAF_SCOPED_ACTOR_HPP

#include "caf/none.hpp"
#include "caf/actor_cast.hpp"
#include "caf/actor_system.hpp"
#include "caf/actor_storage.hpp"
#include "caf/intrusive_ptr.hpp"
#include "caf/blocking_actor.hpp"
#include "caf/scoped_execution_unit.hpp"

namespace caf {

/// A scoped handle to a blocking actor.
class scoped_actor {
public:
  // allow conversion via actor_cast
  template <class, class, int>
  friend class actor_cast_access;

  using signatures = none_t;

  // tell actor_cast which semantic this type uses
  static constexpr bool has_weak_ptr_semantics = false;

  scoped_actor(actor_system& sys, bool hide = false);

  scoped_actor(const scoped_actor&) = delete;
  scoped_actor& operator=(const scoped_actor&) = delete;

  scoped_actor(scoped_actor&&) = delete;
  scoped_actor& operator=(scoped_actor&&) = delete;

  ~scoped_actor();

  inline explicit operator bool() const {
    return static_cast<bool>(self_);
  }

  inline actor_system& home_system() const {
    return *self_->home_system;
  }

  inline blocking_actor* operator->() const {
    return ptr();
  }

  inline blocking_actor& operator*() const {
    return *ptr();
  }

  inline actor_addr address() const {
    return ptr()->address();
  }

  blocking_actor* ptr() const;

private:

  inline actor_control_block* get() const {
    return self_.get();
  }

  actor_id prev_; // used for logging/debugging purposes only
  scoped_execution_unit context_;
  strong_actor_ptr self_;
};

std::string to_string(const scoped_actor& x);

} // namespace caf

#endif // CAF_SCOPED_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_STAGE_IMPL_HPP
#define CAF_STREAM_STAGE_IMPL_HPP

#include "caf/sec.hpp"
#include "caf/logger.hpp"
#include "caf/downstream.hpp"
#include "caf/outbound_path.hpp"
#include "caf/stream_manager.hpp"
#include "caf/stream_stage_trait.hpp"

namespace caf {

template <class Fun, class Cleanup,
          class UpstreamPolicy, class DownstreamPolicy>
class stream_stage_impl : public stream_manager {
public:
  using trait = stream_stage_trait_t<Fun>;

  using state_type = typename trait::state;

  using input_type = typename trait::input;

  using output_type = typename trait::output;

  stream_stage_impl(local_actor* self, const stream_id&,
                    Fun fun, Cleanup cleanup)
      : fun_(std::move(fun)),
        cleanup_(std::move(cleanup)),
        in_(self),
        out_(self) {
    // nop
  }

  state_type& state() {
    return state_;
  }

  UpstreamPolicy& in() override {
    return in_;
  }

  DownstreamPolicy& out() override {
    return out_;
  }

  bool done() const override {
    return in_.closed() && out_.closed();
  }

protected:
  void input_closed(error reason) override {
    if (reason == none) {
      if (out_.buffered() == 0)
        out_.close();
    } else {
      out_.abort(std::move(reason));
    }
  }

  error process_batch(message& msg) override {
    CAF_LOG_TRACE(CAF_ARG(msg));
    using vec_type = std::vector<output_type>;
    if (msg.match_elements<vec_type>()) {
      auto& xs = msg.get_as<vec_type>(0);
      downstream<typename DownstreamPolicy::value_type> ds{out_.buf()};
      for (auto& x : xs)
        fun_(state_, ds, x);
      return none;
    }
    CAF_LOG_ERROR("received unexpected batch type");
    return sec::unexpected_message;
  }

  message make_output_token(const stream_id& x) const override {
    return make_message(stream<output_type>{x});
  }

  void downstream_demand(outbound_path* path, long) override {
    CAF_LOG_TRACE(CAF_ARG(path));
    auto hdl = path->hdl;
    if(out_.buffered() > 0)
      push();
    else if (in_.closed()) {
      // don't pass path->hdl: path can become invalid
      auto sid = path->sid;
      out_.remove_path(sid, hdl, none, false);
    }
    auto current_size = out_.buffered();
    auto desired_size = out_.credit();
    if (current_size < desired_size)
      in_.assign_credit(desired_size - current_size);
  }

private:
  state_type state_;
  Fun fun_;
  Cleanup cleanup_;
  UpstreamPolicy in_;
  DownstreamPolicy out_;
};

} // namespace caf

#endif // CAF_STREAM_STAGE_IMPL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_BEHAVIOR_POLICY_HPP
#define CAF_BEHAVIOR_POLICY_HPP

namespace caf {

struct keep_behavior_t {
  constexpr keep_behavior_t() {
    // nop
  }
};

/// Policy tag that causes {@link event_based_actor::become} to
/// keep the current behavior available.
/// @relates local_actor
constexpr keep_behavior_t keep_behavior = keep_behavior_t{};

} // namespace caf

#endif // CAF_BEHAVIOR_POLICY_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_CATCH_ALL_HPP
#define CAF_CATCH_ALL_HPP

#include <functional>
#include <type_traits>

#include "caf/result.hpp"
#include "caf/message.hpp"
#include "caf/message_view.hpp"

namespace caf {

template <class F>
struct catch_all {
  using fun_type = std::function<result<message> (message_view&)>;

  F handler;

  catch_all(catch_all&& x) : handler(std::move(x.handler)) {
    // nop
  }

  template <class T>
  catch_all(T&& x) : handler(std::forward<T>(x)) {
    // nop
  }

  static_assert(std::is_convertible<F, fun_type>::value,
                "catch-all handler must have signature "
                "result<message> (message_view&)");

  fun_type lift() const {
    return handler;
  }
};

template <class T>
struct is_catch_all : std::false_type {};

template <class T>
struct is_catch_all<catch_all<T>> : std::true_type {};

} // namespace caf

#endif // CAF_CATCH_ALL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MAKE_ACTOR_HPP
#define CAF_MAKE_ACTOR_HPP

#include <type_traits>

#include "caf/fwd.hpp"
#include "caf/logger.hpp"
#include "caf/ref_counted.hpp"
#include "caf/infer_handle.hpp"
#include "caf/intrusive_ptr.hpp"
#include "caf/actor_storage.hpp"
#include "caf/actor_control_block.hpp"

namespace caf {

template <class T, class R = infer_handle_from_class_t<T>, class... Ts>
R make_actor(actor_id aid, node_id nid, actor_system* sys, Ts&&... xs) {
#if defined(CAF_LOG_LEVEL) && CAF_LOG_LEVEL >= CAF_LOG_LEVEL_DEBUG
  actor_storage<T>* ptr = nullptr;
  if (logger::current_logger()->accepts(CAF_LOG_LEVEL_DEBUG,
                                        CAF_LOG_FLOW_COMPONENT)) {
    std::string args;
    args = deep_to_string(std::forward_as_tuple(xs...));
    ptr = new actor_storage<T>(aid, std::move(nid), sys,
                               std::forward<Ts>(xs)...);
    CAF_LOG_SPAWN_EVENT(ptr->data, args);
  } else {
    ptr = new actor_storage<T>(aid, std::move(nid), sys,
                               std::forward<Ts>(xs)...);
  }
#else
  auto ptr = new actor_storage<T>(aid, std::move(nid), sys,
                                  std::forward<Ts>(xs)...);
#endif
  return {&(ptr->ctrl), false};
}

} // namespace caf

#endif // CAF_MAKE_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OTHERS_HPP
#define CAF_OTHERS_HPP

#include <functional>
#include <type_traits>

#include "caf/catch_all.hpp"

namespace caf {

struct others_t {
  constexpr others_t() {
    // nop
  }

  template <class F>
  catch_all<F> operator>>(F fun) const {
    return {fun};
  }
};

constexpr others_t others = others_t{};

} // namespace caf

#endif // CAF_OTHERS_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_FUNCTION_VIEW_HPP
#define CAF_FUNCTION_VIEW_HPP

#include <new>
#include <functional>
#include <utility>

#include "caf/expected.hpp"
#include "caf/typed_actor.hpp"
#include "caf/scoped_actor.hpp"
#include "caf/response_type.hpp"

namespace caf {

template <class T>
class function_view_storage {
public:
  using type = function_view_storage;

  function_view_storage(T& storage) : storage_(&storage) {
    // nop
  }

  void operator()(T& x) {
    *storage_ = std::move(x);
  }

private:
  T* storage_;
};

template <class... Ts>
class function_view_storage<std::tuple<Ts...>> {
public:
  using type = function_view_storage;

  function_view_storage(std::tuple<Ts...>& storage) : storage_(&storage) {
    // nop
  }

  void operator()(Ts&... xs) {
    *storage_ = std::forward_as_tuple(std::move(xs)...);
  }

private:
  std::tuple<Ts...>* storage_;
};

template <>
class function_view_storage<unit_t> {
public:
  using type = function_view_storage;

  function_view_storage(unit_t&) {
    // nop
  }

  void operator()() {
    // nop
  }
};

struct function_view_storage_catch_all {
  message* storage_;

  function_view_storage_catch_all(message& ptr) : storage_(&ptr) {
    // nop
  }

  result<message> operator()(message_view& xs) {
    *storage_ = xs.move_content_to_message();
    return message{};
  }
};

template <>
class function_view_storage<message> {
public:
  using type = catch_all<function_view_storage_catch_all>;
};

template <class T>
struct function_view_flattened_result {
  using type = T;
};

template <class T>
struct function_view_flattened_result<std::tuple<T>> {
  using type = T;
};

template <>
struct function_view_flattened_result<std::tuple<void>> {
  using type = unit_t;
};

template <class T>
using function_view_flattened_result_t =
  typename function_view_flattened_result<T>::type;

template <class T>
struct function_view_result {
  T value;
};

template <class... Ts>
struct function_view_result<typed_actor<Ts...>> {
  typed_actor<Ts...> value{unsafe_actor_handle_init};
};

/// A function view for an actor hides any messaging from the caller.
/// Internally, a function view uses a `scoped_actor` and uses
/// blocking send and receive operations.
/// @experimental
template <class Actor>
class function_view {
public:
  using type = Actor;

  function_view(duration rel_timeout = infinite) : timeout(rel_timeout) {
    // nop
  }

  function_view(type  impl, duration rel_timeout = infinite)
      : timeout(rel_timeout),
        impl_(std::move(impl)) {
    new_self(impl_);
  }

  ~function_view() {
    if (impl_)
      self_.~scoped_actor();
  }

  function_view(function_view&& x)
      : timeout(x.timeout),
        impl_(std::move(x.impl_)) {
    if (impl_) {
      new (&self_) scoped_actor(impl_.home_system()); //(std::move(x.self_));
      x.self_.~scoped_actor();
    }
  }

  function_view& operator=(function_view&& x) {
    timeout = x.timeout;
    assign(x.impl_);
    x.reset();
    return *this;
  }

  /// Sends a request message to the assigned actor and returns the result.
  template <class... Ts,
            class R =
              function_view_flattened_result_t<
                typename response_type<
                  typename type::signatures,
                  detail::implicit_conversions_t<
                    typename std::decay<Ts>::type
                  >...
                >::tuple_type>>
  expected<R> operator()(Ts&&... xs) {
    if (!impl_)
      return sec::bad_function_call;
    error err;
    function_view_result<R> result;
    self_->request(impl_, timeout, std::forward<Ts>(xs)...).receive(
      [&](error& x) {
        err = std::move(x);
      },
      typename function_view_storage<R>::type{result.value}
    );
    if (err)
      return err;
    return flatten(result.value);
  }

  void assign(type x) {
    if (!impl_ && x)
      new_self(x);
    if (impl_ && !x)
      self_.~scoped_actor();
    impl_.swap(x);
  }

  void reset() {
    self_.~scoped_actor();
    impl_ = type();
  }

  /// Checks whether this function view has an actor assigned to it.
  explicit operator bool() const {
    return static_cast<bool>(impl_);
  }

  /// Returns the associated actor handle.
  type handle() const {
    return impl_;
  }

  duration timeout;

private:
  template <class T>
  T&& flatten(T& x) {
    return std::move(x);
  }

  template <class T>
  T&& flatten(std::tuple<T>& x) {
    return std::move(get<0>(x));
  }

  void new_self(const Actor& x) {
    if (x)
      new (&self_) scoped_actor(x->home_system());
  }

  union { scoped_actor self_; };
  type impl_;
};

/// @relates function_view
template <class T>
bool operator==(const function_view<T>& x, std::nullptr_t) {
  return !x;
}

/// @relates function_view
template <class T>
bool operator==(std::nullptr_t x, const function_view<T>& y) {
  return y == x;
}

/// @relates function_view
template <class T>
bool operator!=(const function_view<T>& x, std::nullptr_t y) {
  return !(x == y);
}

/// @relates function_view
template <class T>
bool operator!=(std::nullptr_t x, const function_view<T>& y) {
  return !(y == x);
}

/// Creates a new function view for `x`.
/// @relates function_view
/// @experimental
template <class T>
function_view<T> make_function_view(const T& x, duration t = infinite) {
  return {x, t};
}

} // namespace caf

#endif // CAF_FUNCTION_VIEW_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_RESPONSE_TYPE_HPP
#define CAF_RESPONSE_TYPE_HPP

#include <tuple>

#include "caf/fwd.hpp"
#include "caf/replies_to.hpp"

#include "caf/detail/type_list.hpp"

namespace caf {

/// Defines:
/// - `valid` if typedefs are set, can be used to check if actors accept input
/// - `type` list of output types or `message` for dynamically typed actors
/// - `delegated_type` type above wrapped in a `delegated`
/// - `tuple_type` output types wrapped in a `std::tuple` or `message`
template <class Ts, class... Xs>
struct response_type;

// short-circuit for dynamically typed messaging
template <class... Xs>
struct response_type<none_t, Xs...> {
  static constexpr bool valid = true;
  using type = message;
  using delegated_type = delegated<message>;
  using tuple_type = message;
};

// end of recursion (suppress type definitions for enabling SFINAE)
template <class... Xs>
struct response_type<detail::type_list<>, Xs...> {
  static constexpr bool valid = false;
};

// case #1: no match
template <class In, class Out, class... Ts, class... Xs>
struct response_type<detail::type_list<typed_mpi<In, Out>, Ts...>, Xs...>
    : response_type<detail::type_list<Ts...>, Xs...> {};

// case #2: match
template <class... Out, class... Ts, class... Xs>
struct response_type<detail::type_list<typed_mpi<detail::type_list<Xs...>,
                                                 output_tuple<Out...>>,
                                       Ts...>,
                     Xs...> {
  static constexpr bool valid = true;
  using type = detail::type_list<Out...>;
  using tuple_type = std::tuple<Out...>;
  using delegated_type = delegated<Out...>;
};

/// Computes the response message for input `Xs...` from the list
/// of message passing interfaces `Ts`.
template <class Ts, class... Xs>
using response_type_t = typename response_type<Ts, Xs...>::type;

/// Unboxes `Xs` and calls `response_type`.
template <class Ts, class Xs>
struct response_type_unbox;

template <class Ts, class... Xs>
struct response_type_unbox<Ts, detail::type_list<Xs...>>
  : response_type<Ts, Xs...> {};

template <class Ts>
struct response_type_unbox<Ts, message> : response_type<Ts, message> {};

/// Computes the response message for input `Xs` from the list
/// of message passing interfaces `Ts`.
template <class Ts, class Xs>
using response_type_unbox_t = typename response_type_unbox<Ts, Xs>::type;

} // namespace caf

#endif // CAF_RESPONSE_TYPE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_PRIORITY_HPP
#define CAF_STREAM_PRIORITY_HPP

#include <string>

namespace caf {

/// Categorizes individual streams.
enum class stream_priority {
  /// Denotes soft-realtime traffic.
  very_high,
  /// Denotes time-sensitive traffic.
  high,
  /// Denotes traffic with moderate timing requirements.
  normal,
  /// Denotes uncritical traffic without timing requirements.
  low,
  /// Denotes best-effort traffic.
  very_low
};

/// Stores the number of `stream_priority` classes.
static constexpr size_t stream_priorities = 5;

/// @relates stream_priority
std::string to_string(stream_priority x);

} // namespace caf

#endif // CAF_STREAM_PRIORITY_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_GROUP_HPP
#define CAF_GROUP_HPP

#include <string>
#include <utility>
#include <functional>

#include "caf/fwd.hpp"
#include "caf/none.hpp"
#include "caf/group_module.hpp"
#include "caf/intrusive_ptr.hpp"
#include "caf/abstract_group.hpp"

#include "caf/detail/comparable.hpp"
#include "caf/detail/type_traits.hpp"

namespace caf {

struct invalid_group_t {
  constexpr invalid_group_t() = default;
};

/// Identifies an invalid {@link group}.
/// @relates group
constexpr invalid_group_t invalid_group = invalid_group_t{};

class group : detail::comparable<group>,
              detail::comparable<group, invalid_group_t> {
public:
  template <class, class, int>
  friend class actor_cast_access;

  using signatures = none_t;

  group() = default;

  group(group&&) = default;

  group(const group&) = default;

  group(const invalid_group_t&);

  group& operator=(group&&) = default;

  group& operator=(const group&) = default;

  group& operator=(const invalid_group_t&);

  group(abstract_group*);

  group(intrusive_ptr<abstract_group> gptr);

  inline explicit operator bool() const noexcept {
    return static_cast<bool>(ptr_);
  }

  inline bool operator!() const noexcept {
    return !ptr_;
  }

  static intptr_t compare(const abstract_group* lhs, const abstract_group* rhs);

  intptr_t compare(const group& other) const noexcept;

  inline intptr_t compare(const invalid_group_t&) const noexcept {
    return ptr_ ? 1 : 0;
  }

  template <class Inspector>
  friend typename Inspector::result_type inspect(Inspector& f, group& x) {
    std::string x_id;
    std::string x_mod;
    auto ptr = x.get();
    if (ptr) {
      x_id = ptr->identifier();
      x_mod = ptr->module().name();
    }
    return f(meta::type_name("group"),
             meta::omittable_if_empty(), x_id,
             meta::omittable_if_empty(), x_mod);
  }

  friend error inspect(serializer&, group&);

  friend error inspect(deserializer&, group&);

  inline abstract_group* get() const noexcept {
    return ptr_.get();
  }

  /// @cond PRIVATE

  template <class... Ts>
  void eq_impl(message_id mid, strong_actor_ptr sender,
               execution_unit* ctx, Ts&&... xs) const {
    CAF_ASSERT(!mid.is_request());
    if (ptr_)
      ptr_->enqueue(std::move(sender), mid,
                    make_message(std::forward<Ts>(xs)...), ctx);
  }

  inline bool subscribe(strong_actor_ptr who) const {
    if (!ptr_)
      return false;
    return ptr_->subscribe(std::move(who));
  }

  inline void unsubscribe(const actor_control_block* who) const {
    if (ptr_)
      ptr_->unsubscribe(who);
  }

  /// CAF's messaging primitives assume a non-null guarantee. A group
  /// object indirects pointer-like access to a group to prevent UB.
  inline const group* operator->() const noexcept {
    return this;
  }

  /// @endcond

private:
  inline abstract_group* release() noexcept {
    return ptr_.release();
  }

  group(abstract_group*, bool);

  abstract_group_ptr ptr_;
};

/// @relates group
std::string to_string(const group& x);

} // namespace caf

namespace std {
template <>
struct hash<caf::group> {
  inline size_t operator()(const caf::group& x) const {
    // groups are singleton objects, the address is thus the best possible hash
    return !x ? 0 : reinterpret_cast<size_t>(x.get());
  }
};
} // namespace std

#endif // CAF_GROUP_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_SYSTEM_MESSAGES_HPP
#define CAF_SYSTEM_MESSAGES_HPP

#include <vector>
#include <cstdint>
#include <type_traits>

#include "caf/fwd.hpp"
#include "caf/group.hpp"
#include "caf/actor_addr.hpp"
#include "caf/deep_to_string.hpp"

#include "caf/meta/type_name.hpp"

#include "caf/detail/tbind.hpp"
#include "caf/detail/type_list.hpp"

namespace caf {

/// Sent to all links when an actor is terminated.
/// @note Actors can override the default handler by calling
///       `self->set_exit_handler(...)`.
struct exit_msg {
  /// The source of this message, i.e., the terminated actor.
  actor_addr source;

  /// The exit reason of the terminated actor.
  error reason;
};

/// @relates exit_msg
template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, exit_msg& x) {
  return f(meta::type_name("exit_msg"), x.source, x.reason);
}

/// Sent to all actors monitoring an actor when it is terminated.
struct down_msg {
  /// The source of this message, i.e., the terminated actor.
  actor_addr source;

  /// The exit reason of the terminated actor.
  error reason;
};

/// @relates down_msg
template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, down_msg& x) {
  return f(meta::type_name("down_msg"), x.source, x.reason);
}

/// Sent to all members of a group when it goes offline.
struct group_down_msg {
  /// The source of this message, i.e., the now unreachable group.
  group source;
};

/// @relates group_down_msg
template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, group_down_msg& x) {
  return f(meta::type_name("group_down_msg"), x.source);
}

/// Signalizes a timeout event.
/// @note This message is handled implicitly by the runtime system.
struct timeout_msg {
  /// Actor-specific timeout ID.
  uint32_t timeout_id;
};

/// @relates timeout_msg
template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, timeout_msg& x) {
  return f(meta::type_name("timeout_msg"), x.timeout_id);
}

} // namespace caf

#endif // CAF_SYSTEM_MESSAGES_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ACTOR_COMPANION_HPP
#define CAF_ACTOR_COMPANION_HPP

#include <memory>
#include <functional>

#include "caf/fwd.hpp"
#include "caf/extend.hpp"
#include "caf/scheduled_actor.hpp"
#include "caf/mailbox_element.hpp"

#include "caf/mixin/sender.hpp"
#include "caf/mixin/subscriber.hpp"
#include "caf/mixin/behavior_changer.hpp"

#include "caf/detail/disposer.hpp"
#include "caf/detail/shared_spinlock.hpp"

namespace caf {

template <>
class behavior_type_of<actor_companion> {
public:
  using type = behavior;
};

/// An co-existing actor forwarding all messages through a user-defined
/// callback to another object, thus serving as gateway to
/// allow any object to interact with other actors.
/// @extends local_actor
class actor_companion : public extend<scheduled_actor, actor_companion>::
                               with<mixin::sender,
                                    mixin::subscriber,
                                    mixin::behavior_changer> {
public:
  // -- member types -----------------------------------------------------------

  /// Required by `spawn` for type deduction.
  using signatures = none_t;

  /// Required by `spawn` for type deduction.
  using behavior_type = behavior;

  /// A shared lockable.
  using lock_type = detail::shared_spinlock;

  /// Delegates incoming messages to user-defined event loop.
  using enqueue_handler = std::function<void (mailbox_element_ptr)>;

  /// Callback for actor termination.
  using on_exit_handler = std::function<void ()>;

  // -- constructors, destructors ----------------------------------------------

  actor_companion(actor_config& cfg);

  ~actor_companion() override;

  // -- overridden functions ---------------------------------------------------

  void enqueue(mailbox_element_ptr ptr, execution_unit* host) override;

  void enqueue(strong_actor_ptr src, message_id mid, message content,
               execution_unit* eu) override;

  void launch(execution_unit* eu, bool lazy, bool hide) override;

  void on_exit() override;

  // -- modifiers --------------------------------------------------------------

  /// Removes the handler for incoming messages and terminates
  /// the companion for exit reason `rsn`.
  void disconnect(exit_reason rsn = exit_reason::normal);

  /// Sets the handler for incoming messages.
  /// @warning `handler` needs to be thread-safe
  void on_enqueue(enqueue_handler handler);

  /// Sets the handler for incoming messages.
  void on_exit(on_exit_handler handler);

private:
  // set by parent to define custom enqueue action
  enqueue_handler on_enqueue_;

  // custom code for on_exit()
  on_exit_handler on_exit_;

  // guards access to handler_
  lock_type lock_;
};

} // namespace caf

#endif // CAF_ACTOR_COMPANION_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_BINARY_SERIALIZER_HPP
#define CAF_BINARY_SERIALIZER_HPP

#include "caf/stream_serializer.hpp"
#include "caf/streambuf.hpp"

namespace caf {

/// A stream serializer that writes into an unbounded contiguous character
/// sequence.
using binary_serializer = stream_serializer<vectorbuf>;

} // namespace caf

#endif // CAF_BINARY_SERIALIZER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MESSAGE_HPP
#define CAF_MESSAGE_HPP

#include <tuple>
#include <sstream>
#include <type_traits>

#include "caf/fwd.hpp"
#include "caf/skip.hpp"
#include "caf/atom.hpp"
#include "caf/none.hpp"
#include "caf/config.hpp"
#include "caf/optional.hpp"
#include "caf/make_counted.hpp"
#include "caf/index_mapping.hpp"

#include "caf/detail/int_list.hpp"
#include "caf/detail/apply_args.hpp"
#include "caf/detail/comparable.hpp"
#include "caf/detail/type_traits.hpp"
#include "caf/detail/message_data.hpp"
#include "caf/detail/implicit_conversions.hpp"

namespace caf {
class message_handler;

/// Describes a fixed-length, copy-on-write, type-erased
/// tuple with elements of any type.
class message {
public:
  // -- nested types -----------------------------------------------------------

  struct cli_arg;

  struct cli_res;

  // -- member types -----------------------------------------------------------

  /// Raw pointer to content.
  using raw_ptr = detail::message_data*;

  /// Copy-on-write pointer to content.
  using data_ptr = detail::message_data::cow_ptr;

  /// Function object for generating CLI argument help text.
  using help_factory = std::function<std::string (const std::vector<cli_arg>&)>;

  // -- constructors, destructors, and assignment operators --------------------

  message() noexcept = default;
  message(none_t) noexcept;
  message(const message&) noexcept = default;
  message& operator=(const message&) noexcept = default;

  message(message&&) noexcept;
  message& operator=(message&&) noexcept;
  explicit message(data_ptr  ptr) noexcept;

  ~message();

  // -- factories --------------------------------------------------------------

  /// Creates a new message by concatenating `xs...`.
  template <class... Ts>
  static message concat(const Ts&... xs) {
    return concat_impl({xs.vals()...});
  }

  /// Creates a new message by copying all elements in a type-erased tuple.
  static message copy(const type_erased_tuple& xs);

  // -- modifiers --------------------------------------------------------------

  /// Concatenates `*this` and `x`.
  message& operator+=(const message& x);

  /// Returns a mutable pointer to the element at position `p`.
  void* get_mutable(size_t p);

  /// Returns the value at position `p` as mutable reference of type `T`.
  template <class T>
  T& get_mutable_as(size_t p) {
    CAF_ASSERT(match_element(p, type_nr<T>::value, &typeid(T)));
    return *reinterpret_cast<T*>(get_mutable(p));
  }

  /// Returns `handler(*this)`.
  optional<message> apply(message_handler handler);

  /// Forces the message to copy its content if there are more than
  /// one references to the content.
  inline void force_unshare() {
    vals_.unshare();
  }

  /// Returns a mutable reference to the content. Callers are responsible
  /// for unsharing content if necessary.
  inline data_ptr& vals() {
    return vals_;
  }

  /// Exchanges content of `this` and `other`.
  void swap(message& other) noexcept;

  /// Assigns new content.
  void reset(raw_ptr new_ptr = nullptr, bool add_ref = true) noexcept;

  // -- observers --------------------------------------------------------------

  /// Creates a new message with all but the first n values.
  message drop(size_t n) const;

  /// Creates a new message with all but the last n values.
  message drop_right(size_t n) const;

  /// Creates a new message of size `n` starting at the element at position `p`.
  message slice(size_t pos, size_t n) const;

  /// Filters this message by applying slices of it to `handler` and  returns
  /// the remaining elements of this operation. Slices are generated in the
  /// sequence `[0, size)`, `[0, size-1)`, `...` , `[1, size-1)`, `...`,
  /// `[size-1, size)`. Whenever a slice matches, it is removed from the message
  /// and the next slice starts at the *same* index on the reduced message.
  ///
  /// For example:
  ///
  /// ~~~
  /// auto msg = make_message(1, 2.f, 3.f, 4);
  /// // extract float and integer pairs
  /// auto msg2 = msg.extract({
  ///   [](float, float) { },
  ///   [](int, int) { }
  /// });
  /// assert(msg2 == make_message(1, 4));
  /// ~~~
  ///
  /// Step-by-step explanation:
  /// - Slice 1: `(1, 2.f, 3.f, 4)`, no match
  /// - Slice 2: `(1, 2.f, 3.f)`, no match
  /// - Slice 3: `(1, 2.f)`, no match
  /// - Slice 4: `(1)`, no match
  /// - Slice 5: `(2.f, 3.f, 4)`, no match
  /// - Slice 6: `(2.f, 3.f)`, *match*; new message is `(1, 4)`
  /// - Slice 7: `(4)`, no match
  ///
  /// Slice 7 is `(4)`, i.e., does not contain the first element, because the
  /// match on slice 6 occurred at index position 1. The function `extract`
  /// iterates a message only once, from left to right.
  message extract(message_handler handler) const;

  /// A simplistic interface for using `extract` to parse command line options.
  /// Usage example:
  ///
  /// ~~~
  /// int main(int argc, char** argv) {
  ///   uint16_t port;
  ///   string host = "localhost";
  ///   auto res = message_builder(argv + 1, argv + argc).extract_opts({
  ///     {"port,p", "set port", port},
  ///     {"host,H", "set host (default: localhost)", host},
  ///     {"verbose,v", "enable verbose mode"}
  ///   });
  ///   if (!res.error.empty()) {
  ///     cerr << res.error << endl;
  ///     return 1;
  ///   }
  ///   if (res.opts.count("help") > 0) {
  ///     // CLI arguments contained "-h", "--help", or "-?" (builtin);
  ///     cout << res.helptext << endl;
  ///     return 0;
  ///   }
  ///   if (!res.remainder.empty()) {
  ///     // ... extract did not consume all CLI arguments ...
  ///   }
  ///   if (res.opts.count("verbose") > 0) {
  ///     // ... enable verbose mode ...
  ///   }
  ///   // ...
  /// }
  /// ~~~
  /// @param xs List of argument descriptors.
  /// @param f Optional factory function to generate help text
  ///          (overrides the default generator).
  /// @param no_help Suppress generation of default-generated help option.
  /// @returns A struct containing remainder
  ///          (i.e. unmatched elements), a set containing the names of all
  ///          used arguments, and the generated help text.
  /// @throws std::invalid_argument if no name or more than one long name is set
  cli_res extract_opts(std::vector<cli_arg> xs,
                       const help_factory& f = nullptr,
                       bool no_help = false) const;

  // -- inline observers -------------------------------------------------------

  /// Returns a const pointer to the element at position `p`.
  inline const void* at(size_t p) const noexcept {
    CAF_ASSERT(vals_);
    return vals_->get(p);
  }

  /// Returns a reference to the content.
  inline const data_ptr& vals() const noexcept {
    return vals_;
  }

  /// Returns a reference to the content.
  inline const data_ptr& cvals() const noexcept {
    return vals_;
  }

  /// Returns a type hint for the pattern matching engine.
  inline uint32_t type_token() const noexcept {
    return vals_ ? vals_->type_token() : 0xFFFFFFFF;
  }

  /// Returns whether there are more than one references to the content.
  inline bool shared() const noexcept {
    return vals_ ? vals_->shared() : false;
  }

  /// Returns the size of this message.
  inline size_t size() const noexcept {
    return vals_ ? vals_->size() : 0;
  }

  /// Creates a new message from the first n values.
  inline message take(size_t n) const {
    return n >= size() ? *this : drop_right(size() - n);
  }

  /// Creates a new message from the last n values.
  inline message take_right(size_t n) const {
    return n >= size() ? *this : drop(size() - n);
  }

  /// Returns true if `size() == 0, otherwise false.
  inline bool empty() const {
    return size() == 0;
  }

  /// Returns the value at position `p` as const reference of type `T`.
  template <class T>
  const T& get_as(size_t p) const {
    CAF_ASSERT(match_element(p, type_nr<T>::value, &typeid(T)));
    return *reinterpret_cast<const T*>(at(p));
  }

  /// Queries whether the element at position `p` is of type `T`.
  template <class T>
  bool match_element(size_t p) const noexcept {
    return vals_ ? vals_->match_element<T>(p) : false;
  }

  /// Queries whether the types of this message are `Ts...`.
  template <class... Ts>
  bool match_elements() const noexcept {
    detail::type_list<Ts...> token;
    return match_elements(token);
  }

  /// Queries the run-time type information for the element at position `pos`.
  inline std::pair<uint16_t, const std::type_info*>
  type(size_t pos) const noexcept {
    CAF_ASSERT(vals_ && vals_->size() > pos);
    return vals_->type(pos);
  }

  /// Checks whether the type of the stored value at position `pos`
  /// matches type number `n` and run-time type information `p`.
  bool match_element(size_t pos, uint16_t n,
                     const std::type_info* p) const noexcept {
    CAF_ASSERT(vals_);
    return vals_->matches(pos, n, p);
  }

  inline bool match_elements(detail::type_list<>) const noexcept {
    return !vals_ || vals_->empty();
  }

  template <class T, class... Ts>
  bool match_elements(detail::type_list<T, Ts...>) const noexcept {
    return vals_ ? vals_->match_elements<T, Ts...>() : false;
  }

  /// @cond PRIVATE

  /// @pre `!empty()`
  type_erased_tuple& content() {
    CAF_ASSERT(vals_);
    return *vals_;
  }

  /// @endcond

private:
  template <size_t P>
  static bool match_elements_impl(std::integral_constant<size_t, P>,
                                  detail::type_list<>) noexcept {
    return true; // end of recursion
  }

  template <size_t P, class T, class... Ts>
  bool match_elements_impl(std::integral_constant<size_t, P>,
                           detail::type_list<T, Ts...>) const noexcept {
    std::integral_constant<size_t, P + 1> next_p;
    detail::type_list<Ts...> next_list;
    return match_element<T>(P) && match_elements_impl(next_p, next_list);
  }

  message extract_impl(size_t start, message_handler handler) const;

  static message concat_impl(std::initializer_list<data_ptr> xs);

  data_ptr vals_;
};

/// @relates message
error inspect(serializer& sink, message& msg);

/// @relates message
error inspect(deserializer& source, message& msg);

/// @relates message
std::string to_string(const message& msg);

/// Stores the name of a command line option ("<long name>[,<short name>]")
/// along with a description and a callback.
struct message::cli_arg {
  /// Returns `true` on a match, `false` otherwise.
  using consumer = std::function<bool (const std::string&)>;

  /// Full name of this CLI argument using format "<long name>[,<short name>]"
  std::string name;

  /// Desciption of this CLI argument for the auto-generated help text.
  std::string text;

  /// Auto-generated helptext for this item.
  std::string helptext;

  /// Evaluates option arguments.
  consumer fun;

  /// Set to true for zero-argument options.
  bool* flag;

  /// Creates a CLI argument without data.
  cli_arg(std::string nstr, std::string tstr);

  /// Creates a CLI flag option. The `flag` is set to `true` if the option
  /// was set, otherwise it is `false`.
  cli_arg(std::string nstr, std::string tstr, bool& arg);

  /// Creates a CLI argument storing its matched argument in `dest`.
  cli_arg(std::string nstr, std::string tstr, atom_value& arg);

  /// Creates a CLI argument storing its matched argument in `dest`.
  cli_arg(std::string nstr, std::string tstr, std::string& arg);

  /// Creates a CLI argument appending matched arguments to `dest`.
  cli_arg(std::string nstr, std::string tstr, std::vector<std::string>& arg);

  /// Creates a CLI argument using the function object `f`.
  cli_arg(std::string nstr, std::string tstr, consumer f);

  /// Creates a CLI argument for converting from strings,
  /// storing its matched argument in `dest`.
  template <class T>
  cli_arg(typename std::enable_if<
            type_nr<T>::value != 0,
            std::string
          >::type nstr,
          std::string tstr, T& arg)
      : name(std::move(nstr)),
        text(std::move(tstr)),
        flag(nullptr) {
    fun = [&arg](const std::string& str) -> bool {
      T x;
      // TODO: using this stream is a workaround for the missing
      //       from_string<T>() interface and has downsides such as
      //       not performing overflow/underflow checks etc.
      std::istringstream iss{str};
      if (iss >> x) {
        arg = x;
        return true;
      }
      return false;
    };
  }

  /// Creates a CLI argument for converting from strings,
  /// appending matched arguments to `dest`.
  template <class T>
  cli_arg(std::string nstr, std::string tstr, std::vector<T>& arg)
      : name(std::move(nstr)),
        text(std::move(tstr)),
        flag(nullptr) {
    fun = [&arg](const std::string& str) -> bool {
      T x;
      std::istringstream iss{ str };
      if (iss >> x) {
        arg.emplace_back(std::move(x));
        return true;
      }
      return false;
    };
  }
};

/// Stores the result of `message::extract_opts`.
struct message::cli_res {
  /// Stores the remaining (unmatched) arguments.
  message remainder;
  /// Stores the names of all active options.
  std::set<std::string> opts;
  /// Stores the automatically generated help text.
  std::string helptext;
  /// Stores errors during option parsing.
  std::string error;
};

/// @relates message
inline message operator+(const message& lhs, const message& rhs) {
  return message::concat(lhs, rhs);
}

} // namespace caf

#endif // CAF_MESSAGE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DECORATOR_SEQUENCER_HPP
#define CAF_DECORATOR_SEQUENCER_HPP

#include "caf/actor_addr.hpp"
#include "caf/mailbox_element.hpp"
#include "caf/monitorable_actor.hpp"

namespace caf {
namespace decorator {

/// An actor decorator implementing "dot operator"-like compositions,
/// i.e., `f.g(x) = f(g(x))`. Composed actors are hidden actors.
/// A composed actor exits when either of its constituent actors exits;
/// Constituent actors have no dependency on the composed actor
/// by default, and exit of a composed actor has no effect on its
/// constituent actors. A composed actor is hosted on the same actor
/// system and node as `g`, the first actor on the forwarding chain.
class sequencer : public monitorable_actor {
public:
  using message_types_set = std::set<std::string>;

  sequencer(strong_actor_ptr f, strong_actor_ptr g,
            message_types_set msg_types);

  // non-system messages are processed and then forwarded;
  // system messages are handled and consumed on the spot;
  // in either case, the processing is done synchronously
  void enqueue(mailbox_element_ptr what, execution_unit* context) override;

  message_types_set message_types() const override;

protected:
  void on_cleanup() override;

private:
  strong_actor_ptr f_;
  strong_actor_ptr g_;
  message_types_set msg_types_;
};

} // namespace decorator
} // namespace caf

#endif // CAF_DECORATOR_SEQUENCER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DECORATOR_SPLITTER_HPP
#define CAF_DECORATOR_SPLITTER_HPP

#include <vector>

#include "caf/actor_addr.hpp"
#include "caf/mailbox_element.hpp"
#include "caf/monitorable_actor.hpp"

namespace caf {
namespace decorator {

/// An actor decorator implementing "dot operator"-like compositions,
/// i.e., `f.g(x) = f(g(x))`. Composed actors are hidden actors.
/// A composed actor exits when either of its constituent actors exits;
/// Constituent actors have no dependency on the composed actor
/// by default, and exit of a composed actor has no effect on its
/// constituent actors. A composed actor is hosted on the same actor
/// system and node as `g`, the first actor on the forwarding chain.
class splitter : public monitorable_actor {
public:
  using message_types_set = std::set<std::string>;

  splitter(std::vector<strong_actor_ptr> workers, message_types_set msg_types);

  // non-system messages are processed and then forwarded;
  // system messages are handled and consumed on the spot;
  // in either case, the processing is done synchronously
  void enqueue(mailbox_element_ptr what, execution_unit* context) override;

  message_types_set message_types() const override;

private:
  const size_t num_workers;
  std::vector<strong_actor_ptr> workers_;
  message_types_set msg_types_;
};

} // namespace decorator
} // namespace caf

#endif // CAF_DECORATOR_SPLITTER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_SERIALIZER_HPP
#define CAF_STREAM_SERIALIZER_HPP

#include <string>
#include <limits>
#include <cstddef>
#include <cstdint>
#include <iomanip>
#include <sstream>
#include <streambuf>
#include <type_traits>

#include "caf/sec.hpp"
#include "caf/streambuf.hpp"
#include "caf/serializer.hpp"

#include "caf/detail/ieee_754.hpp"
#include "caf/detail/network_order.hpp"

namespace caf {

/// Implements the serializer interface with a binary serialization protocol.
template <class Streambuf>
class stream_serializer : public serializer {
  using streambuf_type = typename std::remove_reference<Streambuf>::type;
  using char_type = typename streambuf_type::char_type;
  using streambuf_base = std::basic_streambuf<char_type>;
  static_assert(std::is_base_of<streambuf_base, streambuf_type>::value,
                "Streambuf must inherit from std::streambuf");

public:
  template <class... Ts>
  explicit stream_serializer(actor_system& sys, Ts&&... xs)
    : serializer(sys),
      streambuf_{std::forward<Ts>(xs)...} {
  }

  template <class... Ts>
  explicit stream_serializer(execution_unit* ctx, Ts&&... xs)
    : serializer(ctx),
      streambuf_{std::forward<Ts>(xs)...} {
  }

  template <
    class S,
    class = typename std::enable_if<
      std::is_same<
        typename std::remove_reference<S>::type,
        typename std::remove_reference<Streambuf>::type
      >::value
    >::type
  >
  explicit stream_serializer(S&& sb)
    : serializer(nullptr),
      streambuf_(std::forward<S>(sb)) {
  }

  error begin_object(uint16_t& typenr, std::string& name) override {
    return error::eval([&] { return apply(typenr); },
                       [&] { return typenr == 0 ? apply(name) : error{}; });

  }

  error end_object() override {
    return none;
  }

  error begin_sequence(size_t& list_size) override {
    return varbyte_encode(list_size);
  }

  error end_sequence() override {
    return none;
  }

  error apply_raw(size_t num_bytes, void* data) override {
    auto ssize = static_cast<std::streamsize>(num_bytes);
    auto n = streambuf_.sputn(reinterpret_cast<char_type*>(data), ssize);
    if (n != ssize)
      return sec::end_of_stream;
    return none;
  }

protected:
  // Encode an unsigned integral type as variable-byte sequence.
  template <class T>
  error varbyte_encode(T x) {
    static_assert(std::is_unsigned<T>::value, "T must be an unsigned type");
    // For 64-bit values, the encoded representation cannot get larger than 10
    // bytes. A scratch space of 16 bytes suffices as upper bound.
    uint8_t buf[16];
    auto i = buf;
    while (x > 0x7f) {
      *i++ = (static_cast<uint8_t>(x) & 0x7f) | 0x80;
      x >>= 7;
    }
    *i++ = static_cast<uint8_t>(x) & 0x7f;
    auto res = streambuf_.sputn(reinterpret_cast<char_type*>(buf),
                                static_cast<std::streamsize>(i - buf));
    if (res != (i - buf))
      return sec::end_of_stream;
    return none;
  }

  error apply_builtin(builtin type, void* val) override {
    CAF_ASSERT(val != nullptr);
    switch (type) {
      default: // i8_v or u8_v
        CAF_ASSERT(type == i8_v || type == u8_v);
        return apply_raw(sizeof(uint8_t), val);
      case i16_v:
      case u16_v:
        return apply_int(*reinterpret_cast<uint16_t*>(val));
      case i32_v:
      case u32_v:
        return apply_int(*reinterpret_cast<uint32_t*>(val));
      case i64_v:
      case u64_v:
        return apply_int(*reinterpret_cast<uint64_t*>(val));
      case float_v:
        return apply_int(detail::pack754(*reinterpret_cast<float*>(val)));
      case double_v:
        return apply_int(detail::pack754(*reinterpret_cast<double*>(val)));
      case ldouble_v: {
        // the IEEE-754 conversion does not work for long double
        // => fall back to string serialization (event though it sucks)
        std::ostringstream oss;
        oss << std::setprecision(std::numeric_limits<long double>::digits)
            << *reinterpret_cast<long double*>(val);
        auto tmp = oss.str();
        return apply(tmp);
      }
      case string8_v: {
        auto str = reinterpret_cast<std::string*>(val);
        auto s = str->size();
        auto data = reinterpret_cast<char_type*>(
                      const_cast<std::string::value_type*>(str->data()));
        return error::eval([&] { return begin_sequence(s); },
                           [&] { return apply_raw(str->size(),  data); },
                           [&] { return end_sequence(); });
      }
      case string16_v: {
        auto str = reinterpret_cast<std::u16string*>(val);
        auto s = str->size();
        // the standard does not guarantee that char16_t is exactly 16 bits...
        return error::eval([&] { return begin_sequence(s); },
                           [&] { return consume_range_c<uint16_t>(*str); },
                           [&] { return end_sequence(); });
      }
      case string32_v: {
        auto str = reinterpret_cast<std::u32string*>(val);
        auto s = str->size();
        // the standard does not guarantee that char32_t is exactly 32 bits...
        return error::eval([&] { return begin_sequence(s); },
                           [&] { return consume_range_c<uint32_t>(*str); },
                           [&] { return end_sequence(); });
      }
    }
  }

  template <class T>
  error apply_int(T x) {
    auto y = detail::to_network_order(x);
    return apply_raw(sizeof(T), &y);
  }

private:
  Streambuf streambuf_;
};

} // namespace caf

#endif // CAF_STREAM_SERIALIZER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_BROADCAST_SCATTERER_HPP
#define CAF_BROADCAST_SCATTERER_HPP

#include "caf/buffered_scatterer.hpp"

namespace caf {

template <class T>
class broadcast_scatterer : public buffered_scatterer<T> {
public:
  using super = buffered_scatterer<T>;

  broadcast_scatterer(local_actor* selfptr) : super(selfptr) {
    // nop
  }

  long credit() const override {
    // We receive messages until we have exhausted all downstream credit and
    // have filled our buffer to its minimum size.
    return this->min_credit() + this->min_buffer_size();
  }

  void emit_batches() override {
    CAF_LOG_TRACE("");
    auto chunk = this->get_chunk(this->min_credit());
    auto csize = static_cast<long>(chunk.size());
    CAF_LOG_TRACE(CAF_ARG(chunk));
    if (csize == 0)
      return;
    auto wrapped_chunk = make_message(std::move(chunk));
    for (auto& x : this->paths_) {
      CAF_ASSERT(x->open_credit >= csize);
      x->emit_batch(csize, wrapped_chunk);
    }
  }
};

} // namespace caf

#endif // CAF_BROADCAST_SCATTERER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ACTOR_PROXY_HPP
#define CAF_ACTOR_PROXY_HPP

#include <atomic>
#include <cstdint>

#include "caf/abstract_actor.hpp"
#include "caf/monitorable_actor.hpp"

#include "caf/detail/shared_spinlock.hpp"

namespace caf {

/// Represents an actor running on a remote machine,
/// or different hardware, or in a separate process.
class actor_proxy : public monitorable_actor {
public:
  explicit actor_proxy(actor_config& cfg);

  ~actor_proxy() override;

  /// Invokes cleanup code.
  virtual void kill_proxy(execution_unit* ctx, error reason) = 0;
};

} // namespace caf

#endif // CAF_ACTOR_PROXY_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DESERIALIZER_HPP
#define CAF_DESERIALIZER_HPP

#include <string>
#include <cstddef>
#include <utility>
#include <type_traits>

#include "caf/config.hpp"

#ifndef CAF_NO_EXCEPTIONS
#include <exception>
#endif // CAF_NO_EXCEPTIONS

#include "caf/fwd.hpp"
#include "caf/data_processor.hpp"

namespace caf {

/// @ingroup TypeSystem
/// Technology-independent deserialization interface.
class deserializer : public data_processor<deserializer> {
public:
  ~deserializer() override;

  using super = data_processor<deserializer>;

  static constexpr bool reads_state = false;
  static constexpr bool writes_state = true;

  // Boost Serialization compatibility
  using is_saving = std::false_type;
  using is_loading = std::true_type;

  explicit deserializer(actor_system& x);

  explicit deserializer(execution_unit* x = nullptr);
};

#ifndef CAF_NO_EXCEPTIONS

template <class T>
typename std::enable_if<
  std::is_same<
    error,
    decltype(std::declval<deserializer&>().apply(std::declval<T&>()))
  >::value
>::type
operator&(deserializer& source, T& x) {
  auto e = source.apply(x);
  if (e)
    CAF_RAISE_ERROR(to_string(e));
}

template <class T>
typename std::enable_if<
  std::is_same<
    error,
    decltype(std::declval<deserializer&>().apply(std::declval<T&>()))
  >::value,
  deserializer&
>::type
operator>>(deserializer& source, T& x) {
  source & x;
  return source;
}

#endif // CAF_NO_EXCEPTIONS

} // namespace caf

#endif // CAF_DESERIALIZER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TYPED_BEHAVIOR_HPP
#define CAF_TYPED_BEHAVIOR_HPP

#include "caf/behavior.hpp"
#include "caf/deduce_mpi.hpp"
#include "caf/message_handler.hpp"
#include "caf/system_messages.hpp"
#include "caf/interface_mismatch.hpp"

#include "caf/detail/typed_actor_util.hpp"

namespace caf {

namespace detail {

// converts a list of replies_to<...>::with<...> elements to a list of
// lists containing the replies_to<...> half only
template <class List>
struct input_only;

template <class... Ts>
struct input_only<detail::type_list<Ts...>> {
  using type = detail::type_list<typename Ts::input_types...>;
};

using skip_list = detail::type_list<skip_t>;

template <class Input, class RepliesToWith>
struct same_input : std::is_same<Input, typename RepliesToWith::input_types> {};

template <class Output, class RepliesToWith>
struct same_output_or_skip_t {
  using other = typename RepliesToWith::output_types;
  static constexpr bool value =
    std::is_same<Output, typename RepliesToWith::output_types>::value ||
    std::is_same<Output, type_list<skip_t>>::value;
};

template <class SList>
struct valid_input_predicate {
  template <class Expr>
  struct inner {
    using input_types = typename Expr::input_types;
    using output_types = typename Expr::output_types;
    // get matching elements for input type
    using filtered_slist =
      typename tl_filter<
        SList,
        tbind<same_input, input_types>::template type
      >::type;
    static_assert(tl_size<filtered_slist>::value > 0,
                  "cannot assign given match expression to "
                  "typed behavior, because the expression "
                  "contains at least one pattern that is "
                  "not defined in the actor's type");
    static constexpr bool value = tl_exists<
      filtered_slist, tbind<same_output_or_skip_t,
                            output_types>::template type>::value;
    // check whether given output matches in the filtered list
    static_assert(value,
                  "cannot assign given match expression to "
                  "typed behavior, because at least one return "
                  "type does not match");
  };
};

template <class T>
struct is_system_msg_handler : std::false_type { };

template <>
struct is_system_msg_handler<reacts_to<exit_msg>> : std::true_type { };

template <>
struct is_system_msg_handler<reacts_to<down_msg>> : std::true_type { };

// Tests whether the input list (IList) matches the
// signature list (SList) for a typed actor behavior
template <class SList, class IList>
struct valid_input {
  // strip exit_msg and down_msg from input types,
  // because they're always allowed
  using adjusted_slist =
    typename tl_filter_not<
      SList,
      is_system_msg_handler
    >::type;
  using adjusted_ilist =
    typename tl_filter_not<
      IList,
      is_system_msg_handler
    >::type;
  // check for each element in IList that there's an element in SList that
  // (1) has an identical input type list
  // (2)  has an identical output type list
  //   OR the output of the element in IList is skip_t
  static_assert(detail::tl_is_distinct<IList>::value,
                "given pattern is not distinct");
  static constexpr bool value =
    tl_size<adjusted_slist>::value == tl_size<adjusted_ilist>::value
    && tl_forall<
         adjusted_ilist,
         valid_input_predicate<adjusted_slist>::template inner
       >::value;
};

// this function is called from typed_behavior<...>::set and its whole
// purpose is to give users a nicer error message on a type mismatch
// (this function only has the type informations needed to understand the error)
template <class SignatureList, class InputList>
void static_check_typed_behavior_input() {
  constexpr bool is_valid = valid_input<SignatureList, InputList>::value;
  // note: it might be worth considering to allow a wildcard in the
  //     InputList if its return type is identical to all "missing"
  //     input types ... however, it might lead to unexpected results
  //     and would cause a lot of not-so-straightforward code here
  static_assert(is_valid,
                "given pattern cannot be used to initialize "
                "typed behavior (exact match needed)");
}

} // namespace detail

template <class... Sigs>
class typed_actor;

namespace mixin {
template <class, class, class>
class behavior_stack_based_impl;
}

template <class... Sigs>
class typed_behavior {
public:
  // -- friends ----------------------------------------------------------------

  template <class... OtherSigs>
  friend class typed_actor;

  template <class... OtherSigs>
  friend class typed_behavior;

  template <class, class, class>
  friend class mixin::behavior_stack_based_impl;

  // -- member types -----------------------------------------------------------

  /// Stores the template parameter pack in a type list.
  using signatures = detail::type_list<Sigs...>;

  /// Empty struct tag for constructing from an untyped behavior.
  struct unsafe_init { };

  // -- constructors, destructors, and assignment operators --------------------

  typed_behavior(typed_behavior&&) = default;
  typed_behavior(const typed_behavior&) = default;
  typed_behavior& operator=(typed_behavior&&) = default;
  typed_behavior& operator=(const typed_behavior&) = default;

  template <class... Ts>
  typed_behavior(const typed_behavior<Ts...>& other) : bhvr_(other.bhvr_) {
    using other_signatures = detail::type_list<Ts...>;
    using m = interface_mismatch_t<other_signatures, signatures>;
    // trigger static assert on mismatch
    detail::static_error_printer<sizeof...(Ts), m::value,
                                 typename m::xs, typename m::ys> guard;
    CAF_IGNORE_UNUSED(guard);
  }

  template <class T, class... Ts>
  typed_behavior(T x, Ts... xs) {
    set(detail::make_behavior(std::move(x), std::move(xs)...));
  }

  typed_behavior(unsafe_init, behavior x) : bhvr_(std::move(x)) {
    // nop
  }

  typed_behavior(unsafe_init, message_handler x) : bhvr_(std::move(x)) {
    // nop
  }

  // -- modifiers --------------------------------------------------------------

  /// Exchanges the contents of this and other.
  inline void swap(typed_behavior& other) {
    bhvr_.swap(other.bhvr_);
  }

  /// Invokes the timeout callback.
  void handle_timeout() {
    bhvr_.handle_timeout();
  }

  // -- observers --------------------------------------------------------------

  /// Returns whether this behavior contains any callbacks.
  explicit operator bool() const {
    return static_cast<bool>(bhvr_);
  }

  /// Returns the duration after which receives using
  /// this behavior should time out.
  const duration& timeout() const {
    return bhvr_.timeout();
  }

  /// @cond PRIVATE

  behavior& unbox() {
    return bhvr_;
  }

  static typed_behavior make_empty_behavior() {
    return {};
  }

  /// @endcond

private:
  typed_behavior() = default;

  template <class... Ts>
  void set(intrusive_ptr<detail::default_behavior_impl<std::tuple<Ts...>>> bp) {
    using found_signatures = detail::type_list<deduce_mpi_t<Ts>...>;
    using m = interface_mismatch_t<found_signatures, signatures>;
    // trigger static assert on mismatch
    detail::static_error_printer<sizeof...(Ts), m::value,
                                 typename m::xs, typename m::ys> guard;
    CAF_IGNORE_UNUSED(guard);
    // final (type-erasure) step
    intrusive_ptr<detail::behavior_impl> ptr = std::move(bp);
    bhvr_.assign(std::move(ptr));
  }

  behavior bhvr_;
};

template <class T>
struct is_typed_behavior : std::false_type { };

template <class... Sigs>
struct is_typed_behavior<typed_behavior<Sigs...>> : std::true_type { };

} // namespace caf

#endif // CAF_TYPED_BEHAVIOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_RESUMABLE_HPP
#define CAF_RESUMABLE_HPP

#include <type_traits>

#include "caf/fwd.hpp"

namespace caf {

/// A cooperatively executed task managed by one or more
/// instances of `execution_unit`. Note that this class is
/// meant as mixin for reference counted object, i.e., the
/// subclass is required to inherit from `ref_counted`
/// at some point.
class resumable {
public:
  /// Denotes the state in which a `resumable`
  /// returned from its last call to `resume`.
  enum resume_result {
    resume_later,
    awaiting_message,
    done,
    shutdown_execution_unit
  };

  /// Denotes common subtypes of `resumable`.
  enum subtype_t {
    /// Identifies non-actors or blocking actors.
    unspecified,
    /// Identifies event-based, cooperatively scheduled actors.
    scheduled_actor,
    /// Identifies broker, i.e., actors performing I/O.
    io_actor,
    /// Identifies tasks, usually one-shot callbacks.
    function_object
  };

  resumable() = default;

  virtual ~resumable();

  /// Returns a subtype hint for this object. This allows an execution
  /// unit to limit processing to a specific set of resumables and
  /// delegate other subtypes to dedicated workers.
  virtual subtype_t subtype() const;

  /// Resume any pending computation until it is either finished
  /// or needs to be re-scheduled later.
  virtual resume_result resume(execution_unit*, size_t max_throughput) = 0;

  /// Add a strong reference count to this object.
  virtual void intrusive_ptr_add_ref_impl() = 0;

  /// Remove a strong reference count from this object.
  virtual void intrusive_ptr_release_impl() = 0;
};

// enables intrusive_ptr<resumable> without introducing ambiguity
template <class T>
typename std::enable_if<
  std::is_same<T*, resumable*>::value
>::type
intrusive_ptr_add_ref(T* ptr) {
  ptr->intrusive_ptr_add_ref_impl();
}

// enables intrusive_ptr<resumable> without introducing ambiguity
template <class T>
typename std::enable_if<
  std::is_same<T*, resumable*>::value
>::type
intrusive_ptr_release(T* ptr) {
  ptr->intrusive_ptr_release_impl();
}

} // namespace caf

#endif // CAF_RESUMABLE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MATCH_CASE_HPP
#define CAF_MATCH_CASE_HPP

#include <tuple>
#include <type_traits>

#include "caf/none.hpp"
#include "caf/param.hpp"
#include "caf/optional.hpp"
#include "caf/match_case.hpp"
#include "caf/skip.hpp"

#include "caf/detail/int_list.hpp"
#include "caf/detail/try_match.hpp"
#include "caf/detail/type_list.hpp"
#include "caf/detail/apply_args.hpp"
#include "caf/detail/type_traits.hpp"
#include "caf/detail/pseudo_tuple.hpp"
#include "caf/detail/invoke_result_visitor.hpp"

namespace caf {

class match_case {
public:
  enum result {
    no_match,
    match,
    skip
  };

  match_case(uint32_t tt);

  match_case(match_case&&) = default;
  match_case(const match_case&) = default;

  virtual ~match_case();

  /// Tries to invoke this match case with the contents of `xs`.
  virtual result invoke(detail::invoke_result_visitor& rv,
                        type_erased_tuple& xs) = 0;

  inline uint32_t type_token() const {
    return token_;
  }

private:
  uint32_t token_;
};

template <bool IsVoid, class F>
class lfinvoker {
public:
  lfinvoker(F& fun) : fun_(fun) {
    // nop
  }

  template <class... Ts>
  typename detail::get_callable_trait<F>::result_type operator()(Ts&&... xs) {
    return fun_(std::forward<Ts>(xs)...);
  }

private:
  F& fun_;
};

template <class F>
class lfinvoker<true, F> {
public:
  lfinvoker(F& fun) : fun_(fun) {
    // nop
  }

  template <class... Ts>
  unit_t operator()(Ts&&... xs) {
    fun_(std::forward<Ts>(xs)...);
    return unit;
  }

private:
  F& fun_;
};

template <class F>
class trivial_match_case : public match_case {
public:
  using fun_trait = typename detail::get_callable_trait<F>::type;

  using plain_result_type = typename fun_trait::result_type;

  using result_type =
    typename std::conditional<
      std::is_reference<plain_result_type>::value,
      plain_result_type,
      typename std::remove_const<plain_result_type>::type
    >::type;

  using arg_types = typename fun_trait::arg_types;

  static constexpr bool is_manipulator =
    detail::tl_exists<
      arg_types,
      detail::is_mutable_ref
    >::value;

  using pattern =
    typename detail::tl_map<
      arg_types,
      param_decay
    >::type;

  using decayed_arg_types =
    typename detail::tl_map<
      arg_types,
      std::decay
    >::type;

  using intermediate_pseudo_tuple =
    typename detail::tl_apply<
      decayed_arg_types,
      detail::pseudo_tuple
    >::type;

  trivial_match_case(trivial_match_case&&) = default;
  trivial_match_case(const trivial_match_case&) = default;
  trivial_match_case& operator=(trivial_match_case&&) = default;
  trivial_match_case& operator=(const trivial_match_case&) = default;

  trivial_match_case(F f)
      : match_case(make_type_token_from_list<pattern>()),
        fun_(std::move(f)) {
    // nop
  }

  match_case::result invoke(detail::invoke_result_visitor& f,
                            type_erased_tuple& xs) override {
    detail::meta_elements<pattern> ms;
    // check if try_match() reports success
    if (!detail::try_match(xs, ms.arr.data(), ms.arr.size()))
      return match_case::no_match;
    typename detail::il_indices<decayed_arg_types>::type indices;
    lfinvoker<std::is_same<result_type, void>::value, F> fun{fun_};
    message tmp;
    auto needs_detaching = is_manipulator && xs.shared();
    if (needs_detaching)
      tmp = message::copy(xs);
    intermediate_pseudo_tuple tup{needs_detaching ? tmp.content() : xs};
    auto fun_res = apply_args(fun, indices, tup);
    return f.visit(fun_res) ? match_case::match : match_case::skip;
  }

protected:
  F fun_;
};

struct match_case_info {
  uint32_t type_token;
  match_case* ptr;
};

inline bool operator<(const match_case_info& x, const match_case_info& y) {
  return x.type_token < y.type_token;
}

template <class F>
typename std::enable_if<
  !std::is_base_of<match_case, F>::value,
  std::tuple<trivial_match_case<F>>
>::type
to_match_case_tuple(F fun) {
  return std::make_tuple(std::move(fun));
}

template <class MatchCase>
typename std::enable_if<
  std::is_base_of<match_case, MatchCase>::value,
  std::tuple<const MatchCase&>
>::type
to_match_case_tuple(const MatchCase& x) {
  return std::tie(x);
}

template <class... Ts>
const std::tuple<Ts...>& to_match_case_tuple(const std::tuple<Ts...>& x) {
  static_assert(detail::conjunction<
                  std::is_base_of<
                    match_case,
                    Ts
                  >::value...
                >::value,
                "to_match_case_tuple received a tuple of non-match_case Ts");
  return x;
}

template <class T, class U>
typename std::enable_if<
  std::is_base_of<match_case, T>::value || std::is_base_of<match_case, U>::value
>::type
operator,(T, U) {
  static_assert(!std::is_same<T, T>::value,
                "this syntax is not supported -> you probably did "
                "something like 'return (...)' instead of 'return {...}'");
}

} // namespace caf

#endif // CAF_MATCH_CASE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_BINARY_DESERIALIZER_HPP
#define CAF_BINARY_DESERIALIZER_HPP

#include "caf/stream_deserializer.hpp"
#include "caf/streambuf.hpp"

namespace caf {

/// A stream serializer that writes into an unbounded contiguous character
/// sequence.
using binary_deserializer = stream_deserializer<charbuf>;

} // namespace caf

#endif // CAF_BINARY_DESERIALIZER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_FORWARDING_ACTOR_PROXY_HPP
#define CAF_FORWARDING_ACTOR_PROXY_HPP

#include "caf/actor.hpp"
#include "caf/actor_proxy.hpp"

#include "caf/detail/shared_spinlock.hpp"

namespace caf {

/// Implements a simple proxy forwarding all operations to a manager.
class forwarding_actor_proxy : public actor_proxy {
public:
  using forwarding_stack = std::vector<strong_actor_ptr>;

  forwarding_actor_proxy(actor_config& cfg, actor dest);

  ~forwarding_actor_proxy() override;

  void enqueue(mailbox_element_ptr what, execution_unit* context) override;

  bool add_backlink(abstract_actor* x) override;

  bool remove_backlink(abstract_actor* x) override;

  void kill_proxy(execution_unit* ctx, error rsn) override;

private:
  void forward_msg(strong_actor_ptr sender, message_id mid, message msg,
                   const forwarding_stack* fwd = nullptr);

  mutable detail::shared_spinlock mtx_;
  actor broker_;
};

} // namespace caf

#endif // CAF_FORWARDING_ACTOR_PROXY_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ERROR_HPP
#define CAF_ERROR_HPP

#include <cstdint>
#include <utility>
#include <functional>

#include "caf/fwd.hpp"
#include "caf/atom.hpp"
#include "caf/none.hpp"
#include "caf/atom.hpp"

#include "caf/meta/type_name.hpp"
#include "caf/meta/omittable_if_empty.hpp"

#include "caf/detail/comparable.hpp"

namespace caf {

class error;

/// Evaluates to true if `T` is an enum with a free function
/// `make_error` for converting it to an `error`.
template <class T>
struct has_make_error {
private:
  template <class U>
  static auto test_make_error(U* x) -> decltype(make_error(*x));

  template <class U>
  static auto test_make_error(...) -> void;

  using type = decltype(test_make_error<T>(nullptr));

public:
  static constexpr bool value = std::is_enum<T>::value
                                && std::is_same<error, type>::value;
};

/// Convenience alias for `std::enable_if<has_make_error<T>::value, U>::type`.
template <class T, class U = void>
using enable_if_has_make_error_t
  = typename std::enable_if<has_make_error<T>::value, U>::type;

/// A serializable type for storing error codes with category and optional,
/// human-readable context information. Unlike error handling classes from
/// the C++ standard library, this type is serializable. It consists of an
/// 8-bit code, a 64-bit atom constant, plus optionally a ::message to store
/// additional information.
///
/// # Why not `std::error_code` or `std::error_condition`?
///
/// First, the standard does *not* define the values for `std::errc`.
/// This means serializing error conditions (which are meant to be portable)
/// is not safe in a distributed setting unless all machines are running the
/// same operating system and version of the C++ standard library.
///
/// Second, the standard library primitives, unlike exceptions, do not offer
/// an API for attaching additional context to an error. The error handling API
/// offered by the standard is meant to wrap C system calls in a (source code)
/// portable way. In a distributed setting, an error may not occur locally.
/// In this case, an error code and category alone is often not satisfactory
/// information when signalling errors back to end users. The additional
/// context also enables *composition* of errors by modifying the message
/// details as needed.
///
/// # Why is there no `string()` member function?
///
/// The C++ standard library uses category singletons and virtual dispatching
/// to correlate error codes to descriptive strings. However, singletons are
/// a poor choice when it comes to serialization. CAF uses atoms for
/// categories instead and requires users to register custom error categories
/// to the actor system. This makes the actor system the natural instance for
/// rendering error messages via `actor_system::render(const error&)`.
class error : detail::comparable<error> {
public:
  // -- member types -----------------------------------------------------------

  using inspect_fun = std::function<error (meta::type_name_t,
                                           uint8_t&, atom_value&,
                                           meta::omittable_if_empty_t,
                                           message&)>;

  // -- constructors, destructors, and assignment operators --------------------

  error() noexcept;
  error(none_t) noexcept;

  error(error&&) noexcept;
  error& operator=(error&&) noexcept;

  error(const error&);
  error& operator=(const error&);

  error(uint8_t x, atom_value y);
  error(uint8_t x, atom_value y, message z);

  template <class E, class = enable_if_has_make_error_t<E>>
  error(E error_value) : error(make_error(error_value)) {
    // nop
  }

  template <class E, class = enable_if_has_make_error_t<E>>
  error& operator=(E error_value) {
    auto tmp = make_error(error_value);
    std::swap(data_, tmp.data_);
    return *this;
  }

  ~error();

  // -- observers --------------------------------------------------------------

  /// Returns the category-specific error code, whereas `0` means "no error".
  /// @pre `*this != none`
  uint8_t code() const noexcept;

  /// Returns the category of this error.
  /// @pre `*this != none`
  atom_value category() const noexcept;

  /// Returns context information to this error.
  /// @pre `*this != none`
  const message& context() const noexcept;

  /// Returns `*this != none`.
  inline explicit operator bool() const noexcept {
    return data_ != nullptr;
  }

  /// Returns `*this == none`.
  inline bool operator!() const noexcept {
    return data_ == nullptr;
  }

  int compare(const error&) const noexcept;

  int compare(uint8_t x, atom_value y) const noexcept;

  // -- modifiers --------------------------------------------------------------

  /// Returns context information to this error.
  /// @pre `*this != none`
  message& context() noexcept;

  /// Sets the error code to 0.
  void clear() noexcept;

  // -- static convenience functions -------------------------------------------

  /// @cond PRIVATE

  static inline error eval() {
    return none;
  }

  template <class F, class... Fs>
  static error eval(F&& f, Fs&&... fs) {
    auto x = f();
    return x ? x : eval(std::forward<Fs>(fs)...);
  }

  /// @endcond

  // -- friend functions -------------------------------------------------------

  template <class Inspector>
  friend typename Inspector::result_type inspect(Inspector& f, error& x) {
    auto fun = [&](meta::type_name_t x0, uint8_t& x1, atom_value& x2,
                   meta::omittable_if_empty_t x3, message& x4) -> error{
      return f(x0, x1, x2, x3, x4);
    };
    return x.apply(fun);
  }

private:
  // -- inspection support -----------------------------------------------------

  error apply(const inspect_fun& f);

  // -- nested classes ---------------------------------------------------------

  struct data;

  // -- member variables -------------------------------------------------------

  data* data_;
};

/// @relates error
std::string to_string(const error& x);

/// @relates error
inline bool operator==(const error& x, none_t) {
  return !x;
}

/// @relates error
inline bool operator==(none_t, const error& x) {
  return !x;
}

/// @relates error
template <class E, class = enable_if_has_make_error_t<E>>
bool operator==(const error& x, E y) {
  return x == make_error(y);
}

/// @relates error
template <class E, class = enable_if_has_make_error_t<E>>
bool operator==(E x, const error& y) {
  return make_error(x) == y;
}

/// @relates error
inline bool operator!=(const error& x, none_t) {
  return static_cast<bool>(x);
}

/// @relates error
inline bool operator!=(none_t, const error& x) {
  return static_cast<bool>(x);
}

/// @relates error
template <class E, class = enable_if_has_make_error_t<E>>
bool operator!=(const error& x, E y) {
  return !(x == y);
}

/// @relates error
template <class E, class = enable_if_has_make_error_t<E>>
bool operator!=(E x, const error& y) {
  return !(x == y);
}

} // namespace caf

#endif // CAF_ERROR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_PROHIBIT_TOP_LEVEL_SPAWN_MARKER_HPP
#define CAF_PROHIBIT_TOP_LEVEL_SPAWN_MARKER_HPP

namespace caf {

struct prohibit_top_level_spawn_marker {
  // used as marker only
};

} // namespace caf

#endif // CAF_PROHIBIT_TOP_LEVEL_SPAWN_MARKER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_SPAWN_OPTIONS_HPP
#define CAF_SPAWN_OPTIONS_HPP

namespace caf {

/// @addtogroup ActorCreation
/// @{

/// Stores options passed to the `spawn` function family.
#ifdef CAF_DOCUMENTATION
class spawn_options {};
#else
enum class spawn_options : int {
  no_flags = 0x00,
  link_flag = 0x01,
  monitor_flag = 0x02,
  detach_flag = 0x04,
  hide_flag = 0x08,
  priority_aware_flag = 0x20,
  lazy_init_flag = 0x40
};
#endif

/// Concatenates two {@link spawn_options}.
/// @relates spawn_options
constexpr spawn_options operator+(const spawn_options& lhs,
                  const spawn_options& rhs) {
  return static_cast<spawn_options>(static_cast<int>(lhs) |
                    static_cast<int>(rhs));
}

/// Denotes default settings.
constexpr spawn_options no_spawn_options = spawn_options::no_flags;

/// Causes `spawn` to call `self->monitor(...) immediately
/// after the new actor was spawned.
constexpr spawn_options monitored = spawn_options::monitor_flag;

/// Causes `spawn` to call `self->link_to(...) immediately
/// after the new actor was spawned.
constexpr spawn_options linked = spawn_options::link_flag;

/// Causes the new actor to opt out of the cooperative scheduling.
constexpr spawn_options detached = spawn_options::detach_flag;

/// Causes the runtime to ignore the new actor in `await_all_actors_done()`.
constexpr spawn_options hidden = spawn_options::hide_flag;

/// Causes the new actor to evaluate message priorities.
/// @note This implicitly causes the actor to run in its own thread.
constexpr spawn_options priority_aware = spawn_options::priority_aware_flag;

/// Causes the new actor to delay its
/// initialization until a message arrives.
constexpr spawn_options lazy_init = spawn_options::lazy_init_flag;

/// Checks wheter `haystack` contains `needle`.
/// @relates spawn_options
constexpr bool has_spawn_option(spawn_options haystack, spawn_options needle) {
  return (static_cast<int>(haystack) & static_cast<int>(needle)) != 0;
}

/// Checks wheter the {@link detached} flag is set in `opts`.
/// @relates spawn_options
constexpr bool has_detach_flag(spawn_options opts) {
  return has_spawn_option(opts, detached);
}

/// Checks wheter the {@link priority_aware} flag is set in `opts`.
/// @relates spawn_options
constexpr bool has_priority_aware_flag(spawn_options opts) {
  return has_spawn_option(opts, priority_aware);
}

/// Checks wheter the {@link hidden} flag is set in `opts`.
/// @relates spawn_options
constexpr bool has_hide_flag(spawn_options opts) {
  return has_spawn_option(opts, hidden);
}

/// Checks wheter the {@link linked} flag is set in `opts`.
/// @relates spawn_options
constexpr bool has_link_flag(spawn_options opts) {
  return has_spawn_option(opts, linked);
}

/// Checks wheter the {@link monitored} flag is set in `opts`.
/// @relates spawn_options
constexpr bool has_monitor_flag(spawn_options opts) {
  return has_spawn_option(opts, monitored);
}

/// Checks wheter the {@link lazy_init} flag is set in `opts`.
/// @relates spawn_options
constexpr bool has_lazy_init_flag(spawn_options opts) {
  return has_spawn_option(opts, lazy_init);
}

/// @}

/// @cond PRIVATE

constexpr bool is_unbound(spawn_options opts) {
  return !has_monitor_flag(opts) && !has_link_flag(opts);
}

constexpr spawn_options make_unbound(spawn_options opts) {
  return static_cast<spawn_options>(
    (static_cast<int>(opts) &
     ~(static_cast<int>(linked) | static_cast<int>(monitored))));
}

/// @endcond

} // namespace caf

#endif // CAF_SPAWN_OPTIONS_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_EXTEND_HPP
#define CAF_EXTEND_HPP

namespace caf {

namespace detail {

template <class D, class B, template <class, class> class... Ms>
struct extend_helper;

template <class D, class B>
struct extend_helper<D, B> {
  using type = B;
};

template <class D, class B, template <class, class> class M,
      template <class, class> class... Ms>
struct extend_helper<D, B, M, Ms...> : extend_helper<D, M<B, D>, Ms...> {
  // no content
};

} // namespace detail

/// Allows convenient definition of types using mixins.
/// For example, `extend<ar, T>::with<ob, fo>` is an alias for
/// `fo<ob<ar, T>, T>`.
///
/// Mixins always have two template parameters: base type and
/// derived type. This allows mixins to make use of the curiously recurring
/// template pattern (CRTP). However, if none of the used mixins use CRTP,
/// the second template argument can be ignored (it is then set to Base).
template <class Base, class Derived = Base>
struct extend {
  /// Identifies the combined type.
  template <template <class, class> class... Mixins>
  using with = typename detail::extend_helper<Derived, Base, Mixins...>::type;
};

} // namespace caf

#endif // CAF_EXTEND_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MESSAGE_VIEW_HPP
#define CAF_MESSAGE_VIEW_HPP

#include "caf/fwd.hpp"

namespace caf {

/// Represents an object pointing to a `type_erased_tuple` that
/// is convertible to a `message`
class message_view {
public:
  virtual ~message_view();

  virtual type_erased_tuple& content() = 0;

  virtual message move_content_to_message() = 0;

  virtual message copy_content_to_message() const = 0;
};

} // namespace caf

#endif // CAF_MESSAGE_VIEW_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_DETAIL_UNIFORM_TYPE_INFO_MAP_HPP
#define CAF_DETAIL_UNIFORM_TYPE_INFO_MAP_HPP

#include <set>
#include <map>
#include <string>
#include <utility>
#include <typeinfo>
#include <stdexcept>
#include <typeindex>
#include <type_traits>
#include <unordered_map>

#include "caf/fwd.hpp"

#include "caf/atom.hpp"
#include "caf/unit.hpp"
#include "caf/node_id.hpp"
#include "caf/duration.hpp"
#include "caf/system_messages.hpp"
#include "caf/type_erased_value.hpp"

#include "caf/type_nr.hpp"
#include "caf/detail/type_list.hpp"
#include "caf/detail/shared_spinlock.hpp"

namespace caf {

class uniform_type_info_map {
public:
  friend class actor_system;

  using value_factory = std::function<type_erased_value_ptr ()>;

  using actor_factory_result = std::pair<strong_actor_ptr, std::set<std::string>>;

  using actor_factory = std::function<actor_factory_result (actor_config&, message&)>;

  using actor_factories = std::unordered_map<std::string, actor_factory>;

  using value_factories_by_name = std::unordered_map<std::string, value_factory>;

  using value_factories_by_rtti = std::unordered_map<std::type_index, value_factory>;

  using value_factory_kvp = std::pair<std::string, value_factory>;

  using portable_names = std::unordered_map<std::type_index, std::string>;

  using error_renderer = std::function<std::string (uint8_t, atom_value, const message&)>;

  using error_renderers = std::unordered_map<atom_value, error_renderer>;

  type_erased_value_ptr make_value(uint16_t nr) const;

  type_erased_value_ptr make_value(const std::string& x) const;

  type_erased_value_ptr make_value(const std::type_info& x) const;

  /// Returns the portable name for given type information or `nullptr`
  /// if no mapping was found.
  const std::string* portable_name(uint16_t nr, const std::type_info* ti) const;

  /// Returns the portable name for given type information or `nullptr`
  /// if no mapping was found.
  inline const std::string*
  portable_name(const std::pair<uint16_t, const std::type_info*>& x) const {
    return portable_name(x.first, x.second);
  }

  /// Returns the enclosing actor system.
  inline actor_system& system() const {
    return system_;
  }

private:
  uniform_type_info_map(actor_system& sys);

  actor_system& system_;

  // message types
  std::array<value_factory_kvp, type_nrs - 1> builtin_;
  value_factories_by_name ad_hoc_;
  mutable detail::shared_spinlock ad_hoc_mtx_;

  // message type names
  std::array<std::string, type_nrs - 1> builtin_names_;
};

} // namespace caf

#endif // CAF_DETAIL_UNIFORM_TYPE_INFO_MAP_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_BEHAVIOR_HPP
#define CAF_BEHAVIOR_HPP

#include <functional>
#include <type_traits>

#include "caf/none.hpp"

#include "caf/duration.hpp"
#include "caf/timeout_definition.hpp"

#include "caf/detail/type_list.hpp"
#include "caf/detail/type_traits.hpp"
#include "caf/detail/behavior_impl.hpp"

namespace caf {

class message_handler;

/// Describes the behavior of an actor, i.e., provides a message
/// handler and an optional timeout.
class behavior {
public:
  friend class message_handler;

  behavior() = default;
  behavior(behavior&&) = default;
  behavior(const behavior&) = default;
  behavior& operator=(behavior&&) = default;
  behavior& operator=(const behavior&) = default;

  /// Creates a behavior from `fun` without timeout.
  behavior(const message_handler& mh);

  /// The list of arguments can contain match expressions, message handlers,
  /// and up to one timeout (if set, the timeout has to be the last argument).
  template <class T, class... Ts>
  behavior(T x, Ts&&... xs) {
    assign(std::move(x), std::forward<Ts>(xs)...);
  }

  /// Creates a behavior from `tdef` without message handler.
  template <class F>
  behavior(timeout_definition<F> tdef) : impl_(detail::make_behavior(tdef)) {
    // nop
  }

  /// Assigns new handlers.
  template <class... Ts>
  void assign(Ts&&... xs) {
    static_assert(sizeof...(Ts) > 0, "assign() called without arguments");
    impl_ = detail::make_behavior(std::forward<Ts>(xs)...);
  }

  inline void swap(behavior& other) {
    impl_.swap(other.impl_);
  }

  void assign(intrusive_ptr<detail::behavior_impl> ptr) {
    impl_.swap(ptr);
  }

  /// Equal to `*this = other`.
  void assign(message_handler other);

  /// Equal to `*this = other`.
  void assign(behavior other);

  /// Invokes the timeout callback if set.
  inline void handle_timeout() {
    impl_->handle_timeout();
  }

  /// Returns the duration after which receive operations
  /// using this behavior should time out.
  inline const duration& timeout() const {
    return impl_->timeout();
  }

  /// Runs this handler and returns its (optional) result.
  inline optional<message> operator()(message& xs) {
    return impl_ ? impl_->invoke(xs) : none;
  }

  inline optional<message> operator()(type_erased_tuple& xs) {
    return impl_ ? impl_->invoke(xs) : none;
  }

  /// Runs this handler with callback.
  inline match_case::result operator()(detail::invoke_result_visitor& f,
                                       type_erased_tuple& xs) {
    return impl_ ? impl_->invoke(f, xs) : match_case::no_match;
  }

  /// Runs this handler with callback.
  inline match_case::result operator()(detail::invoke_result_visitor& f,
                                       message& xs) {
    return impl_ ? impl_->invoke(f, xs) : match_case::no_match;
  }

  /// Checks whether this behavior is not empty.
  inline operator bool() const {
    return static_cast<bool>(impl_);
  }

  /// @cond PRIVATE

  using impl_ptr = intrusive_ptr<detail::behavior_impl>;

  inline const impl_ptr& as_behavior_impl() const {
    return impl_;
  }

  inline behavior(impl_ptr ptr) : impl_(std::move(ptr)) {
    // nop
  }

  inline behavior& unbox() {
    return *this;
  }

  /// @endcond

private:
  impl_ptr impl_;
};

} // namespace caf

#endif // CAF_BEHAVIOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MAKE_MESSAGE_HPP
#define CAF_MAKE_MESSAGE_HPP

#include <tuple>
#include <sstream>
#include <type_traits>

#include "caf/message.hpp"
#include "caf/allowed_unsafe_message_type.hpp"

#include "caf/detail/tuple_vals.hpp"
#include "caf/detail/type_traits.hpp"

namespace caf {

/// Unboxes atom constants, i.e., converts `atom_constant<V>` to `V`.
/// @relates message
template <class T, int IsPlaceholderRes = std::is_placeholder<T>::value>
struct unbox_message_element {
  using type = index_mapping;
};

template <class T>
struct unbox_message_element<T, 0> {
  using type = T;
};

template <atom_value V>
struct unbox_message_element<atom_constant<V>, 0> {
  using type = atom_value;
};

template <>
struct unbox_message_element<actor_control_block*, 0> {
  using type = strong_actor_ptr;
};

///
template <class T>
struct is_serializable_or_whitelisted {
  static constexpr bool value = detail::is_serializable<T>::value
                                || allowed_unsafe_message_type<T>::value;
};

/// Returns a new `message` containing the values `(x, xs...)`.
/// @relates message
template <class T, class... Ts>
typename std::enable_if<
  !std::is_same<message, typename std::decay<T>::type>::value
  || (sizeof...(Ts) > 0),
  message
>::type
make_message(T&& x, Ts&&... xs) {
  using namespace caf::detail;
  using stored_types =
    type_list<
      typename unbox_message_element<
        typename strip_and_convert<T>::type
      >::type,
      typename unbox_message_element<
        typename strip_and_convert<Ts>::type
      >::type...
    >;
  static_assert(tl_forall<stored_types, is_serializable_or_whitelisted>::value,
                "at least one type is neither inspectable via "
                "inspect(Inspector&, T&) nor serializable via "
                "'serialize(Processor&, T&, const unsigned int)' or "
                "`T::serialize(Processor&, const unsigned int)`; "
                "you can whitelist individual types by "
                "specializing `caf::allowed_unsafe_message_type<T>` "
                "or using the macro CAF_ALLOW_UNSAFE_MESSAGE_TYPE");
  using storage = typename tl_apply<stored_types, tuple_vals>::type;
  auto ptr = make_counted<storage>(std::forward<T>(x), std::forward<Ts>(xs)...);
  return message{detail::message_data::cow_ptr{std::move(ptr)}};
}

/// Returns a copy of @p other.
/// @relates message
inline message make_message(message other) {
  return other;
}

/// Returns an empty `message`.
/// @relates message
inline message make_message() {
  return message{};
}

struct message_factory {
  template <class... Ts>
  message operator()(Ts&&... xs) const {
    return make_message(std::forward<Ts>(xs)...);
  }
};

/// Converts the tuple `xs` to a message.
template <class... Ts>
message make_message_from_tuple(std::tuple<Ts...> xs) {
  message_factory f;
  return detail::apply_moved_args(f, detail::get_indices(xs), xs);
}

} // namespace caf

#endif // CAF_MAKE_MESSAGE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_MSG_HPP
#define CAF_STREAM_MSG_HPP

#include <utility>
#include <vector>
#include <cstdint>

#include "caf/atom.hpp"
#include "caf/message.hpp"
#include "caf/variant.hpp"
#include "caf/stream_id.hpp"
#include "caf/stream_priority.hpp"
#include "caf/actor_control_block.hpp"

#include "caf/tag/boxing_type.hpp"

#include "caf/detail/type_list.hpp"

namespace caf {

/// Stream communication messages for handshaking, ACKing, data transmission,
/// etc.
struct stream_msg : tag::boxing_type {
  /// Initiates a stream handshake.
  struct open {
    /// Allows the testing DSL to unbox this type automagically.
    using outer_type = stream_msg;
    /// Contains a type-erased stream<T> object as first argument followed by
    /// any number of user-defined additional handshake data.
    message msg;
    /// Identifies the previous stage in the pipeline.
    strong_actor_ptr prev_stage;
    /// Identifies the original receiver of this message.
    strong_actor_ptr original_stage;
    /// Configures the priority for stream elements.
    stream_priority priority;
    /// Tells the downstream whether rebindings can occur on this path.
    bool redeployable;
  };

  /// Acknowledges a previous `open` message and finalizes a stream handshake.
  /// Also signalizes initial demand.
  struct ack_open {
    /// Allows the testing DSL to unbox this type automagically.
    using outer_type = stream_msg;
    /// Allows actors to participate in a stream instead of the actor
    /// originally receiving the `open` message. No effect when set to
    /// `nullptr`. This mechanism enables pipeline definitions consisting of
    /// proxy actors that are replaced with actual actors on demand.
    actor_addr rebind_from;
    /// Points to sender_, but with a strong reference.
    strong_actor_ptr rebind_to;
    /// Grants credit to the source.
    int32_t initial_demand;
    /// Tells the upstream whether rebindings can occur on this path.
    bool redeployable;
  };

  /// Transmits stream data.
  struct batch {
    /// Allows the testing DSL to unbox this type automagically.
    using outer_type = stream_msg;
    /// Size of the type-erased vector<T> (used credit).
    int32_t xs_size;
    /// A type-erased vector<T> containing the elements of the batch.
    message xs;
    /// ID of this batch (ascending numbering).
    int64_t id;
  };

  /// Cumulatively acknowledges received batches and signalizes new demand from
  /// a sink to its source.
  struct ack_batch {
    /// Allows the testing DSL to unbox this type automagically.
    using outer_type = stream_msg;
    /// Newly available credit.
    int32_t new_capacity;
    /// Cumulative ack ID.
    int64_t acknowledged_id;
  };

  /// Orderly shuts down a stream after receiving an ACK for the last batch.
  struct close {
    /// Allows the testing DSL to unbox this type automagically.
    using outer_type = stream_msg;
  };

  /// Informs a source that a sink orderly drops out of a stream.
  struct drop {
    /// Allows the testing DSL to unbox this type automagically.
    using outer_type = stream_msg;
  };

  /// Propagates a fatal error from sources to sinks.
  struct forced_close {
    /// Allows the testing DSL to unbox this type automagically.
    using outer_type = stream_msg;
    /// Reason for shutting down the stream.
    error reason;
  };

  /// Propagates a fatal error from sinks to sources.
  struct forced_drop {
    /// Allows the testing DSL to unbox this type automagically.
    using outer_type = stream_msg;
    /// Reason for shutting down the stream.
    error reason;
  };

  /// Lists all possible options for the payload.
  using content_alternatives =
    detail::type_list<open, ack_open, batch, ack_batch, close, drop,
                      forced_close, forced_drop>;

  /// Stores one of `content_alternatives`.
  using content_type = variant<open, ack_open, batch, ack_batch, close, drop,
                               forced_close, forced_drop>;

  /// ID of the affected stream.
  stream_id sid;

  /// Address of the sender. Identifies the up- or downstream actor sending
  /// this message. Note that abort messages can get send after `sender`
  /// already terminated. Hence, `current_sender()` can be `nullptr`, because
  /// no strong pointers can be formed any more and receiver would receive an
  /// anonymous message.
  actor_addr sender;

  /// Palyoad of the message.
  content_type content;

  template <class T>
  stream_msg(const stream_id& id, actor_addr addr, T&& x)
      : sid(std::move(id)),
        sender(std::move(addr)),
        content(std::forward<T>(x)) {
    // nop
  }

  stream_msg() = default;
  stream_msg(stream_msg&&) = default;
  stream_msg(const stream_msg&) = default;
  stream_msg& operator=(stream_msg&&) = default;
  stream_msg& operator=(const stream_msg&) = default;
};

/// Allows the testing DSL to unbox `stream_msg` automagically.
template <class T>
const T& get(const stream_msg& x) {
  return get<T>(x.content);
}

/// Allows the testing DSL to check whether `stream_msg` holds a `T`.
template <class T>
bool is(const stream_msg& x) {
  return holds_alternative<T>(x.content);
}

template <class T, class... Ts>
typename std::enable_if<
  detail::tl_contains<
    stream_msg::content_alternatives,
    T
  >::value,
  stream_msg
>::type
make(const stream_id& sid, actor_addr addr, Ts&&... xs) {
  return {sid, std::move(addr), T{std::forward<Ts>(xs)...}};
}

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, stream_msg::open& x) {
  return f(meta::type_name("open"), x.msg, x.prev_stage, x.original_stage,
           x.priority, x.redeployable);
}

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, stream_msg::ack_open& x) {
  return f(meta::type_name("ack_open"), x.rebind_from, x.rebind_to,
           x.initial_demand, x.redeployable);
}

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, stream_msg::batch& x) {
  return f(meta::type_name("batch"), meta::omittable(), x.xs_size, x.xs, x.id);
}

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f,
                                        stream_msg::ack_batch& x) {
  return f(meta::type_name("ack_batch"), x.new_capacity, x.acknowledged_id);
}

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f,
                                        stream_msg::close&) {
  return f(meta::type_name("close"));
}

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f,
                                        stream_msg::drop&) {
  return f(meta::type_name("drop"));
}

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f,
                                        stream_msg::forced_close& x) {
  return f(meta::type_name("forced_close"), x.reason);
}

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f,
                                        stream_msg::forced_drop& x) {
  return f(meta::type_name("forced_drop"), x.reason);
}

template <class Inspector>
typename Inspector::result_type inspect(Inspector& f, stream_msg& x) {
  return f(meta::type_name("stream_msg"), x.sid, x.sender, x.content);
}

} // namespace caf

#endif // CAF_STREAM_MSG_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_POLICY_ARG_HPP
#define CAF_POLICY_ARG_HPP

namespace caf {
namespace policy {

/// Provides a wrapper to pass policy types as values to functions.
template <class... Ts>
struct arg {
public:
  static const arg value;
};

template <class... Ts>
const arg<Ts...> arg<Ts...>::value = arg<Ts...>{};

} // namespace policy
} // namespace caf

#endif // CAF_POLICY_ARG_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_POLICY_WORK_SHARING_HPP
#define CAF_POLICY_WORK_SHARING_HPP

#include <list>
#include <mutex>
#include <cstddef>
#include <condition_variable>

#include "caf/resumable.hpp"
#include "caf/policy/unprofiled.hpp"

namespace caf {
namespace policy {

/// Implements scheduling of actors via work sharing (central job queue).
/// @extends scheduler_policy
class work_sharing : public unprofiled {
public:
  // A thread-safe queue implementation.
  using queue_type = std::list<resumable*>;

  ~work_sharing() override;

  struct coordinator_data {
    inline explicit coordinator_data(scheduler::abstract_coordinator*) {
      // nop
    }

    queue_type queue;
    std::mutex lock;
    std::condition_variable cv;
  };

  struct worker_data {
    inline explicit worker_data(scheduler::abstract_coordinator*) {
      // nop
    }
  };

  template <class Coordinator>
  void enqueue(Coordinator* self, resumable* job) {
    queue_type l;
    l.push_back(job);
    std::unique_lock<std::mutex> guard(d(self).lock);
    d(self).queue.splice(d(self).queue.end(), l);
    d(self).cv.notify_one();
  }

  template <class Coordinator>
  void central_enqueue(Coordinator* self, resumable* job) {
    enqueue(self, job);
  }

  template <class Worker>
  void external_enqueue(Worker* self, resumable* job) {
    enqueue(self->parent(), job);
  }

  template <class Worker>
  void internal_enqueue(Worker* self, resumable* job) {
    enqueue(self->parent(), job);
  }

  template <class Worker>
  void resume_job_later(Worker* self, resumable* job) {
    // job has voluntarily released the CPU to let others run instead
    // this means we are going to put this job to the very end of our queue
    enqueue(self->parent(), job);
  }

  template <class Worker>
  resumable* dequeue(Worker* self) {
    auto& parent_data = d(self->parent());
    std::unique_lock<std::mutex> guard(parent_data.lock);
    parent_data.cv.wait(guard, [&] { return !parent_data.queue.empty(); });
    resumable* job = parent_data.queue.front();
    parent_data.queue.pop_front();
    return job;
  }

  template <class Worker, class UnaryFunction>
  void foreach_resumable(Worker*, UnaryFunction) {
    // nop
  }

  template <class Coordinator, class UnaryFunction>
  void foreach_central_resumable(Coordinator* self, UnaryFunction f) {
    auto& queue = d(self).queue;
    auto next = [&]() -> resumable* {
      if (queue.empty()) {
        return nullptr;
      }
      auto front = queue.front();
      queue.pop_front();
      return front;
    };
    std::unique_lock<std::mutex> guard(d(self).lock);
    for (auto job = next(); job != nullptr; job = next()) {
      f(job);
    }
  }
};

} // namespace policy
} // namespace caf

#endif // CAF_POLICY_WORK_SHARING_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_POLICY_UNPROFILED_HPP
#define CAF_POLICY_UNPROFILED_HPP

#include "caf/scheduler/abstract_coordinator.hpp"

namespace caf {
namespace policy {

/// This class is intended to be used as a base class for actual polices.
/// It provides a default empty implementation for the customization points.
/// By deriving from it, actual policy classes only need to implement/override
/// the customization points they need. This class also serves as a place to
/// factor common utilities for implementing actual policies.
class unprofiled {
public:
  virtual ~unprofiled();

  /// Performs cleanup action before a shutdown takes place.
  template <class Worker>
  void before_shutdown(Worker*) {
    // nop
  }

  /// Called immediately before resuming an actor.
  template <class Worker>
  void before_resume(Worker*, resumable*) {
    // nop
  }

  /// Called whenever an actor has been resumed. This function can
  /// prepare some fields before the next resume operation takes place
  /// or perform cleanup actions between to actor runs.
  template <class Worker>
  void after_resume(Worker*, resumable*) {
    // nop
  }

  /// Called whenever an actor has completed a job.
  template <class Worker>
  void after_completion(Worker*, resumable*) {
    // nop
  }

protected:
  // Convenience function to access the data field.
  template <class WorkerOrCoordinator>
  static auto d(WorkerOrCoordinator* self) -> decltype(self->data()) {
    return self->data();
  }
};

} // namespace policy
} // namespace caf

#endif // CAF_POLICY_UNPROFILED_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_POLICY_SCHEDULER_POLICY_HPP
#define CAF_POLICY_SCHEDULER_POLICY_HPP

#include "caf/fwd.hpp"
#include "caf/scheduler/abstract_coordinator.hpp"

namespace caf {
namespace policy {

/// This concept class describes a policy for worker
/// and coordinator of the scheduler.
class scheduler_policy {
public:
  /// Policy-specific data fields for the coordinator.
  struct coordinator_data {
    explicit coordinator_data(scheduler::abstract_coordinator*);
  };

  /// Policy-specific data fields for the worker.
  struct worker_data {
    explicit worker_data(scheduler::abstract_coordinator*);
  };

  /// Enqueues a new job to coordinator.
  template <class Coordinator>
  void central_enqueue(Coordinator* self, resumable* job);

  /// Enqueues a new job to the worker's queue from an
  /// external source, i.e., from any other thread.
  template <class Worker>
  void external_enqueue(Worker* self, resumable* job);

  /// Enqueues a new job to the worker's queue from an
  /// internal source, i.e., from the same thread.
  template <class Worker>
  void internal_enqueue(Worker* self, resumable* job);

  /// Called whenever resumable returned for reason `resumable::resume_later`.
  template <class Worker>
  void resume_job_later(Worker* self, resumable* job);

  /// Blocks until a job could be dequeued.
  /// Called by the worker itself to acquire a new job.
  template <class Worker>
  resumable* dequeue(Worker* self);

  /// Performs cleanup action before a shutdown takes place.
  template <class Worker>
  void before_shutdown(Worker* self);

  /// Called immediately before resuming an actor.
  template <class Worker>
  void before_resume(Worker* self, resumable* job);

  /// Called whenever an actor has been resumed. This function can
  /// prepare some fields before the next resume operation takes place
  /// or perform cleanup actions between to actor runs.
  template <class Worker>
  void after_resume(Worker* self, resumable* job);

  /// Called whenever an actor has completed a job.
  template <class Worker>
  void after_completion(Worker* self, resumable* job);

  /// Applies given functor to all resumables attached to a worker.
  template <class Worker, typename UnaryFunction>
  void foreach_resumable(Worker* self, UnaryFunction f);

  /// Applies given functor to all resumables attached to the coordinator.
  template <class Coordinator, typename UnaryFunction>
  void foreach_central_resumable(Coordinator* self, UnaryFunction f);
};

} // namespace policy
} // namespace caf

#endif // CAF_POLICY_SCHEDULER_POLICY_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_POLICY_PROFILED_HPP
#define CAF_POLICY_PROFILED_HPP

#include "caf/resumable.hpp"
#include "caf/abstract_actor.hpp"

namespace caf {

namespace scheduler  {

template <class>
class profiled_coordinator;

} // namespace scheduler

namespace policy {

/// An enhancement of CAF's scheduling policy which records fine-grained
/// resource utiliziation for worker threads and actors in the parent
/// coordinator of the workers.
template <class Policy>
struct profiled : Policy {
  using coordinator_type = scheduler::profiled_coordinator<profiled<Policy>>;

  static actor_id id_of(resumable* job) {
    auto ptr = dynamic_cast<abstract_actor*>(job);
    return ptr != nullptr ? ptr->id() : 0;
  }

  template <class Worker>
  void before_resume(Worker* worker, resumable* job) {
    Policy::before_resume(worker, job);
    auto parent = static_cast<coordinator_type*>(worker->parent());
    parent->start_measuring(worker->id(), id_of(job));
  }

  template <class Worker>
  void after_resume(Worker* worker, resumable* job) {
    Policy::after_resume(worker, job);
    auto parent = static_cast<coordinator_type*>(worker->parent());
    parent->stop_measuring(worker->id(), id_of(job));
  }

  template <class Worker>
  void after_completion(Worker* worker, resumable* job) {
    Policy::after_completion(worker, job);
    auto parent = static_cast<coordinator_type*>(worker->parent());
    parent->remove_job(id_of(job));
  }
};

} // namespace policy
} // namespace caf

#endif // CAF_POLICY_PROFILED_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_POLICY_WORK_STEALING_HPP
#define CAF_POLICY_WORK_STEALING_HPP

#include <deque>
#include <chrono>
#include <thread>
#include <random>
#include <cstddef>

#include "caf/resumable.hpp"
#include "caf/actor_system_config.hpp"

#include "caf/policy/unprofiled.hpp"

#include "caf/detail/double_ended_queue.hpp"

namespace caf {
namespace policy {

/// Implements scheduling of actors via work stealing.
/// @extends scheduler_policy
class work_stealing : public unprofiled {
public:
  ~work_stealing() override;

  // A thread-safe queue implementation.
  using queue_type = detail::double_ended_queue<resumable>;

  using usec = std::chrono::microseconds;

  // configuration for aggressive/moderate/relaxed poll strategies.
  struct poll_strategy {
    size_t attempts;
    size_t step_size;
    size_t steal_interval;
    usec sleep_duration;
  };

  // The coordinator has only a counter for round-robin enqueue to its workers.
  struct coordinator_data {
    inline explicit coordinator_data(scheduler::abstract_coordinator*)
        : next_worker(0) {
      // nop
    }

    std::atomic<size_t> next_worker;
  };

  // Holds job job queue of a worker and a random number generator.
  struct worker_data {
    inline explicit worker_data(scheduler::abstract_coordinator* p)
        : rengine(std::random_device{}()),
          // no need to worry about wrap-around; if `p->num_workers() < 2`,
          // `uniform` will not be used anyway
          uniform(0, p->num_workers() - 2),
          strategies{
            {p->system().config().work_stealing_aggressive_poll_attempts, 1,
             p->system().config().work_stealing_aggressive_steal_interval,
             usec{0}},
            {p->system().config().work_stealing_moderate_poll_attempts, 1,
             p->system().config().work_stealing_moderate_steal_interval,
             usec{p->system().config().work_stealing_moderate_sleep_duration_us}},
            {1, 0, p->system().config().work_stealing_relaxed_steal_interval,
            usec{p->system().config().work_stealing_relaxed_sleep_duration_us}}
          } {
      // nop
    }

    // This queue is exposed to other workers that may attempt to steal jobs
    // from it and the central scheduling unit can push new jobs to the queue.
    queue_type queue;
    // needed to generate pseudo random numbers
    std::default_random_engine rengine;
    std::uniform_int_distribution<size_t> uniform;
    poll_strategy strategies[3];
  };

  // Goes on a raid in quest for a shiny new job.
  template <class Worker>
  resumable* try_steal(Worker* self) {
    auto p = self->parent();
    if (p->num_workers() < 2) {
      // you can't steal from yourself, can you?
      return nullptr;
    }
    // roll the dice to pick a victim other than ourselves
    auto victim = d(self).uniform(d(self).rengine);
    if (victim == self->id())
      victim = p->num_workers() - 1;
    // steal oldest element from the victim's queue
    return d(p->worker_by_id(victim)).queue.take_tail();
  }

  template <class Coordinator>
  void central_enqueue(Coordinator* self, resumable* job) {
    auto w = self->worker_by_id(d(self).next_worker++ % self->num_workers());
    w->external_enqueue(job);
  }

  template <class Worker>
  void external_enqueue(Worker* self, resumable* job) {
    d(self).queue.append(job);
  }

  template <class Worker>
  void internal_enqueue(Worker* self, resumable* job) {
    d(self).queue.prepend(job);
  }

  template <class Worker>
  void resume_job_later(Worker* self, resumable* job) {
    // job has voluntarily released the CPU to let others run instead
    // this means we are going to put this job to the very end of our queue
    d(self).queue.append(job);
  }

  template <class Worker>
  resumable* dequeue(Worker* self) {
    // we wait for new jobs by polling our external queue: first, we
    // assume an active work load on the machine and perform aggresive
    // polling, then we relax our polling a bit and wait 50 us between
    // dequeue attempts, finally we assume pretty much nothing is going
    // on and poll every 10 ms; this strategy strives to minimize the
    // downside of "busy waiting", which still performs much better than a
    // "signalizing" implementation based on mutexes and conition variables
    auto& strategies = d(self).strategies;
    resumable* job = nullptr;
    for (auto& strat : strategies) {
      for (size_t i = 0; i < strat.attempts; i += strat.step_size) {
        job = d(self).queue.take_head();
        if (job)
          return job;
        // try to steal every X poll attempts
        if ((i % strat.steal_interval) == 0) {
          job = try_steal(self);
          if (job)
            return job;
        }
        if (strat.sleep_duration.count() > 0)
          std::this_thread::sleep_for(strat.sleep_duration);
      }
    }
    // unreachable, because the last strategy loops
    // until a job has been dequeued
    return nullptr;
  }

  template <class Worker, class UnaryFunction>
  void foreach_resumable(Worker* self, UnaryFunction f) {
    auto next = [&] { return d(self).queue.take_head(); };
    for (auto job = next(); job != nullptr; job = next()) {
      f(job);
    }
  }

  template <class Coordinator, class UnaryFunction>
  void foreach_central_resumable(Coordinator*, UnaryFunction) {
    // nop
  }
};

} // namespace policy
} // namespace caf

#endif // CAF_POLICY_WORK_STEALING_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_EDGE_IMPL_HPP
#define CAF_STREAM_EDGE_IMPL_HPP

#include <memory>
#include <vector>
#include <numeric>
#include <cstddef>
#include <algorithm>

#include "caf/fwd.hpp"
#include "caf/send.hpp"
#include "caf/config.hpp"
#include "caf/stream_msg.hpp"
#include "caf/actor_addr.hpp"
#include "caf/local_actor.hpp"
#include "caf/inbound_path.hpp"
#include "caf/outbound_path.hpp"
#include "caf/stream_aborter.hpp"
#include "caf/actor_control_block.hpp"

namespace caf {

/// Provides a common scaffold for implementations of the `stream_gatherer` and
/// `stream_scatterer` interfaces.
template <class Base>
class stream_edge_impl : public Base {
public:
  // -- member types -----------------------------------------------------------

  using super = Base;

  /// Either `inbound_path` or `outbound_path`.
  using path_type = typename super::path_type;

  /// A raw pointer to a path.
  using path_ptr = path_type*;

  /// Vector of raw pointers (views) of paths.
  using path_ptr_vec = std::vector<path_ptr>;

  /// Iterator to a vector of raw pointers.
  using path_ptr_iter = typename path_ptr_vec::iterator;

  /// A unique pointer to a path.
  using path_uptr = std::unique_ptr<path_type>;

  /// Vector of owning pointers of paths.
  using path_uptr_vec = std::vector<path_uptr>;

  /// Iterator to a vector of owning pointers.
  using path_uptr_iter = typename path_uptr_vec::iterator;

  /// Message type for sending graceful shutdowns along the path (either
  /// `stream_msg::drop` or `stream_msg::close`).
  using regular_shutdown = typename path_type::regular_shutdown;

  /// Message type for sending errors along the path (either
  /// `stream_msg::forced_drop` or `stream_msg::forced_close`).
  using irregular_shutdown = typename path_type::irregular_shutdown;

  /// Stream aborter flag to monitor paths.
  static constexpr const auto aborter_type = path_type::aborter_type;

  // -- constructors, destructors, and assignment operators --------------------

  stream_edge_impl(local_actor* selfptr)
      : self_(selfptr),
        continuous_(false) {
    // nop
  }

  ~stream_edge_impl() override {
    // nop
  }

  // -- static utility functions for path vectors ------------------------------
  
  /// Sorts `xs` in descending order by available credit.
  template <class PathContainer>
  static void sort_by_credit(PathContainer& xs) {
    using value_type = typename PathContainer::value_type;
    auto cmp = [](const value_type& x, const value_type& y) {
      return x->open_credit > y->open_credit;
    };
    std::sort(xs.begin(), xs.end(), cmp);
  }

  template <class T, class PathContainer, class F>
  static T fold(PathContainer& xs, T init, F f) {
    auto b = xs.begin();
    auto e = xs.end();
    return b != e ? std::accumulate(b, e, init, f) : static_cast<T>(0);
  }

  /// Finds the path for `ptr` and returns a pointer to it.
  template <class PathContainer, class Handle>
  static path_ptr find(PathContainer& xs, const stream_id& sid,
                       const Handle& x) {
    auto predicate = [&](const typename PathContainer::value_type& y) {
      return y->hdl == x && y->sid == sid;
    };
    auto e = xs.end();
    auto i = std::find_if(xs.begin(), e, predicate);
    if (i != e)
      return &(*(*i)); // Ugly, but works for both raw and smart pointers.
    return nullptr;
  }

  /// Finds the path for `ptr` and returns an iterator to it.
  template <class PathContainer, class Handle>
  static typename PathContainer::iterator
  iter_find(PathContainer& xs, const stream_id& sid, const Handle& x) {
    auto predicate = [&](const typename PathContainer::value_type& y) {
      return y->hdl == x && y->sid == sid;
    };
    return std::find_if(xs.begin(), xs.end(), predicate);
  }

  // -- accessors --------------------------------------------------------------

  /// Returns all available paths.
  inline const path_uptr_vec& paths() const {
    return paths_;
  }

  /// Returns a pointer to the parent actor.
  inline local_actor* self() const {
    return self_;
  }

  // -- reusable convenience functions -----------------------------------------

  using super::remove_path;

  bool remove_path(path_uptr_iter i, error reason, bool silent) {
    CAF_LOG_TRACE(CAF_ARG(reason) << CAF_ARG(silent));
    auto e = paths_.end();
    if (i == e) {
      CAF_LOG_DEBUG("unable to remove path");
      return false;
    }
    auto& p = *(*i);
    stream_aborter::del(p.hdl, self_->address(), p.sid, aborter_type);
    if (silent)
      p.hdl = nullptr;
    if (reason != none)
      p.shutdown_reason = std::move(reason);
    if (i != paths_.end() - 1)
      std::swap(*i, paths_.back());
    paths_.pop_back();
    return true;
  }

  // -- implementation of common methods ---------------------------------------

  bool remove_path(const stream_id& sid, const actor_addr& x,
                   error reason, bool silent) override {
    CAF_LOG_TRACE(CAF_ARG(sid) << CAF_ARG(x)
                  << CAF_ARG(reason) << CAF_ARG(silent));
    return remove_path(iter_find(paths_, sid, x), std::move(reason), silent);
  }

  void abort(error reason) override {
    auto i = paths_.begin();
    auto e = paths_.end();
    if (i != e) {
      // Handle last element separately after the loop.
      --e;
      for (; i != e; ++i)
        (*i)->shutdown_reason = reason;
      (*e)->shutdown_reason = std::move(reason);
      paths_.clear();
    }
  }

  long num_paths() const override {
    return static_cast<long>(paths_.size());
  }

  bool closed() const override {
    return !continuous_ && paths_.empty();
  }

  bool continuous() const override {
    return continuous_;
  }

  void continuous(bool value) override {
    continuous_ = value;
  }

  // -- implementation of identical methods in scatterer and gatherer  ---------

  path_ptr path_at(size_t index) override {
    return paths_[index].get();
  }

  using super::find;

  path_ptr find(const stream_id& sid, const actor_addr& x) override {
    return find(paths_, sid, x);
  }

protected:
  /// Adds a path to the edge without emitting messages.
  path_ptr add_path_impl(const stream_id& sid, strong_actor_ptr x) {
    CAF_LOG_TRACE(CAF_ARG(x) << CAF_ARG(sid));
    stream_aborter::add(x, self_->address(), sid, aborter_type);
    paths_.emplace_back(new path_type(self_, sid, std::move(x)));
    return paths_.back().get();
  }

  template <class F>
  void close_impl(F f) {
    for (auto& x : paths_) {
      stream_aborter::del(x->hdl, self_->address(), x->sid, aborter_type);
      f(*x);
    }
    paths_.clear();
  }

  local_actor* self_;
  path_uptr_vec paths_;
  bool continuous_;
};

} // namespace caf

#endif // CAF_STREAM_EDGE_IMPL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MIXIN_BEHAVIOR_CHANGER_HPP
#define CAF_MIXIN_BEHAVIOR_CHANGER_HPP

#include <type_traits>

#include "caf/fwd.hpp"
#include "caf/message_id.hpp"
#include "caf/local_actor.hpp"
#include "caf/actor_marker.hpp"
#include "caf/typed_behavior.hpp"
#include "caf/behavior_policy.hpp"
#include "caf/response_handle.hpp"

#include "caf/mixin/sender.hpp"
#include "caf/mixin/requester.hpp"

namespace caf {
namespace mixin {

/// A `behavior_changer` is an actor that supports
/// `self->become(...)` and `self->unbecome()`.
template <class Base, class Subtype>
class behavior_changer : public Base {
public:
  // -- member types -----------------------------------------------------------

  using extended_base = behavior_changer;

  using behavior_type = typename behavior_type_of<Subtype>::type;

  // -- constructors, destructors, and assignment operators --------------------

  template <class... Ts>
  behavior_changer(Ts&&... xs) : Base(std::forward<Ts>(xs)...) {
    // nop
  }

  // -- behavior management ----------------------------------------------------

  void become(behavior_type bhvr) {
    dptr()->do_become(std::move(bhvr.unbox()), true);
  }

  void become(const keep_behavior_t&, behavior_type bhvr) {
    dptr()->do_become(std::move(bhvr.unbox()), false);
  }

  template <class T0, class T1, class... Ts>
  typename std::enable_if<
    !std::is_same<keep_behavior_t, typename std::decay<T0>::type>::value
  >::type
  become(T0&& x0, T1&& x1, Ts&&... xs) {
    behavior_type bhvr{std::forward<T0>(x0),
                       std::forward<T1>(x1),
                       std::forward<Ts>(xs)...};
    dptr()->do_become(std::move(bhvr.unbox()), true);
  }

  template <class T0, class T1, class... Ts>
  void become(const keep_behavior_t&, T0&& x0, T1&& x1, Ts&&... xs) {
    behavior_type bhvr{std::forward<T0>(x0),
                       std::forward<T1>(x1),
                       std::forward<Ts>(xs)...};
    dptr()->do_become(std::move(bhvr.unbox()), false);
  }

  void unbecome() {
    dptr()->bhvr_stack_.pop_back();
  }

private:
  Subtype* dptr() {
    return static_cast<Subtype*>(this);
  }
};

} // namespace mixin
} // namespace caf

#endif // CAF_MIXIN_BEHAVIOR_CHANGER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MIXIN_SUBSCRIBER_HPP
#define CAF_MIXIN_SUBSCRIBER_HPP

#include <unordered_set>

#include "caf/fwd.hpp"
#include "caf/group.hpp"

namespace caf {
namespace mixin {

/// Marker for `subscriber`.
struct subscriber_base {};

/// A `subscriber` is an actor that can subscribe
/// to a `group` via `self->join(...)`.
template <class Base, class Subtype>
class subscriber : public Base, public subscriber_base {
public:
  // -- member types -----------------------------------------------------------

  /// Allows subtypes to refer mixed types with a simple name.
  using extended_base = subscriber;

  /// A container for storing subscribed groups.
  using subscriptions = std::unordered_set<group>;

  // -- constructors, destructors, and assignment operators --------------------

  template <class... Ts>
  subscriber(actor_config& cfg, Ts&&... xs)
      : Base(cfg, std::forward<Ts>(xs)...) {
    if (cfg.groups != nullptr)
      for (auto& grp : *cfg.groups)
        join(grp);
  }

  // -- overridden functions of monitorable_actor ------------------------------

  bool cleanup(error&& fail_state, execution_unit* ptr) override {
    auto me = dptr()->ctrl();
    for (auto& subscription : subscriptions_)
      subscription->unsubscribe(me);
    subscriptions_.clear();
    return Base::cleanup(std::move(fail_state), ptr);
  }

  // -- group management -------------------------------------------------------

  /// Causes this actor to subscribe to the group `what`.
  /// The group will be unsubscribed if the actor finishes execution.
  void join(const group& what) {
    CAF_LOG_TRACE(CAF_ARG(what));
    if (what == invalid_group)
      return;
    if (what->subscribe(dptr()->ctrl()))
      subscriptions_.emplace(what);
  }

  /// Causes this actor to leave the group `what`.
  void leave(const group& what) {
    CAF_LOG_TRACE(CAF_ARG(what));
    if (subscriptions_.erase(what) > 0)
      what->unsubscribe(dptr()->ctrl());
  }

  /// Returns all subscribed groups.
  const subscriptions& joined_groups() const {
    return subscriptions_;
  }

private:
  Subtype* dptr() {
    return static_cast<Subtype*>(this);
  }

  // -- data members -----------------------------------------------------------

  /// Stores all subscribed groups.
  subscriptions subscriptions_;
};

} // namespace mixin
} // namespace caf

#endif // CAF_MIXIN_SUBSCRIBER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MIXIN_ACTOR_WIDGET_HPP
#define CAF_MIXIN_ACTOR_WIDGET_HPP

#include "caf/config.hpp"
#include "caf/make_actor.hpp"
#include "caf/actor_companion.hpp"
#include "caf/message_handler.hpp"

#include "caf/scoped_execution_unit.hpp"

CAF_PUSH_WARNINGS
#include <QEvent>
#include <QApplication>
CAF_POP_WARNINGS

namespace caf {
namespace mixin {

template<typename Base, int EventId = static_cast<int>(QEvent::User + 31337)>
class actor_widget : public Base {
public:
  struct event_type : public QEvent {
    mailbox_element_ptr mptr;
    event_type(mailbox_element_ptr ptr)
        : QEvent(static_cast<QEvent::Type>(EventId)), mptr(std::move(ptr)) {
      // nop
    }
  };

  template <typename... Ts>
  actor_widget(Ts&&... xs) : Base(std::forward<Ts>(xs)...), alive_(false) {
    // nop
  }

  ~actor_widget() {
    if (companion_)
      self()->cleanup(error{}, &dummy_);
  }


  void init(actor_system& system) {
    alive_ = true;
    companion_ = actor_cast<strong_actor_ptr>(system.spawn<actor_companion>());
    self()->on_enqueue([=](mailbox_element_ptr ptr) {
      qApp->postEvent(this, new event_type(std::move(ptr)));
    });
    self()->on_exit([=] {
      // close widget if actor companion dies
      this->close();
    });
  }

  template <class F>
  void set_message_handler(F pfun) {
    self()->become(pfun(self()));
  }

  /// Terminates the actor companion and closes this widget.
  void quit_and_close(error exit_state = error{}) {
    self()->quit(std::move(exit_state));
    this->close();
  }

  bool event(QEvent* event) override {
    if (event->type() == static_cast<QEvent::Type>(EventId)) {
      auto ptr = dynamic_cast<event_type*>(event);
      if (ptr && alive_) {
        switch (self()->activate(&dummy_, *(ptr->mptr))) {
          default:
            break;
        };
        return true;
      }
    }
    return Base::event(event);
  }

  actor as_actor() const {
    CAF_ASSERT(companion_);
    return actor_cast<actor>(companion_);
  }

  actor_companion* self() {
    using bptr = abstract_actor*;  // base pointer
    using dptr = actor_companion*; // derived pointer
    return companion_ ? static_cast<dptr>(actor_cast<bptr>(companion_))
                      : nullptr;
  }

private:

  scoped_execution_unit dummy_;
  strong_actor_ptr companion_;
  bool alive_;
};

} // namespace mixin
} // namespace caf

#endif // CAF_MIXIN_ACTOR_WIDGET_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MIXIN_REQUESTER_HPP
#define CAF_MIXIN_REQUESTER_HPP

#include <tuple>
#include <chrono>

#include "caf/fwd.hpp"
#include "caf/actor.hpp"
#include "caf/message.hpp"
#include "caf/duration.hpp"
#include "caf/message_id.hpp"
#include "caf/response_type.hpp"
#include "caf/response_handle.hpp"
#include "caf/message_priority.hpp"
#include "caf/check_typed_input.hpp"

namespace caf {
namespace mixin {

template <class T>
struct is_blocking_requester : std::false_type { };

/// A `requester` is an actor that supports
/// `self->request(...).{then|await|receive}`.
template <class Base, class Subtype>
class requester : public Base {
public:
  // -- member types -----------------------------------------------------------

  using extended_base = requester;

  // -- constructors, destructors, and assignment operators --------------------

  template <class... Ts>
  requester(Ts&&... xs) : Base(std::forward<Ts>(xs)...) {
    // nop
  }

  // -- request ----------------------------------------------------------------

  /// Sends `{xs...}` as a synchronous message to `dest` with priority `mp`.
  /// @returns A handle identifying a future-like handle to the response.
  /// @warning The returned handle is actor specific and the response to the
  ///          sent message cannot be received by another actor.
  template <message_priority P = message_priority::normal,
            class Handle = actor, class... Ts>
  response_handle<Subtype,
                  response_type_t<
                    typename Handle::signatures,
                    typename detail::implicit_conversions<
                      typename std::decay<Ts>::type
                    >::type...>,
                  is_blocking_requester<Subtype>::value>
  request(const Handle& dest, const duration& timeout, Ts&&... xs) {
    static_assert(sizeof...(Ts) > 0, "no message to send");
    using token =
      detail::type_list<
        typename detail::implicit_conversions<
          typename std::decay<Ts>::type
        >::type...>;
    static_assert(response_type_unbox<signatures_of_t<Handle>, token>::valid,
                  "receiver does not accept given message");
    auto dptr = static_cast<Subtype*>(this);
    auto req_id = dptr->new_request_id(P);
    if (dest) {
      dest->eq_impl(req_id, dptr->ctrl(), dptr->context(),
                    std::forward<Ts>(xs)...);
      dptr->request_response_timeout(timeout, req_id);
    } else {
      dptr->eq_impl(req_id.response_id(), dptr->ctrl(), dptr->context(),
                    make_error(sec::invalid_argument));
    }
    return {req_id.response_id(), dptr};
   }

  /// Sends `{xs...}` as a synchronous message to `dest` with priority `mp`.
  /// @returns A handle identifying a future-like handle to the response.
  /// @warning The returned handle is actor specific and the response to the
  ///          sent message cannot be received by another actor.
  template <message_priority P = message_priority::normal,
            class Rep = int, class Period = std::ratio<1>,
            class Handle = actor, class... Ts>
  response_handle<Subtype,
                  response_type_t<
                    typename Handle::signatures,
                    typename detail::implicit_conversions<
                      typename std::decay<Ts>::type
                    >::type...>,
                  is_blocking_requester<Subtype>::value>
  request(const Handle& dest, std::chrono::duration<Rep, Period> timeout,
          Ts&&... xs) {
    return request(dest, duration{timeout}, std::forward<Ts>(xs)...);
  }
};

} // namespace mixin
} // namespace caf

#endif // CAF_MIXIN_REQUESTER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MIXIN_SENDER_HPP
#define CAF_MIXIN_SENDER_HPP

#include <tuple>
#include <chrono>

#include "caf/fwd.hpp"
#include "caf/actor.hpp"
#include "caf/message.hpp"
#include "caf/duration.hpp"
#include "caf/no_stages.hpp"
#include "caf/response_type.hpp"
#include "caf/response_handle.hpp"
#include "caf/message_priority.hpp"
#include "caf/check_typed_input.hpp"

namespace caf {
namespace mixin {

/// A `sender` is an actor that supports `self->send(...)`.
template <class Base, class Subtype>
class sender : public Base {
public:
  // -- member types -----------------------------------------------------------

  using extended_base = sender;

  // -- constructors, destructors, and assignment operators --------------------

  template <class... Ts>
  sender(Ts&&... xs) : Base(std::forward<Ts>(xs)...) {
    // nop
  }

  // -- send function family ---------------------------------------------------

  /// Sends `{xs...}` as a synchronous message to `dest` with priority `mp`.
  /// @warning The returned handle is actor specific and the response to the
  ///          sent message cannot be received by another actor.
  /// @throws std::invalid_argument if `dest == invalid_actor`
  template <message_priority P = message_priority::normal,
            class Dest = actor, class... Ts>
  void send(const Dest& dest, Ts&&... xs) {
    using detail::type_list;
    static_assert(sizeof...(Ts) > 0, "no message to send");
    using res_t = response_type<
                    signatures_of_t<Dest>,
                    detail::implicit_conversions_t<
                      typename std::decay<Ts>::type
                    >...>;
    static_assert(!statically_typed<Subtype>() || statically_typed<Dest>(),
                  "statically typed actors can only send() to other "
                  "statically typed actors; use anon_send() or request() when "
                  "communicating with dynamically typed actors");
    static_assert(res_t::valid, "receiver does not accept given message");
    static_assert(is_void_response<typename res_t::type>::value
                  || response_type_unbox<
                       signatures_of_t<Subtype>,
                       typename res_t::type
                     >::valid,
                  "this actor does not accept the response message");
    if (dest)
      dest->eq_impl(make_message_id(P), dptr()->ctrl(),
                    dptr()->context(), std::forward<Ts>(xs)...);
  }

  template <message_priority P = message_priority::normal,
            class Source = actor, class Dest = actor, class... Ts>
  void anon_send(const Dest& dest, Ts&&... xs) {
    static_assert(sizeof...(Ts) > 0, "no message to send");
    using token =
      detail::type_list<
        typename detail::implicit_conversions<
          typename std::decay<Ts>::type
        >::type...>;
    static_assert(response_type_unbox<
                    signatures_of_t<Dest>,
                    token
                  >::valid,
                  "receiver does not accept given message");
    if (dest)
      dest->eq_impl(make_message_id(P), nullptr,
                    dptr()->context(), std::forward<Ts>(xs)...);
  }

  template <message_priority P = message_priority::normal, class Rep = int,
            class Period = std::ratio<1>, class Dest = actor, class... Ts>
  void delayed_send(const Dest& dest, std::chrono::duration<Rep, Period> rtime,
                    Ts&&... xs) {
    using token =
      detail::type_list<
        typename detail::implicit_conversions<
          typename std::decay<Ts>::type
        >::type...>;
    static_assert(!statically_typed<Subtype>() || statically_typed<Dest>(),
                  "statically typed actors are only allowed to send() to other "
                  "statically typed actors; use anon_send() or request() when "
                  "communicating with dynamically typed actors");
    static_assert(response_type_unbox<
                    signatures_of_t<Dest>,
                    token
                  >::valid,
                  "receiver does not accept given message");
    // TODO: this only checks one way, we should check for loops
    static_assert(is_void_response<
                    typename response_type<
                      signatures_of_t<Dest>,
                      detail::implicit_conversions_t<
                        typename std::decay<Ts>::type
                      >...
                    >::type
                  >::value
                  ||  response_type_unbox<
                        signatures_of_t<Subtype>,
                        typename response_type<
                          signatures_of_t<Dest>,
                          detail::implicit_conversions_t<
                            typename std::decay<Ts>::type
                          >...
                        >::type
                      >::valid,
                  "this actor does not accept the response message");
    if (dest) {
      auto& clock = dptr()->system().clock();
      auto t = clock.now() + rtime;
      auto me = make_mailbox_element(dptr()->ctrl(), make_message_id(P),
                                     no_stages, std::forward<Ts>(xs)...);
      clock.schedule_message(t, actor_cast<strong_actor_ptr>(dest),
                             std::move(me));
    }
  }

  template <message_priority P = message_priority::normal, class Rep = int,
            class Period = std::ratio<1>, class Source = actor,
            class Dest = actor, class... Ts>
  void delayed_anon_send(const Dest& dest,
                         std::chrono::duration<Rep, Period> rtime, Ts&&... xs) {
    static_assert(sizeof...(Ts) > 0, "no message to send");
    using token =
      detail::type_list<
        typename detail::implicit_conversions<
          typename std::decay<Ts>::type
        >::type...>;
    static_assert(response_type_unbox<
                    signatures_of_t<Dest>,
                    token
                  >::valid,
                  "receiver does not accept given message");
    if (dest) {
      auto& clock = dptr()->system().clock();
      auto t = clock.now() + rtime;
      auto me = make_mailbox_element(nullptr, make_message_id(P), no_stages,
                                     std::forward<Ts>(xs)...);
      clock.schedule_message(t, actor_cast<strong_actor_ptr>(dest),
                             std::move(me));
    }
  }

private:
  Subtype* dptr() {
    return static_cast<Subtype*>(this);
  }
};

} // namespace mixin
} // namespace caf

#endif // CAF_MIXIN_SENDER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_CONFIG_OPTION_HPP
#define CAF_CONFIG_OPTION_HPP

#include <memory>
#include <string>
#include <vector>
#include <cstdint>
#include <cstring>
#include <functional>

#include "caf/atom.hpp"
#include "caf/error.hpp"
#include "caf/message.hpp"
#include "caf/variant.hpp"
#include "caf/config_value.hpp"
#include "caf/deep_to_string.hpp"
#include "caf/static_visitor.hpp"

#include "caf/detail/type_traits.hpp"

namespace caf {

extern const char* type_name_visitor_tbl[];

/// Helper class to generate config readers for different input types.
class config_option {
public:
  using config_reader_sink = std::function<void (size_t, config_value&,
                                                 optional<std::ostream&>)>;

  using legal_types = detail::type_list<bool, float, double, std::string,
                                        atom_value, int8_t, uint8_t, int16_t,
                                        uint16_t, int32_t, uint32_t, int64_t,
                                        uint64_t>;

  config_option(const char* cat, const char* nm, const char* expl);

  virtual ~config_option();

  inline const char* name() const {
    return name_.c_str();
  }

  inline char short_name() const {
    return short_name_;
  }

  inline const char* category() const {
    return category_;
  }

  inline const char* explanation() const {
    return explanation_;
  }

  /// Returns the full name for this config option as "<category>.<long name>".
  std::string full_name() const;

  /// Returns the held value as string.
  virtual std::string to_string() const = 0;

  /// Returns a sink function for config readers.
  virtual config_reader_sink to_sink() = 0;

  /// Returns a CLI argument parser.
  virtual message::cli_arg to_cli_arg(bool use_caf_prefix = false) = 0;

  /// Returns a human-readable type name for the visited type.
  class type_name_visitor : public static_visitor<const char*> {
  public:
    template <class T>
    const char* operator()(const T&) const {
      static constexpr bool is_int = std::is_integral<T>::value
                                     && !std::is_same<bool, T>::value;
      static constexpr std::integral_constant<bool, is_int> tk{};
      static constexpr int index = idx<T>(tk);
      static_assert(index >= 0, "illegal type in name visitor");
      return type_name_visitor_tbl[static_cast<size_t>(index)];
    }

  private:
    // Catches non-integer types.
    template <class T>
    static constexpr int idx(std::false_type) {
      return detail::tl_index_of<legal_types, T>::value;
    }

    // Catches integer types.
    template <class T>
    static constexpr int idx(std::true_type) {
      using squashed = detail::squashed_int_t<T>;
      return detail::tl_index_of<legal_types, squashed>::value;
    }
  };

protected:
  template <class T, class U>
  static bool assign_config_value(T& x, U& y) {
    x = std::move(y);
    return true;
  }

  // Catches any integer type that is smaller than int64_t.
  template <class T>
  static typename std::enable_if<sizeof(T) < sizeof(int64_t), bool>::type
  assign_config_value(T& x, int64_t& y) {
    if (y < static_cast<int64_t>(std::numeric_limits<T>::lowest())
        || y > static_cast<int64_t>(std::numeric_limits<T>::max()))
      return false;
    x = static_cast<T>(y);
    return true;
  }

  // Catches size_t and uint64_t (yes, they differ on some compilers).
  template <class T>
  static typename std::enable_if<std::is_unsigned<T>::value
                                 && sizeof(T) == sizeof(int64_t), bool>::type
  assign_config_value(T& x, int64_t& y) {
    if (y < 0)
      return false;
    x = static_cast<uint64_t>(y);
    return true;
  }

  static bool assign_config_value(float& x, double& y) {
    if (y < static_cast<double>(std::numeric_limits<float>::lowest())
        || y > static_cast<double>(std::numeric_limits<float>::max()))
      return false;
    x = static_cast<float>(y);
    return true;
  }

  void report_type_error(size_t ln, config_value& x, const char* expected,
                         optional<std::ostream&> out);

private:
  const char* category_;
  std::string name_;
  const char* explanation_;
  char short_name_;
};

template <class T,
          bool IsInsertable = detail::can_insert_elements<T>()
                              && !std::is_same<T, std::string>::value>
class config_option_impl : public config_option {
public:
  config_option_impl(T& ref, const char* ctg, const char* nm, const char* xp)
      : config_option(ctg, nm, xp),
        ref_(ref) {
    // nop
  }

  std::string to_string() const override {
    return deep_to_string(ref_);
  }

  message::cli_arg to_cli_arg(bool use_caf_prefix) override {
    std::string argname;
    if (use_caf_prefix)
      argname = "caf#";
    if (strcmp(category(), "global") != 0) {
      argname += category();
      argname += ".";
    }
    argname += name();
    if (short_name() != '\0') {
      argname += ',';
      argname += short_name();
    }
    return {std::move(argname), explanation(), ref_};
  }

  config_reader_sink to_sink() override {
    return [=](size_t ln, config_value& x, optional<std::ostream&> errors) {
      // the INI parser accepts all integers as int64_t
      // and all floating point numbers as doubles
      using cfg_type =
        typename std::conditional<
          std::is_integral<T>::value && !std::is_same<bool, T>::value,
          int64_t,
          typename std::conditional<
            std::is_floating_point<T>::value,
            double,
            T
            >::type
        >::type;
      if (get_if<cfg_type>(&x) && assign_config_value(ref_, get<cfg_type>(x)))
        return;
      type_name_visitor tnv;
      report_type_error(ln, x, tnv(ref_), errors);
    };
  }

private:
  T& ref_;
};

template <class T>
class config_option_impl<T, true> : public config_option {
public:
  using value_type = typename T::value_type;

  config_option_impl(T& ref, const char* ctg, const char* nm, const char* xp)
      : config_option(ctg, nm, xp),
        ref_(ref) {
    // nop
  }

  std::string to_string() const override {
    return deep_to_string(ref_);
  }

  message::cli_arg to_cli_arg(bool use_caf_prefix) override {
    std::string argname;
    if (use_caf_prefix)
      argname = "caf#";
    if (strcmp(category(), "global") != 0) {
      argname += category();
      argname += ".";
    }
    argname += name();
    if (short_name() != '\0') {
      argname += ',';
      argname += short_name();
    }
    return {std::move(argname), explanation(), ref_};
  }

  config_reader_sink to_sink() override {
    return [=](size_t ln, config_value& x, optional<std::ostream&> errors) {
      // the INI parser accepts all integers as int64_t
      // and all floating point numbers as doubles
      using cfg_type =
        typename std::conditional<
          std::is_integral<value_type>::value && 
                           !std::is_same<bool, value_type>::value,
          int64_t,
          typename std::conditional<
            std::is_floating_point<value_type>::value,
            double,
            value_type 
            >::type
        >::type;
      value_type tmp;
      if (get_if<cfg_type>(&x) && assign_config_value(tmp, get<cfg_type>(x))) {
        ref_.insert(ref_.end(), std::move(tmp));
        return;
      }
      type_name_visitor tnv;
      report_type_error(ln, x, tnv(tmp), errors);
    };
  }

private:
  T& ref_;
};


template <class T>
std::unique_ptr<config_option>
make_config_option(T& storage, const char* category,
                   const char* name, const char* explanation) {
  auto ptr = new config_option_impl<T>(storage, category, name, explanation);
  return std::unique_ptr<config_option>{ptr};
}

} // namespace caf

#endif // CAF_CONFIG_OPTION_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MESSAGE_BUILDER_HPP
#define CAF_MESSAGE_BUILDER_HPP

#include <vector>

#include "caf/fwd.hpp"
#include "caf/message.hpp"
#include "caf/message_handler.hpp"
#include "caf/type_erased_value.hpp"

namespace caf {

/// Provides a convenient interface for createing `message` objects
/// from a series of values using the member function `append`.
class message_builder {
public:
  friend class message;

  message_builder(const message_builder&) = delete;
  message_builder& operator=(const message_builder&) = delete;

  message_builder();
  ~message_builder();

  /// Creates a new instance and immediately calls `append(first, last)`.
  template <class Iter>
  message_builder(Iter first, Iter last) {
    init();
    append(first, last);
  }

  /// Appends all values in range [first, last).
  template <class Iter>
  message_builder& append(Iter first, Iter last) {
    for (; first != last; ++first)
      append(*first);
    return *this;
  }

  /// Adds `x` to the elements of the buffer.
  template <class T>
  message_builder& append(T&& x) {
    using type = typename unbox_message_element<
                   typename detail::implicit_conversions<
                    typename std::decay<T>::type
                   >::type
                 >::type;
    return emplace(make_type_erased_value<type>(std::forward<T>(x)));
  }

  inline message_builder& append_all() {
    return *this;
  }

  template <class T, class... Ts>
  message_builder& append_all(T&& x, Ts&&... xs) {
    append(std::forward<T>(x));
    return append_all(std::forward<Ts>(xs)...);
  }

  /// Converts the buffer to an actual message object without
  /// invalidating this message builder (nor clearing it).
  message to_message() const;

  /// Converts the buffer to an actual message object and transfers
  /// ownership of the data to it, leaving this object in an invalid state.
  /// @warning Calling *any*  member function on this object afterwards
  ///          is undefined behavior (dereferencing a `nullptr`)
  message move_to_message();

  /// @copydoc message::extract
  inline message extract(message_handler f) const {
    return to_message().extract(std::move(f));
  }

  /// @copydoc message::extract_opts
  inline message::cli_res extract_opts(std::vector<message::cli_arg> xs,
                                       message::help_factory f = nullptr,
                                       bool no_help = false) const {
    return to_message().extract_opts(std::move(xs), std::move(f), no_help);
  }

  /// @copydoc message::apply
  optional<message> apply(message_handler handler);

  /// Removes all elements from the buffer.
  void clear();

  /// Returns whether the buffer is empty.
  bool empty() const;

  /// Returns the number of elements in the buffer.
  size_t size() const;

private:
  void init();

  message_builder& emplace(type_erased_value_ptr);

  detail::dynamic_message_data* data();

  const detail::dynamic_message_data* data() const;

  intrusive_ptr<ref_counted> data_; // hide dynamic_message_data implementation
};

} // namespace caf

#endif // CAF_MESSAGE_BUILDER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_STREAM_SCATTERER_HPP
#define CAF_STREAM_SCATTERER_HPP

#include <cstddef>

#include "caf/fwd.hpp"
#include "caf/duration.hpp"
#include "caf/optional.hpp"
#include "caf/mailbox_element.hpp"

namespace caf {

/// Type-erased policy for dispatching data to sinks.
class stream_scatterer {
public:
  // -- member types -----------------------------------------------------------

  using path_type = outbound_path;

  using path_ptr = path_type*;

  // -- constructors, destructors, and assignment operators --------------------

  stream_scatterer() = default;

  virtual ~stream_scatterer();

  // -- pure virtual memeber functions -----------------------------------------

  /// Adds a path to the edge.
  /// @returns The added path on success, `nullptr` otherwise.
  virtual path_ptr add_path(const stream_id& sid, strong_actor_ptr origin,
                            strong_actor_ptr sink_ptr,
                            mailbox_element::forwarding_stack stages,
                            message_id handshake_mid, message handshake_data,
                            stream_priority prio, bool redeployable) = 0;

  /// Adds a path to a sink and initiates the handshake.
  virtual path_ptr confirm_path(const stream_id& sid, const actor_addr& from,
                                strong_actor_ptr to, long initial_demand,
                                bool redeployable) = 0;

  /// Removes a path from the scatterer.
  virtual bool remove_path(const stream_id& sid, const actor_addr& x,
                           error reason, bool silent) = 0;

  /// Returns `true` if there is no data pending and no unacknowledged batch on
  /// any path.
  virtual bool paths_clean() const = 0;

  /// Removes all paths gracefully.
  virtual void close() = 0;

  /// Removes all paths with an error message.
  virtual void abort(error reason) = 0;

  /// Returns the number of paths managed on this edge.
  virtual long num_paths() const = 0;

  /// Returns `true` if no downstream exists, `false` otherwise.
  virtual bool closed() const = 0;

  /// Returns whether this edge remains open after the last path is removed.
  virtual bool continuous() const = 0;

  /// Sets whether this edge remains open after the last path is removed.
  virtual void continuous(bool value) = 0;

  /// Sends batches to sinks.
  virtual void emit_batches() = 0;

  /// Returns the stored state for `x` if `x` is a known path and associated to
  /// `sid`, otherwise `nullptr`.
  virtual path_ptr find(const stream_id& sid, const actor_addr& x) = 0;

  /// Returns the stored state for `x` if `x` is a known path and associated to
  /// `sid`, otherwise `nullptr`.
  virtual path_ptr path_at(size_t index) = 0;

  /// Returns the currently available credit, depending on the policy in use.
  /// For example, a broadcast policy would return the minimum of all available
  /// downstream credits.
  virtual long credit() const = 0;

  /// Returns the size of the output buffer.
  virtual long buffered() const = 0;

  /// Minimum amount of messages required to emit a batch. A value of 0
  /// disables batch delays.
  virtual long min_batch_size() const = 0;

  /// Maximum amount of messages to put into a single batch. Causes the actor
  /// to split a buffer into more batches if necessary.
  virtual long max_batch_size() const = 0;

  /// Minimum amount of messages we wish to store at the actor in order to emit
  /// new batches immediately when receiving new downstream demand.
  virtual long min_buffer_size() const = 0;

  /// Forces to actor to emit a batch even if the minimum batch size was not
  /// reached.
  virtual duration max_batch_delay() const = 0;

  /// Minimum amount of messages required to emit a batch. A value of 0
  /// disables batch delays.
  virtual void min_batch_size(long x) = 0;

  /// Maximum amount of messages to put into a single batch. Causes the actor
  /// to split a buffer into more batches if necessary.
  virtual void max_batch_size(long x) = 0;

  /// Minimum amount of messages we wish to store at the actor in order to emit
  /// new batches immediately when receiving new downstream demand.
  virtual void min_buffer_size(long x) = 0;

  /// Forces to actor to emit a batch even if the minimum batch size was not
  /// reached.
  virtual void max_batch_delay(duration x) = 0;

  // -- convenience functions --------------------------------------------------

  /// Removes a path from the scatterer.
  bool remove_path(const stream_id& sid, const strong_actor_ptr& x,
                   error reason, bool silent);

  /// Convenience function for calling `find(x, actor_cast<actor_addr>(x))`.
  path_ptr find(const stream_id& sid, const strong_actor_ptr& x);
};

} // namespace caf

#endif // CAF_STREAM_SCATTERER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TYPED_ACTOR_HPP
#define CAF_TYPED_ACTOR_HPP

#include <cstddef>

#include "caf/actor.hpp"
#include "caf/make_actor.hpp"
#include "caf/actor_cast.hpp"
#include "caf/replies_to.hpp"
#include "caf/actor_system.hpp"
#include "caf/intrusive_ptr.hpp"
#include "caf/composed_type.hpp"
#include "caf/abstract_actor.hpp"
#include "caf/stateful_actor.hpp"
#include "caf/typed_behavior.hpp"
#include "caf/typed_response_promise.hpp"
#include "caf/unsafe_actor_handle_init.hpp"

#include "caf/detail/mpi_splice.hpp"
#include "caf/decorator/splitter.hpp"
#include "caf/decorator/sequencer.hpp"

namespace caf {

template <class... Sigs>
class typed_event_based_actor;

namespace io {

template <class... Sigs>
class typed_broker;

} // namespace io

/// Identifies a statically typed actor.
/// @tparam Sigs Signature of this actor as `replies_to<...>::with<...>`
///              parameter pack.
template <class... Sigs>
class typed_actor : detail::comparable<typed_actor<Sigs...>>,
                    detail::comparable<typed_actor<Sigs...>, actor>,
                    detail::comparable<typed_actor<Sigs...>, actor_addr>,
                    detail::comparable<typed_actor<Sigs...>, strong_actor_ptr> {
 public:
  static_assert(sizeof...(Sigs) > 0, "Empty typed actor handle");

  // -- friend types that need access to private ctors
  friend class local_actor;

  template <class>
  friend class data_processor;

  template <class>
  friend class detail::type_erased_value_impl;

  template <class...>
  friend class typed_actor;

  // allow conversion via actor_cast
  template <class, class, int>
  friend class actor_cast_access;

  // tell actor_cast which semantic this type uses
  static constexpr bool has_weak_ptr_semantics = false;

  /// Creates a new `typed_actor` type by extending this one with `Es...`.
  template <class... Es>
  using extend = typed_actor<Sigs..., Es...>;

  /// Creates a new `typed_actor` type by extending this one with another
  /// `typed_actor`.
  template <class... Ts>
  using extend_with =
    typename detail::extend_with_helper<typed_actor, Ts...>::type;

  /// Identifies the behavior type actors of this kind use
  /// for their behavior stack.
  using behavior_type = typed_behavior<Sigs...>;

  /// Identifies pointers to instances of this kind of actor.
  using pointer = typed_event_based_actor<Sigs...>*;

  /// Identifies the base class for this kind of actor.
  using base = typed_event_based_actor<Sigs...>;

  /// Identifies pointers to brokers implementing this interface.
  using broker_pointer = io::typed_broker<Sigs...>*;

  /// Identifies the base class of brokers implementing this interface.
  using broker_base = io::typed_broker<Sigs...>;

  /// Stores the template parameter pack.
  using signatures = detail::type_list<Sigs...>;

  /// Identifies the base class for this kind of actor with actor.
  template <class State>
  using stateful_base = stateful_actor<State, base>;

  /// Identifies the base class for this kind of actor with actor.
  template <class State>
  using stateful_pointer = stateful_actor<State, base>*;

  /// Identifies the broker_base class for this kind of actor with actor.
  template <class State>
  using stateful_broker_base =
    stateful_actor<State, broker_base>;

  /// Identifies the broker_base class for this kind of actor with actor.
  template <class State>
  using stateful_broker_pointer =
    stateful_actor<State, broker_base>*;

  typed_actor() = default;
  typed_actor(typed_actor&&) = default;
  typed_actor(const typed_actor&) = default;
  typed_actor& operator=(typed_actor&&) = default;
  typed_actor& operator=(const typed_actor&) = default;

  template <class... Ts>
  typed_actor(const typed_actor<Ts...>& other) : ptr_(other.ptr_) {
    static_assert(detail::tl_subset_of<
                    signatures,
                    detail::type_list<Ts...>
                  >::value,
                  "Cannot assign incompatible handle");
  }

  // allow `handle_type{this}` for typed actors
  template <class T>
  typed_actor(T* ptr,
              typename std::enable_if<
                std::is_base_of<statically_typed_actor_base, T>::value
              >::type* = 0)
      : ptr_(ptr->ctrl()) {
    static_assert(detail::tl_subset_of<
                    signatures,
                    typename T::signatures
                  >::value,
                  "Cannot assign T* to incompatible handle type");
    CAF_ASSERT(ptr != nullptr);
  }

  template <class... Ts>
  typed_actor& operator=(const typed_actor<Ts...>& other) {
    static_assert(detail::tl_subset_of<
                    signatures,
                    detail::type_list<Ts...>
                  >::value,
                  "Cannot assign incompatible handle");
    ptr_ = other.ptr_;
    return *this;
  }

  inline typed_actor& operator=(std::nullptr_t) {
    ptr_.reset();
    return *this;
  }

  explicit typed_actor(const unsafe_actor_handle_init_t&) CAF_DEPRECATED {
    // nop
  }

  /// Queries whether this actor handle is valid.
  inline explicit operator bool() const {
    return static_cast<bool>(ptr_);
  }

  /// Queries whether this actor handle is invalid.
  inline bool operator!() const {
    return !ptr_;
  }

  /// Queries the address of the stored actor.
  actor_addr address() const noexcept {
    return {ptr_.get(), true};
  }

  /// Returns the ID of this actor.
  actor_id id() const noexcept {
    return ptr_->id();
  }

  /// Returns the origin node of this actor.
  node_id node() const noexcept {
    return ptr_->node();
  }

  /// Returns the hosting actor system.
  inline actor_system& home_system() const noexcept {
    return *ptr_->home_system;
  }

  /// Exchange content of `*this` and `other`.
  void swap(typed_actor& other) noexcept {
    ptr_.swap(other.ptr_);
  }

  /// Queries whether this object was constructed using
  /// `unsafe_actor_handle_init` or is in moved-from state.
  bool unsafe() const CAF_DEPRECATED {
    return !ptr_;
  }

  /// @cond PRIVATE

  abstract_actor* operator->() const noexcept {
    return ptr_->get();
  }

  abstract_actor& operator*() const noexcept {
    return *ptr_->get();
  }

  intptr_t compare(const typed_actor& x) const noexcept {
    return actor_addr::compare(get(), x.get());
  }

  intptr_t compare(const actor& x) const noexcept {
    return actor_addr::compare(get(), actor_cast<actor_control_block*>(x));
  }

  intptr_t compare(const actor_addr& x) const noexcept {
    return actor_addr::compare(get(), actor_cast<actor_control_block*>(x));
  }

  intptr_t compare(const strong_actor_ptr& x) const noexcept {
    return actor_addr::compare(get(), actor_cast<actor_control_block*>(x));
  }

  typed_actor(actor_control_block* ptr, bool add_ref) : ptr_(ptr, add_ref) {
    // nop
  }

  friend inline std::string to_string(const typed_actor& x) {
    return to_string(x.ptr_);
  }

  friend inline void append_to_string(std::string& x, const typed_actor& y) {
    return append_to_string(x, y.ptr_);
  }

  template <class Inspector>
  friend typename Inspector::result_type inspect(Inspector& f, typed_actor& x) {
    return f(x.ptr_);
  }

  /// Releases the reference held by handle `x`. Using the
  /// handle after invalidating it is undefined behavior.
  friend void destroy(typed_actor& x) {
    x.ptr_.reset();
  }

  /// @endcond

private:
  actor_control_block* get() const noexcept {
    return ptr_.get();
  }

  actor_control_block* release() noexcept {
    return ptr_.release();
  }

  typed_actor(actor_control_block* ptr) : ptr_(ptr) {
    // nop
  }

  strong_actor_ptr ptr_;
};

/// @relates typed_actor
template <class... Xs, class... Ys>
bool operator==(const typed_actor<Xs...>& x,
                const typed_actor<Ys...>& y) noexcept {
  return actor_addr::compare(actor_cast<actor_control_block*>(x),
                             actor_cast<actor_control_block*>(y)) == 0;
}

/// @relates typed_actor
template <class... Xs, class... Ys>
bool operator!=(const typed_actor<Xs...>& x,
                const typed_actor<Ys...>& y) noexcept {
  return !(x == y);
}

/// @relates typed_actor
template <class... Xs>
bool operator==(const typed_actor<Xs...>& x, std::nullptr_t) noexcept {
  return actor_addr::compare(actor_cast<actor_control_block*>(x), nullptr) == 0;
}

/// @relates typed_actor
template <class... Xs>
bool operator==(std::nullptr_t, const typed_actor<Xs...>& x) noexcept {
  return actor_addr::compare(actor_cast<actor_control_block*>(x), nullptr) == 0;
}

/// @relates typed_actor
template <class... Xs>
bool operator!=(const typed_actor<Xs...>& x, std::nullptr_t) noexcept {
  return !(x == nullptr);
}

/// @relates typed_actor
template <class... Xs>
bool operator!=(std::nullptr_t, const typed_actor<Xs...>& x) noexcept {
  return !(x == nullptr);
}

/// Returns a new actor that implements the composition `f.g(x) = f(g(x))`.
/// @relates typed_actor
template <class... Xs, class... Ys>
composed_type_t<detail::type_list<Xs...>, detail::type_list<Ys...>>
operator*(typed_actor<Xs...> f, typed_actor<Ys...> g) {
  using result = composed_type_t<detail::type_list<Xs...>,
                                 detail::type_list<Ys...>>;
  auto& sys = g->home_system();
  auto mts = sys.message_types(detail::type_list<result>{});
  return make_actor<decorator::sequencer, result>(
    sys.next_actor_id(), sys.node(), &sys,
    actor_cast<strong_actor_ptr>(std::move(f)),
    actor_cast<strong_actor_ptr>(std::move(g)), std::move(mts));
}

template <class... Xs, class... Ts>
typename detail::mpi_splice<
  typed_actor,
  detail::type_list<Xs...>,
  typename Ts::signatures...
>::type
splice(const typed_actor<Xs...>& x, const Ts&... xs) {
  using result =
    typename detail::mpi_splice<
      typed_actor,
      detail::type_list<Xs...>,
      typename Ts::signatures...
    >::type;
  std::vector<strong_actor_ptr> tmp{actor_cast<strong_actor_ptr>(x),
                                    actor_cast<strong_actor_ptr>(xs)...};
  auto& sys = x->home_system();
  auto mts = sys.message_types(detail::type_list<result>{});
  return make_actor<decorator::splitter, result>(sys.next_actor_id(),
                                                 sys.node(), &sys,
                                                 std::move(tmp),
                                                 std::move(mts));
}

} // namespace caf

// allow typed_actor to be used in hash maps
namespace std {
template <class... Sigs>
struct hash<caf::typed_actor<Sigs...>> {
  size_t operator()(const caf::typed_actor<Sigs...>& ref) const {
    return ref ? static_cast<size_t>(ref->id()) : 0;
  }
};
} // namespace std

#endif // CAF_TYPED_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_MAKE_TYPE_ERASED_VIEW_HPP
#define CAF_MAKE_TYPE_ERASED_VIEW_HPP

#include <functional>

#include "caf/type_erased_value.hpp"

#include "caf/detail/type_erased_value_impl.hpp"

namespace caf {

/// @relates type_erased_value
/// Creates a type-erased view for `x`.
template <class T>
detail::type_erased_value_impl<std::reference_wrapper<T>>
make_type_erased_view(T& x) {
  return {std::ref(x)};
}

} // namespace caf

#endif // CAF_MAKE_TYPE_ERASED_VIEW_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_ABSTRACT_ACTOR_HPP
#define CAF_ABSTRACT_ACTOR_HPP

#include <set>
#include <mutex>
#include <atomic>
#include <memory>
#include <string>
#include <vector>
#include <cstdint>
#include <type_traits>

#include "caf/fwd.hpp"
#include "caf/node_id.hpp"
#include "caf/attachable.hpp"
#include "caf/message_id.hpp"
#include "caf/exit_reason.hpp"
#include "caf/intrusive_ptr.hpp"
#include "caf/execution_unit.hpp"
#include "caf/mailbox_element.hpp"
#include "caf/abstract_channel.hpp"

#include "caf/detail/disposer.hpp"
#include "caf/detail/type_traits.hpp"
#include "caf/detail/functor_attachable.hpp"

namespace caf {

/// A unique actor ID.
/// @relates abstract_actor
using actor_id = uint64_t;

/// Denotes an ID that is never used by an actor.
constexpr actor_id invalid_actor_id = 0;

/// Base class for all actor implementations.
class abstract_actor : public abstract_channel {
public:
  // allow placement new (only)
  inline void* operator new(std::size_t, void* ptr) {
    return ptr;
  }

  actor_control_block* ctrl() const;

  ~abstract_actor() override;

  /// Cleans up any remaining state before the destructor is called.
  /// This function makes sure it is safe to call virtual functions
  /// in sub classes before destroying the object, because calling
  /// virtual function in the destructor itself is not safe. Any override
  /// implementation is required to call `super::destroy()` at the end.
  virtual void on_destroy();

  void enqueue(strong_actor_ptr sender, message_id mid,
               message msg, execution_unit* host) override;

  /// Enqueues a new message wrapped in a `mailbox_element` to the actor.
  /// This `enqueue` variant allows to define forwarding chains.
  virtual void enqueue(mailbox_element_ptr what, execution_unit* host) = 0;

  /// Attaches `ptr` to this actor. The actor will call `ptr->detach(...)` on
  /// exit, or immediately if it already finished execution.
  virtual void attach(attachable_ptr ptr) = 0;

  /// Convenience function that attaches the functor `f` to this actor. The
  /// actor executes `f()` on exit or immediatley if it is not running.
  template <class F>
  void attach_functor(F f) {
    attach(attachable_ptr{new detail::functor_attachable<F>(std::move(f))});
  }

  /// Returns the logical actor address.
  actor_addr address() const;

  /// Detaches the first attached object that matches `what`.
  virtual size_t detach(const attachable::token& what) = 0;

  /// Returns the set of accepted messages types as strings or
  /// an empty set if this actor is untyped.
  virtual std::set<std::string> message_types() const;

  /// Returns the ID of this actor.
  actor_id id() const noexcept;

  /// Returns the node this actor is living on.
  node_id node() const noexcept;

  /// Returns the system that created this actor (or proxy).
  actor_system& home_system() const noexcept;

  /****************************************************************************
   *                 here be dragons: end of public interface                 *
   ****************************************************************************/

  /// @cond PRIVATE

  template <class... Ts>
  void eq_impl(message_id mid, strong_actor_ptr sender,
               execution_unit* ctx, Ts&&... xs) {
    enqueue(make_mailbox_element(std::move(sender), mid,
                                 {}, std::forward<Ts>(xs)...),
            ctx);
  }

  // flags storing runtime information                     used by ...
  static constexpr int has_timeout_flag       = 0x0004; // single_timeout
  static constexpr int is_registered_flag     = 0x0008; // (several actors)
  static constexpr int is_initialized_flag    = 0x0010; // event-based actors
  static constexpr int is_blocking_flag       = 0x0020; // blocking_actor
  static constexpr int is_detached_flag       = 0x0040; // local_actor
  static constexpr int is_priority_aware_flag = 0x0080; // local_actor
  static constexpr int is_serializable_flag   = 0x0100; // local_actor
  static constexpr int is_migrated_from_flag  = 0x0200; // local_actor
  static constexpr int has_used_aout_flag     = 0x0400; // local_actor
  static constexpr int is_terminated_flag     = 0x0800; // local_actor
  static constexpr int is_cleaned_up_flag     = 0x1000; // monitorable_actor

  inline void setf(int flag) {
    auto x = flags();
    flags(x | flag);
  }

  inline void unsetf(int flag) {
    auto x = flags();
    flags(x & ~flag);
  }

  inline bool getf(int flag) const {
    return (flags() & flag) != 0;
  }

  /// Sets `is_registered_flag` and calls `system().registry().inc_running()`.
  void register_at_system();

  /// Unsets `is_registered_flag` and calls `system().registry().dec_running()`.
  void unregister_from_system();

  /// Causes the actor to establish a link to `other`.
  virtual void add_link(abstract_actor* other) = 0;

  /// Causes the actor to remove any established link to `other`.
  virtual void remove_link(abstract_actor* other) = 0;

  /// Adds an entry to `other` to the link table of this actor.
  /// @warning Must be called inside a critical section, i.e.,
  ///          while holding `mtx_`.
  virtual bool add_backlink(abstract_actor* other) = 0;

  /// Removes an entry to `other` from the link table of this actor.
  /// @warning Must be called inside a critical section, i.e.,
  ///          while holding `mtx_`.
  virtual bool remove_backlink(abstract_actor* other) = 0;

  /// Calls `fun` with exclusive access to an actor's state.
  template <class F>
  auto exclusive_critical_section(F fun) -> decltype(fun()) {
    std::unique_lock<std::mutex> guard{mtx_};
    return fun();
  }

  /// Calls `fun` with readonly access to an actor's state.
  template <class F>
  auto shared_critical_section(F fun) -> decltype(fun()) {
    std::unique_lock<std::mutex> guard{mtx_};
    return fun();
  }

  /// Calls `fun` with exclusive access to the state of both `p1` and `p2`. This
  /// function guarantees that the order of acquiring the locks is always
  /// identical, independently from the order of `p1` and `p2`.
  template <class F>
  static auto joined_exclusive_critical_section(abstract_actor* p1,
                                                abstract_actor* p2,
                                                F fun)
  -> decltype(fun()) {
    // Make sure to allocate locks always in the same order by starting on the
    // actor with the lowest address.
    CAF_ASSERT(p1 != p2 && p1 != nullptr && p2 != nullptr);
    if (p1 < p2) {
      std::unique_lock<std::mutex> guard1{p1->mtx_};
      std::unique_lock<std::mutex> guard2{p2->mtx_};
      return fun();
    }
    std::unique_lock<std::mutex> guard1{p2->mtx_};
    std::unique_lock<std::mutex> guard2{p1->mtx_};
    return fun();
  }

  /// @endcond

protected:
  /// Creates a new actor instance.
  explicit abstract_actor(actor_config& cfg);

  // Guards potentially concurrent access to the state. For example,
  // `exit_state_`, `attachables_`, and `links_` in a `monitorable_actor`.
  mutable std::mutex mtx_;

private:
  // prohibit copies, assigments, and heap allocations
  void* operator new(size_t);
  void* operator new[](size_t);
  abstract_actor(const abstract_actor&) = delete;
  abstract_actor& operator=(const abstract_actor&) = delete;
};

} // namespace caf

#endif // CAF_ABSTRACT_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/test/unit_test_impl.hpp"
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/all.hpp"
#include "caf/meta/annotation.hpp"
#include "caf/test/unit_test.hpp"

namespace {

struct wildcard { };

constexpr wildcard _ = wildcard{};

constexpr bool operator==(const wildcard&, const wildcard&) {
  return true;
}

template <size_t I, class T>
bool cmp_one(const caf::message& x, const T& y) {
  if (std::is_same<T, wildcard>::value)
    return true;
  return x.match_element<T>(I) && x.get_as<T>(I) == y;
}

template <size_t I, class... Ts>
typename std::enable_if<(I == sizeof...(Ts)), bool>::type
msg_cmp_rec(const caf::message&, const std::tuple<Ts...>&) {
  return true;
}

template <size_t I, class... Ts>
typename std::enable_if<(I < sizeof...(Ts)), bool>::type
msg_cmp_rec(const caf::message& x, const std::tuple<Ts...>& ys) {
  return cmp_one<I>(x, std::get<I>(ys)) && msg_cmp_rec<I + 1>(x, ys);
}

} // namespace <anonymous>

// allow comparing arbitrary `T`s to `message` objects for the purpose of the
// testing DSL
namespace caf {

template <class... Ts>
bool operator==(const message& x, const std::tuple<Ts...>& y) {
  return x.size() == sizeof...(Ts) && msg_cmp_rec<0>(x, y);
}

template <class T>
bool operator==(const message& x, const T& y) {
  return x.match_elements<T>() && x.get_as<T>(0) == y;
}

} // namespace caf

namespace {

// dummy function to force ADL later on
//int inspect(int, int);

template <class T>
struct has_outer_type {
  template <class U>
  static auto sfinae(U* x) -> typename U::outer_type*;

  template <class U>
  static auto sfinae(...) -> std::false_type;

  using type = decltype(sfinae<T>(nullptr));
  static constexpr bool value = !std::is_same<type, std::false_type>::value;
};

// enables ADL in `with_content`
template <class T, class U>
T get(const U&);

// enables ADL in `with_content`
template <class T, class U>
bool is(const U&);

template <class Tup>
class elementwise_compare_inspector {
public:
  using result_type = bool;

  template <size_t X>
  using pos = std::integral_constant<size_t, X>;

  elementwise_compare_inspector(const Tup& xs) : xs_(xs) {
    // nop
  }

  template <class... Ts>
  bool operator()(const Ts&... xs) {
    return iterate(pos<0>{}, xs...);
  }

private:
  template <size_t X>
  bool iterate(pos<X>) {
    // end of recursion
    return true;
  }

  template <size_t X, class T, class... Ts>
  typename std::enable_if<
    caf::meta::is_annotation<T>::value,
    bool
  >::type
  iterate(pos<X> pos, const T&, const Ts&... ys) {
    return iterate(pos, ys...);
  }

  template <size_t X, class T, class... Ts>
  typename std::enable_if<
    !caf::meta::is_annotation<T>::value,
    bool
  >::type
  iterate(pos<X>, const T& y, const Ts&... ys) {
    std::integral_constant<size_t, X + 1> next;
    check(y, get<X>(xs_));
    return iterate(next, ys...);
  }

  template <class T, class U>
  static void check(const T& x, const U& y) {
    CAF_CHECK_EQUAL(x, y);
  }

  template <class T>
  static void check(const T&, const wildcard&) {
    // nop
  }

  const Tup& xs_;
};

template <class Derived>
class expect_clause_base {
public:
  expect_clause_base(caf::scheduler::test_coordinator& sched)
      : sched_(sched),
        mock_dest_(false),
        dest_(nullptr) {
    // nop
  }

  expect_clause_base(expect_clause_base&& other)
      : sched_(other.sched_),
        src_(std::move(other.src_)) {
    // nop
  }

  Derived& from(const wildcard&) {
    return dref();
  }

  template <class Handle>
  Derived& from(const Handle& whom) {
    src_ = caf::actor_cast<caf::strong_actor_ptr>(whom);
    return dref();
  }

  template <class Handle>
  Derived& to(const Handle& whom) {
    CAF_REQUIRE(sched_.prioritize(whom));
    dest_ = &sched_.next_job<caf::scheduled_actor>();
    auto ptr = dest_->mailbox().peek();
    CAF_REQUIRE(ptr != nullptr);
    if (src_)
      CAF_REQUIRE_EQUAL(ptr->sender, src_);
    return dref();
  }

  Derived& to(const wildcard& whom) {
    CAF_REQUIRE(sched_.prioritize(whom));
    dest_ = &sched_.next_job<caf::scheduled_actor>();
    return dref();
  }

  Derived& to(const caf::scoped_actor& whom) {
    mock_dest_ = true;
    dest_ = whom.ptr();
    return dref();
  }

  template <class... Ts>
  std::tuple<const Ts&...> peek() {
    CAF_REQUIRE(dest_ != nullptr);
    auto ptr = dest_->mailbox().peek();
    if (!ptr->content().match_elements<Ts...>()) {
      CAF_FAIL("Message does not match expected pattern: " << to_string(ptr->content()));
    }
    //CAF_REQUIRE(ptr->content().match_elements<Ts...>());
    return ptr->content().get_as_tuple<Ts...>();
  }

protected:
  void run_once() {
    if (dynamic_cast<caf::blocking_actor*>(dest_) == nullptr)
      sched_.run_once();
    else // remove message from mailbox
      delete dest_->mailbox().try_pop();
  }

  Derived& dref() {
    return *static_cast<Derived*>(this);
  }

  // denotes whether destination is a mock actor, i.e., a scoped_actor without
  // functionality other than checking outputs of other actors
  caf::scheduler::test_coordinator& sched_;
  bool mock_dest_;
  caf::strong_actor_ptr src_;
  caf::local_actor* dest_;
};

template <class... Ts>
class expect_clause : public expect_clause_base<expect_clause<Ts...>> {
public:
  template <class... Us>
  expect_clause(Us&&... xs)
      : expect_clause_base<expect_clause<Ts...>>(std::forward<Us>(xs)...) {
    // nop
  }

  template <class... Us>
  void with(Us&&... xs) {
    auto tmp = std::make_tuple(std::forward<Us>(xs)...);
    elementwise_compare_inspector<decltype(tmp)> inspector{tmp};
    auto ys = this->template peek<Ts...>();
    CAF_CHECK(inspector(get<0>(ys)));
    this->run_once();
  }
};

/// The single-argument expect-clause allows to automagically unwrap T
/// if it's a variant-like wrapper.
template <class T>
class expect_clause<T> : public expect_clause_base<expect_clause<T>> {
public:
  template <class... Us>
  expect_clause(Us&&... xs)
      : expect_clause_base<expect_clause<T>>(std::forward<Us>(xs)...) {
    // nop
  }

  template <class... Us>
  void with(Us&&... xs) {
    std::integral_constant<bool, has_outer_type<T>::value> token;
    auto tmp = std::make_tuple(std::forward<Us>(xs)...);
    with_content(token, tmp);
    this->run_once();
  }

private:
  template <class U>
  void with_content(std::integral_constant<bool, false>, const U& x) {
    elementwise_compare_inspector<U> inspector{x};
    auto xs = this->template peek<T>();
    CAF_CHECK(inspector(get<0>(xs)));
  }

  template <class U>
  void with_content(std::integral_constant<bool, true>, const U& x) {
    elementwise_compare_inspector<U> inspector{x};
    auto xs = this->template peek<typename T::outer_type>();
    auto& x0 = get<0>(xs);
    if (!is<T>(x0)) {
      CAF_FAIL("is<T>(x0) !! " << caf::deep_to_string(x0));
    }
    CAF_CHECK(inspect(inspector, const_cast<T&>(get<T>(x0))));
  }

};

template <>
class expect_clause<void> : public expect_clause_base<expect_clause<void>> {
public:
  template <class... Us>
  expect_clause(Us&&... xs)
      : expect_clause_base<expect_clause<void>>(std::forward<Us>(xs)...) {
    // nop
  }

  void with() {
    CAF_REQUIRE(dest_ != nullptr);
    auto ptr = dest_->mailbox().peek();
    CAF_CHECK(ptr->content().empty());
    this->run_once();
  }
};

template <class Derived>
class disallow_clause_base {
public:
  disallow_clause_base(caf::scheduler::test_coordinator& sched)
      : sched_(sched),
        mock_dest_(false),
        dest_(nullptr) {
    // nop
  }

  disallow_clause_base(disallow_clause_base&& other)
      : sched_(other.sched_),
        src_(std::move(other.src_)) {
    // nop
  }

  Derived& from(const wildcard&) {
    return dref();
  }

  template <class Handle>
  Derived& from(const Handle& whom) {
    src_ = caf::actor_cast<caf::strong_actor_ptr>(whom);
    return dref();
  }

  template <class Handle>
  Derived& to(const Handle& whom) {
    // not setting dest_ causes the content checking to succeed immediately
    if (sched_.prioritize(whom)) {
      dest_ = &sched_.next_job<caf::scheduled_actor>();
    }
    return dref();
  }

  Derived& to(const wildcard& whom) {
    if (sched_.prioritize(whom))
      dest_ = &sched_.next_job<caf::scheduled_actor>();
  }

  Derived& to(const caf::scoped_actor& whom) {
    mock_dest_ = true;
    dest_ = whom.ptr();
    return dref();
  }

  template <class... Ts>
  caf::optional<std::tuple<const Ts&...>> peek() {
    CAF_REQUIRE(dest_ != nullptr);
    auto ptr = dest_->mailbox().peek();
    if (!ptr->content().match_elements<Ts...>())
      return caf::none;
    return ptr->content().get_as_tuple<Ts...>();
  }

protected:
  Derived& dref() {
    return *static_cast<Derived*>(this);
  }

  // denotes whether destination is a mock actor, i.e., a scoped_actor without
  // functionality other than checking outputs of other actors
  caf::scheduler::test_coordinator& sched_;
  bool mock_dest_;
  caf::strong_actor_ptr src_;
  caf::local_actor* dest_;
};

template <class... Ts>
class disallow_clause : public disallow_clause_base<disallow_clause<Ts...>> {
public:
  template <class... Us>
  disallow_clause(Us&&... xs)
      : disallow_clause_base<disallow_clause<Ts...>>(std::forward<Us>(xs)...) {
    // nop
  }

  template <class... Us>
  void with(Us&&... xs) {
    // succeed immediately if dest_ is empty
    if (this->dest_ == nullptr)
      return;
    auto tmp = std::make_tuple(std::forward<Us>(xs)...);
    elementwise_compare_inspector<decltype(tmp)> inspector{tmp};
    auto ys = this->template peek<Ts...>();
    if (ys && inspector(get<0>(*ys)))
      CAF_FAIL("disallowed message found: " << caf::deep_to_string(ys));
  }
};

/// The single-argument disallow-clause allows to automagically unwrap T
/// if it's a variant-like wrapper.
template <class T>
class disallow_clause<T> : public disallow_clause_base<disallow_clause<T>> {
public:
  template <class... Us>
  disallow_clause(Us&&... xs)
      : disallow_clause_base<disallow_clause<T>>(std::forward<Us>(xs)...) {
    // nop
  }

  template <class... Us>
  void with(Us&&... xs) {
    if (this->dest_ == nullptr)
      return;
    std::integral_constant<bool, has_outer_type<T>::value> token;
    auto tmp = std::make_tuple(std::forward<Us>(xs)...);
    with_content(token, tmp);
  }

private:
  template <class U>
  void with_content(std::integral_constant<bool, false>, const U& x) {
    elementwise_compare_inspector<U> inspector{x};
    auto xs = this->template peek<T>();
    if (xs && inspector(get<0>(*xs)))
      CAF_FAIL("disallowed message found: " << caf::deep_to_string(*xs));
  }

  template <class U>
  void with_content(std::integral_constant<bool, true>, const U& x) {
    elementwise_compare_inspector<U> inspector{x};
    auto xs = this->template peek<typename T::outer_type>();
    if (!xs)
      return;
    auto& x0 = get<0>(*xs);
    if (is<T>(x0) && inspect(inspector, const_cast<T&>(get<T>(x0))))
      CAF_FAIL("disallowed message found: " << caf::deep_to_string(x0));
  }

};

template <>
class disallow_clause<void>
  : public disallow_clause_base<disallow_clause<void>> {
public:
  template <class... Us>
  disallow_clause(Us&&... xs)
      : disallow_clause_base<disallow_clause<void>>(std::forward<Us>(xs)...) {
    // nop
  }

  void with() {
    if (dest_ == nullptr)
      return;
    auto ptr = dest_->mailbox().peek();
    CAF_REQUIRE(!ptr->content().empty());
  }
};

template <class Config = caf::actor_system_config>
struct test_coordinator_fixture {
  using scheduler_type = caf::scheduler::test_coordinator;

  Config cfg;
  caf::actor_system sys;
  caf::scoped_actor self;
  scheduler_type& sched;

  test_coordinator_fixture()
      : sys(cfg.parse(caf::test::engine::argc(), caf::test::engine::argv())
               .set("scheduler.policy", caf::atom("testing"))),
        self(sys),
        sched(dynamic_cast<scheduler_type&>(sys.scheduler())) {
    // nop
  }

  template <class T = int>
  caf::expected<T> fetch_result() {
    caf::expected<T> result = caf::error{};
    self->receive(
      [&](T& x) {
        result = std::move(x);
      },
      [&](caf::error& x) {
        result = std::move(x);
      },
      caf::after(std::chrono::seconds(0)) >> [&] {
        result = caf::sec::request_timeout;
      }
    );
    return result;
  }

  template <class T>
  const T& peek() {
    return sched.template peek<T>();
  }

  template <class T = caf::scheduled_actor, class Handle = caf::actor>
  T& deref(const Handle& hdl) {
    auto ptr = caf::actor_cast<caf::abstract_actor*>(hdl);
    CAF_REQUIRE(ptr != nullptr);
    return dynamic_cast<T&>(*ptr);
  }

  template <class... Ts>
  expect_clause<Ts...> expect_impl() {
    return {sched};
  }

  template <class... Ts>
  disallow_clause<Ts...> disallow_impl() {
    return {sched};
  }
};

} // namespace <anonymous>

#define CAF_EXPAND(x) x
#define CAF_DSL_LIST(...) __VA_ARGS__

#define expect(types, fields)                                                  \
  CAF_MESSAGE("expect" << #types << "." << #fields);                           \
  expect_clause< CAF_EXPAND(CAF_DSL_LIST types) >{sched} . fields

#define disallow(types, fields)                                                \
  CAF_MESSAGE("disallow" << #types << "." << #fields);                         \
  disallow_clause< CAF_EXPAND(CAF_DSL_LIST types) >{sched} . fields
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TEST_UNIT_TEST_IMPL_HPP
#define CAF_TEST_UNIT_TEST_IMPL_HPP

#include <regex>
#include <cctype>
#include <thread>
#include <cassert>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <condition_variable>

#include "caf/config.hpp"

#ifndef CAF_WINDOWS
#include <unistd.h>
#endif

#include "caf/message_builder.hpp"
#include "caf/message_handler.hpp"
#include "caf/string_algorithms.hpp"

#include "caf/test/unit_test.hpp"

namespace caf {
namespace test {

class watchdog {
public:
   static void start(int secs);
   static void stop();

private:
  watchdog(int secs) {
    thread_ = std::thread{[=] {
      auto tp =
        std::chrono::high_resolution_clock::now() + std::chrono::seconds(secs);
        std::unique_lock<std::mutex> guard{mtx_};
      while (!canceled_
             && cv_.wait_until(guard, tp) != std::cv_status::timeout) {
        // spin
      }
      if (!canceled_) {
        logger::instance().error()
          << "WATCHDOG: unit test did not finish within "
          << secs << "s, abort\n";
        abort();
      }
    }};
  }
  ~watchdog() {
    { // lifetime scope of guard
      std::lock_guard<std::mutex> guard{mtx_};
      canceled_ = true;
      cv_.notify_all();
    }
    thread_.join();
  }

  volatile bool canceled_ = false;
  std::mutex mtx_;
  std::condition_variable cv_;
  std::thread thread_;
};

namespace { watchdog* s_watchdog; }

void watchdog::start(int secs) {
  if (secs > 0)
    s_watchdog = new watchdog(secs);
}

void watchdog::stop() {
  delete s_watchdog;
}

test::test(std::string test_name)
    : expected_failures_(0),
      name_(std::move(test_name)),
      good_(0),
      bad_(0) {
  // nop
}

test::~test() {
  // nop
}

size_t test::expected_failures() const {
  return expected_failures_;
}

void test::pass() {
  ++good_;
}

void test::fail(bool expected) {
  ++bad_;
  if (expected)
    ++expected_failures_;
}

const std::string& test::name() const {
  return name_;
}

namespace detail {

[[noreturn]] void requirement_failed(const std::string& msg) {
  auto& log = logger::instance();
  log.error() << term::red << "     REQUIRED: " << msg
              << term::reset << '\n'
              << "     " << term::blue << engine::last_check_file()
              << term::yellow << ":" << term::cyan
              << engine::last_check_line() << term::reset
              << detail::fill(engine::last_check_line())
              << "had last successful check" << '\n';
  abort();
}

const char* fill(size_t line) {
  if (line < 10)
    return "    ";
  if (line < 100)
    return "   ";
  if (line < 1000)
    return "  ";
  return " ";
}

void remove_trailing_spaces(std::string& x) {
  x.erase(std::find_if_not(x.rbegin(), x.rend(), ::isspace).base(), x.end());
}

bool check(test* parent, const char *file, size_t line,
           const char *expr, bool should_fail, bool result) {
  auto out = logger::instance().massive();
  if (result) {
    out << term::green << "** "
        << term::blue << file << term::yellow << ":"
        << term::blue << line << fill(line) << term::reset
        << expr << '\n';
    parent->pass();
  } else {
    out << term::red << "!! "
        << term::blue << file << term::yellow << ":"
        << term::blue << line << fill(line) << term::reset
        << expr << '\n';
    parent->fail(should_fail);
  }
  return result;
}

} // namespace detail

logger::stream::stream(logger& parent, logger::level lvl)
    : parent_(parent),
      lvl_(lvl) {
  // nop
}

bool logger::init(int lvl_cons, int lvl_file, const std::string& logfile) {
  instance().level_console_ = static_cast<level>(lvl_cons);
  instance().level_file_ = static_cast<level>(lvl_file);
  if (!logfile.empty()) {
    instance().file_.open(logfile, std::ofstream::out | std::ofstream::app);
    return !!instance().file_;
  }
  return true;
}

logger& logger::instance() {
  static logger l;
  return l;
}

logger::stream logger::error() {
  return stream{*this, level::error};
}

logger::stream logger::info() {
  return stream{*this, level::info};
}

logger::stream logger::verbose() {
  return stream{*this, level::verbose};
}

logger::stream logger::massive() {
  return stream{*this, level::massive};
}

void logger::disable_colors() {
  // Disable colors by piping all writes through dummy_.
  // Since dummy_ is not a TTY, colors are turned off implicitly.
  dummy_.copyfmt(std::cerr);
  dummy_.clear(std::cerr.rdstate());
  dummy_.basic_ios<char>::rdbuf(std::cerr.rdbuf());
  console_ = &dummy_;
}

logger::logger()
    : level_console_(level::error),
      level_file_(level::error),
      console_(&std::cerr) {
  // nop
}

void engine::args(int argc, char** argv) {
  instance().argc_ = argc;
  instance().argv_ = argv;
}

int engine::argc() {
  return instance().argc_;
}

char** engine::argv() {
  return instance().argv_;
}

void engine::path(char* argv) {
  instance().path_ = argv;
}

char* engine::path() {
  return instance().path_;
}

int engine::max_runtime() {
  return instance().max_runtime_;
}

void engine::max_runtime(int value) {
  instance().max_runtime_ = value;
}

void engine::add(const char* cstr_name, std::unique_ptr<test> ptr) {
  std::string name = cstr_name != nullptr ? cstr_name : "";
  auto& suite = instance().suites_[name];
  for (auto& x : suite) {
    if (x->name() == ptr->name()) {
      std::cerr << "duplicate test name: " << ptr->name() << std::endl;
      std::abort();
    }
  }
  suite.emplace_back(std::move(ptr));
}

bool engine::run(bool colorize,
                 const std::string& log_file,
                 int verbosity_console,
                 int verbosity_file,
                 const std::string& suites_str,
                 const std::string& not_suites_str,
                 const std::string& tests_str,
                 const std::string& not_tests_str) {
  if (not_suites_str == "*" || not_tests_str == "*") {
    // nothing to do
    return true;
  }
  instance().colorize_ = colorize;
  if (!logger::init(verbosity_console, verbosity_file, log_file)) {
    return false;
  }
  auto& log = logger::instance();
  if (!colorize)
    log.disable_colors();
  std::chrono::microseconds runtime{0};
  size_t total_suites = 0;
  size_t total_tests = 0;
  size_t total_good = 0;
  size_t total_bad = 0;
  size_t total_bad_expected = 0;
  auto bar = '+' + std::string(70, '-') + '+';
#if (!defined(__clang__) && defined(__GNUC__) && __GNUC__ == 4                 \
     && __GNUC_MINOR__ < 9)                                                    \
  || (defined(__clang__) && !defined(_LIBCPP_VERSION))
  // regex implementation is broken prior to 4.9
  using strvec = std::vector<std::string>;
  auto from_psv = [](const std::string& psv) -> strvec {
    // psv == pipe-separated-values
    strvec result;
    if (psv != ".*") {
      split(result, psv, "|", token_compress_on);
      std::sort(result.begin(), result.end());
    }
    return result;
  };
  auto suites = from_psv(suites_str);
  auto not_suites = from_psv(not_suites_str);
  auto tests = from_psv(tests_str);
  auto not_tests = from_psv(not_tests_str);
  auto enabled = [](const strvec& whitelist,
                    const strvec& blacklist,
                    const std::string& x) {
    // an empty whitelist means original input was ".*", i.e., enable all
    return !std::binary_search(blacklist.begin(), blacklist.end(), x)
           && (whitelist.empty()
               || std::binary_search(whitelist.begin(), whitelist.end(), x));
  };
# else
  std::regex suites{suites_str};
  std::regex tests{tests_str};
  std::regex not_suites;
  std::regex not_tests;
  // a default constructored regex matches is not equal to an "empty" regex
  if (!not_suites_str.empty())
    not_suites.assign(not_suites_str);
  if (!not_tests_str.empty())
    not_tests.assign(not_tests_str);
  auto enabled = [](const std::regex& whitelist,
                    const std::regex& blacklist,
                    const std::string& x) {
    // an empty whitelist means original input was "*", i.e., enable all
    return std::regex_search(x, whitelist)
           && !std::regex_search(x, blacklist);
  };
# endif
  std::vector<std::string> failed_tests;
  for (auto& p : instance().suites_) {
    if (!enabled(suites, not_suites, p.first))
      continue;
    auto suite_name = p.first.empty() ? "<unnamed>" : p.first;
    auto pad = std::string((bar.size() - suite_name.size()) / 2, ' ');
    bool displayed_header = false;
    size_t tests_ran = 0;
    for (auto& t : p.second) {
      if (!enabled(tests, not_tests, t->name()))
        continue;
      instance().current_test_ = t.get();
      ++tests_ran;
      if (!displayed_header) {
        log.verbose() << term::yellow << bar << '\n' << pad << suite_name
                      << '\n' << bar << term::reset << "\n\n";
        displayed_header = true;
      }
      log.verbose() << term::yellow << "- " << term::reset << t->name()
                    << '\n';
      auto start = std::chrono::high_resolution_clock::now();
      watchdog::start(max_runtime());
      t->run();
      watchdog::stop();
      auto stop = std::chrono::high_resolution_clock::now();
      auto elapsed =
        std::chrono::duration_cast<std::chrono::microseconds>(stop - start);
      runtime += elapsed;
      ++total_tests;
      size_t good = t->good();
      size_t bad = t->bad();
      total_good += good;
      total_bad += bad;
      total_bad_expected += t->expected_failures();
      log.verbose() << term::yellow << "  -> " << term::cyan << good + bad
                    << term::reset << " check" << (good + bad > 1 ? "s " : " ")
                    << "took " << term::cyan << render(elapsed)
                    << term::reset << '\n';
      if (bad > 0) {
        // concat suite name + test name
        failed_tests.emplace_back(p.first);
        failed_tests.back() += ":";
        failed_tests.back() += t->name();
        log.verbose() << " (" << term::green << good << term::reset << '/'
                      << term::red << bad << term::reset << ")" << '\n';
      } else {
        log.verbose() << '\n';
      }
    }
    // only count suites which have executed one or more tests
    if (tests_ran > 0) {
      ++total_suites;
    }
    if (displayed_header)
      log.verbose() << '\n';
  }
  unsigned percent_good = 100;
  if (total_bad > 0) {
    auto tmp = (100000.0 * static_cast<double>(total_good))
               / static_cast<double>(total_good + total_bad
                                     - total_bad_expected);
    percent_good = static_cast<unsigned>(tmp / 1000.0);
  }
  auto title = std::string{"summary"};
  auto pad = std::string((bar.size() - title.size()) / 2, ' ');
  auto indent = std::string(24, ' ');
  log.info() << term::cyan << bar << '\n' << pad << title << '\n' << bar
             << term::reset << "\n\n" << indent << "suites:  " << term::yellow
             << total_suites << term::reset << '\n' << indent
             << "tests:   " << term::yellow << total_tests << term::reset
             << '\n' << indent << "checks:  " << term::yellow
             << total_good + total_bad << term::reset;
  if (total_bad > 0) {
    log.info() << " (" << term::green << total_good << term::reset << '/'
               << term::red << total_bad << term::reset << ")";
    if (total_bad_expected > 0) {
      log.info()
        << ' ' << term::cyan << total_bad_expected << term::reset
        << " failures expected";
    }
  }
  log.info() << '\n' << indent << "time:    " << term::yellow
             << render(runtime) << '\n' << term::reset << indent
             << "success: "
             << (total_bad == total_bad_expected ? term::green : term::red)
             << percent_good << "%" << term::reset << "\n\n";
  if (!failed_tests.empty()) {
    log.info() << indent << "failed tests:" << '\n';
    for (auto& name : failed_tests)
      log.info() << indent << "- " << name << '\n';
    log.info() << '\n';
  }
  log.info() << term::cyan << bar << term::reset << '\n';
  return total_bad == total_bad_expected;
}

const char* engine::last_check_file() {
  return instance().check_file_;
}

void engine::last_check_file(const char* file) {
  instance().check_file_ = file;
}

size_t engine::last_check_line() {
  return instance().check_line_;
}

void engine::last_check_line(size_t line) {
  instance().check_line_ = line;
}

test* engine::current_test() {
  return instance().current_test_;
}

std::vector<std::string> engine::available_suites() {
  std::vector<std::string> result;
  for (auto& kvp : instance().suites_)
    result.push_back(kvp.first);
  return result;
}

std::vector<std::string> engine::available_tests(const std::string& suite) {
  std::vector<std::string> result;
  auto i = instance().suites_.find(suite);
  if (i == instance().suites_.end())
    return result;
  for (auto& ptr : i->second)
    result.push_back(ptr->name());
  return result;
}

engine& engine::instance() {
  static engine e;
  return e;
}

std::string engine::render(std::chrono::microseconds t) {
  return t.count() > 1000000
    ? (std::to_string(t.count() / 1000000) + '.'
       + std::to_string((t.count() % 1000000) / 10000) + " s")
    : t.count() > 1000
      ? (std::to_string(t.count() / 1000) + " ms")
      : (std::to_string(t.count()) + " us");
}

int main(int argc, char** argv) {
  // set path of executable
  engine::path(argv[0]);
  // default values.
  int verbosity_console = 3;
  int verbosity_file = 3;
  int max_runtime = engine::max_runtime();
  std::string log_file;
  std::string suites = ".*";
  std::string not_suites;
  std::string tests = ".*";
  std::string not_tests;
  std::string suite_query;
  // use all arguments after '--' for the test engine.
  std::string delimiter = "--";
  auto divider = argc;
  auto cli_argv = argv + 1;
  for (auto i = 1; i < argc; ++i) {
    if (delimiter == argv[i]) {
      divider = i;
      break;
    }
  }
  // our simple command line parser.
  auto res = message_builder(cli_argv, cli_argv + divider - 1).extract_opts({
    {"no-colors,n", "disable coloring (ignored on Windows)"},
    {"log-file,l", "set output file", log_file},
    {"console-verbosity,v", "set verbosity level of console (1-5)",
     verbosity_console},
    {"file-verbosity,V", "set verbosity level of file output (1-5)",
     verbosity_file},
    {"max-runtime,r", "set maximum runtime in seconds (0 = infinite)",
      max_runtime},
    {"suites,s",
     "define what suites to run, either * or a comma-separated list", suites},
    {"not-suites,S", "exclude suites", not_suites},
    {"tests,t", "set tests", tests},
    {"not-tests,T", "exclude tests", not_tests},
    {"available-suites,a", "print available suites"},
    {"available-tests,A", "print available tests for given suite", suite_query}
  });
  if (res.opts.count("help") > 0) {
    std::cout << res.helptext << std::endl;
    return 0;
  }
  if (!suite_query.empty()) {
    std::cout << "available tests in suite " << suite_query << ":" << std::endl;
    for (auto& t : engine::available_tests(suite_query))
      std::cout << "  - " << t << std::endl;
    return 0;
  }
  if (res.opts.count("available-suites") > 0) {
    std::cout << "available suites:" << std::endl;
    for (auto& s : engine::available_suites())
      std::cout << "  - " << s << std::endl;
    return 0;
  }
  if (!res.remainder.empty()) {
    std::cerr << "*** invalid command line options" << std::endl
              << res.helptext << std::endl;
    return 1;
  }
  auto colorize = res.opts.count("no-colors") == 0;
  std::vector<char*> args;
  if (divider < argc) {
    // make a new args vector that contains argv[0] and all remaining args
    args.push_back(argv[0]);
    for (int i = divider + 1; i < argc; ++i)
      args.push_back(argv[i]);
    engine::args(static_cast<int>(args.size()), args.data());
  } else {
    engine::args(1, argv);
  }
  engine::max_runtime(max_runtime);
  auto result = engine::run(colorize, log_file, verbosity_console,
                            verbosity_file, suites,
                            not_suites, tests, not_tests);
  return result ? 0 : 1;
}

} // namespace test
} // namespace caf

#ifndef CAF_TEST_NO_MAIN
int main(int argc, char** argv) {
  return caf::test::main(argc, argv);
}
#endif // CAF_TEST_UNIT_TEST_IMPL_HPP

#endif // CAF_TEST_UNIT_TEST_IMPL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/all.hpp"
#include "caf/io/network/test_multiplexer.hpp"

#include "caf/test/dsl.hpp"

namespace {

template <class BaseFixture =
            test_coordinator_fixture<caf::actor_system_config>>
class test_node_fixture : public BaseFixture {
public:
  using super = BaseFixture;

  caf::io::middleman& mm;
  caf::io::network::test_multiplexer& mpx;
  caf::io::basp_broker* basp;
  caf::io::connection_handle conn;
  caf::io::accept_handle acc;
  test_node_fixture* peer = nullptr;

  test_node_fixture()
      : mm(this->sys.middleman()),
        mpx(dynamic_cast<caf::io::network::test_multiplexer&>(mm.backend())),
        basp(get_basp_broker()) {
    // nop
  }

  // Convenience function for transmitting all "network" traffic and running
  // all executables on this node.
  void exec_all() {
    while (mpx.try_exec_runnable() || mpx.read_data()
           || this->sched.try_run_once()) {
      // rince and repeat
    }
  }

  void publish(caf::actor whom, uint16_t port) {
    auto ma = mm.actor_handle();
    auto& sys = this->sys;
    auto& sched = this->sched;
    caf::scoped_actor self{sys};
    std::set<std::string> sigs;
    // Make sure no pending BASP broker messages are in the queue.
    mpx.flush_runnables();
    // Trigger middleman actor.
    self->send(ma, caf::publish_atom::value, port,
               caf::actor_cast<caf::strong_actor_ptr>(std::move(whom)),
               std::move(sigs), "", false);
    // Wait for the message of the middleman actor.
    expect((caf::atom_value, uint16_t, caf::strong_actor_ptr,
            std::set<std::string>, std::string, bool),
           from(self)
           .to(sys.middleman().actor_handle())
           .with(caf::publish_atom::value, port, _, _, _, false));
    mpx.exec_runnable();
    // Fetch response.
    self->receive(
      [](uint16_t) {
        // nop
      },
      [&](caf::error& err) {
        CAF_FAIL(sys.render(err));
      }
    );
  }

  caf::actor remote_actor(std::string host, uint16_t port) {
    CAF_MESSAGE("remote actor: " << host << ":" << port);
    auto& sys = this->sys;
    auto& sched = this->sched;
    // both schedulers must be idle at this point
    CAF_REQUIRE(!sched.has_job());
    CAF_REQUIRE(!peer->sched.has_job());
    // get necessary handles
    auto ma = mm.actor_handle();
    caf::scoped_actor self{sys};
    // make sure no pending BASP broker messages are in the queue
    mpx.flush_runnables();
    // trigger middleman actor
    self->send(ma, caf::connect_atom::value, std::move(host), port);
    expect((caf::atom_value, std::string, uint16_t),
           from(self).to(ma).with(caf::connect_atom::value, _, port));
    CAF_MESSAGE("wait for the message of the middleman actor in BASP");
    mpx.exec_runnable();
    CAF_MESSAGE("tell peer to accept the connection");
    peer->mpx.accept_connection(peer->acc);
    CAF_MESSAGE("run handshake between the two BASP broker instances");
    while (sched.try_run_once() || peer->sched.try_run_once()
           || mpx.try_exec_runnable() || peer->mpx.try_exec_runnable()
           || mpx.read_data() || peer->mpx.read_data()) {
      // re-run until handhsake is fully completed
    }
    CAF_MESSAGE("fetch remote actor proxy");
    caf::actor result;
    self->receive(
      [&](caf::node_id&, caf::strong_actor_ptr& ptr, std::set<std::string>&) {
        result = caf::actor_cast<caf::actor>(std::move(ptr));
      },
      [&](caf::error& err) {
        CAF_FAIL(sys.render(err));
      }
    );
    return result;
  }

private:
  caf::io::basp_broker* get_basp_broker() {
    auto hdl = mm.named_broker<caf::io::basp_broker>(caf::atom("BASP"));
    return dynamic_cast<caf::io::basp_broker*>(
      caf::actor_cast<caf::abstract_actor*>(hdl));
  }
};

/// Binds `test_coordinator_fixture<Config>` to `test_node_fixture`.
template <class Config = caf::actor_system_config>
using test_node_fixture_t = test_node_fixture<test_coordinator_fixture<Config>>;

/// A simple fixture that includes two nodes (`earth` and `mars`) that are
/// connected to each other.
template <class BaseFixture =
            test_coordinator_fixture<caf::actor_system_config>>
class point_to_point_fixture {
public:
  using planet_type = test_node_fixture<BaseFixture>;

  planet_type earth;
  planet_type mars;

  point_to_point_fixture() {
    mars.peer = &earth;
    earth.peer = &mars;
    earth.acc = caf::io::accept_handle::from_int(1);
    earth.conn = caf::io::connection_handle::from_int(2);
    mars.acc = caf::io::accept_handle::from_int(3);
    mars.conn = caf::io::connection_handle::from_int(4);
  }

  // Convenience function for transmitting all "network" traffic.
  void network_traffic() {
    run_exhaustively([](planet_type* x) {
      return x->mpx.try_exec_runnable() || x->mpx.read_data();
    });
  }

  // Convenience function for transmitting all "network" traffic and running
  // all executables on earth and mars.
  void exec_all() {
    run_exhaustively([](planet_type* x) {
      return x->mpx.try_exec_runnable() || x->mpx.read_data()
             || x->sched.try_run_once();
    });
  }

  void prepare_connection(planet_type& server, planet_type& client,
                          std::string host, uint16_t port) {
    server.mpx.prepare_connection(server.acc, server.conn, client.mpx,
                                  std::move(host), port, client.conn);
  }

private:
  template <class F>
  void run_exhaustively(F f) {
    planet_type* planets[] = {&earth, &mars};
    while (std::any_of(std::begin(planets), std::end(planets), f))
      ; // rince and repeat
  }
};

/// Binds `test_coordinator_fixture<Config>` to `point_to_point_fixture`.
template <class Config = caf::actor_system_config>
using point_to_point_fixture_t =
  point_to_point_fixture<test_coordinator_fixture<Config>>;

}// namespace <anonymous>

#define expect_on(where, types, fields)                                        \
  CAF_MESSAGE(#where << ": expect" << #types << "." << #fields);               \
  expect_clause< CAF_EXPAND(CAF_DSL_LIST types) >{where . sched} . fields

#define disallow_on(where, types, fields)                                      \
  CAF_MESSAGE(#where << ": disallow" << #types << "." << #fields);             \
  disallow_clause< CAF_EXPAND(CAF_DSL_LIST types) >{where . sched} . fields
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_TEST_UNIT_TEST_HPP
#define CAF_TEST_UNIT_TEST_HPP

#include <map>
#include <cmath>
#include <mutex>
#include <thread>
#include <vector>
#include <string>
#include <memory>
#include <fstream>
#include <sstream>
#include <iostream>

#include "caf/fwd.hpp"
#include "caf/term.hpp"
#include "caf/logger.hpp"
#include "caf/optional.hpp"
#include "caf/deep_to_string.hpp"

namespace caf {
namespace test {

// -- Function objects for implementing CAF_CHECK_* macros ---------------------

template <class F>
struct negated {
  template <class T, class U>
  bool operator()(const T& x, const U& y) {
    F f;
    return !f(x, y);
  }
};

struct equal_to {
  template <class T, class U,
            typename std::enable_if<std::is_floating_point<T>::value
                                    || std::is_floating_point<U>::value,
                                    int>::type = 0>
  bool operator()(const T& t, const U& u) {
    auto x = static_cast<long double>(t);
    auto y = static_cast<long double>(u);
    auto max = std::max(std::abs(x), std::abs(y));
    auto dif = std::abs(x - y);
    return dif <= max * 1e-5l;
  }

  template <class T, class U,
            typename std::enable_if<!std::is_floating_point<T>::value
                                    && !std::is_floating_point<U>::value,
                                    int>::type = 0>
  bool operator()(const T& x, const U& y) {
    return x == y;
  }
};

// note: we could use negated<equal_to>, but that would give us `!(x == y)`
// instead of `x != y` and thus messes with coverage testing
struct not_equal_to {
  template <class T, class U>
  bool operator()(const T& x, const U& y) {
    return x != y;
  }
};

struct less_than {
  template <class T, class U>
  bool operator()(const T& x, const U& y) {
    return x < y;
  }
};

struct less_than_or_equal {
  template <class T, class U>
  bool operator()(const T& x, const U& y) {
    return x <= y;
  }
};

struct greater_than {
  template <class T, class U>
  bool operator()(const T& x, const U& y) {
    return x > y;
  }
};

struct greater_than_or_equal {
  template <class T, class U>
  bool operator()(const T& x, const U& y) {
    return x >= y;
  }
};

// -- Core components of the unit testing abstraction --------------------------

/// Default test-running function.
/// This function will be called automatically unless you define
/// `CAF_TEST_NO_MAIN` before including `caf/test/unit_test.hpp`. In
/// the latter case you will have to provide you own `main` function,
/// where you may want to call `caf::test::main` from.
int main(int argc, char** argv);

/// A sequence of *checks*.
class test {
public:
  test(std::string test_name);

  virtual ~test();

  size_t expected_failures() const;

  void pass();

  void fail(bool expected);

  const std::string& name() const;

  inline size_t good() {
    return good_;
  }

  inline size_t bad() {
    return bad_;
  }

  virtual void run() = 0;

private:
  size_t expected_failures_;
  std::string name_;
  size_t good_;
  size_t bad_;
};

struct dummy_fixture { };

template <class T>
class test_impl : public test {
public:
  test_impl(std::string test_name) : test(std::move(test_name)) {
    // nop
  }

  void run() override {
    T impl;
    impl.run();
  }
};

namespace detail {

[[noreturn]] void requirement_failed(const std::string& msg);

// constructs spacing given a line number.
const char* fill(size_t line);

void remove_trailing_spaces(std::string& x);

} // namespace detail

/// Logs messages for the test framework.
class logger {
public:
  enum class level : int {
    quiet   = 0,
    error   = 1,
    info    = 2,
    verbose = 3,
    massive = 4
  };

  static bool init(int lvl_cons, int lvl_file, const std::string& logfile);

  static logger& instance();

  template <class T>
  void log(level lvl, const T& x) {
    if (lvl <= level_console_) {
      *console_ << x;
    }
    if (lvl <= level_file_) {
      file_ << x;
    }
  }

  /// Output stream for logging purposes.
  class stream {
  public:
    stream(logger& parent, level lvl);

    stream(const stream&) = default;

    template <class T>
    stream& operator<<(const T& x) {
      parent_.log(lvl_, x);
      return *this;
    }

    template <class T>
    stream& operator<<(const optional<T>& x) {
      if (!x)
        return *this << "-none-";
      return *this << *x;
    }

  private:
    logger& parent_;
    level lvl_;
  };

  stream error();
  stream info();
  stream verbose();
  stream massive();

  void disable_colors();

private:
  logger();

  level level_console_;
  level level_file_;
  std::ostream* console_;
  std::ofstream file_;
  std::ostringstream dummy_;
};

/// Drives unit test execution.
class engine {
public:
  /// Sets external command line arguments.
  /// @param argc The argument counter.
  /// @param argv The argument vectors.
  static void args(int argc, char** argv);

  /// Retrieves the argument counter.
  /// @returns The number of arguments set via ::args or 0.
  static int argc();

  /// Retrieves the argument vector.
  /// @returns The argument vector set via ::args or `nullptr`.
  static char** argv();

  /// Sets path of current executable.
  /// @param argv The path of current executable.
  static void path(char* argv);

  /// Retrieves the path of current executable
  /// @returns The path to executable set via ::path(char*) or `nullptr`.
  static char* path();

  /// Returns the maximum number of seconds a test case is allowed to run.
  static int max_runtime();

  /// Sets the maximum number of seconds a test case is
  /// allowed to run to `value`.
  static void max_runtime(int value);

  /// Adds a test to the engine.
  /// @param cstr_name The name of the suite.
  /// @param ptr The test to register.
  static void add(const char* cstr_name, std::unique_ptr<test> ptr);

  /// Invokes tests in all suites.
  /// @param colorize Whether to colorize the output.
  /// @param log_file The filename of the log output. The empty string means
  ///                 that no log file will be written.
  /// @param verbosity_console The log verbosity level on the console.
  /// @param verbosity_file The log verbosity level in the log file.
  /// @param suites_str Regular expression for including test suites.
  /// @param not_suites_str Regular expression for excluding test suites.
  /// @param tests_str Regular expression for individually selecting tests.
  /// @param not_tests_str Regular expression for individually disabling tests.
  /// @returns `true` iff all tests succeeded.
  static bool run(bool colorize,
                  const std::string& log_file,
                  int verbosity_console,
                  int verbosity_file,
                  const std::string& suites_str,
                  const std::string& not_suites_str,
                  const std::string& tests_str,
                  const std::string& not_tests_str);

  static const char* last_check_file();
  static void last_check_file(const char* file);

  static size_t last_check_line();
  static void last_check_line(size_t line);

  static test* current_test();

  static std::vector<std::string> available_suites();

  static std::vector<std::string> available_tests(const std::string& suite);

private:
  engine() = default;

  static engine& instance();

  static std::string render(std::chrono::microseconds t);

  int argc_ = 0;
  char** argv_ = nullptr;
  char*  path_ = nullptr;
  bool colorize_ = false;
  const char* check_file_ = "<none>";
  size_t check_line_ = 0;
  test* current_test_ = nullptr;
  std::map<std::string, std::vector<std::unique_ptr<test>>> suites_;
  int max_runtime_ = 30; // 30s per default
};

namespace detail {

template <class T>
struct adder {
  adder(const char* suite_name, const char* test_name) {
    engine::add(suite_name, std::unique_ptr<T>{new T(test_name)});
  }
};

template <class T>
struct showable_base {
  explicit showable_base(const T& x) : value(x) {
    // nop
  }

  const T& value;
};

// showable_base<T> picks up to_string() via ADL
template <class T>
std::ostream& operator<<(std::ostream& out, const showable_base<T>& x) {
  auto str = caf::deep_to_string(x.value);
  if (str == "<unprintable>")
    out << term::blue << "<unprintable>" << term::reset;
  else
    out << str;
  return out;
}

template <class T>
class showable : public showable_base<T> {
public:
  explicit showable(const T& x) : showable_base<T>(x) {
    // nop
  }
};

// showable<T> picks up custom operator<< overloads for std::ostream
template <class T>
auto operator<<(std::ostream& out, const showable<T>& p)
-> decltype(out << std::declval<const T&>()) {
  return out << p.value;
}

template <class T>
showable<T> show(const T &x) {
  return showable<T>{x};
}

bool check(test* parent, const char *file, size_t line,
           const char *expr, bool should_fail, bool result);

template <class T, class U>
bool check(test* parent, const char *file, size_t line,
           const char *expr, bool should_fail, bool result,
           const T& x, const U& y) {
  auto out = logger::instance().massive();
  if (result) {
    out << term::green << "** "
        << term::blue << file << term::yellow << ":"
        << term::blue << line << fill(line) << term::reset
        << expr << '\n';
    parent->pass();
  } else {
    out << term::red << "!! "
        << term::blue << file << term::yellow << ":"
        << term::blue << line << fill(line) << term::reset
        << expr << term::magenta << " ("
        << term::red << show(x) << term::magenta
        << " !! " << term::red << show(y) << term::magenta
        << ')' << term::reset_endl;
    parent->fail(should_fail);
  }
  return result;
}

} // namespace detail
} // namespace test
} // namespace caf

// on the global namespace so that it can hidden via namespace-scoping
using caf_test_case_auto_fixture = caf::test::dummy_fixture;

#define CAF_TEST_PRINT(level, msg, colorcode)                                  \
  (::caf::test::logger::instance().level()                                     \
   << ::caf::term:: colorcode << "  -> " << ::caf::term::reset << msg          \
   << " [line " << __LINE__ << "]\n")

#define CAF_TEST_PRINT_ERROR(msg)   CAF_TEST_PRINT(info, msg, red)
#define CAF_TEST_PRINT_INFO(msg)    CAF_TEST_PRINT(info, msg, yellow)
#define CAF_TEST_PRINT_VERBOSE(msg) CAF_TEST_PRINT(verbose, msg, yellow)

#define CAF_PASTE_CONCAT(lhs, rhs) lhs ## rhs

#define CAF_PASTE(lhs, rhs) CAF_PASTE_CONCAT(lhs, rhs)

#define CAF_UNIQUE(name) CAF_PASTE(name, __LINE__)

#ifndef CAF_SUITE
#define CAF_SUITE unnamed
#endif

#define CAF_STR(s) #s

#define CAF_XSTR(s) CAF_STR(s)

#define CAF_FUNC_EXPR(func, x_expr, y_expr) #func "(" #x_expr ", " #y_expr ")"

#define CAF_ERROR(msg)                                                         \
  do {                                                                         \
    CAF_TEST_PRINT_ERROR(msg);                                                 \
    ::caf::test::engine::current_test()->fail(false);                          \
    ::caf::test::engine::last_check_file(__FILE__);                            \
    ::caf::test::engine::last_check_line(__LINE__);                            \
  } while (false)

#define CAF_CHECK(...)                                                         \
  do {                                                                         \
    static_cast<void>(::caf::test::detail::check(                              \
      ::caf::test::engine::current_test(), __FILE__, __LINE__,                 \
      #__VA_ARGS__, false, static_cast<bool>(__VA_ARGS__)));                   \
    ::caf::test::engine::last_check_file(__FILE__);                            \
    ::caf::test::engine::last_check_line(__LINE__);                            \
  } while(false)

#define CAF_CHECK_FUNC(func, x_expr, y_expr)                                   \
  do {                                                                         \
    func comparator;                                                           \
    const auto& x_val___ = x_expr;                                             \
    const auto& y_val___ = y_expr;                                             \
    static_cast<void>(::caf::test::detail::check(                              \
      ::caf::test::engine::current_test(), __FILE__, __LINE__,                 \
      CAF_FUNC_EXPR(func, x_expr, y_expr), false,                              \
      comparator(x_val___, y_val___), x_val___, y_val___));                    \
    ::caf::test::engine::last_check_file(__FILE__);                            \
    ::caf::test::engine::last_check_line(__LINE__);                            \
  } while (false)

#define CAF_CHECK_FAIL(...)                                                    \
  do {                                                                         \
    static_cast<void>(::caf::test::detail::check(                              \
      ::caf::test::engine::current_test(), __FILE__, __LINE__,                 \
      #__VA_ARGS__, true, static_cast<bool>(__VA_ARGS__)));                    \
    ::caf::test::engine::last_check_file(__FILE__);                            \
    ::caf::test::engine::last_check_line(__LINE__);                            \
  } while(false)

#define CAF_FAIL(msg)                                                          \
  do {                                                                         \
    CAF_TEST_PRINT_ERROR(msg);                                                 \
    ::caf::test::engine::current_test()->fail(false);                          \
    ::caf::test::detail::requirement_failed("test failure");                   \
  } while (false)

#define CAF_REQUIRE(...)                                                       \
  do {                                                                         \
    auto CAF_UNIQUE(__result) = ::caf::test::detail::check(                    \
      ::caf::test::engine::current_test(), __FILE__, __LINE__, #__VA_ARGS__,   \
      false, static_cast<bool>(__VA_ARGS__));                                  \
    if (!CAF_UNIQUE(__result))                                                 \
      ::caf::test::detail::requirement_failed(#__VA_ARGS__);                   \
    ::caf::test::engine::last_check_file(__FILE__);                            \
    ::caf::test::engine::last_check_line(__LINE__);                            \
  } while (false)

#define CAF_REQUIRE_FUNC(func, x_expr, y_expr)                                 \
  do {                                                                         \
    func comparator;                                                           \
    const auto& x_val___ = x_expr;                                             \
    const auto& y_val___ = y_expr;                                             \
    auto CAF_UNIQUE(__result) = ::caf::test::detail::check(                    \
      ::caf::test::engine::current_test(), __FILE__, __LINE__,                 \
      CAF_FUNC_EXPR(func, x_expr, y_expr), false,                              \
      comparator(x_val___, y_val___), x_val___, y_val___);                     \
    if (!CAF_UNIQUE(__result))                                                 \
      ::caf::test::detail::requirement_failed(                                 \
        CAF_FUNC_EXPR(func, x_expr, y_expr));                                  \
    ::caf::test::engine::last_check_file(__FILE__);                            \
    ::caf::test::engine::last_check_line(__LINE__);                            \
  } while (false)

#define CAF_TEST(name)                                                         \
  namespace {                                                                  \
  struct CAF_UNIQUE(test) : caf_test_case_auto_fixture {                       \
    void run();                                                                \
  };                                                                           \
  ::caf::test::detail::adder< ::caf::test::test_impl<CAF_UNIQUE(test)>>        \
  CAF_UNIQUE(a) {CAF_XSTR(CAF_SUITE), CAF_XSTR(name)};                         \
  } /* namespace <anonymous> */                                                \
  void CAF_UNIQUE(test)::run()

#define CAF_TEST_FIXTURE_SCOPE(scope_name, fixture_name)                       \
  namespace scope_name { using caf_test_case_auto_fixture = fixture_name ;

#define CAF_TEST_FIXTURE_SCOPE_END()                                           \
  } // namespace <scope_name>

// -- Convenience macros -------------------------------------------------------

#define CAF_MESSAGE(msg)                                                       \
  CAF_LOG_INFO(msg);                                                           \
  CAF_TEST_PRINT_VERBOSE(msg)

// -- CAF_CHECK* predicate family ----------------------------------------------

#define CAF_CHECK_EQUAL(x, y)                                                  \
  CAF_CHECK_FUNC(::caf::test::equal_to, x, y)

#define CAF_CHECK_NOT_EQUAL(x, y)                                              \
  CAF_CHECK_FUNC(::caf::test::not_equal_to, x, y)

#define CAF_CHECK_LESS(x, y)                                                   \
  CAF_CHECK_FUNC(::caf::test::less_than, x, y)

#define CAF_CHECK_NOT_LESS(x, y)                                               \
  CAF_CHECK_FUNC(::caf::test::negated<::caf::test::less_than>, x, y)

#define CAF_CHECK_LESS_OR_EQUAL(x, y)                                          \
  CAF_CHECK_FUNC(::caf::test::less_than_or_equal, x, y)

#define CAF_CHECK_NOT_LESS_OR_EQUAL(x, y)                                      \
  CAF_CHECK_FUNC(::caf::test::negated<::caf::test::less_than_or_equal>, x, y)

#define CAF_CHECK_GREATER(x, y)                                                \
  CAF_CHECK_FUNC(::caf::test::greater_than, x, y)

#define CAF_CHECK_NOT_GREATER(x, y)                                            \
  CAF_CHECK_FUNC(::caf::test::negated<::caf::test::greater_than>, x, y)

#define CAF_CHECK_GREATER_OR_EQUAL(x, y)                                       \
  CAF_CHECK_FUNC(::caf::test::greater_than_or_equal, x, y)

#define CAF_CHECK_NOT_GREATER_OR_EQUAL(x, y)                                   \
  CAF_CHECK_FUNC(::caf::test::negated<::caf::test::greater_than_or_equal>, x, y)

// -- CAF_CHECK* predicate family ----------------------------------------------

#define CAF_REQUIRE_EQUAL(x, y)                                                \
  CAF_REQUIRE_FUNC(::caf::test::equal_to, x, y)

#define CAF_REQUIRE_NOT_EQUAL(x, y)                                            \
  CAF_REQUIRE_FUNC(::caf::test::not_equal_to, x, y)

#define CAF_REQUIRE_LESS(x, y)                                                 \
  CAF_REQUIRE_FUNC(::caf::test::less_than, x, y)

#define CAF_REQUIRE_NOT_LESS(x, y)                                             \
  CAF_REQUIRE_FUNC(::caf::test::negated<::caf::test::less_than>, x, y)

#define CAF_REQUIRE_LESS_OR_EQUAL(x, y)                                        \
  CAF_REQUIRE_FUNC(::caf::test::less_than_or_equal, x, y)

#define CAF_REQUIRE_NOT_LESS_OR_EQUAL(x, y)                                    \
  CAF_REQUIRE_FUNC(::caf::test::negated<::caf::test::less_than_or_equal>, x, y)

#define CAF_REQUIRE_GREATER(x, y)                                              \
  CAF_REQUIRE_FUNC(::caf::test::greater_than, x, y)

#define CAF_REQUIRE_NOT_GREATER(x, y)                                          \
  CAF_REQUIRE_FUNC(::caf::test::negated<::caf::test::greater_than>, x, y)

#define CAF_REQUIRE_GREATER_OR_EQUAL(x, y)                                     \
  CAF_REQUIRE_FUNC(::caf::test::greater_than_or_equal, x, y)

#define CAF_REQUIRE_NOT_GREATER_OR_EQUAL(x, y)                                 \
  CAF_REQUIRE_FUNC(::caf::test::negated<::caf::test::greater_than_or_equal>,   \
                   x, y)

#endif // CAF_TEST_UNIT_TEST_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/openssl/session.hpp"

CAF_PUSH_WARNINGS
#include <openssl/err.h>
CAF_POP_WARNINGS

#include "caf/actor_system_config.hpp"

#include "caf/io/network/default_multiplexer.hpp"

#include "caf/openssl/manager.hpp"

// On Linux we need to block SIGPIPE whenever we access OpenSSL functions.
// Unfortunately there's no sane way to configure OpenSSL properly.
#ifdef CAF_LINUX

#include "caf/detail/scope_guard.hpp"
#include <signal.h>

#define CAF_BLOCK_SIGPIPE() \
  sigset_t sigpipe_mask; \
  sigemptyset(&sigpipe_mask); \
  sigaddset(&sigpipe_mask, SIGPIPE); \
  sigset_t saved_mask; \
  if (pthread_sigmask(SIG_BLOCK, &sigpipe_mask, &saved_mask) == -1) { \
    perror("pthread_sigmask"); \
    exit(1); \
  } \
  auto sigpipe_restore_guard = ::caf::detail::make_scope_guard([&] { \
    struct timespec zerotime = {0}; \
    sigtimedwait(&sigpipe_mask, 0, &zerotime); \
    if (pthread_sigmask(SIG_SETMASK, &saved_mask, 0) == -1) { \
      perror("pthread_sigmask"); \
      exit(1); \
    } \
  })

#else

#define CAF_BLOCK_SIGPIPE() static_cast<void>(0)

#endif // CAF_LINUX

namespace caf {
namespace openssl {

namespace {

int pem_passwd_cb(char* buf, int size, int, void* ptr) {
  auto passphrase = reinterpret_cast<session*>(ptr)->openssl_passphrase();
  strncpy(buf, passphrase, static_cast<size_t>(size));
  buf[size - 1] = '\0';
  return static_cast<int>(strlen(buf));
}


} // namespace <anonymous>

session::session(actor_system& sys)
    : sys_(sys),
      ctx_(nullptr),
      ssl_(nullptr),
      connecting_(false),
      accepting_(false) {
  // nop
}

bool session::init() {
  CAF_LOG_TRACE("");
  ctx_ = create_ssl_context();
  ssl_ = SSL_new(ctx_);
  if (ssl_ == nullptr) {
    CAF_LOG_ERROR("cannot create SSL session");
    return false;
  }
  return true;
}

session::~session() {
  SSL_free(ssl_);
  SSL_CTX_free(ctx_);
}

rw_state session::do_some(int (*f)(SSL*, void*, int), size_t& result, void* buf,
                          size_t len, const char* debug_name) {
  CAF_BLOCK_SIGPIPE();
  auto check_ssl_res = [&](int res) -> rw_state {
    result = 0;
    switch (SSL_get_error(ssl_, res)) {
      default:
        CAF_LOG_INFO("SSL error:" << get_ssl_error());
        return rw_state::failure;
      case SSL_ERROR_WANT_READ:
        CAF_LOG_DEBUG("SSL_ERROR_WANT_READ reported");
        // Report success to poll on this socket.
        if (len == 0 && strcmp(debug_name, "write_some") == 0)
          return rw_state::indeterminate;
        return rw_state::success;
      case SSL_ERROR_WANT_WRITE:
        CAF_LOG_DEBUG("SSL_ERROR_WANT_WRITE reported");
        // Report success to poll on this socket.
        return rw_state::success;
    }
  };
  CAF_LOG_TRACE(CAF_ARG(len) << CAF_ARG(debug_name));
  CAF_IGNORE_UNUSED(debug_name);
  if (connecting_) {
    CAF_LOG_DEBUG(debug_name << ": connecting");
    auto res = SSL_connect(ssl_);
    if (res == 1) {
      CAF_LOG_DEBUG("SSL connection established");
      connecting_ = false;
    } else {
      result = 0;
      return check_ssl_res(res);
    }
  }
  if (accepting_) {
    CAF_LOG_DEBUG(debug_name << ": accepting");
    auto res = SSL_accept(ssl_);
    if (res == 1) {
      CAF_LOG_DEBUG("SSL connection accepted");
      accepting_ = false;
    } else {
      result = 0;
      return check_ssl_res(res);
    }
  }
  CAF_LOG_DEBUG(debug_name << ": calling SSL_write or SSL_read");
  if (len == 0) {
    result = 0;
    return rw_state::indeterminate;
  }
  auto ret = f(ssl_, buf, static_cast<int>(len));
  if (ret > 0) {
    result = static_cast<size_t>(ret);
    return rw_state::success;
  }
  result = 0;
  return handle_ssl_result(ret) ? rw_state::success : rw_state::failure;
}

rw_state session::read_some(size_t& result, native_socket, void* buf,
                            size_t len) {
  CAF_LOG_TRACE(CAF_ARG(len));
  return do_some(SSL_read, result, buf, len, "read_some");
}

rw_state session::write_some(size_t& result, native_socket, const void* buf,
                             size_t len) {
  CAF_LOG_TRACE(CAF_ARG(len));
  auto wr_fun = [](SSL* sptr, void* vptr, int ptr_size) {
    return SSL_write(sptr, vptr, ptr_size);
  };
  return do_some(wr_fun, result, const_cast<void*>(buf), len, "write_some");
}

bool session::try_connect(native_socket fd) {
  CAF_LOG_TRACE(CAF_ARG(fd));
  CAF_BLOCK_SIGPIPE();
  SSL_set_fd(ssl_, fd);
  SSL_set_connect_state(ssl_);
  auto ret = SSL_connect(ssl_);
  if (ret == 1)
    return true;
  connecting_ = true;
  return handle_ssl_result(ret);
}

bool session::try_accept(native_socket fd) {
  CAF_LOG_TRACE(CAF_ARG(fd));
  CAF_BLOCK_SIGPIPE();
  SSL_set_fd(ssl_, fd);
  SSL_set_accept_state(ssl_);
  auto ret = SSL_accept(ssl_);
  if (ret == 1)
    return true;
  accepting_ = true;
  return handle_ssl_result(ret);
}

const char* session::openssl_passphrase() {
  return openssl_passphrase_.c_str();
}

SSL_CTX* session::create_ssl_context() {
  CAF_BLOCK_SIGPIPE();
#ifdef CAF_SSL_HAS_NON_VERSIONED_TLS_FUN
  auto ctx = SSL_CTX_new(TLS_method());
#else
  auto ctx = SSL_CTX_new(TLSv1_2_method());
#endif
  if (!ctx)
    raise_ssl_error("cannot create OpenSSL context");
  if (sys_.openssl_manager().authentication_enabled()) {
    // Require valid certificates on both sides.
    auto& cfg = sys_.config();
    if (cfg.openssl_certificate.size() > 0
        && SSL_CTX_use_certificate_chain_file(ctx,
                                              cfg.openssl_certificate.c_str())
             != 1)
      raise_ssl_error("cannot load certificate");
    if (cfg.openssl_passphrase.size() > 0) {
      openssl_passphrase_ = cfg.openssl_passphrase;
      SSL_CTX_set_default_passwd_cb(ctx, pem_passwd_cb);
      SSL_CTX_set_default_passwd_cb_userdata(ctx, this);
    }
    if (cfg.openssl_key.size() > 0
        && SSL_CTX_use_PrivateKey_file(ctx, cfg.openssl_key.c_str(),
                                       SSL_FILETYPE_PEM)
             != 1)
      raise_ssl_error("cannot load private key");
    auto cafile =
      (cfg.openssl_cafile.size() > 0 ? cfg.openssl_cafile.c_str() : nullptr);
    auto capath =
      (cfg.openssl_capath.size() > 0 ? cfg.openssl_capath.c_str() : nullptr);
    if (cafile || capath) {
      if (SSL_CTX_load_verify_locations(ctx, cafile, capath) != 1)
        raise_ssl_error("cannot load trusted CA certificates");
    }
    SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
                       nullptr);
    if (SSL_CTX_set_cipher_list(ctx, "HIGH:!aNULL:!MD5") != 1)
      raise_ssl_error("cannot set cipher list");
  } else {
    // No authentication.
    SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, nullptr);
#ifdef CAF_SSL_HAS_ECDH_AUTO
    SSL_CTX_set_ecdh_auto(ctx, 1);
#else
    auto ecdh = EC_KEY_new_by_curve_name(NID_secp384r1);
    if (!ecdh)
      raise_ssl_error("cannot get ECDH curve");
    CAF_PUSH_WARNINGS
    SSL_CTX_set_tmp_ecdh(ctx, ecdh);
    EC_KEY_free(ecdh);
    CAF_POP_WARNINGS
#endif
#ifdef CAF_SSL_HAS_SECURITY_LEVEL
    const char* cipher = "AECDH-AES256-SHA@SECLEVEL=0";
#else
    const char* cipher = "AECDH-AES256-SHA";
#endif
    if (SSL_CTX_set_cipher_list(ctx, cipher) != 1)
      raise_ssl_error("cannot set anonymous cipher");
  }
  return ctx;
}

std::string session::get_ssl_error() {
  std::string msg = "";
  while (auto err = ERR_get_error()) {
    if (msg.size() > 0)
      msg += " ";
    char buf[256];
    ERR_error_string_n(err, buf, sizeof(buf));
    msg += buf;
  }
  return msg;
}

void session::raise_ssl_error(std::string msg) {
  CAF_RAISE_ERROR(std::string("[OpenSSL] ") + msg + ": " + get_ssl_error());
}

bool session::handle_ssl_result(int ret) {
  auto err = SSL_get_error(ssl_, ret);
  switch (err) {
    case SSL_ERROR_WANT_READ:
      CAF_LOG_DEBUG("Nonblocking call to SSL returned want_read");
      return true;
    case SSL_ERROR_WANT_WRITE:
      CAF_LOG_DEBUG("Nonblocking call to SSL returned want_write");
      return true;
    case SSL_ERROR_ZERO_RETURN: // Regular remote connection shutdown.
    case SSL_ERROR_SYSCALL:     // Socket connection closed.
      return false;
    default: // Other error
      CAF_LOG_INFO("SSL call failed:" << get_ssl_error());
      return false;
  }
}

session_ptr make_session(actor_system& sys, native_socket fd,
                         bool from_accepted_socket) {
  session_ptr ptr{new session(sys)};
  if (!ptr->init())
    return nullptr;
  if (from_accepted_socket) {
    if (!ptr->try_accept(fd))
      return nullptr;
  } else {
    if (!ptr->try_connect(fd))
      return nullptr;
  }
  return ptr;
}

} // namespace openssl
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/openssl/publish.hpp"

#include <set>

#include "caf/atom.hpp"
#include "caf/expected.hpp"
#include "caf/actor_system.hpp"
#include "caf/function_view.hpp"
#include "caf/actor_control_block.hpp"

#include "caf/openssl/manager.hpp"

namespace caf {
namespace openssl {

expected<uint16_t> publish(actor_system& sys, const strong_actor_ptr& whom,
                           std::set<std::string>&& sigs, uint16_t port,
                           const char* cstr, bool ru) {
  CAF_LOG_TRACE(CAF_ARG(whom) << CAF_ARG(sigs) << CAF_ARG(port));
  CAF_ASSERT(whom != nullptr);
  std::string in;
  if (cstr != nullptr)
    in = cstr;
  auto f = make_function_view(sys.openssl_manager().actor_handle());
  return f(publish_atom::value, port, std::move(whom), std::move(sigs),
           std::move(in), ru);
}

} // namespace openssl
} // namespace caf

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/io/middleman_actor.hpp"

#include <tuple>
#include <stdexcept>
#include <utility>

#include "caf/sec.hpp"
#include "caf/send.hpp"
#include "caf/actor.hpp"
#include "caf/logger.hpp"
#include "caf/node_id.hpp"
#include "caf/actor_proxy.hpp"
#include "caf/actor_system_config.hpp"
#include "caf/typed_event_based_actor.hpp"

#include "caf/io/basp_broker.hpp"
#include "caf/io/system_messages.hpp"
#include "caf/io/middleman_actor_impl.hpp"

#include "caf/io/network/interfaces.hpp"
#include "caf/io/network/default_multiplexer.hpp"

#include "caf/openssl/session.hpp"

namespace caf {
namespace openssl {

namespace {

using native_socket = io::network::native_socket;
using default_mpx = io::network::default_multiplexer;

struct ssl_policy {
  ssl_policy(session_ptr session) : session_(std::move(session)) {
    // nop
  }

  rw_state read_some(size_t& result, native_socket fd, void* buf, size_t len) {
    CAF_LOG_TRACE(CAF_ARG(fd) << CAF_ARG(len));
    return session_->read_some(result, fd, buf, len);
  }

  rw_state write_some(size_t& result, native_socket fd, const void* buf,
                      size_t len) {
    CAF_LOG_TRACE(CAF_ARG(fd) << CAF_ARG(len));
    return session_->write_some(result, fd, buf, len);
  }

  bool try_accept(native_socket& result, native_socket fd) {
    CAF_LOG_TRACE(CAF_ARG(fd));
    sockaddr_storage addr;
    memset(&addr, 0, sizeof(addr));
    socklen_t addrlen = sizeof(addr);
    result = accept(fd, reinterpret_cast<sockaddr*>(&addr), &addrlen);
    CAF_LOG_DEBUG(CAF_ARG(fd) << CAF_ARG(result));
    if (result == io::network::invalid_native_socket) {
      auto err = io::network::last_socket_error();
      if (!io::network::would_block_or_temporarily_unavailable(err))
        return false;
    }
    return session_->try_accept(result);
  }

private:
  session_ptr session_;
};

class scribe_impl : public io::scribe {
  public:
    scribe_impl(default_mpx& mpx, native_socket sockfd,
                session_ptr sptr)
        : scribe(io::network::conn_hdl_from_socket(sockfd)),
          launched_(false),
          stream_(mpx, sockfd, std::move(sptr)) {
      // nop
    }

    ~scribe_impl() {
      CAF_LOG_TRACE("");
    }

    void configure_read(io::receive_policy::config config) override {
      CAF_LOG_TRACE(CAF_ARG(config));
      stream_.configure_read(config);
      if (!launched_)
        launch();
    }

    void ack_writes(bool enable) override {
      CAF_LOG_TRACE(CAF_ARG(enable));
      stream_.ack_writes(enable);
    }

    std::vector<char>& wr_buf() override {
      return stream_.wr_buf();
    }

    std::vector<char>& rd_buf() override {
      return stream_.rd_buf();
    }

    void stop_reading() override {
      CAF_LOG_TRACE("");
      stream_.stop_reading();
      detach(&stream_.backend(), false);
    }

    void flush() override {
      CAF_LOG_TRACE("");
      stream_.flush(this);
    }

    std::string addr() const override {
      auto x = io::network::remote_addr_of_fd(stream_.fd());
      if (!x)
        return "";
      return *x;
    }

    uint16_t port() const override {
      auto x = io::network::remote_port_of_fd(stream_.fd());
      if (!x)
        return 0;
      return *x;
    }

    void launch() {
      CAF_LOG_TRACE("");
      CAF_ASSERT(!launched_);
      launched_ = true;
      stream_.start(this);
      // This schedules the scribe in case SSL still needs to call SSL_connect
      // or SSL_accept. Otherwise, the backend simply removes the socket for
      // write operations after the first "nop write".
      stream_.force_empty_write(this);
    }

    void add_to_loop() override {
      CAF_LOG_TRACE("");
      stream_.activate(this);
    }

    void remove_from_loop() override {
      CAF_LOG_TRACE("");
      stream_.passivate();
    }

  private:
    bool launched_;
    io::network::stream_impl<ssl_policy> stream_;
};

class doorman_impl : public io::network::doorman_impl {
public:
  doorman_impl(default_mpx& mx, native_socket sockfd)
      : io::network::doorman_impl(mx, sockfd) {
    // nop
  }

  bool new_connection() override {
    CAF_LOG_TRACE("");
    if (detached())
       // we are already disconnected from the broker while the multiplexer
       // did not yet remove the socket, this can happen if an I/O event causes
       // the broker to call close_all() while the pollset contained
       // further activities for the broker
       return false;
    auto& dm = acceptor_.backend();
    auto fd = acceptor_.accepted_socket();
    io::network::nonblocking(fd, true);
    auto sssn = make_session(parent()->system(), fd, true);
    if (sssn == nullptr) {
      CAF_LOG_ERROR("Unable to create SSL session for accepted socket");
      return false;
    }
    auto scrb = make_counted<scribe_impl>(dm, fd, std::move(sssn));
    auto hdl = scrb->hdl();
    parent()->add_scribe(std::move(scrb));
    return doorman::new_connection(&dm, hdl);
  }
};

class middleman_actor_impl : public io::middleman_actor_impl {
public:
  middleman_actor_impl(actor_config& cfg, actor default_broker)
      : io::middleman_actor_impl(cfg, std::move(default_broker)) {
    // nop
  }

  const char* name() const override {
    return "openssl::middleman_actor";
  }

protected:
  expected<io::scribe_ptr> connect(const std::string& host,
                                   uint16_t port) override {
    CAF_LOG_TRACE(CAF_ARG(host) << CAF_ARG(port));
    auto fd = io::network::new_tcp_connection(host, port);
    if (fd == io::network::invalid_native_socket)
      return std::move(fd.error());
    io::network::nonblocking(*fd, true);
    auto sssn = make_session(system(), *fd, false);
    if (!sssn) {
      CAF_LOG_ERROR("Unable to create SSL session for connection");
      return sec::cannot_connect_to_node;
    }
    CAF_LOG_DEBUG("successfully created an SSL session for:"
                  << CAF_ARG(host) << CAF_ARG(port));
    return make_counted<scribe_impl>(mpx(), *fd, std::move(sssn));
  }

  expected<io::doorman_ptr> open(uint16_t port, const char* addr,
                                 bool reuse) override {
    CAF_LOG_TRACE(CAF_ARG(port) << CAF_ARG(reuse));
    auto fd = io::network::new_tcp_acceptor_impl(port, addr, reuse);
    if (fd == io::network::invalid_native_socket)
      return std::move(fd.error());
    return make_counted<doorman_impl>(mpx(), *fd);
  }

private:
  default_mpx& mpx() {
    return static_cast<default_mpx&>(system().middleman().backend());
  }
};

} // namespace <anonymous>

io::middleman_actor make_middleman_actor(actor_system& sys, actor db) {
  return sys.config().middleman_detach_utility_actors
         ? sys.spawn<middleman_actor_impl, detached + hidden>(std::move(db))
         : sys.spawn<middleman_actor_impl, hidden>(std::move(db));
}

} // namespace openssl
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/openssl/manager.hpp"

CAF_PUSH_WARNINGS
#include <openssl/err.h>
#include <openssl/ssl.h>
CAF_POP_WARNINGS

#include "caf/expected.hpp"
#include "caf/actor_system.hpp"
#include "caf/scoped_actor.hpp"
#include "caf/actor_control_block.hpp"
#include "caf/actor_system_config.hpp"

#include "caf/io/middleman.hpp"
#include "caf/io/basp_broker.hpp"
#include "caf/io/network/default_multiplexer.hpp"

#include "caf/openssl/middleman_actor.hpp"

namespace caf {
namespace openssl {

manager::~manager() {
  // nop
}

void manager::start() {
  CAF_LOG_TRACE("");
  manager_ = make_middleman_actor(
    system(), system().middleman().named_broker<io::basp_broker>(atom("BASP")));
}

void manager::stop() {
  CAF_LOG_TRACE("");
  scoped_actor self{system(), true};
  self->send_exit(manager_, exit_reason::kill);
  if (system().config().middleman_detach_utility_actors)
    self->wait_for(manager_);
  manager_ = nullptr;
}

void manager::init(actor_system_config&) {
  CAF_LOG_TRACE("");
  ERR_load_crypto_strings();
  OPENSSL_add_all_algorithms_conf();
  SSL_library_init();
  SSL_load_error_strings();
  if (authentication_enabled()) {
    if (system().config().openssl_certificate.size() == 0)
      CAF_RAISE_ERROR("No certificate configured for SSL endpoint");
    if (system().config().openssl_key.size() == 0)
      CAF_RAISE_ERROR("No private key configured for SSL endpoint");
  }
}

actor_system::module::id_t manager::id() const {
  return openssl_manager;
}

void* manager::subtype_ptr() {
  return this;
}

bool manager::authentication_enabled() {
  auto& cfg = system().config();
  return cfg.openssl_certificate.size() > 0 || cfg.openssl_key.size() > 0
         || cfg.openssl_passphrase.size() > 0 || cfg.openssl_capath.size() > 0
         || cfg.openssl_cafile.size() > 0;
}

actor_system::module* manager::make(actor_system& sys, detail::type_list<>) {
  if (!sys.has_middleman())
    CAF_RAISE_ERROR("Cannot start OpenSSL module without middleman.");
  auto ptr = &sys.middleman().backend();
  if (dynamic_cast<io::network::default_multiplexer*>(ptr) == nullptr)
    CAF_RAISE_ERROR("Cannot start OpenSSL module without default backend.");
  return new manager(sys);
}

manager::manager(actor_system& sys) : system_(sys) {
  // nop
}

} // namespace openssl
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/openssl/remote_actor.hpp"

#include "caf/sec.hpp"
#include "caf/atom.hpp"
#include "caf/expected.hpp"
#include "caf/function_view.hpp"

#include "caf/openssl/manager.hpp"

namespace caf {
namespace openssl {

/// Establish a new connection to the actor at `host` on given `port`.
/// @param host Valid hostname or IP address.
/// @param port TCP port.
/// @returns An `actor` to the proxy instance representing
///          a remote actor or an `error`.
expected<strong_actor_ptr> remote_actor(actor_system& sys,
                                        const std::set<std::string>& mpi,
                                        std::string host, uint16_t port) {
  CAF_LOG_TRACE(CAF_ARG(mpi) << CAF_ARG(host) << CAF_ARG(port));
  expected<strong_actor_ptr> res{strong_actor_ptr{nullptr}};
  auto f = make_function_view(sys.openssl_manager().actor_handle());
  auto x = f(connect_atom::value, std::move(host), port);
  if (!x)
    return std::move(x.error());
  auto& tup = *x;
  auto& ptr = get<1>(tup);
  if (!ptr)
    return sec::no_actor_published_at_port;
  auto& found_mpi = get<2>(tup);
  if (sys.assignable(found_mpi, mpi))
    return std::move(ptr);
  return sec::unexpected_actor_messaging_interface;
}

} // namespace openssl
} // namespace caf

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#define CAF_SUITE openssl_authentication
#include "caf/test/unit_test.hpp"

#ifndef CAF_WINDOWS
# include <unistd.h>
#else
# include <io.h>
# include <windows.h>
# define F_OK 0
# define PATH_MAX MAX_PATH
#endif

#include <vector>
#include <sstream>
#include <utility>
#include <algorithm>

#include <limits.h>
#include <stdlib.h>

#include "caf/all.hpp"
#include "caf/io/all.hpp"
#include "caf/openssl/all.hpp"

using namespace caf;

namespace {

constexpr char local_host[] = "127.0.0.1";

class config : public actor_system_config {
public:
  config() {
    load<io::middleman>();
    load<openssl::manager>();
    add_message_type<std::vector<int>>("std::vector<int>");
    actor_system_config::parse(test::engine::argc(), test::engine::argv());
    middleman_detach_multiplexer = false;
    middleman_detach_utility_actors = false;
    scheduler_policy = atom("testing");
  }

  static std::string data_dir() {
     std::string path{::caf::test::engine::path()};
     path = path.substr(0, path.find_last_of("/"));
     // TODO: https://github.com/actor-framework/actor-framework/issues/555
     path += "/../../libcaf_openssl/test";
     char rpath[PATH_MAX];
#ifndef CAF_WINDOWS
     auto rp = realpath(path.c_str(), rpath);
#else
     auto rp = GetFullPathName(path.c_str(), PATH_MAX, rpath, nullptr);
#endif
     std::string result;
     if (rp)
       result = rpath;
     return result;
  }
};

behavior make_pong_behavior() {
  return {
    [](int val) -> int {
      ++val;
      CAF_MESSAGE("pong " << val);
      return val;
    }
  };
}

behavior make_ping_behavior(event_based_actor* self, const actor& pong) {
  CAF_MESSAGE("ping " << 0);
  self->send(pong, 0);
  return {
    [=](int val) -> int {
      CAF_MESSAGE("ping " << val);
      if (val >= 3) {
        CAF_MESSAGE("terminate ping");
        self->quit();
      }
      return val;
    }
  };
}

struct fixture {
  using sched_t = scheduler::test_coordinator;

  config server_side_config;
  config client_side_config;
  bool initialized;
  union { actor_system server_side; };
  union { actor_system client_side; };
  sched_t* ssched;
  sched_t* csched;

  fixture() : initialized(false) {
    // nop
  }

  ~fixture() {
    if (initialized) {
      server_side.~actor_system();
      client_side.~actor_system();
    }
  }

  bool init(bool skip_client_side_ca) {
    auto cd = config::data_dir();
    cd += '/';
    server_side_config.openssl_passphrase = "12345";
    // check whether all files exist before setting config parameters
    std::string dummy;
    std::pair<const char*, std::string*> cfg[] {
      {"ca.pem", &server_side_config.openssl_cafile},
      {"cert.1.pem", &server_side_config.openssl_certificate},
      {"key.1.enc.pem", &server_side_config.openssl_key},
      {"ca.pem", skip_client_side_ca ? &dummy
                                     : &client_side_config.openssl_cafile},
      {"cert.2.pem", &client_side_config.openssl_certificate},
      {"key.2.pem", &client_side_config.openssl_key}
    };
    // return if any file is unreadable or non-existend
    for (auto& x : cfg) {
      auto path = cd + x.first;
      if (access(path.c_str(), F_OK) == -1) {
        CAF_MESSAGE("pem files missing, skip test");
        return false;
      }
      *x.second = std::move(path);
    }
    CAF_MESSAGE("initialize server side");
    new (&server_side) actor_system(server_side_config);
    CAF_MESSAGE("initialize client side");
    new (&client_side) actor_system(client_side_config);
    ssched = &dynamic_cast<sched_t&>(server_side.scheduler());
    csched = &dynamic_cast<sched_t&>(client_side.scheduler());
    initialized = true;
    return true;
  }

  sched_t& sched_by_sys(actor_system& sys) {
    return &sys == &server_side ? *ssched : *csched;
  }
  bool exec_one(actor_system& sys) {
    CAF_ASSERT(initialized);
    CAF_PUSH_AID(0);
    CAF_SET_LOGGER_SYS(&sys);
    return sched_by_sys(sys).try_run_once()
           || sys.middleman().backend().try_run_once();
  }

  void exec_loop(actor_system& sys) {
    while (exec_one(sys))
      ; // nop
  }

  void exec_loop() {
    while (exec_one(client_side) | exec_one(server_side))
      ; // nop
  }

  void loop_after_next_enqueue(actor_system& sys) {
    auto s = &sys == &server_side ? ssched : csched;
    s->after_next_enqueue([=] { exec_loop(); });
  }

  bool terminated(const actor& x) {
    return x ? x->getf(abstract_actor::is_terminated_flag) : false;
  }
};

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(authentication, fixture)

using openssl::remote_actor;
using openssl::publish;

CAF_TEST(authentication_success) {
  if (!init(false))
    return;
  // server side
  CAF_MESSAGE("spawn pong on server");
  auto spong = server_side.spawn(make_pong_behavior);
  exec_loop();
  CAF_MESSAGE("publish pong");
  loop_after_next_enqueue(server_side);
  CAF_EXP_THROW(port, publish(spong, 0, local_host));
  exec_loop();
  // client side
  CAF_MESSAGE("connect to pong via port " << port);
  loop_after_next_enqueue(client_side);
  CAF_EXP_THROW(pong, remote_actor(client_side, local_host, port));
  CAF_MESSAGE("spawn ping and exchange messages");
  auto sping = client_side.spawn(make_ping_behavior, pong);
  while (!terminated(sping))
    exec_loop();
  CAF_MESSAGE("terminate pong");
  anon_send_exit(spong, exit_reason::user_shutdown);
  exec_loop();
}

CAF_TEST(authentication_failure) {
  if (!init(true))
    return;
  // server side
  CAF_MESSAGE("spawn pong on server");
  auto spong = server_side.spawn(make_pong_behavior);
  exec_loop();
  loop_after_next_enqueue(server_side);
  CAF_MESSAGE("publish pong");
  CAF_EXP_THROW(port, publish(spong, 0, local_host));
  exec_loop();
  // client side
  CAF_MESSAGE("connect to pong via port " << port);
  loop_after_next_enqueue(client_side);
  auto remote_pong = remote_actor(client_side, local_host, port);
  CAF_CHECK(!remote_pong);
  CAF_MESSAGE("terminate pong");
  anon_send_exit(spong, exit_reason::user_shutdown);
  exec_loop();
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#include <signal.h>

#define CAF_SUITE openssl_dynamic_remote_actor
#include "caf/test/unit_test.hpp"

#include <vector>
#include <sstream>
#include <utility>
#include <algorithm>

#include "caf/all.hpp"
#include "caf/io/all.hpp"
#include "caf/openssl/all.hpp"

using namespace caf;

namespace {

constexpr char local_host[] = "127.0.0.1";

class config : public actor_system_config {
public:
  config() {
    load<io::middleman>();
    load<openssl::manager>();
    add_message_type<std::vector<int>>("std::vector<int>");
    actor_system_config::parse(test::engine::argc(),
                               test::engine::argv());
  }
};

struct fixture {
  config server_side_config;
  actor_system server_side{server_side_config};
  config client_side_config;
  actor_system client_side{client_side_config};
  fixture() {
#ifdef CAF_LINUX
    signal(SIGPIPE, SIG_IGN);
#endif
  }
};

behavior make_pong_behavior() {
  return {
    [](int val) -> int {
      ++val;
      CAF_MESSAGE("pong with " << val);
      return val;
    }
  };
}

behavior make_ping_behavior(event_based_actor* self, const actor& pong) {
  CAF_MESSAGE("ping with " << 0);
  self->send(pong, 0);
  return {
    [=](int val) -> int {
      if (val == 3) {
        CAF_MESSAGE("ping with exit");
        self->send_exit(self->current_sender(),
                        exit_reason::user_shutdown);
        CAF_MESSAGE("ping quits");
        self->quit();
      }
      CAF_MESSAGE("ping with " << val);
      return val;
    }
  };
}

std::string to_string(const std::vector<int>& vec) {
  std::ostringstream os;
  for (size_t i = 0; i + 1 < vec.size(); ++i)
    os << vec[i] << ", ";
  os << vec.back();
  return os.str();
}

behavior make_sort_behavior() {
  return {
    [](std::vector<int>& vec) -> std::vector<int> {
      CAF_MESSAGE("sorter received: " << to_string(vec));
      std::sort(vec.begin(), vec.end());
      CAF_MESSAGE("sorter sent: " << to_string(vec));
      return std::move(vec);
    }
  };
}

behavior make_sort_requester_behavior(event_based_actor* self, const actor& sorter) {
  self->send(sorter, std::vector<int>{5, 4, 3, 2, 1});
  return {
    [=](const std::vector<int>& vec) {
      CAF_MESSAGE("sort requester received: " << to_string(vec));
      for (size_t i = 1; i < vec.size(); ++i)
        CAF_CHECK_EQUAL(static_cast<int>(i), vec[i - 1]);
      self->send_exit(sorter, exit_reason::user_shutdown);
      self->quit();
    }
  };
}

behavior fragile_mirror(event_based_actor* self) {
  return {
    [=](int i) {
      self->quit(exit_reason::user_shutdown);
      return i;
    }
  };
}

behavior linking_actor(event_based_actor* self, const actor& buddy) {
  CAF_MESSAGE("link to mirror and send dummy message");
  self->link_to(buddy);
  self->send(buddy, 42);
  return {
    [](int i) {
      CAF_CHECK_EQUAL(i, 42);
    }
  };
}

} // namespace <anonymous>

CAF_TEST_FIXTURE_SCOPE(dynamic_remote_actor_tests, fixture)

using openssl::remote_actor;
using openssl::publish;

CAF_TEST(identity_semantics) {
  // server side
  auto server = server_side.spawn(make_pong_behavior);
  CAF_EXP_THROW(port1, publish(server, 0, local_host));
  CAF_EXP_THROW(port2, publish(server, 0, local_host));
  CAF_REQUIRE_NOT_EQUAL(port1, port2);
  CAF_EXP_THROW(same_server, remote_actor(server_side, local_host, port2));
  CAF_REQUIRE_EQUAL(same_server, server);
  CAF_CHECK_EQUAL(same_server->node(), server_side.node());
  CAF_EXP_THROW(server1, remote_actor(client_side, local_host, port1));
  CAF_EXP_THROW(server2, remote_actor(client_side, local_host, port2));
  CAF_CHECK_EQUAL(server1, remote_actor(client_side, local_host, port1));
  CAF_CHECK_EQUAL(server2, remote_actor(client_side, local_host, port2));
  anon_send_exit(server, exit_reason::user_shutdown);
}

CAF_TEST(ping_pong) {
  // server side
  CAF_EXP_THROW(port,
                publish(server_side.spawn(make_pong_behavior), 0, local_host));
  // client side
  CAF_EXP_THROW(pong, remote_actor(client_side, local_host, port));
  client_side.spawn(make_ping_behavior, pong);
}

CAF_TEST(custom_message_type) {
  // server side
  CAF_EXP_THROW(port,
                publish(server_side.spawn(make_sort_behavior), 0, local_host));
  // client side
  CAF_EXP_THROW(sorter, remote_actor(client_side, local_host, port));
  client_side.spawn(make_sort_requester_behavior, sorter);
}

CAF_TEST(remote_link) {
  // server side
  CAF_EXP_THROW(port,
                publish(server_side.spawn(fragile_mirror), 0, local_host));
  // client side
  CAF_EXP_THROW(mirror, remote_actor(client_side, local_host, port));
  auto linker = client_side.spawn(linking_actor, mirror);
  scoped_actor self{client_side};
  self->wait_for(linker);
  CAF_MESSAGE("linker exited");
  self->wait_for(mirror);
  CAF_MESSAGE("mirror exited");
}

CAF_TEST_FIXTURE_SCOPE_END()
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENSSL_ALL_HPP
#define CAF_OPENSSL_ALL_HPP

#include "caf/openssl/manager.hpp"
#include "caf/openssl/publish.hpp"
#include "caf/openssl/remote_actor.hpp"

#endif // CAF_OPENSSL_ALL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENSSL_SESSION_HPP
#define CAF_OPENSSL_SESSION_HPP

#include <memory>

#include "caf/config.hpp"

CAF_PUSH_WARNINGS
#include <openssl/ssl.h>
CAF_POP_WARNINGS

#include "caf/actor_system.hpp"

#include "caf/io/network/native_socket.hpp"
#include "caf/io/network/default_multiplexer.hpp"

#if OPENSSL_VERSION_NUMBER >= 0x10100000L
# define CAF_SSL_HAS_SECURITY_LEVEL
# define CAF_SSL_HAS_NON_VERSIONED_TLS_FUN
#endif

#if defined(SSL_CTX_set_ecdh_auto)
# define CAF_SSL_HAS_ECDH_AUTO
#endif

namespace caf {
namespace openssl {

using native_socket = io::network::native_socket;

using rw_state = io::network::rw_state;

class session {
public:
  session(actor_system& sys);
  ~session();

  bool init();
  rw_state read_some(size_t& result, native_socket fd, void* buf, size_t len);
  rw_state write_some(size_t& result, native_socket fd, const void* buf,
                      size_t len);
  bool try_connect(native_socket fd);
  bool try_accept(native_socket fd);
  const char* openssl_passphrase();

private:
  rw_state do_some(int (*f)(SSL*, void*, int), size_t& result, void* buf,
                   size_t len, const char* debug_name);
  SSL_CTX* create_ssl_context();
  std::string get_ssl_error();
  void raise_ssl_error(std::string msg);
  bool handle_ssl_result(int ret);

  actor_system& sys_;
  SSL_CTX* ctx_;
  SSL* ssl_;
  std::string openssl_passphrase_;
  bool connecting_;
  bool accepting_;
};

/// @relates session
using session_ptr = std::unique_ptr<session>;

/// @relates session
session_ptr make_session(actor_system& sys, native_socket fd,
                         bool from_accepted_socket);

} // namespace openssl
} // namespace caf

#endif // CAF_OPENSSL_SESSION_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENSSL_UNPUBLISH_HPP
#define CAF_OPENSSL_UNPUBLISH_HPP

#include <cstdint>

#include "caf/sec.hpp"
#include "caf/error.hpp"
#include "caf/expected.hpp"
#include "caf/actor_cast.hpp"
#include "caf/typed_actor.hpp"
#include "caf/function_view.hpp"
#include "caf/actor_control_block.hpp"

#include "caf/openssl/manager.hpp"

namespace caf {
namespace openssl {

/// Unpublishes `whom` by closing `port` or all assigned ports if `port == 0`.
/// @param whom Actor that should be unpublished at `port`.
/// @param port TCP port.
template <class Handle>
expected<void> unpublish(const Handle& whom, uint16_t port = 0) {
  if (!whom)
    return sec::invalid_argument;
  auto& sys = whom.home_system();
  auto f = make_function_view(sys.openssl_manager().actor_handle());
  return f(unpublish_atom::value, port);
}

} // namespace openssl
} // namespace caf

#endif // CAF_OPENSSL_UNPUBLISH_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENSSL_REMOTE_ACTOR_HPP
#define CAF_OPENSSL_REMOTE_ACTOR_HPP

#include <set>
#include <string>
#include <cstdint>

#include "caf/fwd.hpp"
#include "caf/actor_system.hpp"
#include "caf/actor_control_block.hpp"

namespace caf {
namespace openssl {

/// @private
expected<strong_actor_ptr> remote_actor(actor_system& sys,
                                        const std::set<std::string>& mpi,
                                        std::string host, uint16_t port);

/// Establish a new connection to the actor at `host` on given `port`.
/// @param host Valid hostname or IP address.
/// @param port TCP port.
/// @returns An `actor` to the proxy instance representing
///          a remote actor or an `error`.
template <class ActorHandle = actor>
expected<ActorHandle> remote_actor(actor_system& sys, std::string host,
                                   uint16_t port) {
  detail::type_list<ActorHandle> tk;
  auto res = remote_actor(sys, sys.message_types(tk), std::move(host), port);
  if (res)
    return actor_cast<ActorHandle>(std::move(*res));
  return std::move(res.error());
}

} // namespace openssl
} // namespace caf

#endif // CAF_OPENSSL_REMOTE_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENSSL_MANAGER_HPP
#define CAF_OPENSSL_MANAGER_HPP

#include <set>
#include <string>

#include "caf/actor_system.hpp"
#include "caf/io/middleman_actor.hpp"

namespace caf {
namespace openssl {

/// Stores OpenSSL context information and provides access to necessary
/// credentials for establishing connections.
class manager : public actor_system::module {
public:
  ~manager() override;

  void start() override;

  void stop() override;

  void init(actor_system_config&) override;

  id_t id() const override;

  void* subtype_ptr() override;

  /// Returns an SSL-aware implementation of the middleman actor interface.
  inline const io::middleman_actor& actor_handle() const {
    return manager_;
  }

  /// Returns the enclosing actor system.
  inline actor_system& system() {
    return system_;
  }

  /// Returns true if configured to require certificate-based authentication
  /// of peers.
  bool authentication_enabled();

  /// Returns an OpenSSL manager using the default network backend.
  /// @warning Creating an OpenSSL manager will fail when using the ASIO
  ///          network backend or any other custom implementation.
  /// @throws `logic_error` if the middleman is not loaded or is not using the
  ///         default network backend.
  static actor_system::module* make(actor_system&, detail::type_list<>);

private:
  /// Private since instantiation is only allowed via `make`.
  manager(actor_system& sys);

  /// Reference to the parent.
  actor_system& system_;

  /// OpenSSL-aware connection manager.
  io::middleman_actor manager_;
};

} // namespace openssl
} // namespace caf

#endif // CAF_OPENSSL_MANAGER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENSSL_MIDDLEMAN_ACTOR_HPP
#define CAF_OPENSSL_MIDDLEMAN_ACTOR_HPP

#include "caf/io/middleman_actor.hpp"

namespace caf {
namespace openssl {


io::middleman_actor make_middleman_actor(actor_system& sys, actor db);

} // namespace openssl
} // namespace caf

#endif // CAF_OPENSSL_MIDDLEMAN_ACTOR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENSSL_PUBLISH_HPP
#define CAF_OPENSSL_PUBLISH_HPP

#include <set>
#include <string>
#include <cstdint>

#include "caf/fwd.hpp"
#include "caf/sec.hpp"
#include "caf/error.hpp"
#include "caf/actor_cast.hpp"
#include "caf/typed_actor.hpp"
#include "caf/actor_control_block.hpp"

namespace caf {
namespace openssl {

/// @private
expected<uint16_t> publish(actor_system& sys, const strong_actor_ptr& whom,
                           std::set<std::string>&& sigs, uint16_t port,
                           const char* cstr, bool ru);

/// Tries to publish `whom` at `port` and returns either an `error` or the
/// bound port.
/// @param whom Actor that should be published at `port`.
/// @param port Unused TCP port.
/// @param in The IP address to listen to or `INADDR_ANY` if `in == nullptr`.
/// @param reuse Create socket using `SO_REUSEADDR`.
/// @returns The actual port the OS uses after `bind()`. If `port == 0`
///          the OS chooses a random high-level port.
template <class Handle>
expected<uint16_t> publish(const Handle& whom, uint16_t port,
                           const char* in = nullptr, bool reuse = false) {
  if (!whom)
    return sec::cannot_publish_invalid_actor;
  auto& sys = whom.home_system();
  return publish(sys, actor_cast<strong_actor_ptr>(whom),
                 sys.message_types(whom), port, in, reuse);
}

} // namespace openssl
} // namespace caf

#endif // CAF_OPENSSL_PUBLISH_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <vector>
#include <iomanip>
#include <numeric>
#include <iostream>

#include "caf/all.hpp"
#include "caf/opencl/all.hpp"

using namespace std;
using namespace caf;
using namespace caf::opencl;

using caf::detail::limited_vector;

namespace {

using fvec = std::vector<float>;

constexpr size_t matrix_size = 8;
constexpr const char* kernel_name = "matrix_mult";

// opencl kernel, multiplies matrix1 and matrix2
// last parameter is, by convention, the output parameter
constexpr const char* kernel_source = R"__(
  kernel void matrix_mult(global const float* matrix1,
                          global const float* matrix2,
                          global       float* output) {
    // we only use square matrices, hence: width == height
    size_t size = get_global_size(0); // == get_global_size_(1);
    size_t x = get_global_id(0);
    size_t y = get_global_id(1);
    float result = 0;
    for (size_t idx = 0; idx < size; ++idx)
      result += matrix1[idx + y * size] * matrix2[x + idx * size];
    output[x+y*size] = result;
  }
)__";

} // namespace <anonymous>

void print_as_matrix(const fvec& matrix) {
  for (size_t column = 0; column < matrix_size; ++column) {
    for (size_t row = 0; row < matrix_size; ++row) {
      cout << fixed << setprecision(2) << setw(9)
           << matrix[row + column * matrix_size];
    }
    cout << endl;
  }
}

void multiplier(event_based_actor* self) {
  // the opencl actor only understands vectors
  // so these vectors represent the matrices
  fvec m1(matrix_size * matrix_size);
  fvec m2(matrix_size * matrix_size);

  // fill each with ascending values
  iota(m1.begin(), m1.end(), 0);
  iota(m2.begin(), m2.end(), 0);

  // print "source" matrix
  cout << "calculating square of matrix:" << endl;
  print_as_matrix(m1);
  cout << endl;

  // spawn an opencl actor
  // 1st arg: source code of one or more kernels
  // 2nd arg: name of the kernel to use
  // 3rd arg: a spawn configuration that includes:
  //          - the global dimension arguments for opencl's enqueue
  //            creates matrix_size * matrix_size global work items
  //          - offsets for global dimensions (optional)
  //          - local dimensions (optional)
  // 4th to Nth arg: the kernel signature described by in/out/in_out classes
  //          that contain the argument type in their template. Since the actor
  //          expects its arguments for global memory to be passed in vectors,
  //          the vector type is omitted for brevity.
  auto worker = self->system().opencl_manager().spawn(
    kernel_source, kernel_name,
    nd_range{dim_vec{matrix_size, matrix_size}},
    in<float>{}, in<float>{}, out<float>{}
  );
  // send both matrices to the actor and wait for a result
  self->request(worker, chrono::seconds(5), move(m1), move(m2)).then(
    [](const fvec& result) {
      cout << "result: " << endl;
      print_as_matrix(result);
    }
  );
}

int main() {
  actor_system_config cfg;
  cfg.load<opencl::manager>()
     .add_message_type<fvec>("float_vector");
  actor_system system{cfg};
  system.spawn(multiplier);
  system.await_all_actors_done();
  return 0;
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <vector>
#include <iomanip>
#include <numeric>
#include <cassert>
#include <iostream>

#include "caf/all.hpp"
#include "caf/detail/limited_vector.hpp"

#include "caf/opencl/all.hpp"

using namespace std;
using namespace caf;
using namespace caf::opencl;

using caf::detail::limited_vector;

namespace {

using fvec = vector<float>;

constexpr size_t matrix_size = 8;
constexpr const char* kernel_name = "matrix_mult";

// opencl kernel, multiplies matrix1 and matrix2
// last parameter is, by convention, the output parameter
constexpr const char* kernel_source = R"__(
  kernel void matrix_mult(global const float* matrix1,
                          global const float* matrix2,
                          global       float* output) {
    // we only use square matrices, hence: width == height
    size_t size = get_global_size(0); // == get_global_size_(1);
    size_t x = get_global_id(0);
    size_t y = get_global_id(1);
    float result = 0;
    for (size_t idx = 0; idx < size; ++idx)
      result += matrix1[idx + y * size] * matrix2[x + idx * size];
    output[x+y*size] = result;
  }
)__";

} // namespace <anonymous>

template<size_t Size>
class square_matrix {
public:
  using value_type = fvec::value_type;
  static constexpr size_t num_elements = Size * Size;

  // allows serialization
  template <class Inspector>
  friend typename Inspector::result_type inspect(Inspector& f,
                                                 square_matrix& m) {
    return f(meta::type_name("square_matrix"), m.data_);
  }

  square_matrix(square_matrix&&) = default;
  square_matrix(const square_matrix&) = default;
  square_matrix& operator=(square_matrix&&) = default;
  square_matrix& operator=(const square_matrix&) = default;

  square_matrix() : data_(num_elements) { }

  explicit square_matrix(fvec d) : data_(move(d)) {
    assert(data_.size() == num_elements);
  }

  inline float& operator()(size_t column, size_t row) {
    return data_[column + row * Size];
  }

  inline const float& operator()(size_t column, size_t row) const {
    return data_[column + row * Size];
  }

  inline void iota_fill() {
    iota(data_.begin(), data_.end(), 0);
  }

  using const_iterator = typename fvec::const_iterator;

  const_iterator begin() const { return data_.begin(); }

  const_iterator end() const { return data_.end(); }

  fvec& data() { return data_; }

  const fvec& data() const { return data_; }

private:
  fvec data_;
};

template<size_t Size>
string to_string(const square_matrix<Size>& m) {
  ostringstream oss;
  oss.fill(' ');
  for (size_t row = 0; row < Size; ++row) {
    for (size_t column = 0; column < Size; ++column)
      oss << fixed << setprecision(2) << setw(9) << m(column, row);
    oss << '\n';
  }
  return oss.str();
}

// to annouce the square_matrix to libcaf, we have to define these operators
template<size_t Size>
inline bool operator==(const square_matrix<Size>& lhs,
                       const square_matrix<Size>& rhs) {
  return equal(lhs.begin(), lhs.end(), rhs.begin());
}

template<size_t Size>
inline bool operator!=(const square_matrix<Size>& lhs,
                       const square_matrix<Size>& rhs) {
  return !(lhs == rhs);
}

using matrix_type = square_matrix<matrix_size>;

void multiplier(event_based_actor* self) {
  auto& mngr = self->system().opencl_manager();

  // create two matrices with ascending values
  matrix_type m1;
  m1.iota_fill();
  auto m2 = m1;

  // print "source" matrix
  cout << "calculating square of matrix:" << endl
       << to_string(m1) << endl;

  auto unbox_args = [](message& msg) -> optional<message> {
    return msg.apply([](matrix_type& lhs, matrix_type& rhs) {
      return make_message(std::move(lhs.data()), std::move(rhs.data()));
    });
  };

  auto box_res = [] (fvec& result) -> message {
    return make_message(matrix_type{move(result)});
  };

  // spawn an opencl actor
  // 1st arg: source code of one or more opencl kernels
  // 2nd arg: name of the kernel to use
  // 3rd arg: the config specifies how many dimensions the kernel uses and how
  //          many work items are created, creates matrix_size * matrix_size
  //          global work items in this case
  // 4th arg: the opencl function operates on vectors, this function converts
  //          a tuple of two matrices to a tuple of vectors; note that this
  //          function returns an option (an empty results causes the actor to
  //          ignore the message)
  // 5th arg: converts the ouptut vector back to a matrix that is then
  //          used as response message
  // from 6 : a description of the kernel signature using in/out/in_out classes
  //          with the argument type. Since the actor always expects input
  //          arguments for global memory to be contained in vectors,
  //          the vector is omitted here.
  auto worker = mngr.spawn(kernel_source, kernel_name,
                           nd_range{dim_vec{matrix_size, matrix_size}},
                           unbox_args, box_res,
                           in<float>{}, in<float>{}, out<float>{});

  // send both matrices to the actor and
  // wait for results in form of a matrix_type
  self->request(worker, chrono::seconds(5), move(m1), move(m2)).then(
    [](const matrix_type& result) {
      cout << "result:" << endl << to_string(result);
    }
  );
}

int main() {
  // matrix_type ist not a simple type,
  // it must be annouced to libcaf
  actor_system_config cfg;
  cfg.load<opencl::manager>()
    .add_message_type<fvec>("float_vector")
    .add_message_type<matrix_type>("square_matrix");
  actor_system system{cfg};
  system.spawn(multiplier);
  system.await_all_actors_done();
  return 0;
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/


#include <vector>
#include <random>
#include <iomanip>
#include <numeric>
#include <iostream>

#include "caf/all.hpp"
#include "caf/opencl/all.hpp"

using namespace std;
using namespace caf;
using namespace caf::opencl;

using caf::detail::limited_vector;

namespace {

using uval = unsigned;
using uvec = std::vector<uval>;
using uref = mem_ref<uval>;

constexpr const size_t problem_size = 23;

constexpr const char* kernel_name_1 = "phase_1";
constexpr const char* kernel_name_2 = "phase_2";
constexpr const char* kernel_name_3 = "phase_3";

// opencl kernel, exclusive scan
// last parameter is, by convention, the output parameter
constexpr const char* kernel_source = R"__(
/// Global exclusive scan, phase 1. From:
/// - http://http.developer.nvidia.com/GPUGems3/gpugems3_ch39.html
kernel void phase_1(global uint* restrict data,
                    global uint* restrict increments,
                    local uint* tmp, uint len) {
  const uint thread = get_local_id(0);
  const uint block = get_group_id(0);
  const uint threads_per_block = get_local_size(0);
  const uint elements_per_block = threads_per_block * 2;
  const uint global_offset = block * elements_per_block;
  const uint n = elements_per_block;
  uint offset = 1;
  // A (2 lines) --> load input into shared memory
  tmp[2 * thread] = (global_offset + (2 * thread) < len)
                  ? data[global_offset + (2 * thread)] : 0;
  tmp[2 * thread + 1] = (global_offset + (2 * thread + 1) < len)
                      ? data[global_offset + (2 * thread + 1)] : 0;
  // build sum in place up the tree
  for (uint d = n >> 1; d > 0; d >>= 1) {
    barrier(CLK_LOCAL_MEM_FENCE);
    if (thread < d) {
      // B (2 lines)
      int ai = offset * (2 * thread + 1) - 1;
      int bi = offset * (2 * thread + 2) - 1;
      tmp[bi] += tmp[ai];
    }
    offset *= 2;
  }
  // C (2 lines) --> clear the last element
  if (thread == 0) {
    increments[block] = tmp[n - 1];
    tmp[n - 1] = 0;
  }
  // traverse down tree & build scan
  for (uint d = 1; d < n; d *= 2) {
    offset >>= 1;
    barrier(CLK_LOCAL_MEM_FENCE);
    if (thread < d) {
      // D (2 lines)
      int ai = offset * (2 * thread + 1) - 1;
      int bi = offset * (2 * thread + 2) - 1;
      uint t = tmp[ai];
      tmp[ai] = tmp[bi];
      tmp[bi] += t;
    }
  }
  barrier(CLK_LOCAL_MEM_FENCE);
  // E (2 line) --> write results to device memory
  if (global_offset + (2 * thread) < len)
    data[global_offset + (2 * thread)] = tmp[2 * thread];
  if (global_offset + (2 * thread + 1) < len)
    data[global_offset + (2 * thread + 1)] = tmp[2 * thread + 1];
}

/// Global exclusive scan, phase 2.
kernel void phase_2(global uint* restrict data, // not used ...
                    global uint* restrict increments,
                    uint len) {
  local uint tmp[2048];
  uint thread = get_local_id(0);
  uint offset = 1;
  const uint n = 2048;
  // A (2 lines) --> load input into shared memory
  tmp[2 * thread] = (2 * thread < len) ? increments[2 * thread] : 0;
  tmp[2 * thread + 1] = (2 * thread + 1 < len) ? increments[2 * thread + 1] : 0;
  // build sum in place up the tree
  for (uint d = n >> 1; d > 0; d >>= 1) {
    barrier(CLK_LOCAL_MEM_FENCE);
    if (thread < d) {
      // B (2 lines)
      int ai = offset * (2 * thread + 1) - 1;
      int bi = offset * (2 * thread + 2) - 1;
      tmp[bi] += tmp[ai];
    }
    offset *= 2;
  }
  // C (2 lines) --> clear the last element
  if (thread == 0)
    tmp[n - 1] = 0;
  // traverse down tree & build scan
  for (uint d = 1; d < n; d *= 2) {
    offset >>= 1;
    barrier(CLK_LOCAL_MEM_FENCE);
    if (thread < d) {
      // D (2 lines)
      int ai = offset * (2 * thread + 1) - 1;
      int bi = offset * (2 * thread + 2) - 1;
      uint t = tmp[ai];
      tmp[ai] = tmp[bi];
      tmp[bi] += t;
    }
  }
  barrier(CLK_LOCAL_MEM_FENCE);
  // E (2 line) --> write results to device memory
  if (2 * thread < len) increments[2 * thread] = tmp[2 * thread];
  if (2 * thread + 1 < len) increments[2 * thread + 1] = tmp[2 * thread + 1];
}

kernel void phase_3(global uint* restrict data,
                    global uint* restrict increments,
                    uint len) {
  const uint thread = get_local_id(0);
  const uint block = get_group_id(0);
  const uint threads_per_block = get_local_size(0);
  const uint elements_per_block = threads_per_block * 2;
  const uint global_offset = block * elements_per_block;
  // add the appropriate value to each block
  uint ai = 2 * thread;
  uint bi = 2 * thread + 1;
  uint ai_global = ai + global_offset;
  uint bi_global = bi + global_offset;
  uint increment = increments[block];
  if (ai_global < len) data[ai_global] += increment;
  if (bi_global < len) data[bi_global] += increment;
}
)__";

} // namespace <anonymous>

template <class T, class E = caf::detail::enable_if_t<is_integral<T>::value>>
T round_up(T numToRound, T multiple)  {
  return ((numToRound + multiple - 1) / multiple) * multiple;
}

int main() {
  actor_system_config cfg;
  cfg.load<opencl::manager>()
     .add_message_type<uvec>("uint_vector");
  actor_system system{cfg};
  cout << "Calculating exclusive scan of '" << problem_size
       << "' values." << endl;
  // ---- create data ----
  uvec values(problem_size);
  random_device rd;
  mt19937 gen(rd());
  uniform_int_distribution<uval> val_gen(0, 1023);
  std::generate(begin(values), end(values), [&]() { return val_gen(gen); });
  // ---- find device ----
  auto& mngr = system.opencl_manager();
  //
  string prefix = "GeForce";
  auto opt = mngr.find_device_if([&](const device_ptr dev) {
    auto& name = dev->name();
    return equal(begin(prefix), end(prefix), begin(name));
  });
  if (!opt) {
    cout << "No device starting with '" << prefix << "' found. "
         << "Will try the first OpenCL device available." << endl;
    opt = mngr.find_device();
  }
  if (!opt) {
    cerr << "Not OpenCL device available." << endl;
    return 0;
  } else {
    cerr << "Found device '" << (*opt)->name() << "'." << endl;
  }
  {
    // ---- general ----
    auto dev = move(*opt);
    auto prog = mngr.create_program(kernel_source, "", dev);
    scoped_actor self{system};
    // ---- config parameters ----
    auto half_block = dev->max_work_group_size() / 2;
    auto get_size = [half_block](size_t n) -> size_t {
      return round_up((n + 1) / 2, half_block);
    };
    auto nd_conf = [half_block, get_size](size_t dim) {
      return nd_range{dim_vec{get_size(dim)}, {}, dim_vec{half_block}};
    };
    auto reduced_ref = [&](const uref&, uval n) {
      // calculate number of groups from the group size from the values size
      return size_t{get_size(n) / half_block};
    };
    // default nd-range
    auto ndr = nd_range{dim_vec{half_block}, {}, dim_vec{half_block}};
    // ---- scan actors ----
    auto phase1 = mngr.spawn(
      prog, kernel_name_1, ndr,
      [nd_conf](nd_range& range, message& msg) -> optional<message> {
        return msg.apply([&](uvec& vec) {
          auto size = vec.size();
          range = nd_conf(size);
          return make_message(std::move(vec), static_cast<uval>(size));
        });
      },
      in_out<uval, val, mref>{},
      out<uval,mref>{reduced_ref},
      local<uval>{half_block * 2},
      priv<uval, val>{}
    );
    auto phase2 = mngr.spawn(
      prog, kernel_name_2, ndr,
      [nd_conf](nd_range& range, message& msg) -> optional<message> {
        return msg.apply([&](uref& data, uref& incs) {
          auto size = incs.size();
          range = nd_conf(size);
          return make_message(move(data), move(incs), static_cast<uval>(size));
        });
      },
      in_out<uval,mref,mref>{},
      in_out<uval,mref,mref>{},
      priv<uval, val>{}
    );
    auto phase3 = mngr.spawn(
      prog, kernel_name_3, ndr,
      [nd_conf](nd_range& range, message& msg) -> optional<message> {
        return msg.apply([&](uref& data, uref& incs) {
          auto size = incs.size();
          range = nd_conf(size);
          return make_message(move(data), move(incs), static_cast<uval>(size));
        });
      },
      in_out<uval,mref,val>{},
      in<uval,mref>{},
      priv<uval, val>{}
    );
    // ---- composed scan actor ----
    auto scanner = phase3 * phase2 * phase1;
    // ---- scan the data ----
    self->send(scanner, values);
    self->receive(
      [&](const uvec& results) {
        cout << "Received results." << endl;
        cout << " index | values |  scan  " << endl
             << "-------+--------+--------" << endl;
        for (size_t i = 0; i < problem_size; ++i)
          cout << setw(6) << i << " | " << setw(6) << values[i] << " | "
               << setw(6) << results[i] << endl;
      }
    );
  }
  system.await_all_actors_done();
  return 0;
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <string>
#include <sstream>

#include "caf/opencl/global.hpp"

cl_int clReleaseDeviceDummy(cl_device_id) {
  return 0;
}

cl_int clRetainDeviceDummy(cl_device_id) {
  return 0;
}

namespace caf {
namespace opencl {

std::ostream& operator<<(std::ostream& os, device_type dev) {
  switch(dev) {
    case def         : os << "default";     break;
    case cpu         : os << "CPU";         break;
    case gpu         : os << "GPU";         break;
    case accelerator : os << "accelerator"; break;
    case custom      : os << "custom";      break;
    case all         : os << "all";         break;
    default : os.setstate(std::ios_base::failbit);
  }
  return os;
}

device_type device_type_from_ulong(cl_ulong dev) {
  switch(dev) {
    case CL_DEVICE_TYPE_CPU         : return cpu;
    case CL_DEVICE_TYPE_GPU         : return gpu;
    case CL_DEVICE_TYPE_ACCELERATOR : return accelerator;
    case CL_DEVICE_TYPE_CUSTOM      : return custom;
    case CL_DEVICE_TYPE_ALL         : return all;
    default : return def;
  }
}

std::string opencl_error(cl_int err) {
  switch (err) {
    case CL_SUCCESS:
      return "CL_SUCCESS";
    case CL_DEVICE_NOT_FOUND:
      return "CL_DEVICE_NOT_FOUND";
    case CL_DEVICE_NOT_AVAILABLE:
      return "CL_DEVICE_NOT_AVAILABLE";
    case CL_COMPILER_NOT_AVAILABLE:
      return "CL_COMPILER_NOT_AVAILABLE";
    case CL_MEM_OBJECT_ALLOCATION_FAILURE:
      return "CL_MEM_OBJECT_ALLOCATION_FAILURE";
    case CL_OUT_OF_RESOURCES:
      return "CL_OUT_OF_RESOURCES";
    case CL_OUT_OF_HOST_MEMORY:
      return "CL_OUT_OF_HOST_MEMORY";
    case CL_PROFILING_INFO_NOT_AVAILABLE:
      return "CL_PROFILING_INFO_NOT_AVAILABLE";
    case CL_MEM_COPY_OVERLAP:
      return "CL_MEM_COPY_OVERLAP";
    case CL_IMAGE_FORMAT_MISMATCH:
      return "CL_IMAGE_FORMAT_MISMATCH";
    case CL_IMAGE_FORMAT_NOT_SUPPORTED:
      return "CL_IMAGE_FORMAT_NOT_SUPPORTED";
    case CL_BUILD_PROGRAM_FAILURE:
      return "CL_BUILD_PROGRAM_FAILURE";
    case CL_MAP_FAILURE:
      return "CL_MAP_FAILURE";
    case CL_INVALID_VALUE:
      return "CL_INVALID_VALUE";
    case CL_INVALID_DEVICE_TYPE:
      return "CL_INVALID_DEVICE_TYPE";
    case CL_INVALID_PLATFORM:
      return "CL_INVALID_PLATFORM";
    case CL_INVALID_DEVICE:
      return "CL_INVALID_DEVICE";
    case CL_INVALID_CONTEXT:
      return "CL_INVALID_CONTEXT";
    case CL_INVALID_QUEUE_PROPERTIES:
      return "CL_INVALID_QUEUE_PROPERTIES";
    case CL_INVALID_COMMAND_QUEUE:
      return "CL_INVALID_COMMAND_QUEUE";
    case CL_INVALID_HOST_PTR:
      return "CL_INVALID_HOST_PTR";
    case CL_INVALID_MEM_OBJECT:
      return "CL_INVALID_MEM_OBJECT";
    case CL_INVALID_IMAGE_FORMAT_DESCRIPTOR:
      return "CL_INVALID_IMAGE_FORMAT_DESCRIPTOR";
    case CL_INVALID_IMAGE_SIZE:
      return "CL_INVALID_IMAGE_SIZE";
    case CL_INVALID_SAMPLER:
      return "CL_INVALID_SAMPLER";
    case CL_INVALID_BINARY:
      return "CL_INVALID_BINARY";
    case CL_INVALID_BUILD_OPTIONS:
      return "CL_INVALID_BUILD_OPTIONS";
    case CL_INVALID_PROGRAM:
      return "CL_INVALID_PROGRAM";
    case CL_INVALID_PROGRAM_EXECUTABLE:
      return "CL_INVALID_PROGRAM_EXECUTABLE";
    case CL_INVALID_KERNEL_NAME:
      return "CL_INVALID_KERNEL_NAME";
    case CL_INVALID_KERNEL_DEFINITION:
      return "CL_INVALID_KERNEL_DEFINITION";
    case CL_INVALID_KERNEL:
      return "CL_INVALID_KERNEL";
    case CL_INVALID_ARG_INDEX:
      return "CL_INVALID_ARG_INDEX";
    case CL_INVALID_ARG_VALUE:
      return "CL_INVALID_ARG_VALUE";
    case CL_INVALID_ARG_SIZE:
      return "CL_INVALID_ARG_SIZE";
    case CL_INVALID_KERNEL_ARGS:
      return "CL_INVALID_KERNEL_ARGS";
    case CL_INVALID_WORK_DIMENSION:
      return "CL_INVALID_WORK_DIMENSION";
    case CL_INVALID_WORK_GROUP_SIZE:
      return "CL_INVALID_WORK_GROUP_SIZE";
    case CL_INVALID_WORK_ITEM_SIZE:
      return "CL_INVALID_WORK_ITEM_SIZE";
    case CL_INVALID_GLOBAL_OFFSET:
      return "CL_INVALID_GLOBAL_OFFSET";
    case CL_INVALID_EVENT_WAIT_LIST:
      return "CL_INVALID_EVENT_WAIT_LIST";
    case CL_INVALID_EVENT:
      return "CL_INVALID_EVENT";
    case CL_INVALID_OPERATION:
      return "CL_INVALID_OPERATION";
    case CL_INVALID_GL_OBJECT:
      return "CL_INVALID_GL_OBJECT";
    case CL_INVALID_BUFFER_SIZE:
      return "CL_INVALID_BUFFER_SIZE";
    case CL_INVALID_MIP_LEVEL:
      return "CL_INVALID_MIP_LEVEL";
    case CL_INVALID_GLOBAL_WORK_SIZE:
      return "CL_INVALID_GLOBAL_WORK_SIZE";
    // error codes used by extensions
    // see: http://streamcomputing.eu/blog/2013-04-28/opencl-1-2-error-codes/
    case -1000:
      return "CL_INVALID_GL_SHAREGROUP_REFERENCE_KHR";
    case -1001:
      return "No valid ICDs found";
    case -1002:
      return "CL_INVALID_D3D10_DEVICE_KHR";
    case -1003:
      return "CL_INVALID_D3D10_RESOURCE_KHR";
    case -1004:
      return "CL_D3D10_RESOURCE_ALREADY_ACQUIRED_KHR";
    case -1005:
      return "CL_D3D10_RESOURCE_NOT_ACQUIRED_KHR";
    default:
      return "UNKNOWN_ERROR: " + std::to_string(err);
  }
}

std::string event_status(cl_event e) {
  std::stringstream ss;
  cl_int s;
  auto err = clGetEventInfo(e, CL_EVENT_COMMAND_EXECUTION_STATUS,
                            sizeof(cl_int), &s, nullptr);
  if (err != CL_SUCCESS) {
    ss << std::string("ERROR ") + std::to_string(s);
    return ss.str();
  }
  cl_command_type t;
  err = clGetEventInfo(e, CL_EVENT_COMMAND_TYPE, sizeof(cl_command_type),
                       &t, nullptr);
  if (err != CL_SUCCESS) {
    ss << std::string("ERROR ") + std::to_string(s);
    return ss.str();
  }
  switch (s) {
    case(CL_QUEUED):
      ss << std::string("CL_QUEUED");
      break;
    case(CL_SUBMITTED):
      ss << std::string("CL_SUBMITTED");
      break;
    case(CL_RUNNING):
      ss << std::string("CL_RUNNING");
      break;
    case(CL_COMPLETE):
      ss << std::string("CL_COMPLETE");
      break;
    default:
      ss << std::string("DEFAULT ") + std::to_string(s);
      return ss.str();
  }
  ss << " / ";
  switch (t) {
    case(CL_COMMAND_NDRANGE_KERNEL):
      ss << std::string("CL_COMMAND_NDRANGE_KERNEL");
      break;
    case(CL_COMMAND_TASK):
      ss << std::string("CL_COMMAND_TASK");
      break;
    case(CL_COMMAND_NATIVE_KERNEL):
      ss << std::string("CL_COMMAND_NATIVE_KERNEL");
      break;
    case(CL_COMMAND_READ_BUFFER):
      ss << std::string("CL_COMMAND_READ_BUFFER");
      break;
    case(CL_COMMAND_WRITE_BUFFER):
      ss << std::string("CL_COMMAND_WRITE_BUFFER");
      break;
    case(CL_COMMAND_COPY_BUFFER):
      ss << std::string("CL_COMMAND_COPY_BUFFER");
      break;
    case(CL_COMMAND_READ_IMAGE):
      ss << std::string("CL_COMMAND_READ_IMAGE");
      break;
    case(CL_COMMAND_WRITE_IMAGE):
      ss << std::string("CL_COMMAND_WRITE_IMAGE");
      break;
    case(CL_COMMAND_COPY_IMAGE):
      ss << std::string("CL_COMMAND_COPY_IMAGE");
      break;
    case(CL_COMMAND_COPY_BUFFER_TO_IMAGE):
      ss << std::string("CL_COMMAND_COPY_BUFFER_TO_IMAGE");
      break;
    case(CL_COMMAND_COPY_IMAGE_TO_BUFFER):
      ss << std::string("CL_COMMAND_COPY_IMAGE_TO_BUFFER");
      break;
    case(CL_COMMAND_MAP_BUFFER):
      ss << std::string("CL_COMMAND_MAP_BUFFER");
      break;
    case(CL_COMMAND_MAP_IMAGE):
      ss << std::string("CL_COMMAND_MAP_IMAGE");
      break;
    case(CL_COMMAND_UNMAP_MEM_OBJECT):
      ss << std::string("CL_COMMAND_UNMAP_MEM_OBJECT");
      break;
    case(CL_COMMAND_MARKER):
      ss << std::string("CL_COMMAND_MARKER");
      break;
    case(CL_COMMAND_ACQUIRE_GL_OBJECTS):
      ss << std::string("CL_COMMAND_ACQUIRE_GL_OBJECTS");
      break;
    case(CL_COMMAND_RELEASE_GL_OBJECTS):
      ss << std::string("CL_COMMAND_RELEASE_GL_OBJECTS");
      break;
    case(CL_COMMAND_READ_BUFFER_RECT):
      ss << std::string("CL_COMMAND_READ_BUFFER_RECT");
      break;
    case(CL_COMMAND_WRITE_BUFFER_RECT):
      ss << std::string("CL_COMMAND_WRITE_BUFFER_RECT");
      break;
    case(CL_COMMAND_COPY_BUFFER_RECT):
      ss << std::string("CL_COMMAND_COPY_BUFFER_RECT");
      break;
    case(CL_COMMAND_USER):
      ss << std::string("CL_COMMAND_USER");
      break;
    case(CL_COMMAND_BARRIER):
      ss << std::string("CL_COMMAND_BARRIER");
      break;
    case(CL_COMMAND_MIGRATE_MEM_OBJECTS):
      ss << std::string("CL_COMMAND_MIGRATE_MEM_OBJECTS");
      break;
    case(CL_COMMAND_FILL_BUFFER):
      ss << std::string("CL_COMMAND_FILL_BUFFER");
      break;
    case(CL_COMMAND_FILL_IMAGE):
      ss << std::string("CL_COMMAND_FILL_IMAGE");
      break;
    default:
      ss << std::string("DEFAULT ") + std::to_string(s);
      return ss.str();
  }
  return ss.str();
}

} // namespace opencl
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <iostream>
#include <utility>

#include "caf/logger.hpp"
#include "caf/ref_counted.hpp"
#include "caf/string_algorithms.hpp"

#include "caf/opencl/global.hpp"
#include "caf/opencl/device.hpp"
#include "caf/opencl/opencl_err.hpp"

using namespace std;

namespace caf {
namespace opencl {

device_ptr device::create(const detail::raw_context_ptr& context,
                          const detail::raw_device_ptr& device_id,
                          unsigned id) {
  CAF_LOG_DEBUG("creating device for opencl device with id:" << CAF_ARG(id));
  // look up properties we need to create the command queue
  auto supported = info<cl_ulong>(device_id, CL_DEVICE_QUEUE_PROPERTIES);
  bool profiling = false; // (supported & CL_QUEUE_PROFILING_ENABLE) != 0u;
  bool out_of_order = (supported & CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE) != 0u;
  unsigned properties = profiling ? CL_QUEUE_PROFILING_ENABLE : 0;
  if (out_of_order)
    properties |= CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE;
  // create the command queue
  detail::raw_command_queue_ptr command_queue{
    v2get(CAF_CLF(clCreateCommandQueue),
          context.get(), device_id.get(),
          properties),
    false
  };
  // create the device
  auto dev = make_counted<device>(device_id, std::move(command_queue),
                                  context, id);
  //device dev{device_id, std::move(command_queue), context, id};
  // look up device properties
  dev->address_bits_ = info<cl_uint>(device_id, CL_DEVICE_ADDRESS_BITS);
  dev->little_endian_ = info<cl_bool>(device_id, CL_DEVICE_ENDIAN_LITTLE);
  dev->global_mem_cache_size_ =
    info<cl_ulong>(device_id, CL_DEVICE_GLOBAL_MEM_CACHE_SIZE);
  dev->global_mem_cacheline_size_ =
    info<cl_uint>(device_id, CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE);
  dev->global_mem_size_ =
    info<cl_ulong >(device_id,CL_DEVICE_GLOBAL_MEM_SIZE);
  dev->host_unified_memory_ =
    info<cl_bool>(device_id, CL_DEVICE_HOST_UNIFIED_MEMORY);
  dev->local_mem_size_ =
    info<cl_ulong>(device_id, CL_DEVICE_LOCAL_MEM_SIZE);
  dev->local_mem_type_ =
    info<cl_uint>(device_id, CL_DEVICE_LOCAL_MEM_TYPE);
  dev->max_clock_frequency_ =
    info<cl_uint>(device_id, CL_DEVICE_MAX_CLOCK_FREQUENCY);
  dev->max_compute_units_ =
    info<cl_uint>(device_id, CL_DEVICE_MAX_COMPUTE_UNITS);
  dev->max_constant_args_ =
    info<cl_uint>(device_id, CL_DEVICE_MAX_CONSTANT_ARGS);
  dev->max_constant_buffer_size_ =
    info<cl_ulong>(device_id, CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE);
  dev->max_mem_alloc_size_ =
    info<cl_ulong>(device_id, CL_DEVICE_MAX_MEM_ALLOC_SIZE);
  dev->max_parameter_size_ =
    info<size_t>(device_id, CL_DEVICE_MAX_PARAMETER_SIZE);
  dev->max_work_group_size_ =
    info<size_t>(device_id, CL_DEVICE_MAX_WORK_GROUP_SIZE);
  dev->max_work_item_dimensions_ =
    info<cl_uint>(device_id, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS);
  dev->profiling_timer_resolution_ =
    info<size_t>(device_id, CL_DEVICE_PROFILING_TIMER_RESOLUTION);
  dev->max_work_item_sizes_.resize(dev->max_work_item_dimensions_);
  clGetDeviceInfo(device_id.get(), CL_DEVICE_MAX_WORK_ITEM_SIZES,
                  sizeof(size_t) * dev->max_work_item_dimensions_,
                  dev->max_work_item_sizes_.data(), nullptr);
  dev->device_type_ =
    device_type_from_ulong(info<cl_ulong>(device_id, CL_DEVICE_TYPE));
  string extensions = info_string(device_id, CL_DEVICE_EXTENSIONS);
  split(dev->extensions_, extensions, " ", false);
  dev->opencl_c_version_ = info_string(device_id, CL_DEVICE_EXTENSIONS);
  dev->device_vendor_ = info_string(device_id, CL_DEVICE_VENDOR);
  dev->device_version_ = info_string(device_id, CL_DEVICE_VERSION);
  dev->name_ = info_string(device_id, CL_DEVICE_NAME);
  return dev;
}

void device::synchronize() {
  clFinish(queue_.get());
}

string device::info_string(const detail::raw_device_ptr& device_id,
                           unsigned info_flag) {
  size_t size;
  clGetDeviceInfo(device_id.get(), info_flag, 0, nullptr, &size);
  vector<char> buffer(size);
  clGetDeviceInfo(device_id.get(), info_flag, sizeof(char) * size, buffer.data(),
                  nullptr);
  return string(buffer.data());
}

device::device(detail::raw_device_ptr device_id,
               detail::raw_command_queue_ptr queue,
               detail::raw_context_ptr context,
               unsigned id)
  : device_id_(std::move(device_id)),
    queue_(std::move(queue)),
    context_(std::move(context)),
    id_(id) {
  // nop
}

device::~device() {
  // nop
}

} // namespace opencl
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <utility>
#include <vector>
#include <iostream>

#include "caf/opencl/platform.hpp"
#include "caf/opencl/opencl_err.hpp"

using namespace std;

namespace caf {
namespace opencl {

platform_ptr platform::create(cl_platform_id platform_id,
                              unsigned start_id) {
  vector<unsigned> device_types = {CL_DEVICE_TYPE_GPU,
                                   CL_DEVICE_TYPE_ACCELERATOR,
                                   CL_DEVICE_TYPE_CPU};
  vector<cl_device_id> ids;
  for (cl_device_type device_type : device_types) {
    auto known = ids.size();
    cl_uint discoverd;
    auto err = clGetDeviceIDs(platform_id, device_type, 0, nullptr, &discoverd);
    if (err == CL_DEVICE_NOT_FOUND) {
      continue; // no devices of the type found
    } else if (err != CL_SUCCESS) {
      throwcl("clGetDeviceIDs", err);
    }
    ids.resize(known + discoverd);
    v2callcl(CAF_CLF(clGetDeviceIDs), platform_id, device_type,
             discoverd, (ids.data() + known));
  }
  vector<detail::raw_device_ptr> devices;
  devices.resize(ids.size());
  auto lift = [](cl_device_id ptr) {
    return detail::raw_device_ptr{ptr, false};
  };
  transform(ids.begin(), ids.end(), devices.begin(), lift);
  detail::raw_context_ptr context;
  context.reset(v2get(CAF_CLF(clCreateContext), nullptr,
                      static_cast<unsigned>(ids.size()),
                      ids.data(), pfn_notify, nullptr),
                false);
  vector<device_ptr> device_information;
  for (auto& device_id : devices) {
    device_information.push_back(device::create(context, device_id,
                                                start_id++));
  }
  if (device_information.empty()) {
    string errstr = "no devices for the platform found";
    CAF_LOG_ERROR(CAF_ARG(errstr));
    CAF_RAISE_ERROR(move(errstr));
  }
  auto name = platform_info(platform_id, CL_PLATFORM_NAME);
  auto vendor = platform_info(platform_id, CL_PLATFORM_VENDOR);
  auto version = platform_info(platform_id, CL_PLATFORM_VERSION);
  return make_counted<platform>(platform_id, move(context), move(name),
                                move(vendor), move(version),
                                move(device_information));
}

string platform::platform_info(cl_platform_id platform_id,
                               unsigned info_flag) {
  size_t size;
  auto err = clGetPlatformInfo(platform_id, info_flag, 0, nullptr,
                               &size);
  throwcl("clGetPlatformInfo", err);
  vector<char> buffer(size);
  v2callcl(CAF_CLF(clGetPlatformInfo), platform_id, info_flag,
           sizeof(char) * size, buffer.data());
  return string(buffer.data());
}

platform::platform(cl_platform_id platform_id, detail::raw_context_ptr context,
                   string name, string vendor, string version,
                   vector<device_ptr> devices)
  : platform_id_(platform_id),
    context_(std::move(context)),
    name_(move(name)),
    vendor_(move(vendor)),
    version_(move(version)),
    devices_(move(devices)) {
  // nop
}

platform::~platform() {
  // nop
}

} // namespace opencl
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <map>
#include <vector>
#include <string>
#include <cstring>
#include <iostream>

#include "caf/opencl/manager.hpp"
#include "caf/opencl/program.hpp"
#include "caf/opencl/opencl_err.hpp"

using namespace std;

namespace caf {
namespace opencl {

program::program(detail::raw_context_ptr context,
                 detail::raw_command_queue_ptr queue,
                 detail::raw_program_ptr prog,
                 map<string, detail::raw_kernel_ptr> available_kernels)
    : context_(move(context)),
      program_(move(prog)),
      queue_(move(queue)),
      available_kernels_(move(available_kernels)) {
  // nop
}

program::~program() {
  // nop
}

} // namespace opencl
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 * Raphael Hiesgen <raphael.hiesgen (at) haw-hamburg.de>                      *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

 #include "caf/opencl/opencl_err.hpp"

namespace caf {
namespace opencl {

void throwcl(const char* fname, cl_int err) {
  if (err != CL_SUCCESS) {
    std::string errstr = fname;
    errstr += ": ";
    errstr += opencl_error(err);
    CAF_RAISE_ERROR(std::move(errstr));
  }
}

void CL_CALLBACK pfn_notify(const char* errinfo, const void*, size_t, void*) {
  CAF_LOG_ERROR("\n##### Error message via pfn_notify #####\n"
                << errinfo <<
                "\n########################################");
  static_cast<void>(errinfo); // remove warning
}

} // namespace opencl
} // namespace caf
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 * Raphael Hiesgen <raphael.hiesgen (at) haw-hamburg.de>                      *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <fstream>

#include "caf/detail/type_list.hpp"

#include "caf/opencl/device.hpp"
#include "caf/opencl/manager.hpp"
#include "caf/opencl/platform.hpp"
#include "caf/opencl/opencl_err.hpp"

#include "caf/opencl/detail/raw_ptr.hpp"

using namespace std;

namespace caf {
namespace opencl {

optional<device_ptr> manager::find_device(size_t dev_id) const {
  if (platforms_.empty())
    return none;
  size_t to = 0;
  for (auto& pl : platforms_) {
    auto from = to;
    to += pl->devices().size();
    if (dev_id >= from && dev_id < to)
      return pl->devices()[dev_id - from];
  }
  return none;
}

void manager::init(actor_system_config&) {
  // get number of available platforms
  auto num_platforms = v1get<cl_uint>(CAF_CLF(clGetPlatformIDs));
  // get platform ids
  std::vector<cl_platform_id> platform_ids(num_platforms);
  v2callcl(CAF_CLF(clGetPlatformIDs), num_platforms, platform_ids.data());
  if (platform_ids.empty())
    CAF_RAISE_ERROR("no OpenCL platform found");
  // initialize platforms (device discovery)
  unsigned current_device_id = 0;
  for (auto& pl_id : platform_ids) {
    platforms_.push_back(platform::create(pl_id, current_device_id));
    current_device_id +=
      static_cast<unsigned>(platforms_.back()->devices().size());
  }
}

void manager::start() {
  // nop
}

void manager::stop() {
  // nop
}

actor_system::module::id_t manager::id() const {
  return actor_system::module::opencl_manager;
}

void* manager::subtype_ptr() {
  return this;
}

actor_system::module* manager::make(actor_system& sys,
                                    caf::detail::type_list<>) {
  return new manager{sys};
}

program_ptr manager::create_program_from_file(const char* path,
                                              const char* options,
                                              uint32_t device_id) {
  std::ifstream read_source{std::string(path), std::ios::in};
  string kernel_source;
  if (read_source) {
    read_source.seekg(0, std::ios::end);
    kernel_source.resize(static_cast<size_t>(read_source.tellg()));
    read_source.seekg(0, std::ios::beg);
    read_source.read(&kernel_source[0],
                     static_cast<streamsize>(kernel_source.size()));
    read_source.close();
  } else {
    ostringstream oss;
    oss << "No file at '" << path << "' found.";
    CAF_LOG_ERROR(CAF_ARG(oss.str()));
    CAF_RAISE_ERROR(oss.str());
  }
  return create_program(kernel_source.c_str(), options, device_id);
}

program_ptr manager::create_program(const char* kernel_source,
                                    const char* options,
                                    uint32_t device_id) {
  auto dev = find_device(device_id);
  if (!dev) {
    ostringstream oss;
    oss << "No device with id '" << device_id << "' found.";
    CAF_LOG_ERROR(CAF_ARG(oss.str()));
    CAF_RAISE_ERROR(oss.str());
  }
  return create_program(kernel_source, options, *dev);
}

program_ptr manager::create_program_from_file(const char* path,
                                              const char* options,
                                              const device_ptr dev) {
  std::ifstream read_source{std::string(path), std::ios::in};
  string kernel_source;
  if (read_source) {
    read_source.seekg(0, std::ios::end);
    kernel_source.resize(static_cast<size_t>(read_source.tellg()));
    read_source.seekg(0, std::ios::beg);
    read_source.read(&kernel_source[0],
                     static_cast<streamsize>(kernel_source.size()));
    read_source.close();
  } else {
    ostringstream oss;
    oss << "No file at '" << path << "' found.";
    CAF_LOG_ERROR(CAF_ARG(oss.str()));
    CAF_RAISE_ERROR(oss.str());
  }
  return create_program(kernel_source.c_str(), options, dev);
}

program_ptr manager::create_program(const char* kernel_source,
                                    const char* options,
                                    const device_ptr dev) {
  // create program object from kernel source
  size_t kernel_source_length = strlen(kernel_source);
  detail::raw_program_ptr pptr;
  pptr.reset(v2get(CAF_CLF(clCreateProgramWithSource), dev->context_.get(),
                           1u, &kernel_source, &kernel_source_length),
             false);
  // build programm from program object
  auto dev_tmp = dev->device_id_.get();
  auto err = clBuildProgram(pptr.get(), 1, &dev_tmp, options, nullptr, nullptr);
  if (err != CL_SUCCESS) {
    ostringstream oss;
    oss << "clBuildProgram: " << opencl_error(err);
    if (err == CL_BUILD_PROGRAM_FAILURE) {
      size_t buildlog_buffer_size = 0;
      // get the log length
      clGetProgramBuildInfo(pptr.get(), dev_tmp, CL_PROGRAM_BUILD_LOG,
                            0, nullptr, &buildlog_buffer_size);
      vector<char> buffer(buildlog_buffer_size);
      // fill the buffer with buildlog informations
      clGetProgramBuildInfo(pptr.get(), dev_tmp, CL_PROGRAM_BUILD_LOG,
                            sizeof(char) * buildlog_buffer_size,
                            buffer.data(), nullptr);
      ostringstream ss;
      ss << "############## Build log ##############"
         << endl << string(buffer.data()) << endl
         << "#######################################";
      // seems that just apple implemented the
      // pfn_notify callback, but we can get
      // the build log
#ifndef __APPLE__
      CAF_LOG_ERROR(CAF_ARG(ss.str()));
#endif
      oss << endl << ss.str();
    }
    CAF_RAISE_ERROR(oss.str());
  }
  cl_uint number_of_kernels = 0;
  clCreateKernelsInProgram(pptr.get(), 0u, nullptr, &number_of_kernels);
  map<string, detail::raw_kernel_ptr> available_kernels;
  if (number_of_kernels > 0) {
    vector<cl_kernel> kernels(number_of_kernels);
    err = clCreateKernelsInProgram(pptr.get(), number_of_kernels,
                                   kernels.data(), nullptr);
    if (err != CL_SUCCESS) {
      ostringstream oss;
      oss << "clCreateKernelsInProgram: " << opencl_error(err);
      CAF_RAISE_ERROR(oss.str());
    }
    for (cl_uint i = 0; i < number_of_kernels; ++i) {
      size_t len;
      clGetKernelInfo(kernels[i], CL_KERNEL_FUNCTION_NAME, 0, nullptr, &len);
      vector<char> name(len);
      err = clGetKernelInfo(kernels[i], CL_KERNEL_FUNCTION_NAME, len,
                            reinterpret_cast<void*>(name.data()), nullptr);
      if (err != CL_SUCCESS) {
        ostringstream oss;
        oss << "clGetKernelInfo (CL_KERNEL_FUNCTION_NAME): "
            << opencl_error(err);
        CAF_RAISE_ERROR(oss.str());
      }
      detail::raw_kernel_ptr kernel;
      kernel.reset(move(kernels[i]));
      available_kernels.emplace(string(name.data()), move(kernel));
    }
  } else {
    CAF_LOG_WARNING("Could not built all kernels in program. Since this happens"
                    " on some platforms, we'll ignore this and try to build"
                    " each kernel individually by name.");
  }
  return make_counted<program>(dev->context_, dev->queue_, pptr,
                               move(available_kernels));
}

manager::manager(actor_system& sys) : system_(sys) {
  // nop
}

manager::~manager() {
  // nop
}

} // namespace opencl
} // namespace caf
#define CAF_SUITE opencl
#include "caf/test/unit_test.hpp"

#include <vector>
#include <iomanip>
#include <cassert>
#include <iostream>
#include <algorithm>

#include "caf/all.hpp"
#include "caf/system_messages.hpp"

#include "caf/opencl/all.hpp"

using namespace std;
using namespace caf;
using namespace caf::opencl;

using caf::detail::tl_at;
using caf::detail::tl_head;
using caf::detail::type_list;
using caf::detail::limited_vector;

namespace {

using ivec = vector<int>;
using iref = mem_ref<int>;
using dims = opencl::dim_vec;

constexpr size_t matrix_size = 4;
constexpr size_t array_size = 32;
constexpr size_t problem_size = 1024;

constexpr const char* kn_matrix = "matrix_square";
constexpr const char* kn_compiler_flag = "compiler_flag";
constexpr const char* kn_reduce = "reduce";
constexpr const char* kn_const = "const_mod";
constexpr const char* kn_inout = "times_two";
constexpr const char* kn_scratch = "use_scratch";
constexpr const char* kn_local = "use_local";
constexpr const char* kn_order = "test_order";
constexpr const char* kn_private = "use_private";
constexpr const char* kn_varying = "varying";

constexpr const char* compiler_flag = "-D CAF_OPENCL_TEST_FLAG";

constexpr const char* kernel_source = R"__(
  kernel void matrix_square(global const int* restrict matrix,
                            global       int* restrict output) {
    size_t size = get_global_size(0); // == get_global_size_(1);
    size_t x = get_global_id(0);
    size_t y = get_global_id(1);
    int result = 0;
    for (size_t idx = 0; idx < size; ++idx) {
      result += matrix[idx + y * size] * matrix[x + idx * size];
    }
    output[x + y * size] = result;
  }

// http://developer.amd.com/resources/documentation-articles/
// articles-whitepapers/opencl-optimization-case-study-simple-reductions
  kernel void reduce(global const int* restrict buffer,
                     global       int* restrict result) {
    local int scratch[512];
    int local_index = get_local_id(0);
    scratch[local_index] = buffer[get_global_id(0)];
    barrier(CLK_LOCAL_MEM_FENCE);
    for(int offset = get_local_size(0) / 2; offset > 0; offset = offset / 2) {
      if (local_index < offset) {
        int other = scratch[local_index + offset];
        int mine = scratch[local_index];
        scratch[local_index] = (mine < other) ? mine : other;
      }
      barrier(CLK_LOCAL_MEM_FENCE);
    }
    if (local_index == 0)
      result[get_group_id(0)] = scratch[0];
  }

  kernel void const_mod(constant int* restrict input,
                        global   int* restrict output) {
    size_t idx = get_global_id(0);
    output[idx] = input[0];
  }

  kernel void times_two(global int* restrict values) {
    size_t idx = get_global_id(0);
    values[idx] = values[idx] * 2;
  }

  kernel void use_scratch(global int* restrict values,
                          global int* restrict buf) {
    size_t idx = get_global_id(0);
    buf[idx] = values[idx];
    buf[idx] += values[idx];
    values[idx] = buf[idx];
  }

  inline void prefix_sum(local int* restrict data, size_t len, size_t lids) {
    size_t lid = get_local_id(0);
    size_t inc = 2;
    // reduce
    while (inc <= len) {
      int j = inc >> 1;
      for (int i = (j - 1) + (lid * inc); (i + inc) < len; i += (lids * inc))
        data[i + j] = data[i] + data[i + j];
      inc = inc << 1;
      barrier(CLK_LOCAL_MEM_FENCE);
    }
    // downsweep
    data[len - 1] = 0;
    barrier(CLK_LOCAL_MEM_FENCE);
    while (inc >= 2) {
      int j = inc >> 1;
      for (int i = (j - 1) + (lid * inc); (i + j) <= len; i += (lids * inc)) {
        uint tmp = data[i + j];
        data[i + j] = data[i] + data[i + j];
        data[i] = tmp;
      }
      inc = inc >> 1;
      barrier(CLK_LOCAL_MEM_FENCE);
    }
  }

  kernel void use_local(global int* restrict values,
                        local  int* restrict buf) {
    size_t lid = get_local_id(0);
    size_t gid = get_group_id(0);
    size_t gs = get_local_size(0);
    buf[lid] = values[gid * gs + lid];
    barrier(CLK_LOCAL_MEM_FENCE);
    prefix_sum(buf, gs, gs);
    barrier(CLK_LOCAL_MEM_FENCE);
    values[gid * gs + lid] = buf[lid];
  }

  kernel void test_order(local  int* buf,
                         global int* restrict values) {
    size_t lid = get_local_id(0);
    size_t gid = get_group_id(0);
    size_t gs = get_local_size(0);
    buf[lid] = values[gid * gs + lid];
    barrier(CLK_LOCAL_MEM_FENCE);
    prefix_sum(buf, gs, gs);
    barrier(CLK_LOCAL_MEM_FENCE);
    values[gid * gs + lid] = buf[lid];
  }

  kernel void use_private(global  int* restrict buf,
                          private int  val) {
    buf[get_global_id(0)] += val;
  }

  kernel void varying(global const int* restrict in1,
                      global       int* restrict out1,
                      global const int* restrict in2,
                      global       int* restrict out2) {
    size_t idx = get_global_id(0);
    out1[idx] = in1[idx];
    out2[idx] = in2[idx];
  }
)__";

constexpr const char* kernel_source_error = R"__(
  kernel void missing(global int*) {
    size_t semicolon_missing
  }
)__";

constexpr const char* kernel_source_compiler_flag = R"__(
  kernel void compiler_flag(global const int* restrict input,
                            global       int* restrict output) {
    size_t x = get_global_id(0);
#   ifdef CAF_OPENCL_TEST_FLAG
    output[x] = input[x];
#   else
    output[x] = 0;
#   endif
  }
)__";

} // namespace <anonymous>

template<size_t Size>
class square_matrix {
public:
  using value_type = ivec::value_type;
  static constexpr size_t num_elements = Size * Size;

  template <class Inspector>
  friend typename Inspector::result_type inspect(Inspector& f,
                                                 square_matrix& x) {
    return f(meta::type_name("square_matrix"), x.data_);
  }

  square_matrix(square_matrix&&) = default;
  square_matrix(const square_matrix&) = default;
  square_matrix& operator=(square_matrix&&) = default;
  square_matrix& operator=(const square_matrix&) = default;

  square_matrix() : data_(num_elements) {
    // nop
  }

  explicit square_matrix(ivec d) : data_(move(d)) {
    assert(data_.size() == num_elements);
  }

  float& operator()(size_t column, size_t row) {
    return data_[column + row * Size];
  }

  const float& operator()(size_t column, size_t row) const {
    return data_[column + row * Size];
  }

  using const_iterator = typename ivec::const_iterator;

  const_iterator begin() const {
    return data_.begin();
  }

  const_iterator end() const {
    return data_.end();
  }

  ivec& data() {
    return data_;
  }

  const ivec& data() const {
    return data_;
  }

  void data(ivec new_data) {
    data_ = move(new_data);
  }

private:
  ivec data_;
};


template <class T>
vector<T> make_iota_vector(size_t num_elements) {
  vector<T> result;
  result.resize(num_elements);
  iota(result.begin(), result.end(), T{0});
  return result;
}

template <size_t Size>
square_matrix<Size> make_iota_matrix() {
  square_matrix<Size> result;
  iota(result.data().begin(), result.data().end(), 0);
  return result;
}

template<size_t Size>
bool operator==(const square_matrix<Size>& lhs,
                const square_matrix<Size>& rhs) {
  return lhs.data() == rhs.data();
}

template<size_t Size>
bool operator!=(const square_matrix<Size>& lhs,
                const square_matrix<Size>& rhs) {
  return !(lhs == rhs);
}

using matrix_type = square_matrix<matrix_size>;

template <class T>
void check_vector_results(const string& description,
                          const vector<T>& expected,
                          const vector<T>& result) {
  auto cond = (expected == result);
  CAF_CHECK(cond);
  if (!cond) {
    CAF_ERROR(description << " failed.");
    cout << "Expected: " << endl;
    for (size_t i = 0; i < expected.size(); ++i) {
      cout << " " << expected[i];
    }
    cout << endl << "Received: " << endl;
    for (size_t i = 0; i < result.size(); ++i) {
      cout << " " << result[i];
    }
    cout << endl;
    cout << "Size: " << expected.size() << " vs. " << result.size() << endl;
    cout << "Differ at: " << endl;
    bool same = true;
    for (size_t i = 0; i < min(expected.size(), result.size()); ++i) {
      if (expected[i] != result[i]) {
        cout << "[" << i << "] " << expected[i] << " != " << result[i] << endl;
        same = false;
      }
    }
    if (same) {
      cout << "... nowhere." << endl;
    }
  }
}

template <class T>
void check_mref_results(const string& description,
                        const vector<T>& expected,
                        mem_ref<T>& result) {
  auto exp_res = result.data();
  CAF_REQUIRE(exp_res);
  auto res = *exp_res;
  auto cond = (expected == res);
  CAF_CHECK(cond);
  if (!cond) {
    CAF_ERROR(description << " failed.");
    cout << "Expected: " << endl;
    for (size_t i = 0; i < expected.size(); ++i) {
      cout << " " << expected[i];
    }
    cout << endl << "Received: " << endl;
    for (size_t i = 0; i < res.size(); ++i) {
      cout << " " << res[i];
    }
    cout << endl;
  }
}

void test_opencl(actor_system& sys) {
  auto& mngr = sys.opencl_manager();
  auto opt = mngr.find_device_if([](const device_ptr){ return true; });
  CAF_REQUIRE(opt);
  auto dev = *opt;
  auto prog = mngr.create_program(kernel_source, "", dev);
  scoped_actor self{sys};
  auto wrong_msg = [&](message_view& x) -> result<message> {
    CAF_ERROR("unexpected message" << x.content().stringify());
    return sec::unexpected_message;
  };
  const ivec expected1{ 56,  62,  68,  74,
                       152, 174, 196, 218,
                       248, 286, 324, 362,
                       344, 398, 452, 506};
  auto w1 = mngr.spawn(prog, kn_matrix,
                       opencl::nd_range{dims{matrix_size, matrix_size}},
                       opencl::in<int>{}, opencl::out<int>{});
  self->send(w1, make_iota_vector<int>(matrix_size * matrix_size));
  self->receive (
    [&](const ivec& result) {
      check_vector_results("Simple matrix multiplication using vectors"
                           " (kernel wrapped in program)",
                           expected1, result);
    }, others >> wrong_msg
  );
  opencl::nd_range range2{dims{matrix_size, matrix_size}};
  // Pass kernel directly to the actor
  auto w2 = mngr.spawn(kernel_source, kn_matrix, range2,
                       opencl::in<int>{}, opencl::out<int>{});
  self->send(w2, make_iota_vector<int>(matrix_size * matrix_size));
  self->receive (
    [&](const ivec& result) {
      check_vector_results("Simple matrix multiplication using vectors"
                           " (kernel passed directly)",
                           expected1, result);
    }, others >> wrong_msg
  );
  const matrix_type expected2(move(expected1));
  auto map_arg = [](message& msg) -> optional<message> {
    return msg.apply(
      [](matrix_type& mx) {
        return make_message(move(mx.data()));
      }
    );
  };
  auto map_res = [](ivec result) -> message {
    return make_message(matrix_type{move(result)});
  };
  opencl::nd_range range3{dims{matrix_size, matrix_size}};
  // let the runtime choose the device
  auto w3 = mngr.spawn(mngr.create_program(kernel_source), kn_matrix, range3,
                       map_arg, map_res,
                       opencl::in<int>{}, opencl::out<int>{});
  self->send(w3, make_iota_matrix<matrix_size>());
  self->receive (
    [&](const matrix_type& result) {
      check_vector_results("Matrix multiplication with user defined type "
                           "(kernel wrapped in program)",
                           expected2.data(), result.data());
    }, others >> wrong_msg
  );
  opencl::nd_range range4{dims{matrix_size, matrix_size}};
  auto w4 = mngr.spawn(prog, kn_matrix, range4,
                       map_arg, map_res,
                       opencl::in<int>{}, opencl::out<int>{});
  self->send(w4, make_iota_matrix<matrix_size>());
  self->receive (
    [&](const matrix_type& result) {
      check_vector_results("Matrix multiplication with user defined type",
                           expected2.data(), result.data());
    }, others >> wrong_msg
  );
  CAF_MESSAGE("Expecting exception (compiling invalid kernel, "
              "semicolon is missing).");
  try {
    /* auto expected_error = */ mngr.create_program(kernel_source_error);
  } catch (const exception& exc) {
    std::string starts_with("clBuildProgram: CL_BUILD_PROGRAM_FAILURE");
    auto cond = (strncmp(exc.what(), starts_with.c_str(),
                         starts_with.size()) == 0);
    CAF_CHECK(cond);
    if (!cond)
      CAF_ERROR("Wrong exception cought for program build failure.");
  }

  // create program with opencl compiler flags
  auto prog5 = mngr.create_program(kernel_source_compiler_flag, compiler_flag);
  opencl::nd_range range5{dims{array_size}};
  auto w5 = mngr.spawn(prog5, kn_compiler_flag, range5,
                       opencl::in<int>{}, opencl::out<int>{});
  self->send(w5, make_iota_vector<int>(array_size));
  auto expected3 = make_iota_vector<int>(array_size);
  self->receive (
    [&](const ivec& result) {
      check_vector_results("Passing compiler flags", expected3, result);
    }, others >> wrong_msg
  );

  // test for manuel return size selection (max workgroup size 1d)
  auto max_wg_size = min(dev->max_work_item_sizes()[0], size_t{512});
  auto reduce_buffer_size = static_cast<size_t>(max_wg_size) * 8;
  auto reduce_local_size  = static_cast<size_t>(max_wg_size);
  auto reduce_work_groups = reduce_buffer_size / reduce_local_size;
  auto reduce_global_size = reduce_buffer_size;
  auto reduce_result_size = reduce_work_groups;
  ivec arr6(reduce_buffer_size);
  int n = static_cast<int>(arr6.capacity());
  generate(arr6.begin(), arr6.end(), [&]{ return --n; });
  opencl::nd_range range6{dims{reduce_global_size},
                            dims{                  }, // no offset
                            dims{reduce_local_size}};
  auto result_size_6 = [reduce_result_size](const ivec&) {
    return reduce_result_size;
  };
  auto w6 = mngr.spawn(prog, kn_reduce, range6,
                       opencl::in<int>{}, opencl::out<int>{result_size_6});
  self->send(w6, move(arr6));
  auto wg_size_as_int = static_cast<int>(max_wg_size);
  ivec expected4{wg_size_as_int * 7, wg_size_as_int * 6, wg_size_as_int * 5,
                 wg_size_as_int * 4, wg_size_as_int * 3, wg_size_as_int * 2,
                 wg_size_as_int    ,               0};
  self->receive(
    [&](const ivec& result) {
      check_vector_results("Passing size for the output", expected4, result);
    }, others >> wrong_msg
  );

  // calculator function for getting the size of the output
  auto result_size_7 = [](const ivec&) {
    return problem_size;
  };
  // constant memory arguments
  const ivec arr7{static_cast<int>(problem_size)};
  auto w7 = mngr.spawn(kernel_source, kn_const,
                       opencl::nd_range{dims{problem_size}},
                       opencl::in<int>{},
                       opencl::out<int>{result_size_7});
  self->send(w7, move(arr7));
  ivec expected5(problem_size);
  fill(begin(expected5), end(expected5), static_cast<int>(problem_size));
  self->receive(
    [&](const ivec& result) {
      check_vector_results("Using const input argument", expected5, result);
    }, others >> wrong_msg
  );
}

void test_arguments(actor_system& sys) {
  auto& mngr = sys.opencl_manager();
  auto opt = mngr.find_device_if([](const device_ptr){ return true; });
  CAF_REQUIRE(opt);
  auto dev = *opt;
  scoped_actor self{sys};
  auto wrong_msg = [&](message_view& x) -> result<message> {
    CAF_ERROR("unexpected message" << x.content().stringify());
    return sec::unexpected_message;
  };
  const ivec expected1{ 56,  62,  68,  74,   152, 174, 196, 218,
                       248, 286, 324, 362,   344, 398, 452, 506};
  auto w1 = mngr.spawn(mngr.create_program(kernel_source, "", dev), kn_matrix,
                       opencl::nd_range{dims{matrix_size, matrix_size}},
                       opencl::in<int>{}, opencl::out<int>{});
  self->send(w1, make_iota_vector<int>(matrix_size * matrix_size));
  self->receive (
    [&](const ivec& result) {
      check_vector_results("arguments: from in to out", expected1, result);
    }, others >> wrong_msg
  );
  ivec input9 = make_iota_vector<int>(problem_size);
  ivec expected9{input9};
  for_each(begin(expected9), end(expected9), [](int& val){ val *= 2; });
  auto w9 = mngr.spawn(kernel_source, kn_inout,
                       nd_range{dims{problem_size}},
                       opencl::in_out<int>{});
  self->send(w9, move(input9));
  self->receive(
    [&](const ivec& result) {
      check_vector_results("Testing in_out arugment", expected9, result);
    }, others >> wrong_msg
  );
  ivec input10 = make_iota_vector<int>(problem_size);
  ivec expected10{input10};
  for_each(begin(expected10), end(expected10), [](int& val){ val *= 2; });
  auto result_size_10 = [=](const ivec& input) { return input.size(); };
  auto w10 = mngr.spawn(kernel_source, kn_scratch,
                        nd_range{dims{problem_size}},
                        opencl::in_out<int>{},
                        opencl::scratch<int>{result_size_10});
  self->send(w10, move(input10));
  self->receive(
    [&](const ivec& result) {
      check_vector_results("Testing buffer arugment", expected10, result);
    }, others >> wrong_msg
  );
  // test local
  size_t la_global = 256;
  size_t la_local = la_global / 2;
  ivec input_local = make_iota_vector<int>(la_global);
  ivec expected_local{input_local};
  auto last = 0;
  for (size_t i = 0; i < la_global; ++i) {
    if (i == la_local) last = 0;
    auto tmp = expected_local[i];
    expected_local[i] = last;
    last += tmp;
  }
  auto work_local = mngr.spawn(kernel_source, kn_local,
                               nd_range{dims{la_global}, {}, dims{la_local}},
                               opencl::in_out<int>{},
                               opencl::local<int>{la_local});
  self->send(work_local, std::move(input_local));
  self->receive(
    [&](const ivec& result) {
      check_vector_results("Testing local arugment", expected_local, result);
    }
  );
  // Same test, different argument order
  input_local = make_iota_vector<int>(la_global);
  work_local = mngr.spawn(kernel_source, kn_order,
                          nd_range{dims{la_global}, {}, dims{la_local}},
                          opencl::local<int>{la_local},
                          opencl::in_out<int>{});
  self->send(work_local, std::move(input_local));
  self->receive(
    [&](const ivec& result) {
      check_vector_results("Testing local arugment", expected_local, result);
    }
  );
  // Test private argument
  ivec input_private = make_iota_vector<int>(problem_size);
  int val_private = 42;
  ivec expected_private{input_private};
  for_each(begin(expected_private), end(expected_private),
           [val_private](int& val){ val += val_private; });
  auto worker_private = mngr.spawn(kernel_source, kn_private,
                                   nd_range{dims{problem_size}},
                                   opencl::in_out<int>{},
                                   opencl::priv<int>{val_private});
  self->send(worker_private, std::move(input_private));
  self->receive(
    [&](const ivec& result) {
      check_vector_results("Testing private arugment", expected_private,
                           result);
    }
  );
}

CAF_TEST(opencl_basics) {
  actor_system_config cfg;
  cfg.load<opencl::manager>()
    .add_message_type<ivec>("int_vector")
    .add_message_type<matrix_type>("square_matrix");
  actor_system system{cfg};
  test_opencl(system);
  system.await_all_actors_done();
}

CAF_TEST(opencl_arguments) {
  actor_system_config cfg;
  cfg.load<opencl::manager>()
    .add_message_type<ivec>("int_vector")
    .add_message_type<matrix_type>("square_matrix");
  actor_system system{cfg};
  test_arguments(system);
  system.await_all_actors_done();
}

CAF_TEST(opencl_mem_refs) {
  actor_system_config cfg;
  cfg.load<opencl::manager>();
  actor_system system{cfg};
  auto& mngr = system.opencl_manager();
  auto opt = mngr.find_device(0);
  CAF_REQUIRE(opt);
  auto dev = *opt;
  // global arguments
  vector<uint32_t> input{1, 2, 3, 4};
  auto buf_1 = dev->global_argument(input, buffer_type::input_output);
  CAF_CHECK_EQUAL(buf_1.size(), input.size());
  auto res_1 = buf_1.data();
  CAF_CHECK(res_1);
  CAF_CHECK_EQUAL(res_1->size(), input.size());
  check_vector_results("Testing mem_ref", input, *res_1);
  auto res_2 = buf_1.data(2ul);
  CAF_CHECK(res_2);
  CAF_CHECK_EQUAL(res_2->size(), 2ul);
  CAF_CHECK_EQUAL((*res_2)[0], input[0]);
  CAF_CHECK_EQUAL((*res_2)[1], input[1]);
  vector<uint32_t> new_input{1,2,3,4,5};
  buf_1 = dev->global_argument(new_input, buffer_type::input_output);
  CAF_CHECK_EQUAL(buf_1.size(), new_input.size());
  auto res_3 = buf_1.data();
  CAF_CHECK(res_3);
  mem_ref<uint32_t> buf_2{std::move(buf_1)};
  CAF_CHECK_EQUAL(buf_2.size(), new_input.size());
  auto res_4 = buf_2.data();
  CAF_CHECK(res_4);
  buf_2.reset();
  auto res_5 = buf_2.data();
  CAF_CHECK(!res_5);
}

CAF_TEST(opencl_argument_info) {
  using base_t = int;
  using in_arg_t = ::type_list<opencl::in<base_t>>;
  using in_arg_info_t = typename cl_arg_info_list<in_arg_t>::type;
  using in_arg_wrap_t = typename ::tl_head<in_arg_info_t>::type;
  static_assert(in_arg_wrap_t::in_pos == 0, "In-index for `in` wrong.");
  static_assert(in_arg_wrap_t::out_pos == -1, "Out-index for `in` wrong.");
  using out_arg_t = ::type_list<opencl::out<base_t>>;
  using out_arg_info_t = typename cl_arg_info_list<out_arg_t>::type;
  using out_arg_wrap_t = typename ::tl_head<out_arg_info_t>::type;
  static_assert(out_arg_wrap_t::in_pos == -1, "In-index for `out` wrong.");
  static_assert(out_arg_wrap_t::out_pos == 0, "Out-index for `out` wrong.");
  using io_arg_t = ::type_list<opencl::in_out<base_t>>;
  using io_arg_info_t = typename cl_arg_info_list<io_arg_t>::type;
  using io_arg_wrap_t = typename ::tl_head<io_arg_info_t>::type;
  static_assert(io_arg_wrap_t::in_pos == 0, "In-index for `in_out` wrong.");
  static_assert(io_arg_wrap_t::out_pos == 0, "Out-index for `in_out` wrong.");
  using arg_list_t = ::type_list<opencl::in<base_t>,
                                            opencl::out<base_t>,
                                            opencl::local<base_t>,
                                            opencl::in_out<base_t>,
                                            opencl::priv<base_t>,
                                            opencl::priv<base_t, val>>;
  using arg_info_list_t = typename cl_arg_info_list<arg_list_t>::type;
  using arg_info_0_t = typename ::tl_at<arg_info_list_t,0>::type;
  static_assert(arg_info_0_t::in_pos == 0, "In-index for `in` wrong.");
  static_assert(arg_info_0_t::out_pos == -1, "Out-index for `in` wrong.");
  using arg_info_1_t = typename ::tl_at<arg_info_list_t,1>::type;
  static_assert(arg_info_1_t::in_pos == -1, "In-index for `out` wrong.");
  static_assert(arg_info_1_t::out_pos == 0, "Out-index for `out` wrong.");
  using arg_info_2_t = typename ::tl_at<arg_info_list_t,2>::type;
  static_assert(arg_info_2_t::in_pos == -1, "In-index for `local` wrong.");
  static_assert(arg_info_2_t::out_pos == -1, "Out-index for `local` wrong.");
  using arg_info_3_t = typename ::tl_at<arg_info_list_t,3>::type;
  static_assert(arg_info_3_t::in_pos == 1, "In-index for `in_out` wrong.");
  static_assert(arg_info_3_t::out_pos == 1, "Out-index for `in_out` wrong.");
  using arg_info_4_t = typename ::tl_at<arg_info_list_t,4>::type;
  static_assert(arg_info_4_t::in_pos == -1, "In-index for `priv` wrong.");
  static_assert(arg_info_4_t::out_pos == -1, "Out-index for `priv` wrong.");
  using arg_info_5_t = typename ::tl_at<arg_info_list_t,5>::type;
  static_assert(arg_info_5_t::in_pos == 2, "In-index for `priv` wrong.");
  static_assert(arg_info_5_t::out_pos == -1, "Out-index for `priv` wrong.");
  // gives the test some output.
  CAF_CHECK_EQUAL(true, true);
}

void test_in_val_out_val(actor_system& sys) {
  CAF_MESSAGE("Testing in: val  -> out: val ");
  auto& mngr = sys.opencl_manager();
  auto opt = mngr.find_device(0);
  CAF_REQUIRE(opt);
  auto dev = *opt;
  auto prog = mngr.create_program(kernel_source, "", dev);
  scoped_actor self{sys};
  auto wrong_msg = [&](message_view& x) -> result<message> {
    CAF_ERROR("unexpected message" << x.content().stringify());
    return sec::unexpected_message;
  };
  const ivec res1{ 56,  62,  68,  74, 152, 174, 196, 218,
                  248, 286, 324, 362, 344, 398, 452, 506};
  auto conf = opencl::nd_range{dims{matrix_size, matrix_size}};
  auto w1 = mngr.spawn(prog, kn_matrix, conf, in<int>{}, out<int>{});
  self->send(w1, make_iota_vector<int>(matrix_size * matrix_size));
  self->receive([&](const ivec& result) {
    check_vector_results("Simple matrix multiplication using vectors"
                         " (kernel wrapped in program)", res1, result);
  }, others >> wrong_msg);
  // Pass kernel directly to the actor
  auto w2 = mngr.spawn(kernel_source, kn_matrix, conf,
                           in<int>{}, out<int>{});
  self->send(w2, make_iota_vector<int>(matrix_size * matrix_size));
  self->receive([&](const ivec& result) {
    check_vector_results("Simple matrix multiplication using vectors"
                         " (kernel passed directly)", res1, result);
  }, others >> wrong_msg);
  // Wrap message in user-defined type and use mapping functions
  const matrix_type res2(move(res1));
  auto map_arg = [](message& msg) -> optional<message> {
    return msg.apply([](matrix_type& mx) {
      return make_message(move(mx.data()));
    });
  };
  auto map_res = [](ivec result) -> message {
    return make_message(matrix_type{move(result)});
  };
  auto w3 = mngr.spawn(prog, kn_matrix, conf, map_arg, map_res,
                           in<int, val>{}, out<int, val>{});
  self->send(w3, make_iota_matrix<matrix_size>());
  self->receive([&](const matrix_type& result) {
    check_vector_results("Matrix multiplication with user defined type "
                         "(kernel wrapped in program)",
                         res2.data(), result.data());
  }, others >> wrong_msg);
  // create program with opencl compiler flags
  auto prog2 = mngr.create_program(kernel_source_compiler_flag, compiler_flag);
  nd_range range2{dims{array_size}};
  auto w4 = mngr.spawn(prog2, kn_compiler_flag, range2,
                           in<int>{}, out<int>{});
  self->send(w4, make_iota_vector<int>(array_size));
  auto res3 = make_iota_vector<int>(array_size);
  self->receive([&](const ivec& result) {
    check_vector_results("Passing compiler flags", res3, result);
  }, others >> wrong_msg);

  // test for manuel return size selection (max workgroup size 1d)
  auto max_wg_size = min(dev->max_work_item_sizes()[0], size_t{512});
  auto reduce_buffer_size = static_cast<size_t>(max_wg_size) * 8;
  auto reduce_local_size  = static_cast<size_t>(max_wg_size);
  auto reduce_work_groups = reduce_buffer_size / reduce_local_size;
  auto reduce_global_size = reduce_buffer_size;
  auto reduce_result_size = reduce_work_groups;
  ivec input(reduce_buffer_size);
  int n = static_cast<int>(input.capacity());
  generate(input.begin(), input.end(), [&]{ return --n; });
  nd_range range3{dims{reduce_global_size}, dims{}, dims{reduce_local_size}};
  auto res_size = [&](const ivec&) { return reduce_result_size; };
  auto w5 = mngr.spawn(prog, kn_reduce, range3,
                           in<int>{}, out<int>{res_size});
  self->send(w5, move(input));
  auto wg_size_as_int = static_cast<int>(max_wg_size);
  ivec res4{
    wg_size_as_int * 7, wg_size_as_int * 6, wg_size_as_int * 5,
    wg_size_as_int * 4, wg_size_as_int * 3, wg_size_as_int * 2,
    wg_size_as_int    ,                  0
  };
  self->receive([&](const ivec& result) {
    check_vector_results("Passing size for the output", res4, result);
  }, others >> wrong_msg);
  // calculator function for getting the size of the output
  auto res_size2 = [](const ivec&) { return problem_size; };
  // constant memory arguments
  const ivec input2{static_cast<int>(problem_size)};
  auto w6 = mngr.spawn(kernel_source, kn_const,
                           nd_range{dims{problem_size}},
                           in<int>{}, out<int>{res_size2});
  self->send(w6, move(input2));
  ivec res5(problem_size);
  fill(begin(res5), end(res5), static_cast<int>(problem_size));
  self->receive([&](const ivec& result) {
    check_vector_results("Using const input argument", res5, result);
  }, others >> wrong_msg);
}

void test_in_val_out_mref(actor_system& sys) {
  CAF_MESSAGE("Testing in: val  -> out: mref");
  // setup
  auto& mngr = sys.opencl_manager();
  auto opt = mngr.find_device(0);
  CAF_REQUIRE(opt);
  auto dev = *opt;
  auto prog = mngr.create_program(kernel_source, "", dev);
  scoped_actor self{sys};
  auto wrong_msg = [&](message_view& x) -> result<message> {
    CAF_ERROR("unexpected message" << x.content().stringify());
    return sec::unexpected_message;
  };
  // tests
  const ivec res1{ 56,  62,  68,  74, 152, 174, 196, 218,
                  248, 286, 324, 362, 344, 398, 452, 506};
  auto range = opencl::nd_range{dims{matrix_size, matrix_size}};
  auto w1 = mngr.spawn(prog, kn_matrix, range, in<int>{}, out<int, mref>{});
  self->send(w1, make_iota_vector<int>(matrix_size * matrix_size));
  self->receive([&](iref& result) {
    check_mref_results("Simple matrix multiplication using vectors"
                       " (kernel wrapped in program)", res1, result);
  }, others >> wrong_msg);
  // Pass kernel directly to the actor
  auto w2 = mngr.spawn(kernel_source, kn_matrix, range,
                       in<int>{}, out<int, mref>{});
  self->send(w2, make_iota_vector<int>(matrix_size * matrix_size));
  self->receive([&](iref& result) {
    check_mref_results("Simple matrix multiplication using vectors"
                       " (kernel passed directly)", res1, result);
  }, others >> wrong_msg);
  // test for manuel return size selection (max workgroup size 1d)
  auto max_wg_size = min(dev->max_work_item_sizes()[0], size_t{512});
  auto reduce_buffer_size = static_cast<size_t>(max_wg_size) * 8;
  auto reduce_local_size  = static_cast<size_t>(max_wg_size);
  auto reduce_work_groups = reduce_buffer_size / reduce_local_size;
  auto reduce_global_size = reduce_buffer_size;
  auto reduce_result_size = reduce_work_groups;
  ivec input(reduce_buffer_size);
  int n = static_cast<int>(input.capacity());
  generate(input.begin(), input.end(), [&]{ return --n; });
  nd_range range3{dims{reduce_global_size}, dims{}, dims{reduce_local_size}};
  auto res_size = [&](const ivec&) { return reduce_result_size; };
  auto w5 = mngr.spawn(prog, kn_reduce, range3,
                       in<int>{}, out<int, mref>{res_size});
  self->send(w5, move(input));
  auto wg_size_as_int = static_cast<int>(max_wg_size);
  ivec res4{wg_size_as_int * 7, wg_size_as_int * 6, wg_size_as_int * 5,
            wg_size_as_int * 4, wg_size_as_int * 3, wg_size_as_int * 2,
            wg_size_as_int * 1, wg_size_as_int * 0};
  self->receive([&](iref& result) {
    check_mref_results("Passing size for the output", res4, result);
  }, others >> wrong_msg);
}

void test_in_mref_out_val(actor_system& sys) {
  CAF_MESSAGE("Testing in: mref -> out: val ");
  // setup
  auto& mngr = sys.opencl_manager();
  auto opt = mngr.find_device(0);
  CAF_REQUIRE(opt);
  auto dev = *opt;
  auto prog = mngr.create_program(kernel_source, "", dev);
  scoped_actor self{sys};
  auto wrong_msg = [&](message_view& x) -> result<message> {
    CAF_ERROR("unexpected message" << x.content().stringify());
    return sec::unexpected_message;
  };
  // tests
  const ivec res1{ 56,  62,  68,  74, 152, 174, 196, 218,
                  248, 286, 324, 362, 344, 398, 452, 506};
  auto range = opencl::nd_range{dims{matrix_size, matrix_size}};
  auto w1 = mngr.spawn(prog, kn_matrix, range, in<int, mref>{}, out<int>{});
  auto matrix1 = make_iota_vector<int>(matrix_size * matrix_size);
  auto input1 = dev->global_argument(matrix1);
  self->send(w1, input1);
  self->receive([&](const ivec& result) {
    check_vector_results("Simple matrix multiplication using vectors"
                         " (kernel wrapped in program)", res1, result);
  }, others >> wrong_msg);
  // Pass kernel directly to the actor
  auto w2 = mngr.spawn(kernel_source, kn_matrix, range,
                       in<int, mref>{}, out<int, val>{});
  self->send(w2, input1);
  self->receive([&](const ivec& result) {
    check_vector_results("Simple matrix multiplication using vectors"
                         " (kernel passed directly)", res1, result);
  }, others >> wrong_msg);
  // test for manuel return size selection (max workgroup size 1d)
  auto max_wg_size = min(dev->max_work_item_sizes()[0], size_t{512});
  auto reduce_buffer_size = static_cast<size_t>(max_wg_size) * 8;
  auto reduce_local_size  = static_cast<size_t>(max_wg_size);
  auto reduce_work_groups = reduce_buffer_size / reduce_local_size;
  auto reduce_global_size = reduce_buffer_size;
  auto reduce_result_size = reduce_work_groups;
  ivec values(reduce_buffer_size);
  int n = static_cast<int>(values.capacity());
  generate(values.begin(), values.end(), [&]{ return --n; });
  nd_range range3{dims{reduce_global_size}, dims{}, dims{reduce_local_size}};
  auto res_size = [&](const iref&) { return reduce_result_size; };
  auto w5 = mngr.spawn(prog, kn_reduce, range3,
                       in<int, mref>{}, out<int>{res_size});
  auto input2 = dev->global_argument(values);
  self->send(w5, input2);
  auto multiplier = static_cast<int>(max_wg_size);
  ivec res4{multiplier * 7, multiplier * 6, multiplier * 5,
            multiplier * 4, multiplier * 3, multiplier * 2,
            multiplier * 1, multiplier * 0};
  self->receive([&](const ivec& result) {
    check_vector_results("Passing size for the output", res4, result);
  }, others >> wrong_msg);
}

void test_in_mref_out_mref(actor_system& sys) {
  CAF_MESSAGE("Testing in: mref -> out: mref");
  // setup
  auto& mngr = sys.opencl_manager();
  auto opt = mngr.find_device(0);
  CAF_REQUIRE(opt);
  auto dev = *opt;
  auto prog = mngr.create_program(kernel_source, "", dev);
  scoped_actor self{sys};
  auto wrong_msg = [&](message_view& x) -> result<message> {
    CAF_ERROR("unexpected message" << x.content().stringify());
    return sec::unexpected_message;
  };
  // tests
  const ivec res1{ 56,  62,  68,  74, 152, 174, 196, 218,
                  248, 286, 324, 362, 344, 398, 452, 506};
  auto range = opencl::nd_range{dims{matrix_size, matrix_size}};
  auto w1 = mngr.spawn(prog, kn_matrix, range,
                       in<int, mref>{}, out<int, mref>{});
  auto matrix1 = make_iota_vector<int>(matrix_size * matrix_size);
  auto input1 = dev->global_argument(matrix1);
  self->send(w1, input1);
  self->receive([&](iref& result) {
    check_mref_results("Simple matrix multiplication using vectors"
                       " (kernel wrapped in program)", res1, result);
  }, others >> wrong_msg);
  // Pass kernel directly to the actor
  auto w2 = mngr.spawn(kernel_source, kn_matrix, range,
                       in<int, mref>{}, out<int, mref>{});
  self->send(w2, input1);
  self->receive([&](iref& result) {
    check_mref_results("Simple matrix multiplication using vectors"
                       " (kernel passed directly)", res1, result);
  }, others >> wrong_msg);
  // test for manuel return size selection (max workgroup size 1d)
  auto max_wg_size = min(dev->max_work_item_sizes()[0], size_t{512});
  auto reduce_buffer_size = static_cast<size_t>(max_wg_size) * 8;
  auto reduce_local_size  = static_cast<size_t>(max_wg_size);
  auto reduce_work_groups = reduce_buffer_size / reduce_local_size;
  auto reduce_global_size = reduce_buffer_size;
  auto reduce_result_size = reduce_work_groups;
  ivec values(reduce_buffer_size);
  int n = static_cast<int>(values.capacity());
  generate(values.begin(), values.end(), [&]{ return --n; });
  nd_range range3{dims{reduce_global_size}, dims{}, dims{reduce_local_size}};
  auto res_size = [&](const iref&) { return reduce_result_size; };
  auto w5 = mngr.spawn(prog, kn_reduce, range3,
                       in<int, mref>{}, out<int, mref>{res_size});
  auto input2 = dev->global_argument(values);
  self->send(w5, input2);
  auto multiplier = static_cast<int>(max_wg_size);
  ivec res4{multiplier * 7, multiplier * 6, multiplier * 5,
            multiplier * 4, multiplier * 3, multiplier * 2,
            multiplier    ,              0};
  self->receive([&](iref& result) {
    check_mref_results("Passing size for the output", res4, result);
  }, others >> wrong_msg);
}

void test_varying_arguments(actor_system& sys) {
  CAF_MESSAGE("Testing varying argument order "
              "(Might fail on some integrated GPUs)");
  // setup
  auto& mngr = sys.opencl_manager();
  auto opt = mngr.find_device(0);
  CAF_REQUIRE(opt);
  auto dev = *opt;
  auto prog = mngr.create_program(kernel_source, "", dev);
  scoped_actor self{sys};
  auto wrong_msg = [&](message_view& x) -> result<message> {
    CAF_ERROR("unexpected message" << x.content().stringify());
    return sec::unexpected_message;
  };
  // tests
  size_t size = 23;
  nd_range range{dims{size}};
  auto input1 = make_iota_vector<int>(size);
  auto input2 = dev->global_argument(input1);
  auto w1 = mngr.spawn(prog, kn_varying, range,
                       in<int>{}, out<int>{}, in<int>{}, out<int>{});
  self->send(w1, input1, input1);
  self->receive([&](const ivec& res1, const ivec& res2) {
    check_vector_results("Varying args (vec only), output 1", input1, res1);
    check_vector_results("Varying args (vec only), output 2", input1, res2);
  }, others >> wrong_msg);
  auto w2 = mngr.spawn(prog, kn_varying, range,
                       in<int,mref>{}, out<int>{},
                       in<int>{}, out<int,mref>{});
  self->send(w2, input2, input1);
  self->receive([&](const ivec& res1, iref& res2) {
    check_vector_results("Varying args (vec), output 1", input1, res1);
    check_mref_results("Varying args (ref), output 2", input1, res2);
  }, others >> wrong_msg);
}

void test_inout(actor_system& sys) {
  CAF_MESSAGE("Testing in_out arguments");
  // setup
  auto& mngr = sys.opencl_manager();
  auto opt = mngr.find_device(0);
  CAF_REQUIRE(opt);
  auto dev = *opt;
  auto prog = mngr.create_program(kernel_source, "", dev);
  scoped_actor self{sys};
  auto wrong_msg = [&](message_view& x) -> result<message> {
    CAF_ERROR("unexpected message" << x.content().stringify());
    return sec::unexpected_message;
  };
  // tests
  ivec input = make_iota_vector<int>(problem_size);
  auto input2 = dev->global_argument(input);
  auto input3 = dev->global_argument(input);
  ivec res{input};
  for_each(begin(res), end(res), [](int& val){ val *= 2; });
  auto range = nd_range{dims{problem_size}};
  auto w1 = mngr.spawn(kernel_source, kn_inout, range,
                       in_out<int,val,val>{});
  self->send(w1, input);
  self->receive([&](const ivec& result) {
    check_vector_results("Testing in_out (val -> val)", res, result);
  }, others >> wrong_msg);
  auto w2 = mngr.spawn(kernel_source, kn_inout, range,
                       in_out<int,val,mref>{});
  self->send(w2, input);
  self->receive([&](iref& result) {
    check_mref_results("Testing in_out (val -> mref)", res, result);
  }, others >> wrong_msg);
  auto w3 = mngr.spawn(kernel_source, kn_inout, range,
                       in_out<int,mref,val>{});
  self->send(w3, input2);
  self->receive([&](const ivec& result) {
    check_vector_results("Testing in_out (mref -> val)", res, result);
  }, others >> wrong_msg);
  auto w4 = mngr.spawn(kernel_source, kn_inout, range,
                       in_out<int,mref,mref>{});
  self->send(w4, input3);
  self->receive([&](iref& result) {
    check_mref_results("Testing in_out (mref -> mref)", res, result);
  }, others >> wrong_msg);
}

void test_priv(actor_system& sys) {
  CAF_MESSAGE("Testing priv argument");
  // setup
  auto& mngr = sys.opencl_manager();
  auto opt = mngr.find_device(0);
  CAF_REQUIRE(opt);
  auto dev = *opt;
  auto prog = mngr.create_program(kernel_source, "", dev);
  scoped_actor self{sys};
  auto wrong_msg = [&](message_view& x) -> result<message> {
    CAF_ERROR("unexpected message" << x.content().stringify());
    return sec::unexpected_message;
  };
  // tests
  nd_range range{dims{problem_size}};
  ivec input = make_iota_vector<int>(problem_size);
  int value = 42;
  ivec res{input};
  for_each(begin(res), end(res), [&](int& val){ val += value; });
  auto w1 = mngr.spawn(kernel_source, kn_private, range,
                       in_out<int>{}, priv<int>{value});
  self->send(w1, input);
  self->receive([&](const ivec& result) {
    check_vector_results("Testing hidden private arugment", res, result);
  }, others >> wrong_msg);
  auto w2 = mngr.spawn(kernel_source, kn_private, range,
                       in_out<int>{}, priv<int,val>{});
  self->send(w2, input, value);
  self->receive([&](const ivec& result) {
    check_vector_results("Testing val private arugment", res, result);
  }, others >> wrong_msg);
}

void test_local(actor_system& sys) {
  CAF_MESSAGE("Testing local argument");
  // setup
  auto& mngr = sys.opencl_manager();
  auto opt = mngr.find_device(0);
  CAF_REQUIRE(opt);
  auto dev = *opt;
  auto prog = mngr.create_program(kernel_source, "", dev);
  scoped_actor self{sys};
  auto wrong_msg = [&](message_view& x) -> result<message> {
    CAF_ERROR("unexpected message" << x.content().stringify());
    return sec::unexpected_message;
  };
  // tests
  size_t global_size = 256;
  size_t local_size = global_size / 2;
  ivec res = make_iota_vector<int>(global_size);
  auto last = 0;
  for (size_t i = 0; i < global_size; ++i) {
    if (i == local_size) last = 0;
    auto tmp = res[i];
    res[i] = last;
    last += tmp;
  }
  auto range = nd_range{dims{global_size}, {}, dims{local_size}};
  auto w = mngr.spawn(kernel_source, kn_local, range,
                      in_out<int>{}, local<int>{local_size});
  self->send(w, make_iota_vector<int>(global_size));
  self->receive([&](const ivec& result) {
    check_vector_results("Testing local arugment", res, result);
  }, others >> wrong_msg);
  // Same test, different argument order
  w = mngr.spawn(kernel_source, kn_order, range,
                 local<int>{local_size}, in_out<int>{});
  self->send(w, make_iota_vector<int>(global_size));
  self->receive([&](const ivec& result) {
    check_vector_results("Testing local arugment", res, result);
  }, others >> wrong_msg);
}

CAF_TEST(actor_facade) {
  actor_system_config cfg;
  cfg.load<opencl::manager>()
    .add_message_type<ivec>("int_vector")
    .add_message_type<matrix_type>("square_matrix");
  actor_system system{cfg};
  test_in_val_out_val(system);
  test_in_val_out_mref(system);
  test_in_mref_out_val(system);
  test_in_mref_out_mref(system);
  test_varying_arguments(system);
  test_inout(system);
  test_priv(system);
  test_local(system);
  system.await_all_actors_done();
}
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENCL_MEM_REF_HPP
#define CAF_OPENCL_MEM_REF_HPP

#include <ios>
#include <vector>

#include "caf/sec.hpp"
#include "caf/optional.hpp"
#include "caf/ref_counted.hpp"

#include "caf/opencl/detail/core.hpp"
#include "caf/opencl/detail/raw_ptr.hpp"

namespace caf {
namespace opencl {

/// Updates the reference types in a message with a given event.
struct msg_adding_event {
  msg_adding_event(detail::raw_event_ptr event) : event_(event) {
    // nop
  }
  template <class T, class... Ts>
  message operator()(T& x, Ts&... xs) {
    return make_message(add_event(std::move(x)), add_event(std::move(xs))...);
  }
  template <class... Ts>
  message operator()(std::tuple<Ts...>& values) {
    return apply_args(*this, detail::get_indices(values), values);
  }
  template <class T>
  mem_ref<T> add_event(mem_ref<T> ref) {
    ref.set_event(event_);
    return std::move(ref);
  }
  detail::raw_event_ptr event_;
};

// Tag to separate mem_refs from other types in messages.
struct ref_tag {};

class device;

/// A reference type for buffers on a OpenCL devive. Access is not thread safe.
/// Hence, a mem_ref should only be passed to actors sequentially.
template <class T>
class mem_ref : ref_tag {
public:
  using value_type = T;

  friend struct msg_adding_event;
  template <bool PassConfig, class... Ts>
  friend class actor_facade;
  friend class device;

  expected<std::vector<T>> data(optional<size_t> result_size = none) {
    if (!memory_)
      return make_error(sec::runtime_error, "No memory assigned.");
    if (0 != (access_ & CL_MEM_HOST_NO_ACCESS))
      return make_error(sec::runtime_error, "No memory access.");
    if (result_size && *result_size > num_elements_)
      return make_error(sec::runtime_error, "Buffer has less elements.");
    auto num_elements = (result_size ? *result_size : num_elements_);
    auto buffer_size = sizeof(T) * num_elements;
    std::vector<T> buffer(num_elements);
    std::vector<cl_event> prev_events;
    if (event_)
      prev_events.push_back(event_.get());
    cl_event event;
    auto err = clEnqueueReadBuffer(queue_.get(), memory_.get(), CL_TRUE,
                                   0, buffer_size, buffer.data(),
                                   static_cast<cl_uint>(prev_events.size()),
                                   prev_events.data(), &event);
    if (err != CL_SUCCESS)
      return make_error(sec::runtime_error, opencl_error(err));
    // decrements the previous event we used for waiting above
    event_.reset(event, false);
    return buffer;
  }

  void reset() {
    num_elements_ = 0;
    access_ = CL_MEM_HOST_NO_ACCESS;
    memory_.reset();
    access_ = 0;
    event_.reset();
  }

  inline const detail::raw_mem_ptr& get() const {
    return memory_;
  }

  inline size_t size() const {
    return num_elements_;
  }

  inline cl_mem_flags access() const {
    return access_;
  }

  mem_ref()
    : num_elements_{0},
      access_{CL_MEM_HOST_NO_ACCESS},
      queue_{nullptr},
      event_{nullptr},
      memory_{nullptr} {
    // nop
  }

  mem_ref(size_t num_elements, detail::raw_command_queue_ptr queue,
          detail::raw_mem_ptr memory, cl_mem_flags access,
          detail::raw_event_ptr event)
    : num_elements_{num_elements},
      access_{access},
      queue_{queue},
      event_{event},
      memory_{memory} {
    // nop
  }

  mem_ref(size_t num_elements, detail::raw_command_queue_ptr queue,
          cl_mem memory, cl_mem_flags access, detail::raw_event_ptr event)
    : num_elements_{num_elements},
      access_{access},
      queue_{queue},
      event_{event},
      memory_{memory} {
    // nop
  }

  mem_ref(mem_ref&& other) = default;
  mem_ref& operator=(mem_ref<T>&& other) = default;
  mem_ref(const mem_ref& other) = default;
  mem_ref& operator=(const mem_ref& other) = default;
  ~mem_ref() {
    // nop
  }

private:
  inline void set_event(cl_event e, bool increment_reference = true) {
    event_.reset(e, increment_reference);
  }

  inline void set_event(detail::raw_event_ptr e) {
    event_ = std::move(e);
  }

  inline detail::raw_event_ptr event() {
    return event_;
  }

  inline cl_event take_event() {
    return event_.release();
  }

  size_t num_elements_;
  cl_mem_flags access_;
  detail::raw_command_queue_ptr queue_;
  detail::raw_event_ptr event_;
  detail::raw_mem_ptr memory_;
};

} // namespace opencl

template <class T>
struct allowed_unsafe_message_type<opencl::mem_ref<T>> : std::true_type {};
  
} // namespace caf

#endif // CAF_OPENCL_MEM_REF_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 * Raphael Hiesgen <raphael.hiesgen (at) haw-hamburg.de>                      *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENCL_OPENCL_ERR_HPP
#define CAF_OPENCL_OPENCL_ERR_HPP


#include "caf/opencl/global.hpp"

#include "caf/logger.hpp"

#define CAF_CLF(funname) #funname , funname

namespace caf {
namespace opencl {

void throwcl(const char* fname, cl_int err);
void CL_CALLBACK pfn_notify(const char* errinfo, const void*, size_t, void*);

// call convention for simply calling a function
template <class F, class... Ts>
void v1callcl(const char* fname, F f, Ts&&... vs) {
  throwcl(fname, f(std::forward<Ts>(vs)...));
}

// call convention for simply calling a function, not using the last argument
template <class F, class... Ts>
void v2callcl(const char* fname, F f, Ts&&... vs) {
  throwcl(fname, f(std::forward<Ts>(vs)..., nullptr));
}

// call convention for simply calling a function, and logging errors
template <class F, class... Ts>
void v3callcl(F f, Ts&&... vs) {
  auto err = f(std::forward<Ts>(vs)...);
  if (err != CL_SUCCESS)
    CAF_LOG_ERROR("error: " << opencl_error(err));
}

// call convention with `result` argument at the end returning `err`, not
// using the second last argument (set to nullptr) nor the one before (set to 0)
template <class R, class F, class... Ts>
R v1get(const char* fname, F f, Ts&&... vs) {
  R result;
  throwcl(fname, f(std::forward<Ts>(vs)..., cl_uint{0}, nullptr, &result));
  return result;
}

// call convention with `err` argument at the end returning `result`
template <class F, class... Ts>
auto v2get(const char* fname, F f, Ts&&... vs)
-> decltype(f(std::forward<Ts>(vs)..., nullptr)) {
  cl_int err;
  auto result = f(std::forward<Ts>(vs)..., &err);
  throwcl(fname, err);
  return result;
}

// call convention with `result` argument at second last position (preceeded by
// its size) followed by an ingored void* argument (nullptr) returning `err`
template <class R, class F, class... Ts>
R v3get(const char* fname, F f, Ts&&... vs) {
  R result;
  throwcl(fname, f(std::forward<Ts>(vs)..., sizeof(R), &result, nullptr));
  return result;
}

} // namespace opencl
} // namespace caf

#endif // CAF_OPENCL_OPENCL_ERR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENCL_GLOBAL_HPP
#define CAF_OPENCL_GLOBAL_HPP

#include <string>
#include <iostream>

#include "caf/config.hpp"
#include "caf/detail/limited_vector.hpp"

#if defined(CAF_MACOS) || defined(CAF_IOS)
# include <OpenCL/opencl.h>
#else
# include <CL/opencl.h>
#endif

// needed for OpenCL 1.0 compatibility (works around missing clReleaseDevice)
extern "C" {
cl_int clReleaseDeviceDummy(cl_device_id);
cl_int clRetainDeviceDummy(cl_device_id);
} // extern "C"

namespace caf {
namespace opencl {

enum device_type {
  def         = CL_DEVICE_TYPE_DEFAULT,
  cpu         = CL_DEVICE_TYPE_CPU,
  gpu         = CL_DEVICE_TYPE_GPU,
  accelerator = CL_DEVICE_TYPE_ACCELERATOR,
  custom      = CL_DEVICE_TYPE_CUSTOM,
  all         = CL_DEVICE_TYPE_ALL
};

/// Default values to create OpenCL buffers
enum buffer_type : cl_mem_flags {
  input         = CL_MEM_READ_WRITE | CL_MEM_HOST_WRITE_ONLY,
  input_output  = CL_MEM_READ_WRITE,
  output        = CL_MEM_READ_WRITE | CL_MEM_HOST_READ_ONLY,
  scratch_space = CL_MEM_READ_WRITE | CL_MEM_HOST_NO_ACCESS
};

std::ostream& operator<<(std::ostream& os, device_type dev);
device_type device_type_from_ulong(cl_ulong dev);

/// A vector of up to three elements used for OpenCL dimensions.
using dim_vec = detail::limited_vector<size_t, 3>;

std::string opencl_error(cl_int err);

std::string event_status(cl_event event);


} // namespace opencl
} // namespace caf

#endif // CAF_OPENCL_GLOBAL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 * Raphael Hiesgen <raphael.hiesgen (at) haw-hamburg.de>                      *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENCL_ALL_HPP
#define CAF_OPENCL_ALL_HPP

#include "caf/opencl/manager.hpp"

#endif // CAF_OPENCL_ALL_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENCL_ACTOR_FACADE_HPP
#define CAF_OPENCL_ACTOR_FACADE_HPP

#include <ostream>
#include <iostream>
#include <algorithm>
#include <stdexcept>

#include "caf/all.hpp"

#include "caf/intrusive_ptr.hpp"

#include "caf/detail/limited_vector.hpp"

#include "caf/opencl/global.hpp"
#include "caf/opencl/command.hpp"
#include "caf/opencl/mem_ref.hpp"
#include "caf/opencl/program.hpp"
#include "caf/opencl/nd_range.hpp"
#include "caf/opencl/arguments.hpp"
#include "caf/opencl/opencl_err.hpp"

#include "caf/opencl/detail/core.hpp"
#include "caf/opencl/detail/raw_ptr.hpp"
#include "caf/opencl/detail/command_helper.hpp"

namespace caf {
namespace opencl {

class manager;

template <bool PassConfig, class... Ts>
class actor_facade : public local_actor {
public:
  using arg_types = detail::type_list<Ts...>;
  using unpacked_types = typename detail::tl_map<arg_types, extract_type>::type;

  using input_wrapped_types =
    typename detail::tl_filter<arg_types, is_input_arg>::type;
  using input_types =
    typename detail::tl_map<input_wrapped_types, extract_input_type>::type;
  using input_mapping = typename std::conditional<PassConfig,
          std::function<optional<message> (nd_range&, message&)>,
          std::function<optional<message> (message&)>
        >::type;

  using output_wrapped_types =
    typename detail::tl_filter<arg_types, is_output_arg>::type;
  using output_types =
    typename detail::tl_map<output_wrapped_types, extract_output_type>::type;
  using output_mapping = typename detail::output_function_sig<output_types>::type;

  using processing_list = typename cl_arg_info_list<arg_types>::type;

  using command_type = typename detail::command_sig<actor_facade, output_types>::type;

  typename detail::il_indices<arg_types>::type indices;

  using evnt_vec = std::vector<cl_event>;
  using mem_vec = std::vector<detail::raw_mem_ptr>;
  using len_vec = std::vector<size_t>;
  using out_tup = typename detail::tuple_type_of<output_types>::type;

  const char* name() const override {
    return "OpenCL actor";
  }

  static actor create(actor_config actor_conf, const program_ptr prog,
                      const char* kernel_name, const nd_range& range,
                      input_mapping map_args, output_mapping map_result,
                      Ts&&... xs) {
    if (range.dimensions().empty()) {
      auto str = "OpenCL kernel needs at least 1 global dimension.";
      CAF_RAISE_ERROR(str);
    }
    auto check_vec = [&](const dim_vec& vec, const char* name) {
      if (! vec.empty() && vec.size() != range.dimensions().size()) {
        std::ostringstream oss;
        oss << name << " vector is not empty, but "
            << "its size differs from global dimensions vector's size";
        CAF_RAISE_ERROR(oss.str());
      }
    };
    check_vec(range.offsets(), "offsets");
    check_vec(range.local_dimensions(), "local dimensions");
    auto& sys = actor_conf.host->system();
    auto itr = prog->available_kernels_.find(kernel_name);
    if (itr == prog->available_kernels_.end()) {
      detail::raw_kernel_ptr kernel;
      kernel.reset(v2get(CAF_CLF(clCreateKernel), prog->program_.get(),
                                 kernel_name),
                   false);
      return make_actor<actor_facade, actor>(sys.next_actor_id(), sys.node(),
                                             &sys, std::move(actor_conf),
                                             prog, kernel, range,
                                             std::move(map_args),
                                             std::move(map_result),
                                             std::forward_as_tuple(xs...));
    }
    return make_actor<actor_facade, actor>(sys.next_actor_id(), sys.node(),
                                           &sys, std::move(actor_conf),
                                           prog, itr->second, range,
                                           std::move(map_args),
                                           std::move(map_result),
                                           std::forward_as_tuple(xs...));
  }

  void enqueue(strong_actor_ptr sender, message_id mid,
               message content, response_promise promise) {
    CAF_PUSH_AID(id());
    CAF_LOG_TRACE("");
    if (!map_arguments(content))
      return;
    if (!content.match_elements(input_types{})) {
      CAF_LOG_ERROR("Message types do not match the expected signature.");
      return;
    }
    auto hdl = std::make_tuple(sender, mid.response_id());
    evnt_vec events;
    mem_vec input_buffers;
    mem_vec output_buffers;
    mem_vec scratch_buffers;
    len_vec result_lengths;
    out_tup result;
    add_kernel_arguments(events,          // accumulate events for execution
                         input_buffers,   // opencl buffers included in in msg
                         output_buffers,  // opencl buffers included in out msg
                         scratch_buffers, // opencl only used here
                         result,          // tuple to save the output values
                         result_lengths,  // size of buffers to read back
                         content,         // message content
                         indices);        // enable extraction of types from msg
    auto cmd = make_counted<command_type>(
      std::move(promise),
      actor_cast<strong_actor_ptr>(this),
      std::move(events),
      std::move(input_buffers),
      std::move(output_buffers),
      std::move(scratch_buffers),
      std::move(result_lengths),
      std::move(content),
      std::move(result),
      range_
    );
    cmd->enqueue();
  }

  void enqueue(mailbox_element_ptr ptr, execution_unit*) override {
    CAF_ASSERT(ptr != nullptr);
    CAF_LOG_TRACE(CAF_ARG(*ptr));
    response_promise promise{ctrl(), *ptr};
    enqueue(ptr->sender, ptr->mid, ptr->move_content_to_message(),
            std::move(promise));
  }

  void enqueue(strong_actor_ptr sender, message_id mid,
               message content, execution_unit* host) override {
    CAF_LOG_TRACE("");
    enqueue(make_mailbox_element(std::move(sender), mid, {},
                                 std::move(content)), host);
  }

  actor_facade(actor_config actor_conf, const program_ptr prog,
               detail::raw_kernel_ptr kernel, nd_range range,
               input_mapping map_args, output_mapping map_result,
               std::tuple<Ts...> xs)
      : local_actor(actor_conf),
        kernel_(std::move(kernel)),
        program_(prog->program_),
        context_(prog->context_),
        queue_(prog->queue_),
        range_(std::move(range)),
        map_args_(std::move(map_args)),
        map_results_(std::move(map_result)),
        kernel_signature_(std::move(xs)) {
    CAF_LOG_TRACE(CAF_ARG(this->id()));
    default_length_ = std::accumulate(std::begin(range_.dimensions()),
                                      std::end(range_.dimensions()),
                                      size_t{1},
                                      std::multiplies<size_t>{});
  }

  void add_kernel_arguments(evnt_vec&, mem_vec&, mem_vec&, mem_vec&,
                            out_tup&, len_vec&, message&,
                            detail::int_list<>) {
    // nop
  }

  /// The separation into input, output and scratch buffers is required to
  /// access the related memory handles later on. The scratch and input handles
  /// are saved to prevent deletion before the kernel finished execution.
  template <long I, long... Is>
  void add_kernel_arguments(evnt_vec& events, mem_vec& inputs, mem_vec& outputs,
                            mem_vec& scratch, out_tup& result, len_vec& lengths,
                            message& msg, detail::int_list<I, Is...>) {
    using arg_type = typename detail::tl_at<processing_list,I>::type;
    create_buffer<I, arg_type::in_pos, arg_type::out_pos>(
      std::get<I>(kernel_signature_), events, lengths, inputs,
      outputs, scratch, result, msg
    );
    add_kernel_arguments(events, inputs, outputs, scratch, result, lengths, msg,
                         detail::int_list<Is...>{});
  }

  // Two functions to handle `in` arguments: val and mref

  template <long I, int InPos, int OutPos, class T>
  void create_buffer(const in<T, val>&, evnt_vec& events, len_vec&,
                     mem_vec& inputs, mem_vec&, mem_vec&, out_tup&,
                     message& msg) {
    using value_type = typename detail::tl_at<unpacked_types, I>::type;
    using container_type = std::vector<value_type>;
    auto& container = msg.get_as<container_type>(InPos);
    auto len = container.size();
    size_t num_bytes = sizeof(value_type) * len;
    auto buffer = v2get(CAF_CLF(clCreateBuffer), context_.get(),
                        size_t{CL_MEM_READ_WRITE}, num_bytes, nullptr);
    auto event = v1get<cl_event>(CAF_CLF(clEnqueueWriteBuffer),
                                 queue_.get(), buffer, 0u, // --> CL_FALSE,
                                 0u, num_bytes, container.data());
    v1callcl(CAF_CLF(clSetKernelArg), kernel_.get(), static_cast<unsigned>(I),
             sizeof(cl_mem), static_cast<const void*>(&buffer));
    events.push_back(event);
    inputs.emplace_back(buffer, false);
  }

  template <long I, int InPos, int OutPos, class T>
  void create_buffer(const in<T, mref>&, evnt_vec& events, len_vec&, mem_vec&,
                     mem_vec&, mem_vec&, out_tup&, message& msg) {
    using value_type = typename detail::tl_at<unpacked_types, I>::type;
    using container_type = mem_ref<value_type>;
    auto container = msg.get_as<container_type>(InPos);
    v1callcl(CAF_CLF(clSetKernelArg), kernel_.get(), static_cast<unsigned>(I),
             sizeof(cl_mem), static_cast<const void*>(&container.get()));
    auto event = container.take_event();
    if (event)
      events.push_back(event);
  }

  // Four functions to handle `in_out` arguments:
  //    val->val, val->mref, mref->val, mref->mref

  template <long I, int InPos, int OutPos, class T>
  void create_buffer(const in_out<T,val,val>&, evnt_vec& events,
                     len_vec& lengths, mem_vec&, mem_vec& outputs,
                     mem_vec&, out_tup&, message& msg) {
    using value_type = typename detail::tl_at<unpacked_types, I>::type;
    using container_type = std::vector<value_type>;
    auto& container = msg.get_as<container_type>(InPos);
    auto len = container.size();
    size_t num_bytes = sizeof(value_type) * len;
    auto buffer = v2get(CAF_CLF(clCreateBuffer), context_.get(),
                        size_t{CL_MEM_READ_WRITE}, num_bytes, nullptr);
    auto event = v1get<cl_event>(CAF_CLF(clEnqueueWriteBuffer),
                                 queue_.get(), buffer, 0u, // --> CL_FALSE,
                                 0u, num_bytes, container.data());
    v1callcl(CAF_CLF(clSetKernelArg), kernel_.get(), static_cast<unsigned>(I),
             sizeof(cl_mem), static_cast<const void*>(&buffer));
    lengths.push_back(len);
    events.push_back(event);
    outputs.emplace_back(buffer, false);
  }

  template <long I, int InPos, int OutPos, class T>
  void create_buffer(const in_out<T,val,mref>&, evnt_vec& events, len_vec&,
                     mem_vec&, mem_vec&, mem_vec&, out_tup& result,
                     message& msg) {
    using value_type = typename detail::tl_at<unpacked_types, I>::type;
    using container_type = std::vector<value_type>;
    auto& container = msg.get_as<container_type>(InPos);
    auto len = container.size();
    size_t num_bytes = sizeof(value_type) * len;
    auto buffer = v2get(CAF_CLF(clCreateBuffer), context_.get(),
                        size_t{CL_MEM_READ_WRITE}, num_bytes, nullptr);
    auto event = v1get<cl_event>(CAF_CLF(clEnqueueWriteBuffer),
                                 queue_.get(), buffer, 0u, // --> CL_FALSE,
                                 0u, num_bytes, container.data());
    v1callcl(CAF_CLF(clSetKernelArg), kernel_.get(), static_cast<unsigned>(I),
             sizeof(cl_mem), static_cast<const void*>(&buffer));
    events.push_back(event);
    std::get<OutPos>(result) = mem_ref<value_type>{
      len, queue_, detail::raw_mem_ptr{buffer, false},
      size_t{CL_MEM_READ_WRITE | CL_MEM_HOST_READ_ONLY}, nullptr
    };
  }

  template <long I, int InPos, int OutPos, class T>
  void create_buffer(const in_out<T,mref,val>&, evnt_vec& events,
                     len_vec& lengths, mem_vec&, mem_vec& outputs,
                     mem_vec&, out_tup&, message& msg) {
    using value_type = typename detail::tl_at<unpacked_types, I>::type;
    using container_type = mem_ref<value_type>;
    auto container = msg.get_as<container_type>(InPos);
    v1callcl(CAF_CLF(clSetKernelArg), kernel_.get(), static_cast<unsigned>(I),
             sizeof(cl_mem), static_cast<const void*>(&container.get()));
    auto event = container.take_event();
    if (event)
      events.push_back(event);
    lengths.push_back(container.size());
    outputs.push_back(container.get());
  }

  template <long I, int InPos, int OutPos, class T>
  void create_buffer(const in_out<T,mref,mref>&, evnt_vec& events, len_vec&,
                     mem_vec&, mem_vec&, mem_vec&, out_tup& result,
                     message& msg) {
    using value_type = typename detail::tl_at<unpacked_types, I>::type;
    using container_type = mem_ref<value_type>;
    auto container = msg.get_as<container_type>(InPos);
    v1callcl(CAF_CLF(clSetKernelArg), kernel_.get(), static_cast<unsigned>(I),
                     sizeof(cl_mem), static_cast<const void*>(&container.get()));
    auto event = container.take_event();
    if (event)
      events.push_back(event);
    std::get<OutPos>(result) = container;
  }

  // Two functions to handle `out` arguments: val and mref

  template <long I, int InPos, int OutPos, class T>
  void create_buffer(const out<T,val>& wrapper, evnt_vec&, len_vec& lengths,
                     mem_vec&, mem_vec& outputs, mem_vec&, out_tup&,
                     message& msg) {
    using value_type = typename detail::tl_at<unpacked_types, I>::type;
    auto len = argument_length(wrapper, msg, default_length_);
    auto num_bytes = sizeof(value_type) * len;
    auto buffer = v2get(CAF_CLF(clCreateBuffer), context_.get(),
                        size_t{CL_MEM_READ_WRITE | CL_MEM_HOST_READ_ONLY},
                        num_bytes, nullptr);
    v1callcl(CAF_CLF(clSetKernelArg), kernel_.get(), static_cast<unsigned>(I),
             sizeof(cl_mem), static_cast<const void*>(&buffer));
    outputs.emplace_back(buffer, false);
    lengths.push_back(len);
  }

  template <long I, int InPos, int OutPos, class T>
  void create_buffer(const out<T,mref>& wrapper, evnt_vec&, len_vec&,
                     mem_vec&, mem_vec&, mem_vec&, out_tup& result,
                     message& msg) {
    using value_type = typename detail::tl_at<unpacked_types, I>::type;
    auto len = argument_length(wrapper, msg, default_length_);
    auto num_bytes = sizeof(value_type) * len;
    auto buffer = v2get(CAF_CLF(clCreateBuffer), context_.get(),
                        size_t{CL_MEM_READ_WRITE | CL_MEM_HOST_READ_ONLY},
                        num_bytes, nullptr);
    v1callcl(CAF_CLF(clSetKernelArg), kernel_.get(), static_cast<unsigned>(I),
             sizeof(cl_mem), static_cast<const void*>(&buffer));
    std::get<OutPos>(result) = mem_ref<value_type>{
      len, queue_, {buffer, false},
      size_t{CL_MEM_READ_WRITE | CL_MEM_HOST_READ_ONLY}, nullptr
    };
  }

  // One function to handle `scratch` buffers

  template <long I, int InPos, int OutPos, class T>
  void create_buffer(const scratch<T>& wrapper, evnt_vec&, len_vec&,
                     mem_vec&, mem_vec&, mem_vec& scratch,
                     out_tup&, message& msg) {
    using value_type = typename detail::tl_at<unpacked_types, I>::type;
    auto len = argument_length(wrapper, msg, default_length_);
    auto num_bytes = sizeof(value_type) * len;
    auto buffer = v2get(CAF_CLF(clCreateBuffer), context_.get(),
                        size_t{CL_MEM_READ_WRITE | CL_MEM_HOST_NO_ACCESS},
                        num_bytes, nullptr);
    v1callcl(CAF_CLF(clSetKernelArg), kernel_.get(), static_cast<unsigned>(I),
             sizeof(cl_mem), static_cast<const void*>(&buffer));
    scratch.emplace_back(buffer, false);
  }

  // One functions to handle `local` arguments

  template <long I, int InPos, int OutPos, class T>
  void create_buffer(const local<T>& wrapper, evnt_vec&, len_vec&,
                     mem_vec&, mem_vec&, mem_vec&, out_tup&,
                     message& msg) {
    using value_type = typename detail::tl_at<unpacked_types, I>::type;
    auto len = wrapper(msg);
    auto num_bytes = sizeof(value_type) * len;
    v1callcl(CAF_CLF(clSetKernelArg), kernel_.get(), static_cast<unsigned>(I),
             num_bytes, nullptr);
  }

  // Two functions to handle `priv` arguments: val and hidden

  template <long I, int InPos, int OutPos, class T>
  void create_buffer(const priv<T, val>&, evnt_vec&, len_vec&,
                     mem_vec&, mem_vec&, mem_vec&, out_tup&, message& msg) {
    using value_type = typename detail::tl_at<unpacked_types, I>::type;
    auto value_size = sizeof(value_type);
    auto& value = msg.get_as<value_type>(InPos);
    v1callcl(CAF_CLF(clSetKernelArg), kernel_.get(), static_cast<unsigned>(I),
             value_size, static_cast<const void*>(&value));
  }

  template <long I, int InPos, int OutPos, class T>
  void create_buffer(const priv<T, hidden>& wrapper, evnt_vec&, len_vec&,
                     mem_vec&, mem_vec&, mem_vec&, out_tup&, message& msg) {
    auto value_size = sizeof(T);
    auto value = wrapper(msg);
    v1callcl(CAF_CLF(clSetKernelArg), kernel_.get(), static_cast<unsigned>(I),
             value_size, static_cast<const void*>(&value));
  }

  /// Helper function to calculate the elements in a buffer from in and out
  /// argument wrappers.
  template <class Fun>
  size_t argument_length(Fun& f, message& m, size_t fallback) {
    auto length = f(m);
    return length && (*length > 0) ? *length : fallback;
  }

  // Map function requires only the message as argument
  template <bool Q = PassConfig>
  detail::enable_if_t<!Q, bool> map_arguments(message& content) {
    if (map_args_) {
      auto mapped = map_args_(content);
      if (!mapped) {
        CAF_LOG_ERROR("Mapping argumentes failed.");
        return false;
      }
      content = std::move(*mapped);
    }
    return true;
  }

  // Map function requires reference to config as well as the message
  template <bool Q = PassConfig>
  detail::enable_if_t<Q, bool> map_arguments(message& content) {
    if (map_args_) {
      auto mapped = map_args_(range_, content);
      if (!mapped) {
        CAF_LOG_ERROR("Mapping argumentes failed.");
        return false;
      }
      content = std::move(*mapped);
    }
    return true;
  }

  void launch(execution_unit*, bool, bool) override {
    CAF_RAISE_ERROR("launch of the actor facade should not be called");
  }

  detail::raw_kernel_ptr kernel_;
  detail::raw_program_ptr program_;
  detail::raw_context_ptr context_;
  detail::raw_command_queue_ptr queue_;
  nd_range range_;
  input_mapping map_args_;
  output_mapping map_results_;
  std::tuple<Ts...> kernel_signature_;
  size_t default_length_;
};

} // namespace opencl
} // namespace caf

#endif // CAF_OPENCL_ACTOR_FACADE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENCL_ND_RANGE_HPP
#define CAF_OPENCL_ND_RANGE_HPP

#include "caf/opencl/global.hpp"

namespace caf {
namespace opencl {

class nd_range {
public:
  nd_range(const opencl::dim_vec& dimensions,
           const opencl::dim_vec& offsets = {},
           const opencl::dim_vec& local_dimensions = {})
    : dims_{dimensions},
      offset_{offsets},
      local_dims_{local_dimensions} {
    // nop
  }

  nd_range(opencl::dim_vec&& dimensions,
           opencl::dim_vec&& offsets = {},
           opencl::dim_vec&& local_dimensions = {})
    : dims_{std::move(dimensions)},
      offset_{std::move(offsets)},
      local_dims_{std::move(local_dimensions)} {
    // nop
  }

  nd_range(const nd_range&) = default;
  nd_range(nd_range&&) = default;

  nd_range& operator=(const nd_range&) = default;
  nd_range& operator=(nd_range&&) = default;

  const opencl::dim_vec& dimensions() const {
    return dims_;
  }

  const opencl::dim_vec& offsets() const {
    return offset_;
  }

  const opencl::dim_vec& local_dimensions() const {
    return local_dims_;
  }

private:
  opencl::dim_vec dims_;
  opencl::dim_vec offset_;
  opencl::dim_vec local_dims_;
};

} // namespace opencl
} // namespace caf

#endif // CAF_OPENCL_ND_RANGE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENCL_COMMAND_HPP
#define CAF_OPENCL_COMMAND_HPP

#include <tuple>
#include <vector>
#include <numeric>
#include <algorithm>
#include <functional>

#include "caf/logger.hpp"
#include "caf/actor_cast.hpp"
#include "caf/abstract_actor.hpp"
#include "caf/response_promise.hpp"

#include "caf/detail/scope_guard.hpp"

#include "caf/opencl/global.hpp"
#include "caf/opencl/nd_range.hpp"
#include "caf/opencl/arguments.hpp"
#include "caf/opencl/opencl_err.hpp"

#include "caf/opencl/detail/core.hpp"
#include "caf/opencl/detail/raw_ptr.hpp"

namespace caf {
namespace opencl {

/// A command represents the execution of a kernel on a device. It handles the
/// OpenCL calls to enqueue the kernel with the index space and keeps references
/// to the management data during the execution. Furthermore, the command sends
/// the execution results to the responsible actor.
template <class Actor, class... Ts>
class command : public ref_counted {
public:
  using result_types = detail::type_list<Ts...>;

  command(response_promise promise,
          strong_actor_ptr parent,
          std::vector<cl_event> events,
          std::vector<detail::raw_mem_ptr> inputs,
          std::vector<detail::raw_mem_ptr> outputs,
          std::vector<detail::raw_mem_ptr> scratches,
          std::vector<size_t> lengths,
          message msg,
          std::tuple<Ts...> output_tuple,
          nd_range range)
      : lengths_(std::move(lengths)),
        promise_(std::move(promise)),
        cl_actor_(std::move(parent)),
        mem_in_events_(std::move(events)),
        input_buffers_(std::move(inputs)),
        output_buffers_(std::move(outputs)),
        scratch_buffers_(std::move(scratches)),
        results_(std::move(output_tuple)),
        msg_(std::move(msg)),
        range_(std::move(range)) {
    // nop
  }

  ~command() override {
    for (auto& e : mem_in_events_) {
      if (e)
        v1callcl(CAF_CLF(clReleaseEvent), e);
    }
    for (auto& e : mem_out_events_) {
      if (e)
        v1callcl(CAF_CLF(clReleaseEvent), e);
    }
  }

  /// Enqueue the kernel for execution, schedule reading of the results and
  /// set a callback to send the results to the actor identified by the handle.
  /// Only called if the results includes at least one type that is not a
  /// mem_ref.
  template <class Q = result_types>
  detail::enable_if_t<!detail::tl_forall<Q, is_ref_type>::value>
  enqueue() {
    // Errors in this function can not be handled by opencl_err.hpp
    // because they require non-standard error handling
    CAF_LOG_TRACE("");
    this->ref(); // reference held by the OpenCL comand queue
    auto data_or_nullptr = [](const dim_vec& vec) {
      return vec.empty() ? nullptr : vec.data();
    };
    auto parent = static_cast<Actor*>(actor_cast<abstract_actor*>(cl_actor_));
    // OpenCL expects cl_uint (unsigned int), hence the cast
    mem_out_events_.emplace_back();
    auto success = invoke_cl(
      clEnqueueNDRangeKernel, parent->queue_.get(), parent->kernel_.get(),
      static_cast<unsigned int>(range_.dimensions().size()),
      data_or_nullptr(range_.offsets()),
      data_or_nullptr(range_.dimensions()),
      data_or_nullptr(range_.local_dimensions()),
      static_cast<unsigned int>(mem_in_events_.size()),
      (mem_in_events_.empty() ? nullptr : mem_in_events_.data()),
      &mem_out_events_.back()
    );
    if (!success)
      return;
    size_t pos = 0;
    CAF_ASSERT(!mem_out_events_.empty());
    enqueue_read_buffers(pos, mem_out_events_,
                         detail::get_indices(results_));
    cl_event marker_event;
#if defined(__APPLE__)
    success = invoke_cl(clEnqueueMarkerWithWaitList, parent->queue_.get(),
                        static_cast<unsigned int>(mem_out_events_.size()),
                        mem_out_events_.data(), &marker_event);
#else
    success = invoke_cl(clEnqueueMarker, parent->queue_.get(), &marker_event);
#endif
    callback_.reset(marker_event, false);
    if (!success)
      return;
    auto cb = [](cl_event, cl_int, void* data) {
      auto cmd = reinterpret_cast<command*>(data);
      cmd->handle_results();
      cmd->deref();
    };
    if (!invoke_cl(clSetEventCallback, callback_.get(), CL_COMPLETE,
                   std::move(cb), this))
      return;
    v3callcl(clFlush, parent->queue_.get());
  }

  /// Enqueue the kernel for execution and send the mem_refs relating to the
  /// results to the next actor. A callback is set to clean up the commmand
  /// once the execution is finished. Only called if the results only consist
  /// of mem_ref types.
  template <class Q = result_types>
  detail::enable_if_t<detail::tl_forall<Q, is_ref_type>::value>
  enqueue() {
    // Errors in this function can not be handled by opencl_err.hpp
    // because they require non-standard error handling
    CAF_LOG_TRACE("");
    this->ref(); // reference held by the OpenCL command queue
    auto data_or_nullptr = [](const dim_vec& vec) {
      return vec.empty() ? nullptr : vec.data();
    };
    auto parent = static_cast<Actor*>(actor_cast<abstract_actor*>(cl_actor_));
    cl_event execution_event;
    auto success = invoke_cl(
      clEnqueueNDRangeKernel, parent->queue_.get(), parent->kernel_.get(),
      static_cast<cl_uint>(range_.dimensions().size()),
      data_or_nullptr(range_.offsets()),
      data_or_nullptr(range_.dimensions()),
      data_or_nullptr(range_.local_dimensions()),
      static_cast<unsigned int>(mem_in_events_.size()),
      (mem_in_events_.empty() ? nullptr : mem_in_events_.data()),
      &execution_event
    );
    callback_.reset(execution_event, false);
    if (!success)
      return;
    auto cb = [](cl_event, cl_int, void* data) {
      auto c = reinterpret_cast<command*>(data);
      c->deref();
    };
    if (!invoke_cl(clSetEventCallback, callback_.get(), CL_COMPLETE,
                   std::move(cb), this))
      return;
    v3callcl(clFlush, parent->queue_.get());
    auto msg = msg_adding_event{callback_}(results_);
    promise_.deliver(std::move(msg));
  }

private:
  template <long I, class T>
  void enqueue_read(std::vector<T>&, std::vector<cl_event>& events,
                    size_t& pos) {
    auto p = static_cast<Actor*>(actor_cast<abstract_actor*>(cl_actor_));
    events.emplace_back();
    auto size = lengths_[pos];
    auto buffer_size = sizeof(T) * size;
    std::get<I>(results_).resize(size);
    auto err = clEnqueueReadBuffer(p->queue_.get(), output_buffers_[pos].get(),
                                   CL_FALSE, 0, buffer_size,
                                   std::get<I>(results_).data(), 1,
                                   events.data(), &events.back());
    if (err != CL_SUCCESS) {
      this->deref(); // failed to enqueue command
      CAF_RAISE_ERROR("clEnqueueReadBuffer: " + opencl_error(err));
    }
    pos += 1;
  }

  template <long I, class T>
  void enqueue_read(mem_ref<T>&, std::vector<cl_event>&, size_t&) {
    // Nothing to read back if we return references.
  }

  void enqueue_read_buffers(size_t&, std::vector<cl_event>&,
                            detail::int_list<>) {
    // end of recursion
  }

  template <long I, long... Is>
  void enqueue_read_buffers(size_t& pos, std::vector<cl_event>& events,
                            detail::int_list<I, Is...>) {
    enqueue_read<I>(std::get<I>(results_), events, pos);
    enqueue_read_buffers(pos, events, detail::int_list<Is...>{});
  }

  // handle results if execution result includes a value type
  void handle_results() {
    auto parent = static_cast<Actor*>(actor_cast<abstract_actor*>(cl_actor_));
    auto& map_fun = parent->map_results_;
    auto msg = map_fun ? apply_args(map_fun, detail::get_indices(results_),
                                    results_)
                       : message_from_results{}(results_);
    promise_.deliver(std::move(msg));
  }

  // call function F and derefenrence the command on failure
  template <class F, class... Us>
  bool invoke_cl(F f, Us&&... xs) {
    auto err = f(std::forward<Us>(xs)...);
    if (err == CL_SUCCESS)
      return true;
    CAF_LOG_ERROR("error: " << opencl_error(err));
    this->deref();
    return false;
  }

  std::vector<size_t> lengths_;
  response_promise promise_;
  strong_actor_ptr cl_actor_;
  std::vector<cl_event> mem_in_events_;
  std::vector<cl_event> mem_out_events_;
  detail::raw_event_ptr callback_;
  std::vector<detail::raw_mem_ptr> input_buffers_;
  std::vector<detail::raw_mem_ptr> output_buffers_;
  std::vector<detail::raw_mem_ptr> scratch_buffers_;
  std::tuple<Ts...> results_;
  message msg_; // keeps the argument buffers alive for async copy to device
  nd_range range_;
};

} // namespace opencl
} // namespace caf

#endif // CAF_OPENCL_COMMAND_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENCL_PROGRAM_HPP
#define CAF_OPENCL_PROGRAM_HPP

#include <map>
#include <memory>

#include "caf/ref_counted.hpp"

#include "caf/opencl/device.hpp"
#include "caf/opencl/global.hpp"

#include "caf/opencl/detail/raw_ptr.hpp"

namespace caf {
namespace opencl {

class program;
using program_ptr = intrusive_ptr<program>;

/// @brief A wrapper for OpenCL's cl_program.
class program : public ref_counted {
public:
  friend class manager;
  template <bool PassConfig, class... Ts>
  friend class actor_facade;
  template <class T, class... Ts>
  friend intrusive_ptr<T> caf::make_counted(Ts&&...);

private:
  program(detail::raw_context_ptr context, detail::raw_command_queue_ptr queue,
          detail::raw_program_ptr prog,
          std::map<std::string, detail::raw_kernel_ptr> available_kernels);

  ~program();

  detail::raw_context_ptr context_;
  detail::raw_program_ptr program_;
  detail::raw_command_queue_ptr queue_;
  std::map<std::string, detail::raw_kernel_ptr> available_kernels_;
};

} // namespace opencl
} // namespace caf

#endif // CAF_OPENCL_PROGRAM_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 * Raphael Hiesgen <raphael.hiesgen (at) haw-hamburg.de>                      *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENCL_ARGUMENTS
#define CAF_OPENCL_ARGUMENTS

#include <functional>
#include <type_traits>

#include "caf/message.hpp"
#include "caf/optional.hpp"

#include "caf/opencl/mem_ref.hpp"
#include "caf/opencl/detail/core.hpp"

namespace caf {
namespace opencl {

namespace detail {

template <class T, class F>
std::function<optional<T> (message&)> res_or_none(F fun) {
 return [fun](message& msg) -> optional<T> {
    auto res = msg.apply(fun);
    T result;
    if (res) {
      res->apply([&](size_t x) { result = x; });
      return result;
    }
    return none;
  };
}

template <class F, class T>
T try_apply_fun(F& fun, message& msg, const T& fallback) {
  if (fun) {
    auto res = fun(msg);
    if (res)
      return *res;
  }
  return fallback;
}

} // namespace detail

// Tag classes to mark arguments received in a messages as reference or value
/// Arguments tagged as `val` are expected as a vector (or value in case
/// of a private argument).
struct val {};

/// Arguments tagged as `mref` are expected as mem_ref, which is can be returned
/// by other opencl actors.
struct mref {};

/// Arguments tagged as `hidden` are created by the actor, using the config
/// passed in the argument wrapper. Only available for local and priv arguments.
struct hidden {};

/// Use as a default way to calculate output size. 0 will be set to the number
/// of work items at runtime.
struct dummy_size_calculator {
  template <class... Ts>
  size_t operator()(Ts&&...) const {
    return 0;
  }
};

/// Common parent for opencl argument tags for the spawn function.
struct arg_tag {};

/// Empty tag as an alternative for conditional inheritance.
struct empty_tag {};

/// Tags the argument as input which requires initialization through a message.
struct input_tag {};

/// Tags the argument as output which includes its buffer in the result message.
struct output_tag {};

/// Tags the argument to require specification of the size of its buffer.
struct requires_size_tag {};

/// Tags the argument as a reference and not a value.
struct is_ref_tag;

/// Mark a spawn argument as input only
template <class Arg, class Tag = val>
struct in : arg_tag, input_tag {
  static_assert(std::is_same<Tag, val>::value || std::is_same<Tag, mref>::value,
                "Argument of type `in` must be passed as value or mem_ref.");
  using tag_type = Tag;
  using arg_type = detail::decay_t<Arg>;
};

/// Mark a spawn argument as input and output
template <class Arg, class TagIn = val, class TagOut = val>
struct in_out : arg_tag, input_tag, output_tag {
  static_assert(
    std::is_same<TagIn, val>::value || std::is_same<TagIn, mref>::value,
    "Argument of type `in_out` must be passed as value or mem_ref."
  );
  static_assert(
    std::is_same<TagOut, val>::value || std::is_same<TagOut, mref>::value,
    "Argument of type `in_out` must be returned as value or mem_ref."
  );
  using tag_in_type = TagIn;
  using tag_out_type = TagOut;
  using arg_type = detail::decay_t<Arg>;
};

/// Mark a spawn argument as output only
template <class Arg, class Tag = val>
struct out : arg_tag, output_tag, requires_size_tag {
  static_assert(std::is_same<Tag, val>::value || std::is_same<Tag, mref>::value,
               "Argument of type `out` must be returned as value or mem_ref.");
  using tag_type = Tag;
  using arg_type = detail::decay_t<Arg>;
  out() = default;
  template <class F>
  out(F fun) : fun_{detail::res_or_none<size_t>(fun)} {
    // nop
  }
  optional<size_t> operator()(message& msg) const {
    return detail::try_apply_fun(fun_, msg, 0UL);
  }
  std::function<optional<size_t> (message&)> fun_;
};

/// Mark a spawn argument as on-device scratch space
template <class Arg>
struct scratch : arg_tag, requires_size_tag {
  using arg_type = detail::decay_t<Arg>;
  scratch() = default;
  template <class F>
  scratch(F fun) : fun_{detail::res_or_none<size_t>(fun)} {
    // nop
  }
  optional<size_t> operator()(message& msg) const {
    return detail::try_apply_fun(fun_, msg, 0UL);
  }
  std::function<optional<size_t> (message&)> fun_;
};

/// Mark a spawn argument as a local memory argument. This argument cannot be
/// initalized from the CPU, but requires specification of its size. An
/// optional function allows calculation of the size depeding on the input
/// message.
template <class Arg>
struct local : arg_tag, requires_size_tag {
  using arg_type = detail::decay_t<Arg>;
  local() = default;
  local(size_t size) : size_(size) { }
  template <class F>
  local(size_t size, F fun)
    : size_(size), fun_{detail::res_or_none<size_t>(fun)} {
    // nop
  }
  size_t operator()(message& msg) const {
    return detail::try_apply_fun(fun_, msg, size_);
  }
  size_t size_;
  std::function<optional<size_t> (message&)> fun_;
};

/// Mark a spawn argument as a private argument. Requires a default value but
/// can optionally be calculated depending on the input through a passed
/// function.
template <class Arg, class Tag = hidden>
struct priv : arg_tag, std::conditional<std::is_same<Tag, val>::value,
                                        input_tag, empty_tag>::type {
  static_assert(std::is_same<Tag, val>::value ||
                std::is_same<Tag, hidden>::value,
               "Argument of type `priv` must be either a value or hidden.");
  using tag_type = Tag;
  using arg_type = detail::decay_t<Arg>;
  priv() = default;
  priv(Arg val) : value_(val) {
    static_assert(std::is_same<Tag, hidden>::value,
                  "Argument of type `priv` can only be initialized with a value"
                  " if it is tagged as hidden.");
  }
  template <class F>
  priv(Arg val, F fun) : value_(val), fun_{detail::res_or_none<Arg>(fun)} {
    static_assert(std::is_same<Tag, hidden>::value,
                  "Argument of type `priv` can only be initialized with a value"
                  " if it is tagged as hidden.");
  }
  Arg operator()(message& msg) const {
    return detail::try_apply_fun(fun_, msg, value_);
  }
  Arg value_;
  std::function<optional<Arg> (message&)> fun_;
};

///Cconverts C arrays, i.e., pointers, to vectors.
template <class T>
struct carr_to_vec {
  using type = T;
};

template <class T>
struct carr_to_vec<T*> {
  using type = std::vector<T>;
};

/// Filter types for any argument type.
template <class T>
struct is_opencl_arg : std::is_base_of<arg_tag, T> {};

/// Filter type lists for input arguments
template <class T>
struct is_input_arg : std::is_base_of<input_tag, T> {};

/// Filter type lists for output arguments
template <class T>
struct is_output_arg : std::is_base_of<output_tag, T> {};

/// Filter for arguments that require size
template <class T>
struct requires_size_arg : std::is_base_of<requires_size_tag, T> {};

/// Filter mem_refs
template <class T>
struct is_ref_type : std::is_base_of<is_ref_tag, T> {};

template <class T>
struct is_val_type
  : std::integral_constant<bool, !std::is_base_of<is_ref_tag, T>::value> {};

/// extract types
template <class T>
struct extract_type { };

template <class T, class Tag>
struct extract_type<in<T, Tag>> {
  using type = detail::decay_t<typename carr_to_vec<T>::type>;
};

template <class T, class TagIn, class TagOut>
struct extract_type<in_out<T, TagIn, TagOut>> {
  using type = detail::decay_t<typename carr_to_vec<T>::type>;
};

template <class T, class Tag>
struct extract_type<out<T, Tag>> {
  using type = detail::decay_t<typename carr_to_vec<T>::type>;
};

template <class T>
struct extract_type<scratch<T>> {
  using type = detail::decay_t<typename carr_to_vec<T>::type>;
};

template <class T>
struct extract_type<local<T>> {
  using type = detail::decay_t<typename carr_to_vec<T>::type>;
};

template <class T, class Tag>
struct extract_type<priv<T, Tag>> {
  using type = detail::decay_t<typename carr_to_vec<T>::type>;
};

/// extract type expected in an incoming message
template <class T>
struct extract_input_type { };

template <class Arg>
struct extract_input_type<in<Arg, val>> {
  using type = std::vector<Arg>;
};

template <class Arg>
struct extract_input_type<in<Arg, mref>> {
  using type = opencl::mem_ref<Arg>;
};

template <class Arg, class TagOut>
struct extract_input_type<in_out<Arg, val, TagOut>> {
  using type = std::vector<Arg>;
};

template <class Arg, class TagOut>
struct extract_input_type<in_out<Arg, mref, TagOut>> {
  using type = opencl::mem_ref<Arg>;
};

template <class Arg>
struct extract_input_type<priv<Arg,val>> {
  using type = Arg;
};

/// extract type sent in an outgoing message
template <class T>
struct extract_output_type { };

template <class Arg>
struct extract_output_type<out<Arg, val>> {
  using type = std::vector<Arg>;
};

template <class Arg>
struct extract_output_type<out<Arg, mref>> {
  using type = opencl::mem_ref<Arg>;
};

template <class Arg, class TagIn>
struct extract_output_type<in_out<Arg, TagIn, val>> {
  using type = std::vector<Arg>;
};

template <class Arg, class TagIn>
struct extract_output_type<in_out<Arg, TagIn, mref>> {
  using type = opencl::mem_ref<Arg>;
};

/// extract input tag
template <class T>
struct extract_input_tag { };

template <class Arg, class Tag>
struct extract_input_tag<in<Arg, Tag>> {
  using tag = Tag;
};

template <class Arg, class TagIn, class TagOut>
struct extract_input_tag<in_out<Arg, TagIn, TagOut>> {
  using tag = TagIn;
};

template <class Arg>
struct extract_input_tag<priv<Arg,val>> {
  using tag = val;
};

/// extract output tag
template <class T>
struct extract_output_tag { };

template <class Arg, class Tag>
struct extract_output_tag<out<Arg, Tag>> {
  using tag = Tag;
};

template <class Arg, class TagIn, class TagOut>
struct extract_output_tag<in_out<Arg, TagIn, TagOut>> {
  using tag = TagOut;
};


/// Create the return message from tuple arumgent
struct message_from_results {
  template <class T, class... Ts>
  message operator()(T& x, Ts&... xs) {
    return make_message(std::move(x), std::move(xs)...);
  }
  template <class... Ts>
  message operator()(std::tuple<Ts...>& values) {
    return apply_args(*this, detail::get_indices(values), values);
  }
};

/// Calculate output indices from the kernel message

// index in output tuple
template <int Counter, class Arg>
struct out_index_of {
  static constexpr int value = -1;
  static constexpr int next = Counter;
};

template <int Counter, class Arg, class TagIn, class TagOut>
struct out_index_of<Counter, in_out<Arg,TagIn,TagOut>> {
  static constexpr int value = Counter;
  static constexpr int next = Counter + 1;
};

template <int Counter, class Arg, class Tag>
struct out_index_of<Counter, out<Arg,Tag>> {
  static constexpr int value = Counter;
  static constexpr int next = Counter + 1;
};

// index in input message
template <int Counter, class Arg>
struct in_index_of {
  static constexpr int value = -1;
  static constexpr int next = Counter;
};

template <int Counter, class Arg, class Tag>
struct in_index_of<Counter, in<Arg,Tag>> {
  static constexpr int value = Counter;
  static constexpr int next = Counter + 1;
};

template <int Counter, class Arg, class TagIn, class TagOut>
struct in_index_of<Counter, in_out<Arg,TagIn,TagOut>> {
  static constexpr int value = Counter;
  static constexpr int next = Counter + 1;
};

template <int Counter, class Arg>
struct in_index_of<Counter, priv<Arg,val>> {
  static constexpr int value = Counter;
  static constexpr int next = Counter + 1;
};


template <int In, int Out, class T>
struct cl_arg_info {
  static constexpr int in_pos = In;
  static constexpr int out_pos = Out;
  using type = T;
};

template <class ListA, class ListB, int InCounter, int OutCounter>
struct cl_arg_info_list_impl;

template <class Arg, class... Remaining, int InCounter, int OutCounter>
struct cl_arg_info_list_impl<detail::type_list<>,
                             detail::type_list<Arg, Remaining...>,
                             InCounter, OutCounter> {
  using in_idx = in_index_of<InCounter, Arg>;
  using out_idx = out_index_of<OutCounter, Arg>;
  using type =
    typename cl_arg_info_list_impl<
      detail::type_list<cl_arg_info<in_idx::value, out_idx::value, Arg>>,
      detail::type_list<Remaining...>,
      in_idx::next, out_idx::next
    >::type;
};

template <class... Args, class Arg, class... Remaining,
          int InCounter, int OutCounter>
struct cl_arg_info_list_impl<detail::type_list<Args...>,
                             detail::type_list<Arg, Remaining...>,
                             InCounter, OutCounter> {
  using in_idx = in_index_of<InCounter, Arg>;
  using out_idx = out_index_of<OutCounter, Arg>;
  using type =
    typename cl_arg_info_list_impl<
      detail::type_list<Args..., cl_arg_info<in_idx::value, out_idx::value, Arg>>,
      detail::type_list<Remaining...>,
      in_idx::next, out_idx::next
    >::type;
};

template <class... Args, int InCounter, int OutCounter>
struct cl_arg_info_list_impl<detail::type_list<Args...>,
                             detail::type_list<>,
                             InCounter, OutCounter> {
  using type = detail::type_list<Args...>;
};

template <class List>
struct cl_arg_info_list {
  using type = typename cl_arg_info_list_impl<
    detail::type_list<>,
    List, 0, 0
  >::type;
};

/// Helpers for conversion in deprecated spawn functions

template <class T>
struct to_input_arg {
  using type = in<T>;
};

template <class T>
struct to_output_arg {
  using type = out<T>;
};

} // namespace opencl
} // namespace caf

#endif // CAF_OPENCL_ARGUMENTS
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENCL_PLATFORM_HPP
#define CAF_OPENCL_PLATFORM_HPP

#include "caf/ref_counted.hpp"

#include "caf/opencl/device.hpp"

namespace caf {
namespace opencl {

class platform;
using platform_ptr = intrusive_ptr<platform>;

class platform : public ref_counted {
public:
  friend class program;
  template <class T, class... Ts>
  friend intrusive_ptr<T> caf::make_counted(Ts&&...);

  inline const std::vector<device_ptr>& devices() const;
  inline const std::string& name() const;
  inline const std::string& vendor() const;
  inline const std::string& version() const;
  static platform_ptr create(cl_platform_id platform_id, unsigned start_id);

private:
  platform(cl_platform_id platform_id, detail::raw_context_ptr context,
           std::string name, std::string vendor, std::string version,
           std::vector<device_ptr> devices);

  ~platform();

  static std::string platform_info(cl_platform_id platform_id,
                                   unsigned info_flag);
  cl_platform_id platform_id_;
  detail::raw_context_ptr context_;
  std::string name_;
  std::string vendor_;
  std::string version_;
  std::vector<device_ptr> devices_;
};

/******************************************************************************\
 *                 implementation of inline member functions                  *
\******************************************************************************/

inline const std::vector<device_ptr>& platform::devices() const {
  return devices_;
}

inline const std::string& platform::name() const {
  return name_;
}

inline const std::string& platform::vendor() const {
  return vendor_;
}

inline const std::string& platform::version() const {
  return version_;
}


} // namespace opencl
} // namespace caf

#endif // CAF_OPENCL_PLATFORM_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENCL_MANAGER_HPP
#define CAF_OPENCL_MANAGER_HPP

#include <atomic>
#include <vector>
#include <algorithm>
#include <functional>

#include "caf/optional.hpp"
#include "caf/config.hpp"
#include "caf/actor_system.hpp"

#include "caf/opencl/device.hpp"
#include "caf/opencl/global.hpp"
#include "caf/opencl/program.hpp"
#include "caf/opencl/platform.hpp"
#include "caf/opencl/actor_facade.hpp"

#include "caf/opencl/detail/core.hpp"
#include "caf/opencl/detail/raw_ptr.hpp"
#include "caf/opencl/detail/spawn_helper.hpp"

namespace caf {
namespace opencl {

class manager : public actor_system::module {
public:
  friend class program;
  friend class actor_system;
  friend detail::raw_command_queue_ptr command_queue(uint32_t id);
  manager(const manager&) = delete;
  manager& operator=(const manager&) = delete;
  /// Get the device with id, which is assigned sequientally.
  optional<device_ptr> find_device(size_t dev_id = 0) const;
  /// Get the first device that satisfies the predicate.
  /// The predicate should accept a `const device&` and return a bool;
  template <class UnaryPredicate>
  optional<device_ptr> find_device_if(UnaryPredicate p) const {
    for (auto& pl : platforms_) {
      for (auto& dev : pl->devices()) {
        if (p(dev))
          return dev;
      }
    }
    return none;
  }

  void start() override;
  void stop() override;
  void init(actor_system_config&) override;

  id_t id() const override;

  void* subtype_ptr() override;

  static actor_system::module* make(actor_system& sys,
                                    detail::type_list<>);

  // OpenCL functionality

  /// @brief Factory method, that creates a caf::opencl::program
  ///        reading the source from given @p path.
  /// @returns A program object.
  program_ptr create_program_from_file(const char* path,
                                       const char* options = nullptr,
                                       uint32_t device_id = 0);

  /// @brief Factory method, that creates a caf::opencl::program
  ///        from a given @p kernel_source.
  /// @returns A program object.
  program_ptr create_program(const char* kernel_source,
                             const char* options = nullptr,
                             uint32_t device_id = 0);

  /// @brief Factory method, that creates a caf::opencl::program
  ///        reading the source from given @p path.
  /// @returns A program object.
  program_ptr create_program_from_file(const char* path,
                                       const char* options,
                                       const device_ptr dev);

  /// @brief Factory method, that creates a caf::opencl::program
  ///        from a given @p kernel_source.
  /// @returns A program object.
  program_ptr create_program(const char* kernel_source,
                             const char* options, const device_ptr dev);

  /// Creates a new actor facade for an OpenCL kernel that invokes
  /// the function named `fname` from `prog`.
  /// @throws std::runtime_error if more than three dimensions are set,
  ///                            `dims.empty()`, or `clCreateKernel` failed.
  template <class T, class... Ts>
  detail::enable_if_t<opencl::is_opencl_arg<T>::value, actor>
  spawn(const opencl::program_ptr prog, const char* fname,
        const opencl::nd_range& range, T&& x, Ts&&... xs) {
    detail::cl_spawn_helper<false, T, Ts...> f;
    return f(actor_config{system_.dummy_execution_unit()}, prog, fname, range,
             std::forward<T>(x), std::forward<Ts>(xs)...);
  }

  /// Compiles `source` and creates a new actor facade for an OpenCL kernel
  /// that invokes the function named `fname`.
  /// @throws std::runtime_error if more than three dimensions are set,
  ///                            <tt>dims.empty()</tt>, a compilation error
  ///                            occured, or @p clCreateKernel failed.
  template <class T, class... Ts>
  detail::enable_if_t<opencl::is_opencl_arg<T>::value, actor>
  spawn(const char* source, const char* fname,
        const opencl::nd_range& range, T&& x, Ts&&... xs) {
    detail::cl_spawn_helper<false, T, Ts...> f;
    return f(actor_config{system_.dummy_execution_unit()},
             create_program(source), fname, range,
             std::forward<T>(x), std::forward<Ts>(xs)...);
  }

  /// Creates a new actor facade for an OpenCL kernel that invokes
  /// the function named `fname` from `prog`.
  /// @throws std::runtime_error if more than three dimensions are set,
  ///                            `dims.empty()`, or `clCreateKernel` failed.
  template <class Fun, class... Ts>
  actor spawn(const opencl::program_ptr prog, const char* fname,
              const opencl::nd_range& range,
              std::function<optional<message> (message&)> map_args,
              Fun map_result, Ts&&... xs) {
    detail::cl_spawn_helper<false, Ts...> f;
    return f(actor_config{system_.dummy_execution_unit()}, prog, fname, range,
             std::move(map_args), std::move(map_result),
             std::forward<Ts>(xs)...);
  }

  /// Compiles `source` and creates a new actor facade for an OpenCL kernel
  /// that invokes the function named `fname`.
  /// @throws std::runtime_error if more than three dimensions are set,
  ///                            <tt>dims.empty()</tt>, a compilation error
  ///                            occured, or @p clCreateKernel failed.
  template <class Fun, class... Ts>
  actor spawn(const char* source, const char* fname,
              const opencl::nd_range& range,
              std::function<optional<message> (message&)> map_args,
              Fun map_result, Ts&&... xs) {
    detail::cl_spawn_helper<false, Ts...> f;
    return f(actor_config{system_.dummy_execution_unit()},
             create_program(source), fname, range,
             std::move(map_args), std::move(map_result),
             std::forward<Ts>(xs)...);
  }

  // --- Only accept the input mapping function ---

  /// Creates a new actor facade for an OpenCL kernel that invokes
  /// the function named `fname` from `prog`.
  /// @throws std::runtime_error if more than three dimensions are set,
  ///                            `dims.empty()`, or `clCreateKernel` failed.
  template <class T, class... Ts>
  detail::enable_if_t<opencl::is_opencl_arg<T>::value, actor>
  spawn(const opencl::program_ptr prog, const char* fname,
            const opencl::nd_range& range,
            std::function<optional<message> (message&)> map_args,
            T&& x, Ts&&... xs) {
    detail::cl_spawn_helper<false, Ts...> f;
    return f(actor_config{system_.dummy_execution_unit()}, prog, fname, range,
             std::move(map_args), std::forward<T>(x), std::forward<Ts>(xs)...);
  }

  /// Compiles `source` and creates a new actor facade for an OpenCL kernel
  /// that invokes the function named `fname`.
  /// @throws std::runtime_error if more than three dimensions are set,
  ///                            <tt>dims.empty()</tt>, a compilation error
  ///                            occured, or @p clCreateKernel failed.
  template <class T, class... Ts>
  detail::enable_if_t<opencl::is_opencl_arg<T>::value, actor>
  spawn(const char* source, const char* fname,
            const opencl::nd_range& range,
            std::function<optional<message> (message&)> map_args,
            T&& x, Ts&&... xs) {
    detail::cl_spawn_helper<false, Ts...> f;
    return f(actor_config{system_.dummy_execution_unit()},
             create_program(source), fname, range,
             std::move(map_args), std::forward<T>(x), std::forward<Ts>(xs)...);
  }


  // --- Input mapping function accepts config as well ---

  /// Creates a new actor facade for an OpenCL kernel that invokes
  /// the function named `fname` from `prog`.
  /// @throws std::runtime_error if more than three dimensions are set,
  ///                            `dims.empty()`, or `clCreateKernel` failed.
  template <class Fun, class... Ts>
  detail::enable_if_t<!opencl::is_opencl_arg<Fun>::value, actor>
  spawn(const opencl::program_ptr prog, const char* fname,
        const opencl::nd_range& range,
        std::function<optional<message> (nd_range&, message&)> map_args,
        Fun map_result, Ts&&... xs) {
    detail::cl_spawn_helper<true, Ts...> f;
    return f(actor_config{system_.dummy_execution_unit()}, prog, fname, range,
             std::move(map_args), std::move(map_result),
             std::forward<Ts>(xs)...);
  }

  /// Compiles `source` and creates a new actor facade for an OpenCL kernel
  /// that invokes the function named `fname`.
  /// @throws std::runtime_error if more than three dimensions are set,
  ///                            <tt>dims.empty()</tt>, a compilation error
  ///                            occured, or @p clCreateKernel failed.
  template <class Fun, class... Ts>
  detail::enable_if_t<!opencl::is_opencl_arg<Fun>::value, actor>
  spawn(const char* source, const char* fname,
        const opencl::nd_range& range,
        std::function<optional<message> (nd_range&, message&)> map_args,
        Fun map_result, Ts&&... xs) {
    detail::cl_spawn_helper<true, Ts...> f;
    return f(actor_config{system_.dummy_execution_unit()},
             create_program(source), fname, range,
             std::move(map_args), std::move(map_result),
             std::forward<Ts>(xs)...);
  }

  /// Creates a new actor facade for an OpenCL kernel that invokes
  /// the function named `fname` from `prog`.
  /// @throws std::runtime_error if more than three dimensions are set,
  ///                            `dims.empty()`, or `clCreateKernel` failed.
  template <class T, class... Ts>
  detail::enable_if_t<opencl::is_opencl_arg<T>::value, actor>
  spawn(const opencl::program_ptr prog, const char* fname,
        const opencl::nd_range& range,
        std::function<optional<message> (nd_range&, message&)> map_args,
        T&& x, Ts&&... xs) {
    detail::cl_spawn_helper<true, T, Ts...> f;
    return f(actor_config{system_.dummy_execution_unit()}, prog, fname, range,
             std::move(map_args), std::forward<T>(x), std::forward<Ts>(xs)...);
  }

  /// Compiles `source` and creates a new actor facade for an OpenCL kernel
  /// that invokes the function named `fname`.
  /// @throws std::runtime_error if more than three dimensions are set,
  ///                            <tt>dims.empty()</tt>, a compilation error
  ///                            occured, or @p clCreateKernel failed.
  template <class T, class... Ts>
  detail::enable_if_t<opencl::is_opencl_arg<T>::value, actor>
  spawn(const char* source, const char* fname,
        const opencl::nd_range& range,
        std::function<optional<message> (nd_range&, message&)> map_args,
        T&& x, Ts&&... xs) {
    detail::cl_spawn_helper<true, T, Ts...> f;
    return f(actor_config{system_.dummy_execution_unit()},
             create_program(source), fname, range,
             std::move(map_args), std::forward<T>(x), std::forward<Ts>(xs)...);
  }

protected:
  manager(actor_system& sys);
  ~manager() override;

private:
  actor_system& system_;
  std::vector<platform_ptr> platforms_;
};

} // namespace opencl
} // namespace caf

#endif // CAF_OPENCL_MANAGER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENCL_SMART_PTR_HPP
#define CAF_OPENCL_SMART_PTR_HPP

#include <memory>
#include <algorithm>
#include <type_traits>

#include "caf/intrusive_ptr.hpp"

#include "caf/opencl/global.hpp"

#define CAF_OPENCL_PTR_ALIAS(aliasname, cltype, claddref, clrelease)           \
  inline void intrusive_ptr_add_ref(cltype ptr) { claddref(ptr); }             \
  inline void intrusive_ptr_release(cltype ptr) { clrelease(ptr); }            \
  namespace caf {                                                              \
  namespace opencl {                                                           \
  namespace detail {                                                           \
  using aliasname = intrusive_ptr<std::remove_pointer<cltype>::type>;          \
  } /* namespace detail */                                                     \
  } /* namespace opencl */                                                     \
  } // namespace caf


CAF_OPENCL_PTR_ALIAS(raw_mem_ptr, cl_mem, clRetainMemObject, clReleaseMemObject)

CAF_OPENCL_PTR_ALIAS(raw_event_ptr, cl_event, clRetainEvent, clReleaseEvent)

CAF_OPENCL_PTR_ALIAS(raw_kernel_ptr, cl_kernel, clRetainKernel, clReleaseKernel)

CAF_OPENCL_PTR_ALIAS(raw_context_ptr, cl_context,
                     clRetainContext, clReleaseContext)

CAF_OPENCL_PTR_ALIAS(raw_program_ptr, cl_program,
                     clRetainProgram, clReleaseProgram)

CAF_OPENCL_PTR_ALIAS(raw_device_ptr, cl_device_id,
                     clRetainDeviceDummy, clReleaseDeviceDummy)

CAF_OPENCL_PTR_ALIAS(raw_command_queue_ptr, cl_command_queue,
                     clRetainCommandQueue, clReleaseCommandQueue)

#endif // CAF_OPENCL_SMART_PTR_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENCL_CORE_HPP
#define CAF_OPENCL_CORE_HPP

namespace caf {

namespace detail {

} // namespace detail

namespace opencl {
namespace detail {

using namespace caf::detail;

} // namespace detail
} // namespace opencl
} // namespace caf

#endif // CAF_OPENCL_CORE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/
 
#ifndef CAF_OPENCL_DETAIL_COMMAND_HELPER_HPP
#define CAF_OPENCL_DETAIL_COMMAND_HELPER_HPP

#include "caf/detail/type_list.hpp"

#include "caf/opencl/arguments.hpp"

namespace caf {
namespace opencl {
namespace detail {

// signature for the function that is applied to output arguments
template <class List>
struct output_function_sig;

template <class... Ts>
struct output_function_sig<detail::type_list<Ts...>> {
  using type = std::function<message (Ts&...)>;
};

// derive signature of the command that handles the kernel execution
template <class T, class List>
struct command_sig;

template <class T, class... Ts>
struct command_sig<T, detail::type_list<Ts...>> {
  using type = command<T, Ts...>;
};

// derive type for a tuple matching the arguments as mem_refs
template <class List>
struct tuple_type_of;

template <class... Ts>
struct tuple_type_of<detail::type_list<Ts...>> {
  using type = std::tuple<Ts...>;
};

} // namespace detail
} // namespace opencl
} // namespace caf

#endif // CAF_OPENCL_DETAIL_COMMAND_HELPER_HPP

/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENCL_DETAIL_SPAWN_HELPER_HPP
#define CAF_OPENCL_DETAIL_SPAWN_HELPER_HPP

#include "caf/opencl/actor_facade.hpp"

namespace caf {
namespace opencl {
namespace detail {

struct tuple_construct { };

template <bool PassConfig, class... Ts>
struct cl_spawn_helper {
  using impl = opencl::actor_facade<PassConfig, Ts...>;
  using map_in_fun = typename impl::input_mapping;
  using map_out_fun = typename impl::output_mapping;

  actor operator()(actor_config actor_cfg, const opencl::program_ptr p,
                   const char* fn, const opencl::nd_range& range,
                   Ts&&... xs) const {
    return actor_cast<actor>(impl::create(std::move(actor_cfg),
                                          p, fn, range,
                                          map_in_fun{}, map_out_fun{},
                                          std::forward<Ts>(xs)...));
  }
  actor operator()(actor_config actor_cfg, const opencl::program_ptr p,
                   const char* fn, const opencl::nd_range& range,
                   map_in_fun map_input, Ts&&... xs) const {
    return actor_cast<actor>(impl::create(std::move(actor_cfg),
                                          p, fn, range,
                                          std::move(map_input),
                                          map_out_fun{},
                                          std::forward<Ts>(xs)...));
  }
  actor operator()(actor_config actor_cfg, const opencl::program_ptr p,
                   const char* fn, const opencl::nd_range& range,
                   map_in_fun map_input, map_out_fun map_output,
                   Ts&&... xs) const {
    return actor_cast<actor>(impl::create(std::move(actor_cfg),
                                          p, fn, range,
                                          std::move(map_input),
                                          std::move(map_output),
                                          std::forward<Ts>(xs)...));
  }
};

} // namespace detail
} // namespace opencl
} // namespace caf

#endif // CAF_OPENCL_DETAIL_SPAWN_HELPER_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_OPENCL_DEVICE_HPP
#define CAF_OPENCL_DEVICE_HPP

#include <vector>

#include "caf/sec.hpp"

#include "caf/opencl/global.hpp"
#include "caf/opencl/opencl_err.hpp"

#include "caf/opencl/detail/raw_ptr.hpp"

namespace caf {
namespace opencl {

class program;
class manager;
template <class T> class mem_ref;

class device;
using device_ptr = intrusive_ptr<device>;

class device : public ref_counted {
public:
  friend class program;
  friend class manager;
  template <class T> friend class mem_ref;
  template <class T, class... Ts>
  friend intrusive_ptr<T> caf::make_counted(Ts&&...);

  ~device();

  /// Create an argument for an OpenCL kernel with data placed in global memory.
  template <class T>
  mem_ref<T> global_argument(const std::vector<T>& data,
                             cl_mem_flags flags = buffer_type::input_output,
                             optional<size_t> size = none,
                             cl_bool blocking = CL_FALSE) {
    size_t num_elements = size ? *size : data.size();
    size_t buffer_size = sizeof(T) * num_elements;
    auto buffer = v2get(CAF_CLF(clCreateBuffer), context_.get(), flags,
                        buffer_size, nullptr);
    detail::raw_event_ptr event{v1get<cl_event>(CAF_CLF(clEnqueueWriteBuffer),
                                                queue_.get(), buffer, blocking,
                                                cl_uint{0}, buffer_size,
                                                data.data()),
                                false};
    return mem_ref<T>{num_elements, queue_, std::move(buffer), flags,
                      std::move(event)};
  }

  /// Create an argument for an OpenCL kernel in global memory without data.
  template <class T>
  mem_ref<T> scratch_argument(size_t size,
                              cl_mem_flags flags = buffer_type::scratch_space) {
    auto buffer = v2get(CAF_CLF(clCreateBuffer), context_.get(), flags,
                        sizeof(T) * size, nullptr);
    return mem_ref<T>{size, queue_, std::move(buffer), flags, nullptr};
  }

  template <class T>
  expected<mem_ref<T>> copy(mem_ref<T>& mem) {
    if (!mem.get())
      return make_error(sec::runtime_error, "No memory assigned.");
    auto buffer_size = sizeof(T) * mem.size();
    cl_event event;
    auto buffer = v2get(CAF_CLF(clCreateBuffer), context_.get(), mem.access(),
                        buffer_size, nullptr);
    std::vector<cl_event> prev_events;
    cl_event e = mem.take_event();
    if (e)
      prev_events.push_back(e);
    auto err = clEnqueueCopyBuffer(queue_.get(), mem.get().get(), buffer,
                                   0, 0, // no offset for now
                                   buffer_size, prev_events.size(),
                                   prev_events.data(), &event);
    if (err != CL_SUCCESS)
      return make_error(sec::runtime_error, opencl_error(err));
    // callback to release the previous event 
    if (e) {
      err = clSetEventCallback(event, CL_COMPLETE,
                               [](cl_event, cl_int, void* data) {
                                 auto tmp = reinterpret_cast<cl_event>(data);
                                 if (tmp)
                                   clReleaseEvent(tmp);
                               },
                               e);
      if (err != CL_SUCCESS)
        return make_error(sec::runtime_error, opencl_error(err));
    }
    // decrements the previous event we used for waiting above
    return mem_ref<T>(mem.size(), queue_, std::move(buffer),
                      mem.access(), {event, false});
  }

  /// Initialize a new device in a context using a specific device_id
  static device_ptr create(const detail::raw_context_ptr& context,
                           const detail::raw_device_ptr& device_id,
                           unsigned id);
  /// Synchronizes all commands in its queue, waiting for them to finish.
  void synchronize();
  /// Get the id assigned by caf
  inline unsigned id() const;
  /// Returns device info on CL_DEVICE_ADDRESS_BITS
  inline cl_uint address_bits() const;
  /// Returns device info on CL_DEVICE_ENDIAN_LITTLE
  inline cl_bool little_endian() const;
  /// Returns device info on CL_DEVICE_GLOBAL_MEM_CACHE_SIZE
  inline cl_ulong global_mem_cache_size() const;
  /// Returns device info on CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE
  inline cl_uint global_mem_cacheline_size() const;
  /// Returns device info on CL_DEVICE_GLOBAL_MEM_SIZE
  inline cl_ulong global_mem_size() const;
  /// Returns device info on CL_DEVICE_HOST_UNIFIED_MEMORY
  inline cl_bool host_unified_memory() const;
  /// Returns device info on CL_DEVICE_LOCAL_MEM_SIZE
  inline cl_ulong local_mem_size() const;
  /// Returns device info on CL_DEVICE_LOCAL_MEM_TYPE
  inline cl_ulong local_mem_type() const;
  /// Returns device info on CL_DEVICE_MAX_CLOCK_FREQUENCY
  inline cl_uint max_clock_frequency() const;
  /// Returns device info on CL_DEVICE_MAX_COMPUTE_UNITS
  inline cl_uint max_compute_units() const;
  /// Returns device info on CL_DEVICE_MAX_CONSTANT_ARGS
  inline cl_uint max_constant_args() const;
  /// Returns device info on CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE
  inline cl_ulong max_constant_buffer_size() const;
  /// Returns device info on CL_DEVICE_MAX_MEM_ALLOC_SIZE
  inline cl_ulong max_mem_alloc_size() const;
  /// Returns device info on CL_DEVICE_MAX_PARAMETER_SIZE
  inline size_t max_parameter_size() const;
  /// Returns device info on CL_DEVICE_MAX_WORK_GROUP_SIZE
  inline size_t max_work_group_size() const;
  /// Returns device info on CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS
  inline cl_uint max_work_item_dimensions() const;
  /// Returns device info on CL_DEVICE_PROFILING_TIMER_RESOLUTION
  inline size_t profiling_timer_resolution() const;
  /// Returns device info on CL_DEVICE_MAX_WORK_ITEM_SIZES
  inline const dim_vec& max_work_item_sizes() const;
  /// Returns device info on CL_DEVICE_TYPE
  inline device_type type() const;
  /// Returns device info on CL_DEVICE_EXTENSIONS
  inline const std::vector<std::string>& extensions() const;
  /// Returns device info on CL_DEVICE_OPENCL_C_VERSION
  inline const std::string& opencl_c_version() const;
  /// Returns device info on CL_DEVICE_VENDOR
  inline const std::string& device_vendor() const;
  /// Returns device info on CL_DEVICE_VERSION
  inline const std::string& device_version() const;
  /// Returns device info on CL_DRIVER_VERSION
  inline const std::string& driver_version() const;
  /// Returns device info on CL_DEVICE_NAME
  inline const std::string& name() const;

private:
  device(detail::raw_device_ptr device_id, detail::raw_command_queue_ptr queue,
         detail::raw_context_ptr context, unsigned id);

  template <class T>
  static T info(const detail::raw_device_ptr& device_id, unsigned info_flag) {
    T value;
    clGetDeviceInfo(device_id.get(), info_flag, sizeof(T), &value, nullptr);
    return value;
  }

  static std::string info_string(const detail::raw_device_ptr& device_id,
                                 unsigned info_flag);
  detail::raw_device_ptr device_id_;
  detail::raw_command_queue_ptr queue_;
  detail::raw_context_ptr context_;
  unsigned id_;

  bool profiling_enabled_;              // CL_DEVICE_QUEUE_PROPERTIES
  bool out_of_order_execution_;         // CL_DEVICE_QUEUE_PROPERTIES

  cl_uint address_bits_;                // CL_DEVICE_ADDRESS_BITS
  cl_bool little_endian_;               // CL_DEVICE_ENDIAN_LITTLE
  cl_ulong global_mem_cache_size_;      // CL_DEVICE_GLOBAL_MEM_CACHE_SIZE
  cl_uint global_mem_cacheline_size_;   // CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE
  cl_ulong global_mem_size_;            // CL_DEVICE_GLOBAL_MEM_SIZE
  cl_bool host_unified_memory_;         // CL_DEVICE_HOST_UNIFIED_MEMORY
  cl_ulong local_mem_size_;             // CL_DEVICE_LOCAL_MEM_SIZE
  cl_uint local_mem_type_;              // CL_DEVICE_LOCAL_MEM_TYPE
  cl_uint max_clock_frequency_;         // CL_DEVICE_MAX_CLOCK_FREQUENCY
  cl_uint max_compute_units_;           // CL_DEVICE_MAX_COMPUTE_UNITS
  cl_uint max_constant_args_;           // CL_DEVICE_MAX_CONSTANT_ARGS
  cl_ulong max_constant_buffer_size_;   // CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE
  cl_ulong max_mem_alloc_size_;         // CL_DEVICE_MAX_MEM_ALLOC_SIZE
  size_t max_parameter_size_;           // CL_DEVICE_MAX_PARAMETER_SIZE
  size_t max_work_group_size_;          // CL_DEVICE_MAX_WORK_GROUP_SIZE
  cl_uint max_work_item_dimensions_;    // CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS
  size_t profiling_timer_resolution_;   // CL_DEVICE_PROFILING_TIMER_RESOLUTION
  dim_vec max_work_item_sizes_;         // CL_DEVICE_MAX_WORK_ITEM_SIZES
  device_type device_type_;             // CL_DEVICE_TYPE
  std::vector<std::string> extensions_; // CL_DEVICE_EXTENSIONS
  std::string opencl_c_version_;        // CL_DEVICE_OPENCL_C_VERSION
  std::string device_vendor_;           // CL_DEVICE_VENDOR
  std::string device_version_;          // CL_DEVICE_VERSION
  std::string driver_version_;          // CL_DRIVER_VERSION
  std::string name_;                    // CL_DEVICE_NAME
};

/******************************************************************************\
 *                 implementation of inline member functions                  *
\******************************************************************************/

inline unsigned device::id() const {
  return id_;
}

inline cl_uint device::address_bits() const {
  return address_bits_;
}

inline cl_bool device::little_endian() const {
  return little_endian_;
}

inline cl_ulong device::global_mem_cache_size() const {
  return global_mem_cache_size_;
}

inline cl_uint device::global_mem_cacheline_size() const {
  return global_mem_cacheline_size_;
}

inline cl_ulong device::global_mem_size() const {
  return global_mem_size_;
}

inline cl_bool device::host_unified_memory() const {
  return host_unified_memory_;
}

inline cl_ulong device::local_mem_size() const {
  return local_mem_size_;
}

inline cl_ulong device::local_mem_type() const {
  return local_mem_size_;
}

inline cl_uint device::max_clock_frequency() const {
  return max_clock_frequency_;
}

inline cl_uint device::max_compute_units() const {
  return max_compute_units_;
}

inline cl_uint device::max_constant_args() const {
  return max_constant_args_;
}

inline cl_ulong device::max_constant_buffer_size() const {
  return max_constant_buffer_size_;
}

inline cl_ulong device::max_mem_alloc_size() const {
  return max_mem_alloc_size_;
}

inline size_t device::max_parameter_size() const {
  return max_parameter_size_;
}

inline size_t device::max_work_group_size() const {
  return max_work_group_size_;
}

inline cl_uint device::max_work_item_dimensions() const {
  return max_work_item_dimensions_;
}

inline size_t device::profiling_timer_resolution() const {
  return profiling_timer_resolution_;
}

inline const dim_vec& device::max_work_item_sizes() const {
  return max_work_item_sizes_;
}

inline device_type device::type() const {
  return device_type_;
}

inline const std::vector<std::string>& device::extensions() const {
  return extensions_;
}

inline const std::string& device::opencl_c_version() const {
  return opencl_c_version_;
}

inline const std::string& device::device_vendor() const {
  return device_vendor_;
}

inline const std::string& device::device_version() const {
  return device_version_;
}

inline const std::string& device::driver_version() const {
  return driver_version_;
}

inline const std::string& device::name() const {
  return name_;
}

} // namespace opencl
} // namespace caf

#endif // CAF_OPENCL_DEVICE_HPP
/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright 2011-2018 Dominik Charousset                                     *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include "caf/config.hpp"

#include <set>
#include <chrono>
#include <thread>
#include <iomanip>
#include <iostream>
#include <functional>
#include <unordered_map>

CAF_PUSH_WARNINGS
#include "third_party/pybind/include/pybind11/pybind11.h"
CAF_POP_WARNINGS

#include "caf/all.hpp"
#include "caf/io/all.hpp"

using std::cout;
using std::cerr;
using std::endl;

namespace {

constexpr char default_banner[] = R"__(
                  ____                __  __
      _________  / __/   ____  __  __/ /_/ /_  ____  ____
     / ___/ __ `/ /_____/ __ \/ / / / __/ __ \/ __ \/ __ `
    / /__/ /_/ / __/___/ /_/ / /_/ / /_/ / / / /_/ / / / /
    \___/\__,_/_/     / .___/\__, /\__/_/ /_/\____/_/ /_/
                     /_/    /____/

)__";

constexpr char init_script[] = R"__(
from CAF import *

caf_mail_cache=[]

def select_from_mail_cache(msg_filter):
    global caf_mail_cache
    for i, v in enumerate(caf_mail_cache):
        if msg_filter(v):
            return caf_mail_cache.pop(i)

def no_receive_filter(x):
    return True

def receive_one(abs_timeout):
    if abs_timeout:
        return dequeue_message_with_timeout(abs_timeout)
    else:
        return dequeue_message()

def receive(timeout = None, msg_filter = no_receive_filter):
    # try to get an element from the mailbox for predicate
    msg = select_from_mail_cache(msg_filter)
    if msg:
        return msg
    # calculate absolute timeout
    abs_timeout = None
    if timeout:
      abs_timeout = absolute_receive_timeout(int(timeout))
    # receive message via mailbox
    msg = receive_one(abs_timeout)
    while msg and not msg_filter(msg):
        caf_mail_cache.append(msg)
        msg = receive_one(abs_timeout)
    return msg

)__";

} // namespace <anonymous>

namespace caf {

void register_class(atom_value*, pybind11::module& m,
                    const std::string& name) {
  auto repr_fun = [](atom_value x) {
    return "atom('" + to_string(x) + "')";
  };
  auto cmp = [](atom_value x, atom_value y) {
    return x == y;
  };
  std::string (*to_string_fun)(const atom_value&) = &to_string;
  pybind11::class_<atom_value>(m, name.c_str())
  .def("__str__", to_string_fun)
  .def("__repr__", repr_fun)
  .def("__eq__", cmp);
}

namespace python {
namespace {

class binding {
public:
  binding(std::string py_name, bool builtin_type)
      : python_name_(std::move(py_name)),
        builtin_(builtin_type) {
    // nop
  }

  virtual ~binding() {
    //nop
  }

  inline void docstring(std::string x) {
    docstring_ = std::move(x);
  }

  inline const std::string& docstring() const {
    return docstring_;
  }

  inline const std::string& python_name() const {
    return python_name_;
  }

  inline bool builtin() const {
    return builtin_;
  }

  virtual void append(message_builder& xs, pybind11::handle x) const = 0;

private:
  std::string python_name_;
  std::string docstring_;
  bool builtin_;
};

class py_binding : public binding {
public:
  py_binding(std::string name) : binding(name, true) {
    // nop
  }
};

template <class T>
class default_py_binding : public py_binding {
public:
  using py_binding::py_binding;

  void append(message_builder& xs, pybind11::handle x) const override {
    xs.append(x.cast<T>());
  }
};

class cpp_binding : public binding {
public:
  using binding::binding;

  virtual pybind11::object to_object(const type_erased_tuple& xs,
                                     size_t pos) const = 0;
};

template <class T>
class default_cpp_binding : public cpp_binding {
public:
  using cpp_binding::cpp_binding;

  void append(message_builder& xs, pybind11::handle x) const override {
    xs.append(x.cast<T>());
  }

  pybind11::object to_object(const type_erased_tuple& xs,
                             size_t pos) const override {
    return pybind11::cast(xs.get_as<T>(pos));
  }
};

using binding_ptr = std::unique_ptr<binding>;
using py_binding_ptr = std::unique_ptr<py_binding>;
using cpp_binding_ptr = std::unique_ptr<cpp_binding>;

atom_value atom_from_string(const std::string& str) {
  static constexpr size_t buf_size = 11;
  char buf[buf_size];
  memset(buf, 0, buf_size);
  strncpy(buf, str.c_str(), std::min<size_t>(buf_size - 1, str.size()));
  return atom(buf);
}

template <class T>
class has_register_class {
private:
  template <class U>
  static auto test(U* x) -> decltype(register_class(x,
                                                    std::declval<pybind11::module&>(),
                                                    std::declval<const std::string&>()));

  static auto test(...) -> std::false_type;

  using type = decltype(test(static_cast<T*>(nullptr)));
public:
  static constexpr bool value = std::is_same<type, void>::value;
};

template <class T>
class has_to_string {
private:
  template <class U>
  static auto test(U* x) -> decltype(to_string(*x));

  static auto test(...) -> void;

  using type = decltype(test(static_cast<T*>(nullptr)));
public:
  static constexpr bool value = std::is_same<type, std::string>::value;
};

template <class T>
typename std::enable_if<
  !has_register_class<T>::value
  && has_to_string<T>::value
>::type
default_python_class_init(pybind11::module& m, const std::string& name) {
  auto str_impl = [](const T& x) {
    return to_string(x);
  };
  pybind11::class_<T>(m, name.c_str())
  .def("__str__", str_impl);
}

template <class T>
typename std::enable_if<
  !has_register_class<T>::value
  && !has_to_string<T>::value
>::type
default_python_class_init(pybind11::module& m, const std::string& name) {
  auto str_impl = [](const T& x) {
    return to_string(x);
  };
  pybind11::class_<T>(m, name.c_str());
}

template <class T>
typename std::enable_if<
  has_register_class<T>::value
>::type
default_python_class_init(pybind11::module& m, const std::string& name) {
  register_class(static_cast<T*>(nullptr), m, name);
}

struct absolute_receive_timeout {
public:
  using ms = std::chrono::milliseconds;
  using clock_type = std::chrono::high_resolution_clock;

  absolute_receive_timeout(int msec) {
    x_ = clock_type::now() + ms(msec);
  }

  absolute_receive_timeout() = default;
  absolute_receive_timeout(const absolute_receive_timeout&) = default;
  absolute_receive_timeout& operator=(const absolute_receive_timeout&) = default;

  const clock_type::time_point& value() const {
    return x_;
  }

  friend void serialize(serializer& sink, absolute_receive_timeout& x,
                        const unsigned int) {
    auto tse = x.x_.time_since_epoch();
    auto ms_since_epoch = std::chrono::duration_cast<ms>(tse).count();
    sink << static_cast<uint64_t>(ms_since_epoch);
  }

  friend void serialize(deserializer& source, absolute_receive_timeout& x,
                        const unsigned int) {
    uint64_t ms_since_epoch;
    source >> ms_since_epoch;
    clock_type::time_point y;
    y += ms(static_cast<ms::rep>(ms_since_epoch));
    x.x_ = y;
  }

private:
  clock_type::time_point x_;
};

void register_class(absolute_receive_timeout*, pybind11::module& m,
                    const std::string& name) {
  pybind11::class_<absolute_receive_timeout>(m, name.c_str())
  .def(pybind11::init<>())
  .def(pybind11::init<int>());
}

class py_config : public actor_system_config {
public:
  std::string pre_run;
  std::string banner = default_banner;

  using register_fun = std::function<void (pybind11::module&, const std::string&)>;

  py_config() {
    // allow CAF to convert native Python types to C++ types
    add_py<int>("int");
    add_py<bool>("bool");
    add_py<float>("float");
    add_py<std::string>("str");
    // create Python bindings for builtin CAF types
    add_cpp<actor>("actor", "@actor");
    add_cpp<message>("message", "@message");
    add_cpp<atom_value>("atom_value", "@atom");
    // fill list for native type bindings
    add_cpp<bool>("bool", "bool", nullptr);
    add_cpp<float>("float", "float", nullptr);
    add_cpp<int32_t>("int32_t", "@i32", nullptr);
    add_cpp<std::string>("str", "@str", nullptr);
    // custom types of caf_python
    add_message_type<absolute_receive_timeout>("absolute_receive_timeout");
  }

  template <class T>
  py_config&
  add_message_type(std::string name,
                   register_fun reg = &default_python_class_init<T>) {
    add_cpp<T>(name, name, std::move(reg));
    actor_system_config::add_message_type<T>(std::move(name));
    return *this;
  }

  void py_init(pybind11::module& x) const {
    for (auto& f : register_funs_)
      f(x);
  }

  std::string full_pre_run_script() const {
    return init_script + pre_run;
  }

  std::string ipython_script() const {
    // prepare preload script by formatting it with <space><space>'...'
    std::vector<std::string> lines;
    auto full_pre_run = full_pre_run_script();
    split(lines, full_pre_run, is_any_of("\n"), token_compress_on);
    for (auto& line : lines) {
      line.insert(0, "  '");
      line += "'";
    }
    std::ostringstream oss;
    oss << "import IPython" << endl
        << "c = IPython.Config()" << endl
        << "c.InteractiveShellApp.exec_lines = [" << endl
        << R"(""")"
        << full_pre_run
        << R"(""")" << endl
        << "]" << endl
        << "c.PromptManager.in_template  = ' $: '" << endl
        << "c.PromptManager.in2_template = ' -> '" << endl
        << "c.PromptManager.out_template = ' >> '" << endl
        << "c.display_banner = True" << endl
        << R"(c.TerminalInteractiveShell.banner1 = """)" << endl
        << banner << endl
        << R"(""")" << endl
        << "IPython.start_ipython(config=c)" << endl;
    return oss.str();
  }

   const std::unordered_map<std::string, binding*>& bindings() const {
     return bindings_;
   }

   const std::unordered_map<std::string, cpp_binding*>& portable_bindings() const {
     return portable_bindings_;
   }

   const std::unordered_map<std::string, cpp_binding_ptr>& cpp_bindings() const {
     return cpp_bindings_;
   }

private:
  template <class T>
  void add_py(std::string name) {
    auto ptr = new default_py_binding<T>(name);
    py_bindings_.emplace(name, py_binding_ptr{ptr});
    bindings_.emplace(std::move(name), ptr);
  }

  template <class T>
  void add_cpp(std::string py_name, std::string cpp_name,
               const register_fun& reg = &default_python_class_init<T>) {
    if (reg)
      register_funs_.push_back([=](pybind11::module& m) { reg(m, py_name); });
    auto ptr = new default_cpp_binding<T>(py_name, reg != nullptr);
    // all type names are prefix with "CAF."
    py_name.insert(0, "CAF.");
    cpp_bindings_.emplace(py_name, cpp_binding_ptr{ptr});
    bindings_.emplace(std::move(py_name), ptr);
    portable_bindings_.emplace(std::move(cpp_name), ptr);
  }

  template <class T>
  void add_cpp(std::string name) {
    add_cpp<T>(name, name);
  }

  std::unordered_map<std::string, cpp_binding*> portable_bindings_;
  std::unordered_map<std::string, binding*> bindings_;
  std::unordered_map<std::string, cpp_binding_ptr> cpp_bindings_;
  std::unordered_map<std::string, py_binding_ptr> py_bindings_;

  std::vector<std::function<void (pybind11::module&)>> register_funs_;
};
struct py_context {
  const py_config& cfg;
  actor_system& system;
  scoped_actor& self;
};

namespace {

py_context* s_context;

} // namespace <anonymous>

inline void set_py_exception_fill(std::ostream&) {
  // end of recursion
}

template <class T, class... Ts>
void set_py_exception_fill(std::ostream& oss, T&& x, Ts&&... xs) {
  set_py_exception_fill(oss << std::forward<T>(x), std::forward<Ts>(xs)...);
}


template <class... Ts>
void set_py_exception(Ts&&... xs) {
  std::ostringstream oss;
  set_py_exception_fill(oss, std::forward<Ts>(xs)...);
  PyErr_SetString(PyExc_RuntimeError, oss.str().c_str());
}

void py_send(const pybind11::args& xs) {
  if (xs.size() < 2) {
    set_py_exception("Too few arguments to call CAF.send");
    return;
  }
  auto i = xs.begin();
  auto dest = (*i).cast<actor>();
  ++i;
  message_builder mb;
  auto& bindings = s_context->cfg.bindings();
  for (; i != xs.end(); ++i) {
    std::string type_name = PyEval_GetFuncName((*i).ptr());
    auto kvp = bindings.find(type_name);
    if (kvp == bindings.end()) {
      set_py_exception(R"(Unable to add element of type ")",
                       type_name, R"(" to message: type is unknown to CAF)");
      return;
    }
    kvp->second->append(mb, *i);
  }
  s_context->self->send(dest, mb.move_to_message());
}

pybind11::tuple tuple_from_message(const type_erased_tuple& msg) {
  auto& self = s_context->self;
  auto& bindings = s_context->cfg.portable_bindings();
  pybind11::tuple result(msg.size());
  for (size_t i = 0; i  < msg.size(); ++i) {
    auto rtti = msg.type(i);
    auto str_ptr = self->system().types().portable_name(rtti);
    if (str_ptr == nullptr) {
      set_py_exception("Unable to extract element #", i, " from message: ",
                       "could not get portable name of ", rtti.second->name());
      return pybind11::tuple{};
    }
    auto kvp = bindings.find(*str_ptr);
    if (kvp == bindings.end()) {
      set_py_exception(R"(Unable to add element of type ")",
                       *str_ptr, R"(" to message: type is unknown to CAF)");
      return pybind11::tuple{};
    }
    auto obj = kvp->second->to_object(msg, i);
    PyTuple_SetItem(result.ptr(), static_cast<int>(i), obj.release().ptr());
  }
  return result;
}

pybind11::tuple py_dequeue() {
  auto& self = s_context->self;
  auto ptr = self->next_message();
  while (!ptr) {
    self->await_data();
    ptr = self->next_message();
  }
  return tuple_from_message(std::move(ptr->content()));
}

pybind11::tuple py_dequeue_with_timeout(absolute_receive_timeout timeout) {
  auto& self = s_context->self;
  auto ptr = self->next_message();
  while (!ptr) {
    if (!self->await_data(timeout.value()))
      return pybind11::none{};
    ptr = self->next_message();
  }
  return tuple_from_message(std::move(ptr->content()));
}

actor py_self() {
  return s_context->self;
}

struct foo {
  int x;
  int y;
  foo() : x(0), y(0) {
    // nop
  }
  foo(int a, int b) : x(a), y(b) {
    // nop
  }
};

template <class Processor>
void serialize(Processor& proc, foo& f, const unsigned int) {
  proc & f.x;
  proc & f.y;
}

std::string to_string(const foo& x) {
  return "foo" + deep_to_string_as_tuple(x.x, x.y);
}

void register_class(foo*, pybind11::module& m, const std::string& name) {
  std::string (*str_fun)(const foo&) = &to_string;
  pybind11::class_<foo>(m, name.c_str())
  .def(pybind11::init<>())
  .def(pybind11::init<int, int>())
  .def("__str__", str_fun)
  .def("__repr__", str_fun)
  .def_readwrite("x", &foo::x)
  .def_readwrite("y", &foo::y);
}

#if PY_MAJOR_VERSION == 3
#define CAF_MODULE_INIT_RES PyObject*
#define CAF_MODULE_INIT_RET(res) return res;
#else
#define CAF_MODULE_INIT_RES void
#define CAF_MODULE_INIT_RET(unused)
#endif

CAF_MODULE_INIT_RES caf_module_init() {
  pybind11::module m("CAF", "Python binding for CAF");
  s_context->cfg.py_init(m);
  // add classes
  // add free functions
  m.def("send", &py_send, "Sends a message to an actor")
   .def("dequeue_message", &py_dequeue, "Receives the next message")
   .def("dequeue_message_with_timeout", &py_dequeue_with_timeout, "Receives the next message")
   .def("self", &py_self, "Returns the global self handle")
   .def("atom", &atom_from_string, "Creates an atom from a string");
  CAF_MODULE_INIT_RET(m.ptr())
}


} // namespace <anonymous>
} // namespace python
} // namespace caf

namespace {

using namespace caf;
using namespace caf::python;

class config : public py_config {
public:
  std::string py_file;

  config() {
    add_message_type<foo>("foo");
    opt_group{custom_options_, "python"}
    .add(py_file, "file,f", "Run script instead of interactive shell.");
  }
};

void caf_main(actor_system& system, const config& cfg) {
  // register system and scoped actor in global variables
  scoped_actor self{system};
  py_context ctx{cfg, system, self};
  s_context = &ctx;
  // init Python
  PyImport_AppendInittab("CAF", caf_module_init);
  Py_Initialize();
  // create Python module for CAF
  int py_res = 0;
  if (!cfg.py_file.empty()) {
    auto fp = fopen(cfg.py_file.c_str() , "r");
    if (fp == nullptr) {
      cerr << "Unable to open file " << cfg.py_file << endl;
      Py_Finalize();
      return;
    }
    auto full_pre_run = cfg.full_pre_run_script();
    py_res = PyRun_SimpleString(full_pre_run.c_str());
    if (py_res == 0)
      py_res = PyRun_SimpleFileEx(fp, cfg.py_file.c_str(), 1);
  } else {
    auto script = cfg.ipython_script();
    py_res = PyRun_SimpleString(script.c_str());
  }
  if (py_res != 0) {
    cerr << "Unable to launch interactive Python shell!" << endl
         << "Please install it using: pip install ipython" << endl;
  }
  Py_Finalize();
}

} // namespace <anonymous>

CAF_MAIN()
